# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Damien P. George, Paul Sokolovsky, and
# contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.9.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-03 14:13+0900\n"
"PO-Revision-Date: 2018-11-17 20:02+0900\n"
"Last-Translator: Minoru Inachi\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../../esp8266/general.rst:4
msgid "General information about the ESP8266 port"
msgstr "ESP8266 ポートに関する一般的なこと"

#: ../../../esp8266/general.rst:6
msgid ""
"ESP8266 is a popular WiFi-enabled System-on-Chip (SoC) by Espressif "
"Systems."
msgstr ""
"ESP8266 は Espressif Systems 社の人気 WiFi 対応システムオンチップ(SoC)です。"

#: ../../../esp8266/general.rst:9
msgid "Multitude of boards"
msgstr "ボードの多様さ"

#: ../../../esp8266/general.rst:11
msgid ""
"There is a multitude of modules and boards from different sources which "
"carry the ESP8266 chip. MicroPython tries to provide a generic port which"
" would run on as many boards/modules as possible, but there may be "
"limitations. Adafruit Feather HUZZAH board is taken as a reference board "
"for the port (for example, testing is performed on it). If you have "
"another board, please make sure you have a datasheet, schematics and "
"other reference materials for your board handy to look up various aspects"
" of your board functioning."
msgstr ""
"ESP8266 チップを搭載した、さまざまな多数のモジュールとボードがあります。"
"MicroPython はできるだけ多くのボード/モジュール上で動作する汎用ポートを"
"提供しようとしますが、制限があるかもしれません。Adafruit Feather HUZZAH "
"ボードがリファレンスのボードとして使われています(たとえば、テストが"
"このボードで実行されています)。別のボードを使う場合は、データシート、"
"回路図、およびボードのその他の参考資料を用意して、ボードのさまざまな"
"機能を調べるようにしてください。"

#: ../../../esp8266/general.rst:19
msgid ""
"To make a generic ESP8266 port and support as many boards as possible, "
"the following design and implementation decision were made:"
msgstr ""
"一般的な ESP8266 ポートを作成し、可能な限り多くのボードをサポートする"
"には、次の設計と実装の決定が行われました。"

#: ../../../esp8266/general.rst:22
msgid ""
"GPIO pin numbering is based on ESP8266 chip numbering, not some "
"\"logical\" numbering of a particular board. Please have the manual/pin "
"diagram of your board at hand to find correspondence between your board "
"pins and actual ESP8266 pins. We also encourage users of various boards "
"to share this mapping via MicroPython forum, with the idea to collect "
"community-maintained reference materials eventually."
msgstr ""
"GPIO ピン番号は ESP8266 のチップ番号に基づいており、特定のボードの"
"「論理的」な番号付けには基づいていません。ボードのピンと実際の "
"ESP8266 ピンの対応を見つけるには、ボードのマニュアル/ピン図を"
"用意してください。また、様々なボードのユーザーに、MicroPython "
"フォーラムを介してこのマッピングを共有することを推奨します。"
"これは、最終的にコミュニティ管理の参照資料を収集するという"
"アイデアです。"

#: ../../../esp8266/general.rst:28
msgid ""
"All pins which make sense to support, are supported by MicroPython (for "
"example, pins which are used to connect SPI flash are not exposed, as "
"they're unlikely useful for anything else, and operating on them will "
"lead to board lock-up). However, any particular board may expose only "
"subset of pins. Consult your board reference manual."
msgstr ""
"MicroPython は、サポートするのに理想的なすべてのピンをサポートして"
"います(たとえば、SPI フラッシュを接続するために使用されるピンは露出"
"していません。他用途で使うには有益でないため、ピンで動作させると"
"ボードの障害につながります)。ただし、特定のボードはピンのサブセット"
"のみを露出させることがあります。ボードリファレンスマニュアルを"
"参照してください。"

#: ../../../esp8266/general.rst:33
msgid ""
"Some boards may lack external pins/internal connectivity to support "
"ESP8266 deepsleep mode."
msgstr ""
"一部のボードには、ESP8266 ディープスリープモードをサポートするための"
"外部ピン/内部接続がない場合があります。"

#: ../../../esp8266/general.rst:38
msgid "Technical specifications and SoC datasheets"
msgstr "技術仕様および SoC データシート"

#: ../../../esp8266/general.rst:40
msgid ""
"The datasheets and other reference material for ESP8266 chip are "
"available from the vendor site: "
"http://bbs.espressif.com/viewtopic.php?f=67&t=225 . They are the primary "
"reference for the chip technical specifications, capabilities, operating "
"modes, internal functioning, etc."
msgstr ""
"ESP8266 チップのデータシートおよびその他の参考資料は、ベンダーの"
"サイト http://bbs.espressif.com/viewtopic.php?f=67&t=225 "
"から入手できます。これらは、チップの技術仕様、機能、動作モード、内部機能などの主要な"
"リファレンスとなっています。"

#: ../../../esp8266/general.rst:45
msgid "For your convenience, some of technical specifications are provided below:"
msgstr "便宜上、いくつかの技術仕様を以下に示します。"

#: ../../../esp8266/general.rst:47
msgid "Architecture: Xtensa lx106"
msgstr "アーキテクチャ：Xtensa lx106"

#: ../../../esp8266/general.rst:48
msgid "CPU frequency: 80MHz overclockable to 160MHz"
msgstr "CPU 周波数: 80MHz、160MHz にオーバークロック可能"

#: ../../../esp8266/general.rst:49
msgid "Total RAM available: 96KB (part of it reserved for system)"
msgstr "使用可能なRAMの合計: 96KB (システムの予約分)"

#: ../../../esp8266/general.rst:50
msgid "BootROM: 64KB"
msgstr ""

#: ../../../esp8266/general.rst:51
msgid "Internal FlashROM: None"
msgstr "内蔵フラッシュROM: なし"

#: ../../../esp8266/general.rst:52
msgid "External FlashROM: code and data, via SPI Flash. Normal sizes 512KB-4MB."
msgstr "外部フラッシュROM: コードとデータ、SPIフラッシュ経由。通常のサイズは 512KB-4MB です。"

#: ../../../esp8266/general.rst:53
msgid ""
"GPIO: 16 + 1 (GPIOs are multiplexed with other functions, including "
"external FlashROM, UART, deep sleep wake-up, etc.)"
msgstr ""
"GPIO: 16 + 1 (GPIO は外部フラッシュROM、UART、ディープスリープウェイクアップなど"
"他の機能と多重化されています)"

#: ../../../esp8266/general.rst:55
msgid "UART: One RX/TX UART (no hardware handshaking), one TX-only UART."
msgstr "UART: １つのRX/TX UART (ハードウェアハンドシェイクなし)、１つのTX専用 UART。"

#: ../../../esp8266/general.rst:56
msgid "SPI: 2 SPI interfaces (one used for FlashROM)."
msgstr "SPI: ２つの SPI インタフェース (１つはフラッシュ ROM に使用)。"

#: ../../../esp8266/general.rst:57
msgid ""
"I2C: No native external I2C (bitbang implementation available on any "
"pins)."
msgstr ""
"I2C: ネイティブの外部 I2C なし (任意のピンでビットバングの実装が可能)。"

#: ../../../esp8266/general.rst:58
msgid "I2S: 1."
msgstr "I2S: 1"

#: ../../../esp8266/general.rst:59
msgid ""
"Programming: using BootROM bootloader from UART. Due to external FlashROM"
" and always-available BootROM bootloader, ESP8266 is not brickable."
msgstr ""
"プログラミング: UART から BootROM ブートローダーを使用する。外部 FlashROM と"
"常時使用可能な BootROM ブートローダのため、ESP8266 が文鎮化することはありません。"

#: ../../../esp8266/general.rst:64
msgid "Scarcity of runtime resources"
msgstr "ランタイムリソースの不足"

#: ../../../esp8266/general.rst:66
msgid ""
"ESP8266 has very modest resources (first of all, RAM memory). So, please "
"avoid allocating too big container objects (lists, dictionaries) and "
"buffers. There is also no full-fledged OS to keep track of resources and "
"automatically clean them up, so that's the task of a user/user "
"application: please be sure to close open files, sockets, etc. as soon as"
" possible after use."
msgstr ""
"ESP8266 のリソースは非常に控えめです(なによりも、RAMメモリー容量)。したがって、"
"大きすぎるコンテナオブジェクト(リスト、辞書)とバッファの割り当ては避けてください。"
"また、リソースを追跡して自動的にクリーンアップするための本格的な OS はありませんので、"
"それはユーザー/ユーザーアプリケーションのタスクです。使用後できるだけ早くファイル、"
"ソケットなどを閉じてください。"

#: ../../../esp8266/general.rst:75
msgid "Boot process"
msgstr "ブートプロセス"

#: ../../../esp8266/general.rst:77
msgid ""
"On boot, MicroPython EPS8266 port executes ``_boot.py`` script from "
"internal frozen modules. It mounts filesystem in FlashROM, or if it's not"
" available, performs first-time setup of the module and creates the "
"filesystem. This part of the boot process is considered fixed, and not "
"available for customization for end users (even if you build from source,"
" please refrain from changes to it; customization of early boot process "
"is available only to advanced users and developers, who can diagnose "
"themselves any issues arising from modifying the standard process)."
msgstr ""
"起動時、MicroPython EPS8266 ポートは内部のフリーズされたモジュールから ``_boot.py`` "
"スクリプトを実行します。FlashROM にファイルシステムをマウントするか、マウントでき"
"なければ、モジュールの初回セットアップを実行してファイルシステムを作成します。"
"ブートプロセスのこの部分は固定されていると見なされ、エンドユーザーのカスタマイズには"
"使用できません(たとえソースからビルドしても、変更を控えてください; 初期ブートプロセスの"
"カスタマイズは、上級ユーザーや開発者だけ、標準的なプロセスを変更することによって生じる"
"問題を自分で診断できる方だけが行うようにしてください)。"

#: ../../../esp8266/general.rst:86
msgid ""
"Once the filesystem is mounted, ``boot.py`` is executed from it. The "
"standard version of this file is created during first-time module set up "
"and has commands to start a WebREPL daemon (disabled by default, "
"configurable with ``webrepl_setup`` module), etc. This file is "
"customizable by end users (for example, you may want to set some "
"parameters or add other services which should be run on a module start-"
"up). But keep in mind that incorrect modifications to boot.py may still "
"lead to boot loops or lock ups, requiring to reflash a module from "
"scratch. (In particular, it's recommended that you use either "
"``webrepl_setup`` module or manual editing to configure WebREPL, but not "
"both)."
msgstr ""
"ファイルシステムがマウントされると、 ``boot.py`` がファイルシステムから実行"
"されます。このファイルの標準バージョンは、初めてモジュールをセットアップするときに"
"作成され、WebREPL デーモンを起動するコマンド(デフォルトでは無効、 "
"``webrepl_setup`` モジュールで設定可能)などがあります。このファイルは"
"エンドユーザーがカスタマイズできます(たとえば、いくつかのパラメータを設定するか、"
"モジュールの起動時に実行する必要がある他のサービスを追加します)。しかし、 "
"``boot.py`` を誤って変更すると、ブートループや障害につながる可能性があり、"
"モジュールを最初から再フラッシュすることになるかもしれないことに注意してください。"
"(特に、 ``webrepl_setup`` モジュール使用、WebREPL 設定の手編集のどちらかを"
"使用することをお勧めしますが、両方を使用することはお勧めしません)。"

#: ../../../esp8266/general.rst:98
msgid ""
"As a final step of boot procedure, ``main.py`` is executed from "
"filesystem, if exists. This file is a hook to start up a user application"
" each time on boot (instead of going to REPL). For small test "
"applications, you may name them directly as ``main.py``, and upload to "
"module, but instead it's recommended to keep your application(s) in "
"separate files, and have just the following in ``main.py``::"
msgstr ""
"ブート手順の最終ステップとして、 ``main.py`` がファイルシステムから実行されます"
"(存在する場合)。このファイルは、ブート時に毎回(REPL に行くのではなく)ユーザー"
"アプリケーションを起動するためのフックです。小規模なテストアプリケーションでは、"
"モジュールに ``main.py`` と直に名前を付けてアップロードすることもできますが、"
"アプリケーションを別々のファイルに保存し、 ``main.py`` で次のようにすることを"
"お勧めします。"

#: ../../../esp8266/general.rst:105
msgid ""
"import my_app\n"
"my_app.main()"
msgstr ""

#: ../../../esp8266/general.rst:108
msgid ""
"This will allow to keep the structure of your application clear, as well "
"as allow to install multiple applications on a board, and switch among "
"them."
msgstr ""
"これにより、アプリケーションの構造を明確に保ち、ボード上に複数の"
"アプリケーションをインストールし、それらの間で切り替えることができます。"

#: ../../../esp8266/general.rst:113
msgid "Known Issues"
msgstr "既知の問題"

#: ../../../esp8266/general.rst:116
msgid "Real-time clock"
msgstr "リアルタイムクロック"

#: ../../../esp8266/general.rst:118
msgid ""
"RTC in ESP8266 has very bad accuracy, drift may be seconds per minute. As"
" a workaround, to measure short enough intervals you can use "
"``utime.time()``, etc. functions, and for wall clock time, synchronize "
"from the net using included ``ntptime.py`` module."
msgstr ""
"ESP8266 の RTC は非常に精度が悪く、ドリフトは毎分秒になる可能性があります。"
"回避策として、十分な短い間隔を測定する ``utime.time()`` などの機能を"
"使用できます。また、実時間とするには、含まれている ``ntptime.py`` モジュールを"
"使用してネットから同期してください。"

#: ../../../esp8266/general.rst:123
msgid ""
"Due to limitations of the ESP8266 chip the internal real-time clock (RTC)"
" will overflow every 7:45h.  If a long-term working RTC time is required "
"then ``time()`` or ``localtime()`` must be called at least once within 7 "
"hours. MicroPython will then handle the overflow."
msgstr ""
"ESP8266 チップの制限により、内部リアルタイムクロック (RTC) は 7:45h 毎に"
"オーバフローします。長期の作業で RTC 時間が必要な場合は ``time()`` または "
"``localtime()`` を7時間以内に少なくとも1回は呼び出す必要があります。"
"そのようにすると、MicroPython がオーバーフローを処理します。"

#: ../../../esp8266/general.rst:129
msgid "Sockets and WiFi buffers overflow"
msgstr "ソケットと WiFi バッファのオーバーフロー"

#: ../../../esp8266/general.rst:131
msgid ""
"Socket instances remain active until they are explicitly closed. This has"
" two consequences. Firstly they occupy RAM, so an application which opens"
" sockets without closing them may eventually run out of memory. Secondly "
"not properly closed socket can cause the low-level part of the vendor "
"WiFi stack to emit ``Lmac`` errors. This occurs if data comes in for a "
"socket and is not processed in a timely manner. This can overflow the "
"WiFi stack input queue and lead to a deadlock. The only recovery is by a "
"hard reset."
msgstr ""
"ソケットインスタンスは、明示的に閉じるまでアクティブのままです。これには２つの影響が"
"あります。まず、RAM を占有するため、ソケットを閉じずにソケットを開いていくアプリケー"
"ションは、最終的にメモリ不足になる可能性があります。第２に、適切に閉じられていない"
"ソケットは、ベンダー WiFi スタックの低レベル部分に ``Lmac`` エラーを発生させる"
"可能性があります。これは、データがソケットで受信され、適時に処理されない場合に"
"発生します。これは、WiFiスタックの入力キューをオーバーフローさせ、デッドロックを"
"招く可能性があります。唯一の回復方法は、ハードリセットすることです。"

#: ../../../esp8266/general.rst:139
msgid ""
"The above may also happen after an application terminates and quits to "
"the REPL for any reason including an exception. Subsequent arrival of "
"data provokes the failure with the above error message repeatedly issued."
" So, sockets should be closed in any case, regardless whether an "
"application terminates successfully or by an exeption, for example using "
"try/finally::"
msgstr ""
"上記は、例外を含む何らかの理由でアプリケーションが終了して REPL を終了した後にも"
"発生する可能性があります。データの後続の到着は、上記のエラーメッセージが繰り返し"
"発行されて失敗を引き起こします。したがって、ソケットは、アプリケーションが正常に"
"終了するかどうかにかかわらず、どんな場合でも閉じなければなりません。たとえば、"
"try/finally を使用します。

#: ../../../esp8266/general.rst:145
msgid ""
"sock = socket(...)\n"
"try:\n"
"    # Use sock\n"
"finally:\n"
"    sock.close()"
msgstr ""

#: ../../../esp8266/general.rst:153
msgid "SSL/TLS limitations"
msgstr "SSL/TLS の制限事項"

#: ../../../esp8266/general.rst:155
msgid ""
"ESP8266 uses `axTLS <http://axtls.sourceforge.net/>`_ library, which is "
"one of the smallest TLS libraries with the compatible licensing. However,"
" it also has some known issues/limitations:"
msgstr ""
"ESP8266 は `axTLS <http://axtls.sourceforge.net/>`_ ライブラリを使用します。"
"これは互換性のあるライセンスを持つ最小の TLS ライブラリの１つです。ただし、既知の"
"問題や制限事項もあります:"

#: ../../../esp8266/general.rst:159
msgid ""
"No support for Diffie-Hellman (DH) key exchange and Elliptic-curve "
"cryptography (ECC). This means it can't work with sites which force the "
"use of these features (it works ok with classic RSA certificates)."
msgstr ""
"Diffie-Hellman (DH)鍵交換と楕円曲線暗号(ECC)のサポートはありません。"
"つまり、これらの機能を使用するサイトでは動作しません(従来のRSA証明書"
"では正常に動作します)。"

#: ../../../esp8266/general.rst:162
msgid ""
"Half-duplex communication nature. axTLS uses a single buffer for both "
"sending and receiving, which leads to considerable memory saving and "
"works well with protocols like HTTP. But there may be problems with "
"protocols which don't follow classic request-response model."
msgstr ""
"半二重通信の性質。axTLSは、送信と受信の両方に単一のバッファを使用するため、"
"メモリの節約につながり、HTTP などのプロトコルでうまく機能します。しかし、"
"古典的な要求応答モデルにしたがわないプロトコルには問題があるかもしれません。"

#: ../../../esp8266/general.rst:167
msgid ""
"Besides axTLS own limitations, the configuration used for MicroPython is "
"highly optimized for code size, which leads to additional limitations "
"(these may be lifted in the future):"
msgstr ""
"axTLS 独自の制限の他に、MicroPython で使用される設定はコードサイズに高度に最適化"
"されているため、さらなる制限があります(これらは将来的に解消される可能性があります)。"

#: ../../../esp8266/general.rst:171
msgid ""
"Optimized RSA algorithms are not enabled, which may lead to slow SSL "
"handshakes."
msgstr ""
"最適化された RSA アルゴリズムが有効になっていないため、SSL ハンドシェイクが"
"遅くなる可能性があります。"

#: ../../../esp8266/general.rst:173
msgid ""
"Stored sessions are not supported (may allow faster repeated connections "
"to the same site in some circumstances)."
msgstr ""
"ストアドセッションはサポートされていません(場合によっては、同じサイトへの接続が"
"高速になる可能性があります)。"

#: ../../../esp8266/general.rst:176
msgid ""
"Besides axTLS specific limitations described above, there's another "
"generic limitation with usage of TLS on the low-memory devices:"
msgstr ""
"上記の axTLS 固有の制限の他に、低メモリデバイスでの TLS の使用には別の一般的な"
"制限があります:"

#: ../../../esp8266/general.rst:179
msgid ""
"The TLS standard specifies the maximum length of the TLS record (unit of "
"TLS communication, the entire record must be buffered before it can be "
"processed) as 16KB. That's almost half of the available ESP8266 memory, "
"and inside a more or less advanced application would be hard to allocate "
"due to memory fragmentation issues. As a compromise, a smaller buffer is "
"used, with the idea that the most interesting usage for SSL would be "
"accessing various REST APIs, which usually require much smaller messages."
" The buffers size is on the order of 5KB, and is adjusted from time to "
"time, taking as a reference being able to access https://google.com . The"
" smaller buffer hower means that some sites can't be accessed using it, "
"and it's not possible to stream large amounts of data."
msgstr ""
"TLS 標準では、TLS レコードの最大長(TLS通信の単位、レコード全体を処理する前に"
"バッファリングする必要があります)を 16KB と指定しています。これは利用可能な "
"ESP8266 メモリのほぼ半分であり、多かれ少なかれ高度なアプリケーションのでは、"
"メモリの断片化の問題のために割り当てが難しいでしょう。妥協案として、より小さな"
"バッファが使用されています。SSL の最も興味深い使い方は、通常ははるかに小さい"
"メッセージを必要とするさまざまな REST API にアクセスするという考え方です。"
"バッファサイズは 5KB のオーダで、時々調整され、https://google.com にアクセス"
"できるようになっています。バッファオーバーフローが小さいということは、一部の"
"サイトにはアクセスできず、大量のデータをストリーミングすることができないという"
"ことです。"

#: ../../../esp8266/general.rst:191
msgid ""
"There are also some not implemented features specifically in "
"MicroPython's ``ussl`` module based on axTLS:"
msgstr ""
"また、AxTLS に ussl 基づくMicroPythonのモジュールに実装されていない"
"機能もあります。"

#: ../../../esp8266/general.rst:194
msgid ""
"Certificates are not validated (this may make connections susceptible to "
"man-in-the-middle attacks)."
msgstr ""
"証明書は検証されません(これにより、中間者攻撃に接続が影響を受ける可能性があります)。"

#: ../../../esp8266/general.rst:196
msgid ""
"There is no support for client certificates (scheduled to be fixed in "
"1.9.4 release)."
msgstr ""
"クライアント証明書はサポートされていません(1.9.4リリースで修正予定)。"

#: ../../../esp8266/quickref.rst:4
msgid "Quick reference for the ESP8266"
msgstr "ESP8266 用クイックリファレンス"

msgid ""
".. image:: esp8266/img/adafruit_products_pinoutstop.jpg\n"
"   :alt: Adafruit Feather HUZZAH board"
msgstr ""

#: ../../../esp8266/quickref.rst:10
msgid "The Adafruit Feather HUZZAH board (image attribution: Adafruit)."
msgstr "Adafruit Feather HUZZAH board (画像出所: Adafruit)"

#: ../../../esp8266/quickref.rst:12
msgid ""
"Below is a quick reference for ESP8266-based boards.  If it is your first"
" time working with this board please consider reading the following "
"sections first:"
msgstr ""
"以下は、ESP8266 ベースのボードのためのクイックリファレンスです。"
"このボードを初めて使う場合は、まず次のセクションを読むことを"
"検討してください。"

#: ../../../esp8266/quickref.rst:22
msgid "Installing MicroPython"
msgstr "MicroPython のインストール"

#: ../../../esp8266/quickref.rst:24
msgid ""
"See the corresponding section of tutorial: :ref:`intro`. It also includes"
" a troubleshooting subsection."
msgstr ""
"チュートリアルの章: :ref:`intro` を参照してください。"
"そこには、トラブルシューティングについても記載されています。"

#: ../../../esp8266/quickref.rst:28
msgid "General board control"
msgstr "ボードの一般的な制御"

#: ../../../esp8266/quickref.rst:30
msgid ""
"The MicroPython REPL is on UART0 (GPIO1=TX, GPIO3=RX) at baudrate 115200."
" Tab-completion is useful to find out what methods an object has. Paste "
"mode (ctrl-E) is useful to paste a large slab of Python code into the "
"REPL."
msgstr ""
"MicroPython REPL は、ボーレート 115200 の UART0 (GPIO1 = TX、GPIO3 = RX)で"
"利用できます。タブ補完は、オブジェクトにどのようなメソッドがあるかを"
"調べるのに便利です。貼り付けモード(ctrl-E)は、大きめの Pythonコードを "
"REPL に貼り付けるのに便利です。"

#: ../../../esp8266/quickref.rst:35
msgid "The :mod:`machine` module::"
msgstr ":mod:`machine` モジュール::"

#: ../../../esp8266/quickref.rst:37
msgid ""
"import machine\n"
"\n"
"machine.freq()          # get the current frequency of the CPU\n"
"machine.freq(160000000) # set the CPU frequency to 160 MHz"
msgstr ""
"import machine\n"
"\n"
"machine.freq()          # CPU の現在の周波数を取得\n"
"machine.freq(160000000) # CPU の周波数を 160 MHz に設定"

#: ../../../esp8266/quickref.rst:42
msgid "The :mod:`esp` module::"
msgstr ":mod:`esp` モジュール::"

#: ../../../esp8266/quickref.rst:44
msgid ""
"import esp\n"
"\n"
"esp.osdebug(None)       # turn off vendor O/S debugging messages\n"
"esp.osdebug(0)          # redirect vendor O/S debugging messages to "
"UART(0)"
msgstr ""
"import esp\n"
"\n"
"esp.osdebug(None)       # ベンダ O/S デバッグメッセージをオフにする\n"
"esp.osdebug(0)          # ベンダ O/S デバッグメッセージを UART(0) にリダイレクト"

#: ../../../esp8266/quickref.rst:50
msgid "Networking"
msgstr "ネットワーキング"

#: ../../../esp8266/quickref.rst:52
msgid "The :mod:`network` module::"
msgstr ":mod:`network` モジュール::"

#: ../../../esp8266/quickref.rst:54
msgid ""
"import network\n"
"\n"
"wlan = network.WLAN(network.STA_IF) # create station interface\n"
"wlan.active(True)       # activate the interface\n"
"wlan.scan()             # scan for access points\n"
"wlan.isconnected()      # check if the station is connected to an AP\n"
"wlan.connect('essid', 'password') # connect to an AP\n"
"wlan.config('mac')      # get the interface's MAC adddress\n"
"wlan.ifconfig()         # get the interface's IP/netmask/gw/DNS addresses"
"\n"
"\n"
"ap = network.WLAN(network.AP_IF) # create access-point interface\n"
"ap.active(True)         # activate the interface\n"
"ap.config(essid='ESP-AP') # set the ESSID of the access point"
msgstr ""
"import network\n"
"\n"
"wlan = network.WLAN(network.STA_IF) # ステーションインタフェースを作成\n"
"wlan.active(True)       # インタフェースをアクティブ化\n"
"wlan.scan()             # アクセスポイントをスキャン\n"
"wlan.isconnected()      # oステーションが AP に繋がったかをチェック\n"
"wlan.connect('essid', 'password') # AP に接続\n"
"wlan.config('mac')      # インタフェースの MAC アドレスを取得\n"
"wlan.ifconfig()         # インタフェースの IP/netmask/gw/DNS アドレスを取得"
"\n"
"\n"
"ap = network.WLAN(network.AP_IF) # アクセスポイントインタフェースを作成\n"
"ap.active(True)         # インタフェースをアクティブ化\n"
"ap.config(essid='ESP-AP') # アクセスポイントの ESSID を設定"

#: ../../../esp8266/quickref.rst:68
msgid "A useful function for connecting to your local WiFi network is::"
msgstr "ローカルの WiFi ネットワークに接続するには、次の関数を流用してください::"

#: ../../../esp8266/quickref.rst:70
msgid ""
"def do_connect():\n"
"    import network\n"
"    wlan = network.WLAN(network.STA_IF)\n"
"    wlan.active(True)\n"
"    if not wlan.isconnected():\n"
"        print('connecting to network...')\n"
"        wlan.connect('essid', 'password')\n"
"        while not wlan.isconnected():\n"
"            pass\n"
"    print('network config:', wlan.ifconfig())"
msgstr ""

#: ../../../esp8266/quickref.rst:81
msgid ""
"Once the network is established the :mod:`socket <usocket>` module can be"
" used to create and use TCP/UDP sockets as usual."
msgstr ""
"ネットワークが確立されると、socket モジュールを使って、通常どおり "
"TCP/UDP ソケットを作成して使用できます。"

#: ../../../esp8266/quickref.rst:85
msgid "Delay and timing"
msgstr "遅延とタイミング"

#: ../../../esp8266/quickref.rst:87
msgid "Use the :mod:`time <utime>` module::"
msgstr ":mod:`time <utime>` モジュールを使います::""

#: ../../../esp8266/quickref.rst:89
msgid ""
"import time\n"
"\n"
"time.sleep(1)           # sleep for 1 second\n"
"time.sleep_ms(500)      # sleep for 500 milliseconds\n"
"time.sleep_us(10)       # sleep for 10 microseconds\n"
"start = time.ticks_ms() # get millisecond counter\n"
"delta = time.ticks_diff(time.ticks_ms(), start) # compute time difference"
msgstr ""
"import time\n"
"\n"
"time.sleep(1)           # 1秒間、一時停止する\n"
"time.sleep_ms(500)      # 500ミリ秒間、一時停止する\n"
"time.sleep_us(10)       # 10マイクロ秒間、一時停止する\n"
"start = time.ticks_ms() # ミリ秒カウンター値を取得\n"
"delta = time.ticks_diff(time.ticks_ms(), start) # 時差を計算"

#: ../../../esp8266/quickref.rst:98
msgid "Timers"
msgstr "タイマー"

#: ../../../esp8266/quickref.rst:100
msgid ""
"Virtual (RTOS-based) timers are supported. Use the :ref:`machine.Timer "
"<machine.Timer>` class with timer ID of -1::"
msgstr ""
"仮想(RTOSベース)タイマーがサポートされています。 "
":ref:`machine.Timer <machine.Timer>` クラスを ID -1 で使ってください。"

#: ../../../esp8266/quickref.rst:103
msgid ""
"from machine import Timer\n"
"\n"
"tim = Timer(-1)\n"
"tim.init(period=5000, mode=Timer.ONE_SHOT, callback=lambda t:print(1))\n"
"tim.init(period=2000, mode=Timer.PERIODIC, callback=lambda t:print(2))"
msgstr ""

#: ../../../esp8266/quickref.rst:109
msgid "The period is in milliseconds."
msgstr "period の単位はミリ秒です。"

#: ../../../esp8266/quickref.rst:112
msgid "Pins and GPIO"
msgstr "ピンと GPIO"

#: ../../../esp8266/quickref.rst:114
msgid "Use the :ref:`machine.Pin <machine.Pin>` class::"
msgstr ":ref:`machine.Pin <machine.Pin>` クラスを使います::"

#: ../../../esp8266/quickref.rst:116
msgid ""
"from machine import Pin\n"
"\n"
"p0 = Pin(0, Pin.OUT)    # create output pin on GPIO0\n"
"p0.on()                 # set pin to \"on\" (high) level\n"
"p0.off()                # set pin to \"off\" (low) level\n"
"p0.value(1)             # set pin to on/high\n"
"\n"
"p2 = Pin(2, Pin.IN)     # create input pin on GPIO2\n"
"print(p2.value())       # get value, 0 or 1\n"
"\n"
"p4 = Pin(4, Pin.IN, Pin.PULL_UP) # enable internal pull-up resistor\n"
"p5 = Pin(5, Pin.OUT, value=1) # set pin high on creation"
msgstr ""
"from machine import Pin\n"
"\n"
"p0 = Pin(0, Pin.OUT)    # GPIO 0 の出力ピンを作成\n"
"p0.on()                 # ピンを \"on\" (high) レベルに設定\n"
"p0.off()                # ピンを \"off\" (low) レベルに設定\n"
"p0.value(1)             # ピンを on/high に設定\n"
"\n"
"p2 = Pin(2, Pin.IN)     # GPIO 2 の入力ピンを作成\n"
"print(p2.value())       # 値 0 または 1 を取得\n"
"\n"
"p4 = Pin(4, Pin.IN, Pin.PULL_UP) # 内部プルアップ抵抗を有効化\n"
"p5 = Pin(5, Pin.OUT, value=1) # 作成時にピンを high に設定"

#: ../../../esp8266/quickref.rst:129
msgid ""
"Available pins are: 0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16, which "
"correspond to the actual GPIO pin numbers of ESP8266 chip. Note that many"
" end-user boards use their own adhoc pin numbering (marked e.g. D0, D1, "
"...). As MicroPython supports different boards and modules, physical pin "
"numbering was chosen as the lowest common denominator. For mapping "
"between board logical pins and physical chip pins, consult your board "
"documentation."
msgstr ""
"使用可能なピンは、ESP8266 チップの実際の GPIO ピン番号に対応する "
"0, 1, 2, 3, 4, 5, 12, 13, 14, 15, 16 です。多くのエンドユーザ用"
"ボードは、独自のピン番号(例：D0, D1, ...)を使っています。"
"MicroPython は様々な ESP8266 ボード/モジュールをサポートするため、"
"最小の公分母として物理ピン番号を採用します。ボードの論理ピンと"
"物理ピンとのマッピングについては、各ボードのマニュアルを参照して"
"ください。"

#: ../../../esp8266/quickref.rst:136
msgid ""
"Note that Pin(1) and Pin(3) are REPL UART TX and RX respectively. Also "
"note that Pin(16) is a special pin (used for wakeup from deepsleep mode) "
"and may be not available for use with higher-level classes like "
"``Neopixel``."
msgstr ""
"Pin(1) と Pin(3) はそれぞれ REPL の UART で使っている TX と RX です。"
"また、Pin(16) は特殊なピンであり(ディープスリープモードからのウェイクアップに"
"使われます)、Neopixel のような高レベルのクラスでは使えません。"

#: ../../../esp8266/quickref.rst:142
msgid "PWM (pulse width modulation)"
msgstr "PWM (パルス幅変調)"

#: ../../../esp8266/quickref.rst:144
msgid ""
"PWM can be enabled on all pins except Pin(16).  There is a single "
"frequency for all channels, with range between 1 and 1000 (measured in "
"Hz).  The duty cycle is between 0 and 1023 inclusive."
msgstr ""
"Pin(16) を除くすべてのピンで PWM を有効化できます。すべてのチャンネルに"
"１つの周波数があり、範囲は 1〜1000 (単位は Hz)です。"
"デューティ比は 0〜1023 です。"

#: ../../../esp8266/quickref.rst:148
msgid "Use the ``machine.PWM`` class::"
msgstr "``machine.PWM`` を使います::"

#: ../../../esp8266/quickref.rst:150
msgid ""
"from machine import Pin, PWM\n"
"\n"
"pwm0 = PWM(Pin(0))      # create PWM object from a pin\n"
"pwm0.freq()             # get current frequency\n"
"pwm0.freq(1000)         # set frequency\n"
"pwm0.duty()             # get current duty cycle\n"
"pwm0.duty(200)          # set duty cycle\n"
"pwm0.deinit()           # turn off PWM on the pin\n"
"\n"
"pwm2 = PWM(Pin(2), freq=500, duty=512) # create and configure in one go"
msgstr ""
"from machine import Pin, PWM\n"
"\n"
"pwm0 = PWM(Pin(0))      # ピンから PWM オブジェクトを作成\n"
"pwm0.freq()             # 現在の周波数を取得\n"
"pwm0.freq(1000)         # 周波数を設定\n"
"pwm0.duty()             # 現在のデューティ比を取得\n"
"pwm0.duty(200)          # デューティ比を設定\n"
"pwm0.deinit()           # PWM を無効化\n"
"\n"
"pwm2 = PWM(Pin(2), freq=500, duty=512) # 作成と設定を一度に実行"

#: ../../../esp8266/quickref.rst:162
msgid "ADC (analog to digital conversion)"
msgstr "ADC (アナログ/デジタル変換)"

#: ../../../esp8266/quickref.rst:164
msgid ""
"ADC is available on a dedicated pin. Note that input voltages on the ADC "
"pin must be between 0v and 1.0v."
msgstr ""
"ADC は専用ピンで利用できます。ADC ピンの入力電圧は 0v と 1.0v の間で"
"なければならないことに注意してください。"

#: ../../../esp8266/quickref.rst:167
msgid "Use the :ref:`machine.ADC <machine.ADC>` class::"
msgstr ":ref:`machine.ADC <machine.ADC>` クラスを使います::"

#: ../../../esp8266/quickref.rst:169
msgid ""
"from machine import ADC\n"
"\n"
"adc = ADC(0)            # ADC ピンの ADC オブジェクトを作成\n"
"adc.read()              # 0-1024 の間の値を読込み"
msgstr ""

#: ../../../esp8266/quickref.rst:175
msgid "Software SPI bus"
msgstr "ソフトウェア SPI バス"

#: ../../../esp8266/quickref.rst:177
msgid ""
"There are two SPI drivers. One is implemented in software (bit-banging) "
"and works on all pins, and is accessed via the :ref:`machine.SPI "
"<machine.SPI>` class::"
msgstr ""
"SPI ドライバは２つあります。１つはソフトウェアで実装され(ビットバンギング)、"
"すべてのピンで動作し、 :ref:`machine.SPI <machine.SPI>` "
"クラスを介してアクセスします::"

#: ../../../esp8266/quickref.rst:181
msgid ""
"from machine import Pin, SPI\n"
"\n"
"# construct an SPI bus on the given pins\n"
"# polarity is the idle state of SCK\n"
"# phase=0 means sample on the first edge of SCK, phase=1 means the second"
"\n"
"spi = SPI(-1, baudrate=100000, polarity=1, phase=0, sck=Pin(0), "
"mosi=Pin(2), miso=Pin(4))\n"
"\n"
"spi.init(baudrate=200000) # set the baudrate\n"
"\n"
"spi.read(10)            # read 10 bytes on MISO\n"
"spi.read(10, 0xff)      # read 10 bytes while outputing 0xff on MOSI\n"
"\n"
"buf = bytearray(50)     # create a buffer\n"
"spi.readinto(buf)       # read into the given buffer (reads 50 bytes in "
"this case)\n"
"spi.readinto(buf, 0xff) # read into the given buffer and output 0xff on "
"MOSI\n"
"\n"
"spi.write(b'12345')     # write 5 bytes on MOSI\n"
"\n"
"buf = bytearray(4)      # create a buffer\n"
"spi.write_readinto(b'1234', buf) # write to MOSI and read from MISO into "
"the buffer\n"
"spi.write_readinto(buf, buf) # write buf to MOSI and read MISO back into "
"buf"
msgstr ""
"from machine import Pin, SPI\n"
"\n"
"# 与えたピンから SPI バスを構築\n"
"# 極性 polarity は SCK のアイドル状態\n"
"# phase=0 は SCK の第１エッジでサンプルを意味、chase=1 は第２を意味"
"\n"
"spi = SPI(-1, baudrate=100000, polarity=1, phase=0, sck=Pin(0), "
"mosi=Pin(2), miso=Pin(4))\n"
"\n"
"spi.init(baudrate=200000) # ボーレートを設定\n"
"\n"
"spi.read(10)            # MISO で 10 バイト読込み\n"
"spi.read(10, 0xff)      # 10 バイト読込み、その間 MOSI に 0xff を出力\n"
"\n"
"buf = bytearray(50)     # バッファを作成\n"
"spi.readinto(buf)       # 与えたバッファに読込み(この場合は 50 バイト)\n"
"spi.readinto(buf, 0xff) # 与えたバッファに読込み、MOSI に 0xff を出力\n"
"\n"
"spi.write(b'12345')     # MOSI に 5 バイト書込み\n"
"\n"
"buf = bytearray(4)      # バッファを作成\n"
"spi.write_readinto(b'1234', buf) # MOSI に書き込み、MISO からバッファに読み込み\n"
"spi.write_readinto(buf, buf) # MOSI に buf を書き込み、MISO から buf に読み込み"

#: ../../../esp8266/quickref.rst:205
msgid "Hardware SPI bus"
msgstr "ハードウェア SPI バス"

#: ../../../esp8266/quickref.rst:207
msgid ""
"The hardware SPI is faster (up to 80Mhz), but only works on following "
"pins: ``MISO`` is GPIO12, ``MOSI`` is GPIO13, and ``SCK`` is GPIO14. It "
"has the same methods as the bitbanging SPI class above, except for the "
"pin parameters for the constructor and init (as those are fixed)::"
msgstr ""
"ハードウェア SPI は高速(最大80Mhz)ですが、 ``MISO`` が GPIO12、 ``MOSI`` が "
"GPIO13、 ``SCK`` が GPIO14 のピンでのみ動作します。上記のビットバンギング SPI "
"クラスと同じメソッドを持っていますが、コンストラクタと init のピンパラメータは"
"固定されています。"

#: ../../../esp8266/quickref.rst:212
msgid ""
"from machine import Pin, SPI\n"
"\n"
"hspi = SPI(1, baudrate=80000000, polarity=0, phase=0)"
msgstr ""

#: ../../../esp8266/quickref.rst:216
msgid "(``SPI(0)`` is used for FlashROM and not available to users.)"
msgstr "(``SPI(0)`` は FlashROM 用に使われるため、ユーザは利用できません。)"

#: ../../../esp8266/quickref.rst:219
msgid "I2C bus"
msgstr "I2C バス"

#: ../../../esp8266/quickref.rst:221
msgid ""
"The I2C driver is implemented in software and works on all pins, and is "
"accessed via the :ref:`machine.I2C <machine.I2C>` class::"
msgstr ""
"I2C ドライバはソフトウェアで実装され、すべてのピンで動作し、"
":ref:`machine.I2C <machine.I2C>` クラスを介してアクセスします::"

#: ../../../esp8266/quickref.rst:224
msgid ""
"from machine import Pin, I2C\n"
"\n"
"# construct an I2C bus\n"
"i2c = I2C(scl=Pin(5), sda=Pin(4), freq=100000)\n"
"\n"
"i2c.readfrom(0x3a, 4)   # read 4 bytes from slave device with address "
"0x3a\n"
"i2c.writeto(0x3a, '12') # write '12' to slave device with address 0x3a\n"
"\n"
"buf = bytearray(10)     # create a buffer with 10 bytes\n"
"i2c.writeto(0x3a, buf)  # write the given buffer to the slave"
msgstr ""
"from machine import Pin, I2C\n"
"\n"
"# I2C バスを構築\n"
"i2c = I2C(scl=Pin(5), sda=Pin(4), freq=100000)\n"
"\n"
"i2c.readfrom(0x3a, 4)   # アドレス 0x3a のスレーブデバイスから 4 バイト読込み\n"
"i2c.writeto(0x3a, '12') # アドレス 0x3a のスレーブデバイスに '12' を書込み\n"
"\n"
"buf = bytearray(10)     # 10バイトのバッファを作成\n"
"i2c.writeto(0x3a, buf)  # 与えたバッファをスレーブに書込み"

#: ../../../esp8266/quickref.rst:236
msgid "Real time clock (RTC)"
msgstr "リアルタイムクロック (RTC)"

#: ../../../esp8266/quickref.rst:238
msgid "See :ref:`machine.RTC <machine.RTC>` ::"
msgstr ":ref:`machine.RTC <machine.RTC>` を参照::"

#: ../../../esp8266/quickref.rst:240
msgid ""
"from machine import RTC\n"
"\n"
"rtc = RTC()\n"
"rtc.datetime((2017, 8, 23, 1, 12, 48, 0, 0)) # set a specific date and "
"time\n"
"rtc.datetime() # get date and time"
msgstr ""
"from machine import RTC\n"
"\n"
"rtc = RTC()\n"
"rtc.datetime((2017, 8, 23, 1, 12, 48, 0, 0)) # 指定の日時を設定\n"
"rtc.datetime() # 日時を取得"

#: ../../../esp8266/quickref.rst:247 ../../../esp8266/tutorial/powerctrl.rst:28
msgid "Deep-sleep mode"
msgstr "ディープスリープモード"

#: ../../../esp8266/quickref.rst:249
msgid ""
"Connect GPIO16 to the reset pin (RST on HUZZAH).  Then the following code"
" can be used to sleep, wake and check the reset cause::"
msgstr ""
"GPIO 16 をリセットピン(HUZZAH| では RST)に接続してください。そのようにしておくと、"
"次のコードを使用して、スリープ、スリープ解除、リセット原因のチェックが行えます::"

#: ../../../esp8266/quickref.rst:252
msgid ""
"import machine\n"
"\n"
"# configure RTC.ALARM0 to be able to wake the device\n"
"rtc = machine.RTC()\n"
"rtc.irq(trigger=rtc.ALARM0, wake=machine.DEEPSLEEP)\n"
"\n"
"# check if the device woke from a deep sleep\n"
"if machine.reset_cause() == machine.DEEPSLEEP_RESET:\n"
"    print('woke from a deep sleep')\n"
"\n"
"# set RTC.ALARM0 to fire after 10 seconds (waking the device)\n"
"rtc.alarm(rtc.ALARM0, 10000)\n"
"\n"
"# put the device to sleep\n"
"machine.deepsleep()"
msgstr ""
"import machine\n"
"\n"
"# デバイスを起こすための RTC.ALARM0 を設定\n"
"rtc = machine.RTC()\n"
"rtc.irq(trigger=rtc.ALARM0, wake=machine.DEEPSLEEP)\n"
"\n"
"# ディープスリープから起こされたかをチェック\n"
"if machine.reset_cause() == machine.DEEPSLEEP_RESET:\n"
"    print('woke from a deep sleep')\n"
"\n"
"# 10秒後に RTC.ALARM0 を発火して、デバイスを起こすよう設定\n"
"rtc.alarm(rtc.ALARM0, 10000)\n"
"\n"
"# ディープスリープに入る\n"
"machine.deepsleep()"

#: ../../../esp8266/quickref.rst:269
msgid "OneWire driver"
msgstr "OneWire ドライバ"

#: ../../../esp8266/quickref.rst:271
msgid "The OneWire driver is implemented in software and works on all pins::"
msgstr "OneWire ドライバはソフトウェアで実装され、すべてのピンで動作します::"

#: ../../../esp8266/quickref.rst:273
msgid ""
"from machine import Pin\n"
"import onewire\n"
"\n"
"ow = onewire.OneWire(Pin(12)) # create a OneWire bus on GPIO12\n"
"ow.scan()               # return a list of devices on the bus\n"
"ow.reset()              # reset the bus\n"
"ow.readbyte()           # read a byte\n"
"ow.writebyte(0x12)      # write a byte on the bus\n"
"ow.write('123')         # write bytes on the bus\n"
"ow.select_rom(b'12345678') # select a specific device by its ROM code"
msgstr ""
"from machine import Pin\n"
"import onewire\n"
"\n"
"ow = onewire.OneWire(Pin(12)) # GPIO 12 で OneWire バスを作成\n"
"ow.scan()               # バス上のデバイスリストをスキャン\n"
"ow.reset()              # バスをリセット\n"
"ow.readbyte()           # １バイト読込み\n"
"ow.writebyte(0x12)      # バスに１バイト書込み\n"
"ow.write('123')         # バスに複数バイト書込み\n"
"ow.select_rom(b'12345678') # ROM コードで指定したデバイスを選択"

#: ../../../esp8266/quickref.rst:284
msgid "There is a specific driver for DS18S20 and DS18B20 devices::"
msgstr "DS18S20 と DS18B20 デバイス用の特定のドライバがあります::"

#: ../../../esp8266/quickref.rst:286
msgid ""
"import time, ds18x20\n"
"ds = ds18x20.DS18X20(ow)\n"
"roms = ds.scan()\n"
"ds.convert_temp()\n"
"time.sleep_ms(750)\n"
"for rom in roms:\n"
"    print(ds.read_temp(rom))"
msgstr ""

#: ../../../esp8266/quickref.rst:294
msgid ""
"Be sure to put a 4.7k pull-up resistor on the data line.  Note that the "
"``convert_temp()`` method must be called each time you want to sample the"
" temperature."
msgstr ""
"4.7k のプルアップ抵抗をデータラインに接続してください。"
"``convert_temp()`` メソッドは、温度をサンプリングするたびに呼び出す"
"必要があることに注意してください。"

#: ../../../esp8266/quickref.rst:299
msgid "NeoPixel driver"
msgstr "NeoPixel ドライバ"

#: ../../../esp8266/quickref.rst:301
msgid "Use the ``neopixel`` module::"
msgstr "``neopixel`` モジュールを使います::"

#: ../../../esp8266/quickref.rst:303
msgid ""
"from machine import Pin\n"
"from neopixel import NeoPixel\n"
"\n"
"pin = Pin(0, Pin.OUT)   # set GPIO0 to output to drive NeoPixels\n"
"np = NeoPixel(pin, 8)   # create NeoPixel driver on GPIO0 for 8 pixels\n"
"np[0] = (255, 255, 255) # set the first pixel to white\n"
"np.write()              # write data to all pixels\n"
"r, g, b = np[0]         # get first pixel colour"
msgstr ""
"from machine import Pin\n"
"from neopixel import NeoPixel\n"
"\n"
"pin = Pin(0, Pin.OUT)   # NeoPixel 駆動のための GPIO 0 を出力に設定\n"
"np = NeoPixel(pin, 8)   # 8ピクセル用の NeoPixel ドライバを GPIO 0 で作成\n"
"np[0] = (255, 255, 255) # 第１ピクセルを白に設定\n"
"np.write()              # 全ピクセルにデータ書込み\n"
"r, g, b = np[0]         # 第１ピクセルの色を取得"

#: ../../../esp8266/quickref.rst:312
msgid "For low-level driving of a NeoPixel::"
msgstr "NeoPixel の低レベル駆動もあります::"

#: ../../../esp8266/quickref.rst:314
msgid ""
"import esp\n"
"esp.neopixel_write(pin, grb_buf, is800khz)"
msgstr ""

#: ../../../esp8266/quickref.rst:318
msgid "APA102 driver"
msgstr "APA102 ドライバ"

#: ../../../esp8266/quickref.rst:320
msgid "Use the ``apa102`` module::"
msgstr "``apa102`` モジュールを使います::"

#: ../../../esp8266/quickref.rst:322
msgid ""
"from machine import Pin\n"
"from apa102 import APA102\n"
"\n"
"clock = Pin(14, Pin.OUT)     # set GPIO14 to output to drive the clock\n"
"data = Pin(13, Pin.OUT)      # set GPIO13 to output to drive the data\n"
"apa = APA102(clock, data, 8) # create APA102 driver on the clock and the "
"data pin for 8 pixels\n"
"apa[0] = (255, 255, 255, 31) # set the first pixel to white with a "
"maximum brightness of 31\n"
"apa.write()                  # write data to all pixels\n"
"r, g, b, brightness = apa[0] # get first pixel colour"
msgstr ""
"from machine import Pin\n"
"from apa102 import APA102\n"
"\n"
"clock = Pin(14, Pin.OUT)     # クロック駆動のための GPIO 14 を出力に設定\n"
"data = Pin(13, Pin.OUT)      # データ駆動のための GPIO 13 を出力に設定\n"
"apa = APA102(clock, data, 8) # 8ピクセル用の APA102 ドライバを clock と data ピンで作成\n"
"apa[0] = (255, 255, 255, 31) # 第１ピクセルを輝度 31 の白に設定\n"
"apa.write()                  # 全ピクセルにデータ書込み\n"
"r, g, b, brightness = apa[0] # 第１ピクセルの色を取得"

#: ../../../esp8266/quickref.rst:332
msgid "For low-level driving of an APA102::"
msgstr "APA102 の低レベル駆動もあります::"

#: ../../../esp8266/quickref.rst:334
msgid ""
"import esp\n"
"esp.apa102_write(clock_pin, data_pin, rgbi_buf)"
msgstr ""

#: ../../../esp8266/quickref.rst:338
msgid "DHT driver"
msgstr "DHT ドライバ"

#: ../../../esp8266/quickref.rst:340
msgid "The DHT driver is implemented in software and works on all pins::"
msgstr "DHT ドライバはソフトウェアで実装され、すべてのピンで動作します::"

#: ../../../esp8266/quickref.rst:342
msgid ""
"import dht\n"
"import machine\n"
"\n"
"d = dht.DHT11(machine.Pin(4))\n"
"d.measure()\n"
"d.temperature() # eg. 23 (°C)\n"
"d.humidity()    # eg. 41 (% RH)\n"
"\n"
"d = dht.DHT22(machine.Pin(4))\n"
"d.measure()\n"
"d.temperature() # eg. 23.6 (°C)\n"
"d.humidity()    # eg. 41.3 (% RH)"
msgstr ""
"import dht\n"
"import machine\n"
"\n"
"d = dht.DHT11(machine.Pin(4))\n"
"d.measure()\n"
"d.temperature() # 例: 23 (°C)\n"
"d.humidity()    # 例: 41 (% RH)\n"
"\n"
"d = dht.DHT22(machine.Pin(4))\n"
"d.measure()\n"
"d.temperature() # 例: 23.6 (°C)\n"
"d.humidity()    # 例: 41.3 (% RH)"

#: ../../../esp8266/quickref.rst:356
msgid "WebREPL (web browser interactive prompt)"
msgstr "WebREPL (Web ベースの対話プロンプト)"

#: ../../../esp8266/quickref.rst:358
msgid ""
"WebREPL (REPL over WebSockets, accessible via a web browser) is an "
"experimental feature available in ESP8266 port. Download web client from "
"https://github.com/micropython/webrepl (hosted version available at "
"http://micropython.org/webrepl), and configure it by executing::"
msgstr ""
"WebREPL (Web ブラウザ経由でアクセス可能な REPL)は、ESP8266 ポートで"
"使用可能な実験的な機能です。Web クライアントを "
"https://github.com/micropython/webrepl "
"(http://micropython.org/webrepl で入手可能なホストバージョン)"
"からダウンロードしてきて、次のコマンドを実行して設定してください。"

#: ../../../esp8266/quickref.rst:363 ../../../esp8266/tutorial/repl.rst:51
msgid "import webrepl_setup"
msgstr ""

#: ../../../esp8266/quickref.rst:365
msgid ""
"and following on-screen instructions. After reboot, it will be available "
"for connection. If you disabled automatic start-up on boot, you may run "
"configured daemon on demand using::"
msgstr ""
"画面の指示にしたがいます。再起動後、接続可能になります。起動時に自動起動を無効にした"
"場合は、次のコマンドを使用してデーモンを実行することができます。"

#: ../../../esp8266/quickref.rst:369
msgid ""
"import webrepl\n"
"webrepl.start()"
msgstr ""

#: ../../../esp8266/quickref.rst:372
msgid ""
"The supported way to use WebREPL is by connecting to ESP8266 access "
"point, but the daemon is also started on STA interface if it is active, "
"so if your router is set up and works correctly, you may also use WebREPL"
" while connected to your normal Internet access point (use the ESP8266 AP"
" connection method if you face any issues)."
msgstr ""
"WebREPL を使用するためにサポートされている方法は、ESP8266 アクセスポイントに"
"接続することですが、デーモンがアクティブな場合は STA インタフェースでも起動できます。"
"ルータが設定され正しく動作する場合、通常のインターネットアクセスポイントに接続して"
"いれば WebREPL が使えるでしょう(問題が発生した場合は ESP8266 AP 接続メソッドを"
"使ってください)。"

#: ../../../esp8266/quickref.rst:378
msgid ""
"Besides terminal/command prompt access, WebREPL also has provision for "
"file transfer (both upload and download). Web client has buttons for the "
"corresponding functions, or you can use command-line client "
"``webrepl_cli.py`` from the repository above."
msgstr ""
"ターミナル/コマンドプロンプトでできることの他に、WebREPL にはファイル転送"
"(アップロードとダウンロードの両方)の機能も用意しています。Webクライアントには、"
"対応する機能のボタンがあります。また、上記のリポジトリのコマンドラインクライアント"
"``webrepl_cli.py`` を使うこともできます。"

#: ../../../esp8266/quickref.rst:383
msgid ""
"See the MicroPython forum for other community-supported alternatives to "
"transfer files to ESP8266."
msgstr ""
"ファイルを ESP8266 に転送するための、コミュニティでサポートされている"
"他の代替方法については、MicroPython フォーラムを参照してください。"

#: ../../../esp8266/tutorial/adc.rst:2
msgid "Analog to Digital Conversion"
msgstr "アナログ/デジタル変換"

#: ../../../esp8266/tutorial/adc.rst:4
msgid ""
"The ESP8266 has a single pin (separate to the GPIO pins) which can be "
"used to read analog voltages and convert them to a digital value.  You "
"can construct such an ADC pin object using::"
msgstr ""
"ESP8266 には、アナログ電圧を読み取ってデジタル値に変換するために使用できるピンが"
"１つだけあります(GPIOピンとは別)。このような ADC ピンオブジェクトは、次のように"
"して構築できます。"

#: ../../../esp8266/tutorial/adc.rst:8
msgid ""
">>> import machine\n"
">>> adc = machine.ADC(0)"
msgstr ""

#: ../../../esp8266/tutorial/adc.rst:11
msgid "Then read its value with::"
msgstr "値は次のようにして読んでください::"

#: ../../../esp8266/tutorial/adc.rst:13
msgid ""
">>> adc.read()\n"
"58"
msgstr ""

#: ../../../esp8266/tutorial/adc.rst:16
msgid ""
"The values returned from the ``read()`` function are between 0 (for 0.0 "
"volts) and 1024 (for 1.0 volts).  Please note that this input can only "
"tolerate a maximum of 1.0 volts and you must use a voltage divider "
"circuit to measure larger voltages."
msgstr ""
"``read()`` 関数から返される値は、0 (0.0ボルト)と 1024 (1.0ボルト)の間です。"
"この入力は最大 1.0 ボルトしか許容できないため、これより大きな電圧を測定するには"
"分圧器回路を使用する必要があります。"

#: ../../../esp8266/tutorial/dht.rst:2
msgid "Temperature and Humidity"
msgstr "温度と湿度"

#: ../../../esp8266/tutorial/dht.rst:4
msgid ""
"DHT (Digital Humidity & Temperature) sensors are low cost digital sensors"
" with capacitive humidity sensors and thermistors to measure the "
"surrounding air. They feature a chip that handles analog to digital "
"conversion and provide a 1-wire interface. Newer sensors additionally "
"provide an I2C interface."
msgstr ""
"DHT (Digital Humidity & Temperature)センサは、周囲の空気を測定する静電容量式湿度"
"センサとサーミスタを備えた低コストのデジタルセンサです。これらは、アナログ/デジタル変換を"
"処理し、1-wire インタフェースを提供するチップを備えています。より新しいセンサーは、"
"I2Cインターフェースを追加提供します。"

#: ../../../esp8266/tutorial/dht.rst:9
msgid ""
"The DHT11 (blue) and DHT22 (white) sensors provide the same 1-wire "
"interface, however, the DHT22 requires a separate object as it has more "
"complex calculation. DHT22 have 1 decimal place resolution for both "
"humidity and temperature readings. DHT11 have whole number for both."
msgstr ""
"DHT11 (青)と DHT22 (白)センサーは同じ 1-wire インターフェースを提供しますが、"
"DHT22 はより複雑な計算を必要とするため別のオブジェクトが必要です。DHT22 は、"
"湿度と温度の両方の読み取り値に対して小数点以下1桁の分解能を持ちます。DHT11 は"
"両方とも整数での分解能になります。"

#: ../../../esp8266/tutorial/dht.rst:14
msgid ""
"A custom 1-wire protocol, which is different to Dallas 1-wire, is used to"
" get the measurements from the sensor. The payload consists of a humidity"
" value, a temperature value and a checksum."
msgstr ""
"センサーから測定値を取得するには、Dallas 1-wire とは異なるカスタムの 1-wire "
"プロトコルを使います。ペイロードは、湿度値、温度値、チェックサムで構成されています。"

#: ../../../esp8266/tutorial/dht.rst:18
msgid ""
"To use the 1-wire interface, construct the objects referring to their "
"data pin::"
msgstr ""
"1-wire インタフェースを使うには、データピンを指定してオブジェクトを構築します::"

#: ../../../esp8266/tutorial/dht.rst:20
msgid ""
">>> import dht\n"
">>> import machine\n"
">>> d = dht.DHT11(machine.Pin(4))\n"
"\n"
">>> import dht\n"
">>> import machine\n"
">>> d = dht.DHT22(machine.Pin(4))"
msgstr ""

#: ../../../esp8266/tutorial/dht.rst:28
msgid "Then measure and read their values with::"
msgstr "次に、測定を行い、その結果を読み取ります::"

#: ../../../esp8266/tutorial/dht.rst:30
msgid ""
">>> d.measure()\n"
">>> d.temperature()\n"
">>> d.humidity()"
msgstr ""

#: ../../../esp8266/tutorial/dht.rst:34
msgid ""
"Values returned from ``temperature()`` are in degrees Celsius and values "
"returned from ``humidity()`` are a percentage of relative humidity."
msgstr ""
"``temperature() `` が返す測定値は摂氏で、 ``humidity()`` が返す測定値は相対湿度"
"のパーセンテージです。"

#: ../../../esp8266/tutorial/dht.rst:37
msgid ""
"The DHT11 can be called no more than once per second and the DHT22 once "
"every two seconds for most accurate results. Sensor accuracy will degrade"
" over time. Each sensor supports a different operating range. Refer to "
"the product datasheets for specifics."
msgstr ""
"最も正確な結果を得るために、DHT11 では1秒間に1回、DHT22 では2秒に1回だけ呼び出せます。"
"センサの精度は時間とともに低下します。各センサは異なる動作範囲をサポートしています。"
"詳細については、製品データシートを参照してください。"

#: ../../../esp8266/tutorial/dht.rst:42
msgid ""
"In 1-wire mode, only three of the four pins are used and in I2C mode, all"
" four pins are used. Older sensors may still have 4 pins even though they"
" do not support I2C. The 3rd pin is simply not connected."
msgstr ""
"1-wire モードでは、4ピンのうちの3ピンのみが使用され、I2C モードでは、4ピンがすべて"
"使用されます。古いセンサーは I2C をサポートしていないにもかかわらず4つのピンを持って"
"いることがあります。3番ピンは単に接続されていません。"

#: ../../../esp8266/tutorial/dht.rst:46
msgid "Pin configurations:"
msgstr "ピン配置"

#: ../../../esp8266/tutorial/dht.rst:48
msgid "Sensor without I2C in 1-wire mode (eg. DHT11, DHT22, AM2301, AM2302):"
msgstr "1-wire モードで I2C のないセンサ (例: DHT11, DHT22, AM2301, AM2302):"

#: ../../../esp8266/tutorial/dht.rst:50
msgid "1=VDD, 2=Data, 3=NC, 4=GND"
msgstr ""

#: ../../../esp8266/tutorial/dht.rst:52
msgid "Sensor with I2C in 1-wire mode (eg. DHT12, AM2320, AM2321, AM2322):"
msgstr "1-wite モードで I2C ありのセンサー (例: DHT12, AM2320, AM2321, AM2322):"

#: ../../../esp8266/tutorial/dht.rst:54
msgid "1=VDD, 2=Data, 3=GND, 4=GND"
msgstr ""

#: ../../../esp8266/tutorial/dht.rst:56
msgid "Sensor with I2C in I2C mode (eg. DHT12, AM2320, AM2321, AM2322):"
msgstr "I2C モードで I2C ありのセンサー (例: DHT12, AM2320, AM2321, AM2322):"

#: ../../../esp8266/tutorial/dht.rst:58
msgid "1=VDD, 2=SDA, 3=GND, 4=SCL"
msgstr ""

#: ../../../esp8266/tutorial/dht.rst:60
msgid "You should use pull-up resistors for the Data, SDA and SCL pins."
msgstr "データ、SDA, SCL ピンにはプルアップ抵抗を使用する必要があります。"

#: ../../../esp8266/tutorial/dht.rst:62
msgid ""
"To make newer I2C sensors work in backwards compatible 1-wire mode, you "
"must connect both pins 3 and 4 to GND. This disables the I2C interface."
msgstr ""
"新しい I2C センサを下位互換性のある 1-wire モードで動作させるには、ピン3と4の"
"両方を GND に接続する必要があります。これにより I2C インターフェイスが無効になります。"

#: ../../../esp8266/tutorial/dht.rst:65
msgid ""
"DHT22 sensors are now sold under the name AM2302 and are otherwise "
"identical."
msgstr "DHT22 センサーは現在、AM2302 という名前で販売されています。"

#: ../../../esp8266/tutorial/filesystem.rst:2
msgid "The internal filesystem"
msgstr "内部ファイルシステム"

#: ../../../esp8266/tutorial/filesystem.rst:4
msgid ""
"If your devices has 1Mbyte or more of storage then it will be set up "
"(upon first boot) to contain a filesystem.  This filesystem uses the FAT "
"format and is stored in the flash after the MicroPython firmware."
msgstr ""
"デバイスが 1Mbyte 以上のストレージを持っているなら、ファイルシステムを含むように"
"(最初の起動時に)設定されます。このファイルシステムは FAT フォーマットを使用し、"
"MicroPython ファームウェアの後にフラッシュに保存されます。"

#: ../../../esp8266/tutorial/filesystem.rst:9
msgid "Creating and reading files"
msgstr "ファイルの作成と読み取り"

#: ../../../esp8266/tutorial/filesystem.rst:11
msgid ""
"MicroPython on the ESP8266 supports the standard way of accessing files "
"in Python, using the built-in ``open()`` function."
msgstr ""
"ESP8266 の MicroPython は、組込みの ``open()`` 関数を使用して Python で"
"ファイルにアクセスする標準的な方法をサポートしています。"

#: ../../../esp8266/tutorial/filesystem.rst:14
msgid "To create a file try::"
msgstr "ファイルを作成するには次のようにします::"

#: ../../../esp8266/tutorial/filesystem.rst:16
msgid ""
">>> f = open('data.txt', 'w')\n"
">>> f.write('some data')\n"
"9\n"
">>> f.close()"
msgstr ""

#: ../../../esp8266/tutorial/filesystem.rst:21
msgid ""
"The \"9\" is the number of bytes that were written with the ``write()`` "
"method. Then you can read back the contents of this new file using::"
msgstr ""
"\"9\" は、 ``write()`` メソッドで書き込まれたバイト数です。次のコマンドを"
"使用して、この新しいファイルの内容を読み取ることができます。"

#: ../../../esp8266/tutorial/filesystem.rst:24
msgid ""
">>> f = open('data.txt')\n"
">>> f.read()\n"
"'some data'\n"
">>> f.close()"
msgstr ""

#: ../../../esp8266/tutorial/filesystem.rst:29
msgid ""
"Note that the default mode when opening a file is to open it in read-only"
" mode, and as a text file.  Specify ``'wb'`` as the second argument to "
"``open()`` to open for writing in binary mode, and ``'rb'`` to open for "
"reading in binary mode."
msgstr ""
"ファイルを開くときの既定のモードは、読取り専用モードでテキストファイルとして開くことです。"
"バイナリモードでの書込み用に開くには ``open()`` の第２引数に ``'wb'`` を指定し、"
"読取り用に開くには 'rb' を指定します。"

#: ../../../esp8266/tutorial/filesystem.rst:35
msgid "Listing file and more"
msgstr "ファイルのリスト表示など"

#: ../../../esp8266/tutorial/filesystem.rst:37
msgid ""
"The os module can be used for further control over the filesystem.  First"
" import the module::"
msgstr ""
"os モジュールは、ファイルシステムをさらに制御するために使用できます。最初に"
"モジュールをインポートします::"

#: ../../../esp8266/tutorial/filesystem.rst:40
msgid ">>> import os"
msgstr ""

#: ../../../esp8266/tutorial/filesystem.rst:42
msgid "Then try listing the contents of the filesystem::"
msgstr "次に、ファイルシステムの内容を列挙してみてください::"

#: ../../../esp8266/tutorial/filesystem.rst:44
msgid ""
">>> os.listdir()\n"
"['boot.py', 'port_config.py', 'data.txt']"
msgstr ""

#: ../../../esp8266/tutorial/filesystem.rst:47
msgid "You can make directories::"
msgstr "ディレクトリを作れます::"

#: ../../../esp8266/tutorial/filesystem.rst:49
msgid ">>> os.mkdir('dir')"
msgstr ""

#: ../../../esp8266/tutorial/filesystem.rst:51
msgid "And remove entries::"
msgstr "エントリを削除できます::"

#: ../../../esp8266/tutorial/filesystem.rst:53
msgid ">>> os.remove('data.txt')"
msgstr ""

#: ../../../esp8266/tutorial/filesystem.rst:56
msgid "Start up scripts"
msgstr "スクリプトの起動"

#: ../../../esp8266/tutorial/filesystem.rst:58
msgid ""
"There are two files that are treated specially by the ESP8266 when it "
"starts up: boot.py and main.py.  The boot.py script is executed first (if"
" it exists) and then once it completes the main.py script is executed.  "
"You can create these files yourself and populate them with the code that "
"you want to run when the device starts up."
msgstr ""
"起動時に ESP8266 によって特別に扱われるファイルは、boot.py と main.py の２つです。"
"boot.py スクリプトが(存在する場合)最初に実行され、それが完了すると main.py "
"スクリプトが実行されます。これらのファイルを自分で作成し、デバイスの起動時に実行する"
"コードを入力できます。"

#: ../../../esp8266/tutorial/filesystem.rst:65
msgid "Accessing the filesystem via WebREPL"
msgstr "WebREPL を介したファイルシステムへのアクセス"

#: ../../../esp8266/tutorial/filesystem.rst:67
msgid ""
"You can access the filesystem over WebREPL using the web client in a "
"browser or via the command-line tool. Please refer to Quick Reference and"
" Tutorial sections for more information about WebREPL."
msgstr ""
"ブラウザまたはコマンドラインツールなどの Web クライアントを使い、WebREPL を介して"
"ファイルシステムにアクセスできます。WebREPL の詳細については、クイックリファレンスと"
"チュートリアルの章を参照してください。"

#: ../../../esp8266/tutorial/index.rst:4
msgid "MicroPython tutorial for ESP8266"
msgstr "ESP8266用 MicroPythonチュートリアル"

#: ../../../esp8266/tutorial/index.rst:6
msgid ""
"This tutorial is intended to get you started using MicroPython on the "
"ESP8266 system-on-a-chip.  If it is your first time it is recommended to "
"follow the tutorial through in the order below.  Otherwise the sections "
"are mostly self contained, so feel free to skip to those that interest "
"you."
msgstr ""
"このチュートリアルは、MicroPython を ESP8266 システムオンチップ上で使用することを"
"目的としています。初めての場合は、以下の順番でチュートリアルを読み進めるよう"
"お勧めします。初めてでない場合、章はほとんど自己完結型であるので、興味のあるところを"
"読むだけでよいです。"

#: ../../../esp8266/tutorial/index.rst:11
msgid ""
"The tutorial does not assume that you know Python, but it also does not "
"attempt to explain any of the details of the Python language.  Instead it"
" provides you with commands that are ready to run, and hopes that you "
"will gain a bit of Python knowledge along the way.  To learn more about "
"Python itself please refer to `<https://www.python.org>`__."
msgstr ""
"このチュートリアルでは Python を知っていることを仮定していませんが、Python 言語の"
"詳細については説明しません。代わりに、そのまま実行できるコマンドを示していますし、"
"途中で少しだけ Python 知識が得られるようにしています。Python自体の詳細については、 "
"`<https://www.python.org>`__ を参照してください。"

#: ../../../esp8266/tutorial/intro.rst:4
msgid "Getting started with MicroPython on the ESP8266"
msgstr "ESP8266でのMicroPythonの使い方"

#: ../../../esp8266/tutorial/intro.rst:6
msgid ""
"Using MicroPython is a great way to get the most of your ESP8266 board.  "
"And vice versa, the ESP8266 chip is a great platform for using "
"MicroPython.  This tutorial will guide you through setting up "
"MicroPython, getting a prompt, using WebREPL, connecting to the network "
"and communicating with the Internet, using the hardware peripherals, and "
"controlling some external components."
msgstr ""
"MicroPython を使うと、ESP8266 ボードを最大限に活用することができます。"
"逆も同様、ESP8266 チップは MicroPython を使用するための優れたプラットフォームです。"
"このチュートリアルでは、MicroPython の設定、プロンプトの表示、WebREPLの使用、"
"ネットワークへの接続、インターネットとの通信、ハードウェアペリフェラルの使用、"
"およびいくつかの外部コンポーネントの制御について説明します。"

#: ../../../esp8266/tutorial/intro.rst:12
msgid "Let's get started!"
msgstr "始めましょう！"

#: ../../../esp8266/tutorial/intro.rst:15
msgid "Requirements"
msgstr "必要なもの"

#: ../../../esp8266/tutorial/intro.rst:17
msgid ""
"The first thing you need is a board with an ESP8266 chip.  The "
"MicroPython software supports the ESP8266 chip itself and any board "
"should work.  The main characteristic of a board is how much flash it "
"has, how the GPIO pins are connected to the outside world, and whether it"
" includes a built-in USB-serial convertor to make the UART available to "
"your PC."
msgstr ""
"最初に必要なのは、ESP8266 チップを搭載したボードです。MicroPython ソフトウェアは "
"ESP8266 チップ自体をサポートしており、どのボードでも動作するはずです。"
"ボードについて気にするとことは、どれくらいのフラッシュがあるか、GPIO ピンが外に"
"どのように接続されているか、UART を PC で使用できるようにする内蔵 USB シリアル"
"コンバータが含まれているかどうかです。"

#: ../../../esp8266/tutorial/intro.rst:23
msgid ""
"The minimum requirement for flash size is 1Mbyte. There is also a special"
" build for boards with 512KB, but it is highly limited comparing to the "
"normal build: there is no support for filesystem, and thus features which"
" depend on it won't work (WebREPL, upip, etc.). As such, 512KB build will"
" be more interesting for users who build from source and fine-tune "
"parameters for their particular application."
msgstr ""
"フラッシュサイズの最小要件は1Mバイトです。また、512KB のボード専用のビルドもありますが、"
"通常のビルドに比べて非常に制限されています。ファイルシステムのサポートがないため、"
"それに依存する機能は動作しません(WebREPL、upip など)。したがって、ソースからビルドし、"
"特定のアプリケーションのパラメータを微調整するユーザーにとっては、512KB ビルドが"
"より面白くなります。"

#: ../../../esp8266/tutorial/intro.rst:30
msgid ""
"Names of pins will be given in this tutorial using the chip names (eg "
"GPIO0) and it should be straightforward to find which pin this "
"corresponds to on your particular board."
msgstr ""
"このチュートリアルでは、チップ名(GPIO 0など)を使用してピンの名前を示しています。"
"これは、特定のボード上のどのピンに対応しているかを簡単に見つけることができます。"

#: ../../../esp8266/tutorial/intro.rst:35
msgid "Powering the board"
msgstr "ボードの電源を入れる"

#: ../../../esp8266/tutorial/intro.rst:37
msgid ""
"If your board has a USB connector on it then most likely it is powered "
"through this when connected to your PC.  Otherwise you will need to power"
" it directly. Please refer to the documentation for your board for "
"further details."
msgstr ""
"ボードに USB コネクタがある場合は、PC に接続されているときに電源が供給されている"
"可能性が非常に高いです。それ以外の場合は、直接電源を入力する必要があります。"
"詳細については、ボードのドキュメントを参照してください。"

#: ../../../esp8266/tutorial/intro.rst:42
msgid "Getting the firmware"
msgstr "ファームウェアの入手"

#: ../../../esp8266/tutorial/intro.rst:44
msgid ""
"The first thing you need to do is download the most recent MicroPython "
"firmware .bin file to load onto your ESP8266 device. You can download it "
"from the `MicroPython downloads page "
"<http://micropython.org/download#esp8266>`_. From here, you have 3 main "
"choices"
msgstr ""
"まず、最新の MicroPython ファームウェアの .bin ファイルをダウンロードして、"
"ESP8266 デバイスにロードします。ファームウェアは "
"`MicroPython ダウンロードページ <http://micropython.org/download#esp8266>`_ "
"からダウンロードできます。ここには、3つの主要な選択肢があります。"

#: ../../../esp8266/tutorial/intro.rst:49
msgid "Stable firmware builds for 1024kb modules and above."
msgstr "安定版ファームウェアが 1024kb 以上のモジュール用にビルドされています。"

#: ../../../esp8266/tutorial/intro.rst:50
msgid "Daily firmware builds for 1024kb modules and above."
msgstr "毎日ビルド版ファームウェアが 1024kb以上のモジュール用にビルドされています。"

#: ../../../esp8266/tutorial/intro.rst:51
msgid "Daily firmware builds for 512kb modules."
msgstr "毎日ビルド版ファームウェアが 512kb のモジュール用にビルドされています。"

#: ../../../esp8266/tutorial/intro.rst:53
msgid ""
"If you are just starting with MicroPython, the best bet is to go for the "
"Stable firmware builds. If you are an advanced, experienced MicroPython "
"ESP8266 user who would like to follow development closely and help with "
"testing new features, there are daily builds (note: you actually may need"
" some development experience, e.g. being ready to follow git history to "
"know what new changes and features were introduced)."
msgstr ""
"MicroPython を使い始めたばかりの方には、安定版ファームウェアビルドをお勧めします。"
"経験豊富で経験豊かな MicroPython ESP8266 ユーザーで、開発が続けられている新機能を"
"テストしたい場合は、毎日ビルド版があります(注記: 実際に開発経験が必要です。たとえば、"
"どのような新しい変更や機能が導入されたのか知るために git の履歴を追う準備をするなど)。"

#: ../../../esp8266/tutorial/intro.rst:60
msgid ""
"Support for 512kb modules is provided on a feature preview basis. For end"
" users, it's recommended to use modules with flash of 1024kb or more. As "
"such, only daily builds for 512kb modules are provided."
msgstr ""
"機能のお試しを目的として 512kb モジュールのサポートが提供されています。エンドユーザーに"
"とっては、フラッシュメモリが 1024kb 以上のモジュールを使用することをお勧めします。"
"そのため、512kb モジュールは毎日ビルド版のみが提供されています。"

#: ../../../esp8266/tutorial/intro.rst:65
msgid "Deploying the firmware"
msgstr "ファームウェアの配備"

#: ../../../esp8266/tutorial/intro.rst:67
msgid ""
"Once you have the MicroPython firmware (compiled code), you need to load "
"it onto your ESP8266 device.  There are two main steps to do this: first "
"you need to put your device in boot-loader mode, and second you need to "
"copy across the firmware.  The exact procedure for these steps is highly "
"dependent on the particular board and you will need to refer to its "
"documentation for details."
msgstr ""
"MicroPython ファームウェア(コンパイル済みコード)を取得したら、ESP8266 デバイスに"
"ロードする必要があります。これを行うには、主に２つのステップがあります。まず、"
"デバイスをブートローダモードにし、次にファームウェアをコピーする必要があります。"
"これらの手順の正確な手順は、特定のボードに大きく依存します。詳細については、"
"そのドキュメントを参照する必要があります。"

#: ../../../esp8266/tutorial/intro.rst:73
msgid ""
"If you have a board that has a USB connector, a USB-serial convertor, and"
" has the DTR and RTS pins wired in a special way then deploying the "
"firmware should be easy as all steps can be done automatically.  Boards "
"that have such features include the Adafruit Feather HUZZAH and NodeMCU "
"boards."
msgstr ""
"USB コネクタ、USB シリアルコンバータを備え、DTR ピンと RTS ピンが特別な方法で配線"
"されているボードを使用している場合は、すべてのステップを自動的に行うことができるため、"
"ファームウェアの展開は簡単です。このような機能を備えたボードには、"
"Adafruit Feather HUZZAH と NodeMCU ボードがあります。"

#: ../../../esp8266/tutorial/intro.rst:78
msgid ""
"For best results it is recommended to first erase the entire flash of "
"your device before putting on new MicroPython firmware."
msgstr ""
"最良の結果を得るために、新しい MicroPython ファームウェアをインストールする前に、"
"まずデバイスのフラッシュ全体を消去することをお勧めします。"

#: ../../../esp8266/tutorial/intro.rst:81
msgid ""
"Currently we only support esptool.py to copy across the firmware.  You "
"can find this tool here: `<https://github.com/espressif/esptool/>`__, or "
"install it using pip::"
msgstr ""
"現在は、ファームウェアをコピーするための esptool.py のみをサポートしています。"
"このツールは `<https://github.com/espressif/esptool/>`__ "
"からダウンロードするか、pip を使用してインストールしてください::"

#: ../../../esp8266/tutorial/intro.rst:85
msgid "pip install esptool"
msgstr ""

#: ../../../esp8266/tutorial/intro.rst:87
msgid ""
"Versions starting with 1.3 support both Python 2.7 and Python 3.4 (or "
"newer). An older version (at least 1.2.1 is needed) works fine but will "
"require Python 2.7."
msgstr ""
"1.3 で始まるバージョンは、Python 2.7 と Python 3.4 (またはそれより新しい"
"バージョン)の両方をサポートしています。古いバージョンでも正常に動作しますが"
"(少なくとも 1.2.1 が必要)、Python 2.7 が必要です。"

#: ../../../esp8266/tutorial/intro.rst:91
msgid ""
"Any other flashing program should work, so feel free to try them out or "
"refer to the documentation for your board to see its recommendations."
msgstr ""
"これ以外のフラッシュプログラムが動作するかは、試してみるか、ボードのドキュメントを"
"参照して推奨事項を確認してください。"

#: ../../../esp8266/tutorial/intro.rst:94
msgid "Using esptool.py you can erase the flash with the command::"
msgstr "esptool.py を使用すると、次のコマンドでフラッシュを消去できます::"

#: ../../../esp8266/tutorial/intro.rst:96
msgid "esptool.py --port /dev/ttyUSB0 erase_flash"
msgstr ""

#: ../../../esp8266/tutorial/intro.rst:98
msgid "And then deploy the new firmware using::"
msgstr "消去したら、次の方法で新しいファームウェアを導入します::"

#: ../../../esp8266/tutorial/intro.rst:100
msgid ""
"esptool.py --port /dev/ttyUSB0 --baud 460800 write_flash "
"--flash_size=detect 0 esp8266-20170108-v1.8.7.bin"
msgstr ""

#: ../../../esp8266/tutorial/intro.rst:102
msgid ""
"You might need to change the \"port\" setting to something else relevant "
"for your PC.  You may also need to reduce the baudrate if you get errors "
"when flashing (eg down to 115200).  The filename of the firmware should "
"also match the file that you have."
msgstr ""
"PC により、 \"port \" 指定を別のものに変更する必要があります。また、フラッシュ時に"
"エラーが発生した場合はボーレートを下げる必要があります(たとえば 115200 まで)。"
"ファームウェアのファイル名もダウンロードしたファイルの名前に変える必要があります。"

#: ../../../esp8266/tutorial/intro.rst:107
msgid ""
"For some boards with a particular FlashROM configuration (e.g. some "
"variants of a NodeMCU board) you may need to use the following command to"
" deploy the firmware (note the ``-fm dio`` option)::"
msgstr ""
"特定の FlashROM 構成を持つボード(NodeMCU ボードなど)には、次のコマンドを使用して"
"ファームウェアを展開する必要があります(``-fm dio`` オプションに注意してください)。

#: ../../../esp8266/tutorial/intro.rst:111
msgid ""
"esptool.py --port /dev/ttyUSB0 --baud 460800 write_flash "
"--flash_size=detect -fm dio 0 esp8266-20170108-v1.8.7.bin"
msgstr ""

#: ../../../esp8266/tutorial/intro.rst:113
msgid ""
"If the above commands run without error then MicroPython should be "
"installed on your board!"
msgstr ""
"上記のコマンドがエラーなしで実行されれば、MicroPython がボードにインストール"
"されたことになります。"

#: ../../../esp8266/tutorial/intro.rst:117
msgid "Serial prompt"
msgstr "シリアルプロンプト"

#: ../../../esp8266/tutorial/intro.rst:119
msgid ""
"Once you have the firmware on the device you can access the REPL (Python "
"prompt) over UART0 (GPIO1=TX, GPIO3=RX), which might be connected to a "
"USB-serial convertor, depending on your board.  The baudrate is 115200.  "
"The next part of the tutorial will discuss the prompt in more detail."
msgstr ""
"デバイスにファームウェアをインストールしたら、ボードに応じて UART 0 (GPI O1 = TX, "
"GPI O3 = RX)上の REPL (Pythonプロンプト)にアクセスできます(USB シリアルコンバータ"
"に接続されている可能性があります)。ボーレートは 115200 です。チュートリアルの次の"
"部分では、プロンプトについて詳しく説明します。"

#: ../../../esp8266/tutorial/intro.rst:125
msgid "WiFi"
msgstr ""

#: ../../../esp8266/tutorial/intro.rst:127
msgid ""
"After a fresh install and boot the device configures itself as a WiFi "
"access point (AP) that you can connect to.  The ESSID is of the form "
"MicroPython-xxxxxx where the x's are replaced with part of the MAC "
"address of your device (so will be the same everytime, and most likely "
"different for all ESP8266 chips).  The password for the WiFi is "
"micropythoN (note the upper-case N).  Its IP address will be 192.168.4.1 "
"once you connect to its network.  WiFi configuration will be discussed in"
" more detail later in the tutorial."
msgstr ""
"新規のインストールとブートの後、デバイスは接続可能な WiFi アクセスポイント(AP)と"
"して設定されます。ESSID は、MicroPython-xxxxxx という形式です。x はデバイスの"
"MAC アドレスの一部に置き換えられます(毎回同じで、すべての ESP8266 チップでは"
"おそらく同じです)。WiFi のパスワードは micropythoN です(大文字の N に注意して"
"ください)。一度ネットワークに接続すると、そのIPアドレスは 192.168.4.1 になります。"
"WiFi の設定については、チュートリアルの後半で詳しく説明します。"

#: ../../../esp8266/tutorial/intro.rst:136
msgid "Troubleshooting installation problems"
msgstr "インストールの問題のトラブルシューティング"

#: ../../../esp8266/tutorial/intro.rst:138
msgid ""
"If you experience problems during flashing or with running firmware "
"immediately after it, here are troubleshooting recommendations:"
msgstr ""
"フラッシュ中またはファームウェアの実行直後に問題が発生した場合は、次の推奨事項を"
"参照してください。"

#: ../../../esp8266/tutorial/intro.rst:141
msgid ""
"Be aware of and try to exclude hardware problems. There are 2 common "
"problems: bad power source quality and worn-out/defective FlashROM. "
"Speaking of power source, not just raw amperage is important, but also "
"low ripple and noise/EMI in general. If you experience issues with self-"
"made or wall-wart style power supply, try USB power from a computer. "
"Unearthed power supplies are also known to cause problems as they source "
"of increased EMI (electromagnetic interference) - at the very least, and "
"may lead to electrical devices breakdown. So, you are advised to avoid "
"using unearthed power connections when working with ESP8266 and other "
"boards. In regard to FlashROM hardware problems, there are independent "
"(not related to MicroPython in any way) reports `(e.g.) "
"<http://internetofhomethings.com/homethings/?p=538>`_ that on some "
"ESP8266 modules, FlashROM can be programmed as little as 20 times before "
"programming errors occur. This is *much* less than 100,000 programming "
"cycles cited for FlashROM chips of a type used with ESP8266 by reputable "
"vendors, which points to either production rejects, or second-hand worn-"
"out flash chips to be used on some (apparently cheap) modules/boards. You"
" may want to use your best judgement about source, price, documentation, "
"warranty, post-sales support for the modules/boards you purchase."
msgstr ""
"ハードウェア上の問題がないかを調べ、取り除いてください。発生しやすい問題は２つあります。"
"電源品質が悪いことと FlashROM の寿命/欠陥です。電源と言えば、素のアンペア数だけでなく、
"一般的に低リップルやノイズ/EMIも重要です。自家製または壁飾り式電源で問題が発生した"
"場合は、コンピュータからの USB 電源を試してみてください。また、アースされていない電源"
"装置は、EMI (電磁波干渉)を増やす原因となり、問題を引き起こすことが知られています。"
"少なくとも、電気デバイスの故障を引き起こす可能性があります。したがって、ESP8266 や"
"他のボードで作業する場合は、アースされていない電源を使わないようにしてください。"
"FlashROM のハードウェア問題に関しては、(MicroPython には関係ない)別の報告 "
"`(報告例) <http://internetofhomethings.com/homethings/?p=538>`_ "
"があります。たとえば、一部の ESP8266 モジュールでは、FlashROM のプログラム書換えを、"
"わずか20回行っただけでプログラミングエラーが発生しました。これは、信頼できるベンダーの "
"ESP8266 で採用しているタイプの FlashROM が 100,000回のプログラム書換えを可能と"
"しているのに対し、 *かなり* 少ない回数です。このような(明らかに安い)モジュール/ボード"
"で使われているフラッシュチップの中には欠陥品または中古を再利用したものが使われています。"
"モジュール/ボードの購入にあたっては、ベンダー、価格、ドキュメント、保証、購入後のサポート"
"などをよく考慮するようにしてください。"

#: ../../../esp8266/tutorial/intro.rst:160
msgid ""
"The flashing instructions above use flashing speed of 460800 baud, which "
"is good compromise between speed and stability. However, depending on "
"your module/board, USB-UART convertor, cables, host OS, etc., the above "
"baud rate may be too high and lead to errors. Try a more common 115200 "
"baud rate instead in such cases."
msgstr ""
"上記のフラッシュ手順は、速度と安定性の間の良好な妥協点である 460800 ボーのフラッシュ"
"速度を使っています。ただし、モジュール/ボード、USB-UARTコンバータ、ケーブル、ホスト "
"OS などによっては、上記ボーレートでも速すぎてエラーにつながる可能性があります。"
"そのような場合には、より一般的な 115200 ボーレートを試してください。"

#: ../../../esp8266/tutorial/intro.rst:166
msgid ""
"If lower baud rate didn't help, you may want to try older version of "
"esptool.py, which had a different programming algorithm::"
msgstr ""
"低いボーレートが役に立たなかった場合は、プログラミングアルゴリズムの異なる古い"
"バージョンの esptool.py を試してみてください。"

#: ../../../esp8266/tutorial/intro.rst:169
msgid "pip install esptool==1.0.1"
msgstr ""

#: ../../../esp8266/tutorial/intro.rst:171
msgid ""
"This version doesn't support ``--flash_size=detect`` option, so you will "
"need to specify FlashROM size explicitly (in megabits). It also requires "
"Python 2.7, so you may need to use ``pip2`` instead of ``pip`` in the "
"command above."
msgstr ""
"このバージョンは ``--flash_size=detect`` オプションをサポートしていないので、"
"フラッシュ ROM サイズを明示的に指定する必要があります(Mビット単位)。Python 2.7 "
"も必要です。したがって、上記のコマンドでは ``pip`` の代わりに ``pip2`` を使う"
"必要があるかもしれません。"

#: ../../../esp8266/tutorial/intro.rst:176
msgid ""
"The ``--flash_size`` option in the commands above is mandatory. Omitting "
"it will lead to a corrupted firmware."
msgstr ""
"上記のコマンドの ``--flash_size`` オプションは必須です。これを省略すると、"
"ファームウェアが破損します。"

#: ../../../esp8266/tutorial/intro.rst:179
msgid ""
"To catch incorrect flash content (e.g. from a defective sector on a "
"chip), add ``--verify`` switch to the commands above."
msgstr ""
"フラッシュの内容の不正(たとえば、チップ上の欠陥セクタなど)を検出するには、 "
"上記のコマンドに ``--verify`` オプションを加えてください。"

#: ../../../esp8266/tutorial/intro.rst:182
msgid ""
"Additionally, you can check the firmware integrity from a MicroPython "
"REPL prompt (assuming you were able to flash it and ``--verify`` option "
"doesn't report errors)::"
msgstr ""
"さらに、MicroPython REPL プロンプトからファームウェアの整合性をチェックすることも"
"できます(フラッシュができて、 ``--verify`` オプションでもエラーが報告されない場合)::

#: ../../../esp8266/tutorial/intro.rst:186
msgid ""
"import esp\n"
"esp.check_fw()"
msgstr ""

#: ../../../esp8266/tutorial/intro.rst:189
msgid ""
"If the last output value is True, the firmware is OK. Otherwise, it's "
"corrupted and need to be reflashed correctly."
msgstr ""
"最後の出力値が True の場合、ファームウェアはOKです。それ以外の場合は破損している"
"ため、正しく再フラッシュする必要があります。"

#: ../../../esp8266/tutorial/intro.rst:192
msgid ""
"If you experience any issues with another flashing application (not "
"esptool.py), try esptool.py, it is a generally accepted flashing "
"application in the ESP8266 community."
msgstr ""
"別の(esptool.pyではない)フラッシュアプリケーションで問題が発生した場合は、"
"esptool.py を試してください。これは ESP8266 コミュニティで一般に認められて"
"いるフラッシュアプリケーションです。"

#: ../../../esp8266/tutorial/intro.rst:196
msgid ""
"If you still experience problems with even flashing the firmware, please "
"refer to esptool.py project page, https://github.com/espressif/esptool "
"for additional documentation and bug tracker where you can report "
"problems."
msgstr ""
"ファームウェアをフラッシュしても問題が解決しない場合、問題を報告するために "
"esptool.py プロジェクトページ https://github.com/espressif/esptool にある"
"情報やバグトラッカーを参照してください。"

#: ../../../esp8266/tutorial/intro.rst:200
msgid ""
"If you are able to flash firmware, but ``--verify`` option or "
"``esp.check_fw()`` return errors even after multiple retries, you may "
"have a defective FlashROM chip, as explained above."
msgstr ""
"ファームウェアをフラッシュできた場合でも、 ``--verify`` オプションまたは "
"``esp.check_fw()`` が何度試してもエラーを返す場合は、上で説明したように、"
"欠陥のあるフラッシュROMチップである可能性があります。"

#: ../../../esp8266/tutorial/neopixel.rst:2
msgid "Controlling NeoPixels"
msgstr "NeoPixel の制御"

#: ../../../esp8266/tutorial/neopixel.rst:4
msgid ""
"NeoPixels, also known as WS2812 LEDs, are full-colour LEDs that are "
"connected in serial, are individually addressable, and can have their "
"red, green and blue components set between 0 and 255.  They require "
"precise timing to control them and there is a special neopixel module to "
"do just this."
msgstr ""
"NeoPixel は WS2812 LEDとも呼ばれ、シリアルに接続され、個別にアドレス可能で、"
"赤、緑、青のコンポーネントを 0〜255 の間で設定できるフルカラーLEDです。"
"NeoPixel は正確なタイミングでの制御を必要とするため、特別な neopixel モジュール"
"を用意しています。"

#: ../../../esp8266/tutorial/neopixel.rst:9
msgid "To create a NeoPixel object do the following::"
msgstr "NeoPixel オブジェクトを作成するには、次のようにします::"

#: ../../../esp8266/tutorial/neopixel.rst:11
msgid ""
">>> import machine, neopixel\n"
">>> np = neopixel.NeoPixel(machine.Pin(4), 8)"
msgstr ""

#: ../../../esp8266/tutorial/neopixel.rst:14
msgid ""
"This configures a NeoPixel strip on GPIO4 with 8 pixels.  You can adjust "
"the \"4\" (pin number) and the \"8\" (number of pixel) to suit your set "
"up."
msgstr ""
"これは、GPIO 4 上の8ピクセルの NeoPixel を構築します。繋げたものに合わせて、\"4\" "
"(ピン番号)と \"8\" (ピクセル数)を調整することができます。"

#: ../../../esp8266/tutorial/neopixel.rst:17
msgid "To set the colour of pixels use::"
msgstr "ピクセルの色を設定するには次のようにします::"

#: ../../../esp8266/tutorial/neopixel.rst:19
msgid ""
">>> np[0] = (255, 0, 0) # set to red, full brightness\n"
">>> np[1] = (0, 128, 0) # set to green, half brightness\n"
">>> np[2] = (0, 0, 64)  # set to blue, quarter brightness"
msgstr ""
">>> np[0] = (255, 0, 0) # 赤の最大輝度に設定\n"
">>> np[1] = (0, 128, 0) # 緑の最大輝度に設定\n"
">>> np[2] = (0, 0, 64)  # 青の最大輝度に設定"

#: ../../../esp8266/tutorial/neopixel.rst:23
msgid ""
"For LEDs with more than 3 colours, such as RGBW pixels or RGBY pixels, "
"the NeoPixel class takes a ``bpp`` parameter. To setup a NeoPixel object "
"for an RGBW Pixel, do the following::"
msgstr ""
"３色以上の LED について、RGBW ピクセルや RGBY ピクセルなど、NeoPixel クラスは "
"``bpp`` パラメータを取ります。RGBW ピクセルの NeoPixel オブジェクトを設定するには、"
"次の操作を行います。"

#: ../../../esp8266/tutorial/neopixel.rst:27
msgid ""
">>> import machine, neopixel\n"
">>> np = neopixel.NeoPixel(machine.Pin(4), 8, bpp=4)"
msgstr ""

#: ../../../esp8266/tutorial/neopixel.rst:30
msgid ""
"In a 4-bpp mode, remember to use 4-tuples instead of 3-tuples to set the "
"colour. For example to set the first three pixels use::"
msgstr ""
"4-bpp モードでは、3タプルの代わりに4タプルを使用して色を設定してください。"
"たとえば、先の3つのピクセルを設定するには次のようにします。"

#: ../../../esp8266/tutorial/neopixel.rst:33
msgid ""
">>> np[0] = (255, 0, 0, 128) # RGBY 設定でのオレンジ\n"
">>> np[1] = (0, 255, 0, 128) # RGBY 設定での黄色\n"
">>> np[2] = (0, 0, 255, 128) # RGBY 設定での青緑"
msgstr ""

#: ../../../esp8266/tutorial/neopixel.rst:37
msgid "Then use the ``write()`` method to output the colours to the LEDs::"
msgstr "次に ``write()`` メソッドを使って色を LED に出力します::"

#: ../../../esp8266/tutorial/neopixel.rst:39
msgid ">>> np.write()"
msgstr ""

#: ../../../esp8266/tutorial/neopixel.rst:41
msgid "The following demo function makes a fancy show on the LEDs::"
msgstr "以下のデモ関数は、いろいろな LED の光らせ方を見せてくれます::"

#: ../../../esp8266/tutorial/neopixel.rst:43
msgid ""
"import time\n"
"\n"
"def demo(np):\n"
"    n = np.n\n"
"\n"
"    # cycle\n"
"    for i in range(4 * n):\n"
"        for j in range(n):\n"
"            np[j] = (0, 0, 0)\n"
"        np[i % n] = (255, 255, 255)\n"
"        np.write()\n"
"        time.sleep_ms(25)\n"
"\n"
"    # bounce\n"
"    for i in range(4 * n):\n"
"        for j in range(n):\n"
"            np[j] = (0, 0, 128)\n"
"        if (i // n) % 2 == 0:\n"
"            np[i % n] = (0, 0, 0)\n"
"        else:\n"
"            np[n - 1 - (i % n)] = (0, 0, 0)\n"
"        np.write()\n"
"        time.sleep_ms(60)\n"
"\n"
"    # fade in/out\n"
"    for i in range(0, 4 * 256, 8):\n"
"        for j in range(n):\n"
"            if (i // 256) % 2 == 0:\n"
"                val = i & 0xff\n"
"            else:\n"
"                val = 255 - (i & 0xff)\n"
"            np[j] = (val, 0, 0)\n"
"        np.write()\n"
"\n"
"    # clear\n"
"    for i in range(n):\n"
"        np[i] = (0, 0, 0)\n"
"    np.write()"
msgstr ""
"import time\n"
"\n"
"def demo(np):\n"
"    n = np.n\n"
"\n"
"    # 循環\n"
"    for i in range(4 * n):\n"
"        for j in range(n):\n"
"            np[j] = (0, 0, 0)\n"
"        np[i % n] = (255, 255, 255)\n"
"        np.write()\n"
"        time.sleep_ms(25)\n"
"\n"
"    # バウンド\n"
"    for i in range(4 * n):\n"
"        for j in range(n):\n"
"            np[j] = (0, 0, 128)\n"
"        if (i // n) % 2 == 0:\n"
"            np[i % n] = (0, 0, 0)\n"
"        else:\n"
"            np[n - 1 - (i % n)] = (0, 0, 0)\n"
"        np.write()\n"
"        time.sleep_ms(60)\n"
"\n"
"    # フェードイン/フェードアウト\n"
"    for i in range(0, 4 * 256, 8):\n"
"        for j in range(n):\n"
"            if (i // 256) % 2 == 0:\n"
"                val = i & 0xff\n"
"            else:\n"
"                val = 255 - (i & 0xff)\n"
"            np[j] = (val, 0, 0)\n"
"        np.write()\n"
"\n"
"    # 消灯\n"
"    for i in range(n):\n"
"        np[i] = (0, 0, 0)\n"
"    np.write()"

#: ../../../esp8266/tutorial/neopixel.rst:82
msgid "Execute it using::"
msgstr "この関数は次のように実行します::"

#: ../../../<rst_epilog>:84
msgid ">>> demo(np)"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:2
msgid "Network basics"
msgstr "ネットワークの基礎"

#: ../../../esp8266/tutorial/network_basics.rst:4
msgid ""
"The network module is used to configure the WiFi connection.  There are "
"two WiFi interfaces, one for the station (when the ESP8266 connects to a "
"router) and one for the access point (for other devices to connect to the"
" ESP8266).  Create instances of these objects using::"
msgstr ""
"network モジュールは、WiFi 接続を設定するために使用されます。ステーション用"
"(ESP8266がルータに接続する場合)とアクセスポイント用(ESP8266に接続する他の"
"デバイス用)の2つの WiFi インタフェースがあります。これらのオブジェクトの"
"インスタンスを作成するには次のようにします::"

#: ../../../esp8266/tutorial/network_basics.rst:9
msgid ""
">>> import network\n"
">>> sta_if = network.WLAN(network.STA_IF)\n"
">>> ap_if = network.WLAN(network.AP_IF)"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:13
msgid "You can check if the interfaces are active by::"
msgstr "インターフェイスがアクティブかどうかは、次の方法で確認できます::"

#: ../../../esp8266/tutorial/network_basics.rst:15
msgid ""
">>> sta_if.active()\n"
"False\n"
">>> ap_if.active()\n"
"True"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:20
msgid "You can also check the network settings of the interface by::"
msgstr "また、次の方法でインタフェースのネットワーク設定を確認することもできます::"

#: ../../../esp8266/tutorial/network_basics.rst:22
msgid ""
">>> ap_if.ifconfig()\n"
"('192.168.4.1', '255.255.255.0', '192.168.4.1', '8.8.8.8')"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:25
msgid "The returned values are: IP address, netmask, gateway, DNS."
msgstr "戻り値は、IPアドレス、ネットマスク、ゲートウェイ、DNS です。"

#: ../../../esp8266/tutorial/network_basics.rst:28
msgid "Configuration of the WiFi"
msgstr "WiFi の設定"

#: ../../../esp8266/tutorial/network_basics.rst:30
msgid ""
"Upon a fresh install the ESP8266 is configured in access point mode, so "
"the AP_IF interface is active and the STA_IF interface is inactive.  You "
"can configure the module to connect to your own network using the STA_IF "
"interface."
msgstr ""
"新規インストール時、ESP8266 はアクセスポイントモードで構成されているため、AP_IF "
"インターフェイスがアクティブで、STA_IF インターフェイスはアクティブではありません。"
"STA_IF インターフェイスを使って、自分のネットワークに接続するようにモジュールを"
"設定できます。"

#: ../../../esp8266/tutorial/network_basics.rst:34
msgid "First activate the station interface::"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:36
msgid ">>> sta_if.active(True)"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:38
msgid "Then connect to your WiFi network::"
msgstr "最初にステーションインターフェイスを有効にします::"

#: ../../../esp8266/tutorial/network_basics.rst:40
msgid ">>> sta_if.connect('<your ESSID>', '<your password>')"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:42
msgid "To check if the connection is established use::"
msgstr "次に、WiFiネットワークに接続します::"

#: ../../../esp8266/tutorial/network_basics.rst:44
msgid ">>> sta_if.isconnected()"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:46
msgid "Once established you can check the IP address::"
msgstr "接続が確立されているかどうかを確認するには次のようにします::"

#: ../../../esp8266/tutorial/network_basics.rst:48
msgid ""
">>> sta_if.ifconfig()\n"
"('192.168.0.2', '255.255.255.0', '192.168.0.1', '8.8.8.8')"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:51
msgid "You can then disable the access-point interface if you no longer need it::"
msgstr "アクセスポイントインターフェイスが不要になったら、アクセスポイントインターフェイスを無効にすることができます::"

#: ../../../esp8266/tutorial/network_basics.rst:53
msgid ">>> ap_if.active(False)"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:55
msgid ""
"Here is a function you can run (or put in your boot.py file) to "
"automatically connect to your WiFi network::"
msgstr ""
"以下は WiFi ネットワークに自動的に接続するために実行する関数です"
"(boot.py ファイルに入れておくこともできます)::"

#: ../../../esp8266/tutorial/network_basics.rst:58
msgid ""
"def do_connect():\n"
"    import network\n"
"    sta_if = network.WLAN(network.STA_IF)\n"
"    if not sta_if.isconnected():\n"
"        print('connecting to network...')\n"
"        sta_if.active(True)\n"
"        sta_if.connect('<essid>', '<password>')\n"
"        while not sta_if.isconnected():\n"
"            pass\n"
"    print('network config:', sta_if.ifconfig())"
msgstr ""

#: ../../../esp8266/tutorial/network_basics.rst:70
msgid "Sockets"
msgstr "ソケット"

#: ../../../esp8266/tutorial/network_basics.rst:72
msgid ""
"Once the WiFi is set up the way to access the network is by using "
"sockets. A socket represents an endpoint on a network device, and when "
"two sockets are connected together communication can proceed. Internet "
"protocols are built on top of sockets, such as email (SMTP), the web "
"(HTTP), telnet, ssh, among many others.  Each of these protocols is "
"assigned a specific port, which is just an integer.  Given an IP address "
"and a port number you can connect to a remote device and start talking "
"with it."
msgstr ""
"WiFi が設定されると、ネットワークにアクセスする方法はソケットを使用することです。"
"ソケットはネットワークデバイス上のエンドポイントを表し、2つのソケットが一緒に"
"接続されている場合、通信を続行できます。インターネットプロトコルは、電子メール"
"(SMTP)、Web (HTTP)、telnet、ssh など、ソケットの上に構築されています。"
"これらのプロトコルのそれぞれには特定のポートが割り当てられます。これは単なる"
"整数です。IP アドレスとポート番号を指定すると、リモートデバイスに接続して通話を"
"開始できます。"

#: ../../../esp8266/tutorial/network_basics.rst:80
msgid ""
"The next part of the tutorial discusses how to use sockets to do some "
"common and useful network tasks."
msgstr ""
"チュートリアルの次の章では、ソケットを使用して一般的で有用なネットワークタスクを"
"実行する方法について説明します。"

#: ../../../esp8266/tutorial/network_tcp.rst:2
msgid "Network - TCP sockets"
msgstr "ネットワーク - TCPソケット"

#: ../../../esp8266/tutorial/network_tcp.rst:4
msgid ""
"The building block of most of the internet is the TCP socket.  These "
"sockets provide a reliable stream of bytes between the connected network "
"devices. This part of the tutorial will show how to use TCP sockets in a "
"few different cases."
msgstr ""
"ほとんどのインターネットの構成要素は TCP ソケットです。これらのソケットは、"
"接続されたネットワークデバイス間で信頼できるバイトストリームを提供します。"
"チュートリアルのこの部分では、いくつかの異なるケースで TCP ソケットを"
"使用する方法を示します。"

#: ../../../esp8266/tutorial/network_tcp.rst:10
msgid "Star Wars Asciimation"
msgstr "スターウォーズのテキストアニメーション"

#: ../../../esp8266/tutorial/network_tcp.rst:12
msgid ""
"The simplest thing to do is to download data from the internet.  In this "
"case we will use the Star Wars Asciimation service provided by the "
"blinkenlights.nl website.  It uses the telnet protocol on port 23 to "
"stream data to anyone that connects.  It's very simple to use because it "
"doesn't require you to authenticate (give a username or password), you "
"can just start downloading data straight away."
msgstr ""
"最も簡単なことは、インターネットからデータをダウンロードすることです。ここでは、"
"blinkenlights.nl のウェブサイトで提供されているスターウォーズのアシメーション"
"サービスを使用します。これは、ポート 23 上の Telnet プロトコルを使用して、接続"
"するすべての人にデータをストリーミングします。認証する必要がない(ユーザー名または"
"パスワードを入力する必要がない)ので、データのダウンロードをすぐに開始できで、"
"使い方が簡単です。"

#: ../../../esp8266/tutorial/network_tcp.rst:19
msgid "The first thing to do is make sure we have the socket module available::"
msgstr "最初に行うことは、使用可能なソケットモジュールがあることを確認することです。"

#: ../../../esp8266/tutorial/network_tcp.rst:21
msgid ">>> import socket"
msgstr ""

#: ../../../esp8266/tutorial/network_tcp.rst:23
msgid "Then get the IP address of the server::"
msgstr "次に、サーバーのIPアドレスを取得します。"

#: ../../../esp8266/tutorial/network_tcp.rst:25
msgid ">>> addr_info = socket.getaddrinfo(\"towel.blinkenlights.nl\", 23)"
msgstr ""

#: ../../../esp8266/tutorial/network_tcp.rst:27
msgid ""
"The ``getaddrinfo`` function actually returns a list of addresses, and "
"each address has more information than we need.  We want to get just the "
"first valid address, and then just the IP address and port of the server."
"  To do this use::"
msgstr ""
"``getaddrinfo`` 関数は、実際のアドレスのリストを返します。この関数が返す、"
"各アドレスは、必要以上の情報を持っています。最初の有効なアドレスだけを取得し、"
"次にサーバーのIPアドレスとポートだけを取得する必要があります。これを行うには"
"次のようにします::"

#: ../../../esp8266/tutorial/network_tcp.rst:31
msgid ">>> addr = addr_info[0][-1]"
msgstr ""

#: ../../../esp8266/tutorial/network_tcp.rst:33
msgid ""
"If you type ``addr_info`` and ``addr`` at the prompt you will see exactly"
" what information they hold."
msgstr ""
"プロンプトで ``addr_info`` と ``addr`` だけを入力してみると、これらが保持している"
"情報を確認できます。"

#: ../../../esp8266/tutorial/network_tcp.rst:36
msgid "Using the IP address we can make a socket and connect to the server::"
msgstr "IP アドレスを使用してソケットを作成して、サーバに接続します::"

#: ../../../esp8266/tutorial/network_tcp.rst:38
msgid ""
">>> s = socket.socket()\n"
">>> s.connect(addr)"
msgstr ""

#: ../../../esp8266/tutorial/network_tcp.rst:41
msgid "Now that we are connected we can download and display the data::"
msgstr "これで接続されたので、データをダウンロードして表示できます::"

#: ../../../esp8266/tutorial/network_tcp.rst:43
msgid ""
">>> while True:\n"
"...     data = s.recv(500)\n"
"...     print(str(data, 'utf8'), end='')\n"
"..."
msgstr ""

#: ../../../esp8266/tutorial/network_tcp.rst:48
msgid ""
"When this loop executes it should start showing the animation (use ctrl-C"
" to interrupt it)."
msgstr ""
"このループが実行されると、アニメーションの表示が開始されます(中断するには ctrl-C "
"を使います)。"

#: ../../../esp8266/tutorial/network_tcp.rst:51
msgid ""
"You should also be able to run this same code on your PC using normal "
"Python if you want to try it out there."
msgstr ""
"また、普通の Python を使って、このコードを試してみることもできます。"

#: ../../../esp8266/tutorial/network_tcp.rst:55
msgid "HTTP GET request"
msgstr "HTTP GETリクエスト"

#: ../../../esp8266/tutorial/network_tcp.rst:57
msgid ""
"The next example shows how to download a webpage.  HTTP uses port 80 and "
"you first need to send a \"GET\" request before you can download "
"anything.  As part of the request you need to specify the page to "
"retrieve."
msgstr ""
"次の例は、Web ページをダウンロードする方法を示しています。HTTP はポート 80 を使用し、"
"何かをダウンロードする前にまず \"GET\" リクエストを送信する必要があります。"
"リクエストの一部として、取得するページを指定する必要があります。"

#: ../../../esp8266/tutorial/network_tcp.rst:61
msgid "Let's define a function that can download and print a URL::"
msgstr "URL からダウンロードして表示する関数を定義しましょう::"

#: ../../../esp8266/tutorial/network_tcp.rst:63
#, python-format
msgid ""
"def http_get(url):\n"
"    _, _, host, path = url.split('/', 3)\n"
"    addr = socket.getaddrinfo(host, 80)[0][-1]\n"
"    s = socket.socket()\n"
"    s.connect(addr)\n"
"    s.send(bytes('GET /%s HTTP/1.0\\r\\nHost: %s\\r\\n\\r\\n' % (path, "
"host), 'utf8'))\n"
"    while True:\n"
"        data = s.recv(100)\n"
"        if data:\n"
"            print(str(data, 'utf8'), end='')\n"
"        else:\n"
"            break\n"
"    s.close()"
msgstr ""

#: ../../../esp8266/tutorial/network_tcp.rst:77
msgid ""
"Make sure that you import the socket module before running this function."
"  Then you can try::"
msgstr ""
"この関数を実行する前に、socket モジュールを import しておいてください。関数の実行は"
"次を試してください::"

#: ../../../esp8266/tutorial/network_tcp.rst:80
msgid ">>> http_get('http://micropython.org/ks/test.html')"
msgstr ""

#: ../../../esp8266/tutorial/network_tcp.rst:82
msgid "This should retrieve the webpage and print the HTML to the console."
msgstr "これにより、Webページが取得され、HTMLがコンソールに出力されます。"

#: ../../../esp8266/tutorial/network_tcp.rst:85
msgid "Simple HTTP server"
msgstr "シンプルなHTTPサーバー"

#: ../../../esp8266/tutorial/network_tcp.rst:87
msgid ""
"The following code creates an simple HTTP server which serves a single "
"webpage that contains a table with the state of all the GPIO pins::"
msgstr ""
"次のコードは、すべての GPIO ピンの状態を示す表を含む単一の Web ページを提供する"
"単純な HTTP サーバーを作成します。"

#: ../../../<rst_epilog>:90
#, python-format
msgid ""
"import machine\n"
"pins = [machine.Pin(i, machine.Pin.IN) for i in (0, 2, 4, 5, 12, 13, 14, "
"15)]\n"
"\n"
"html = \"\"\"<!DOCTYPE html>\n"
"<html>\n"
"    <head> <title>ESP8266 Pins</title> </head>\n"
"    <body> <h1>ESP8266 Pins</h1>\n"
"        <table border=\"1\"> <tr><th>Pin</th><th>Value</th></tr> %s "
"</table>\n"
"    </body>\n"
"</html>\n"
"\"\"\"\n"
"\n"
"import socket\n"
"addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]\n"
"\n"
"s = socket.socket()\n"
"s.bind(addr)\n"
"s.listen(1)\n"
"\n"
"print('listening on', addr)\n"
"\n"
"while True:\n"
"    cl, addr = s.accept()\n"
"    print('client connected from', addr)\n"
"    cl_file = cl.makefile('rwb', 0)\n"
"    while True:\n"
"        line = cl_file.readline()\n"
"        if not line or line == b'\\r\\n':\n"
"            break\n"
"    rows = ['<tr><td>%s</td><td>%d</td></tr>' % (str(p), p.value()) for p"
" in pins]\n"
"    response = html % '\\n'.join(rows)\n"
"    cl.send(response)\n"
"    cl.close()"
msgstr ""

#: ../../../esp8266/tutorial/nextsteps.rst:2
msgid "Next steps"
msgstr "次のステップ"

#: ../../../esp8266/tutorial/nextsteps.rst:4
msgid ""
"That brings us to the end of the tutorial!  Hopefully by now you have a "
"good feel for the capabilities of MicroPython on the ESP8266 and "
"understand how to control both the WiFi and IO aspects of the chip."
msgstr ""
"チュートリアルの最後まで来ました！　ここまでくれば、ESP8266 上の MicroPython の"
"機能を十分に理解し、チップの WiFi と I/O の両方を制御する方法を理解している"
"ことでしょう。"

#: ../../../esp8266/tutorial/nextsteps.rst:8
msgid ""
"There are many features that were not covered in this tutorial.  The best"
" way to learn about them is to read the full documentation of the "
"modules, and to experiment!"
msgstr ""
"このチュートリアルでは扱っていない機能もまだ多くあります。それらについて学ぶ最も良い"
"方法は、モジュールの完全なドキュメントを読み、実験することです！"

#: ../../../esp8266/tutorial/nextsteps.rst:12
msgid "Good luck creating your Internet of Things devices!"
msgstr "IoT デバイス作成、がんばってください！"

#: ../../../esp8266/tutorial/onewire.rst:2
msgid "Controlling 1-wire devices"
msgstr "1-wire デバイスの制御"

#: ../../../esp8266/tutorial/onewire.rst:4
msgid ""
"The 1-wire bus is a serial bus that uses just a single wire for "
"communication (in addition to wires for ground and power).  The DS18B20 "
"temperature sensor is a very popular 1-wire device, and here we show how "
"to use the onewire module to read from such a device."
msgstr ""
"1-ware バスは(グランドと電源用の線に加えて)通信用に単線を使用するシリアルバスです。"
"DS18B20 温度センサは非常に一般的な 1-wire デバイスです。ここでは onewire "
"モジュールを使って、そのようなデバイスから読み取る方法を示します。"

#: ../../../esp8266/tutorial/onewire.rst:9
msgid ""
"For the following code to work you need to have at least one DS18S20 or "
"DS18B20 temperature sensor with its data line connected to GPIO12.  You "
"must also power the sensors and connect a 4.7k Ohm resistor between the "
"data pin and the power pin.  ::"
msgstr ""
"以下のコードを動作させるには、少なくとも1つの DS18S20 または DS18B20 温度センサー"
"を用意し、そのデータラインを GPIO12 に接続する必要があります。センサーに電力を"
"供給し、データピンと電源ピンの間に 4.7kΩ の抵抗を接続する必要もあります::"

#: ../../../esp8266/tutorial/onewire.rst:13
msgid ""
"import time\n"
"import machine\n"
"import onewire, ds18x20\n"
"\n"
"# the device is on GPIO12\n"
"dat = machine.Pin(12)\n"
"\n"
"# create the onewire object\n"
"ds = ds18x20.DS18X20(onewire.OneWire(dat))\n"
"\n"
"# scan for devices on the bus\n"
"roms = ds.scan()\n"
"print('found devices:', roms)\n"
"\n"
"# loop 10 times and print all temperatures\n"
"for i in range(10):\n"
"    print('temperatures:', end=' ')\n"
"    ds.convert_temp()\n"
"    time.sleep_ms(750)\n"
"    for rom in roms:\n"
"        print(ds.read_temp(rom), end=' ')\n"
"    print()"
msgstr ""
"import time\n"
"import machine\n"
"import onewire, ds18x20\n"
"\n"
"# デバイスは GPIO 12 に接続\n"
"dat = machine.Pin(12)\n"
"\n"
"# onewire オブジェクトを作成\n"
"ds = ds18x20.DS18X20(onewire.OneWire(dat))\n"
"\n"
"# バス上のデバイスをスキャン\n"
"roms = ds.scan()\n"
"print('found devices:', roms)\n"
"\n"
"# １０回ループして、計測した温度すべてを表示\n"
"for i in range(10):\n"
"    print('temperatures:', end=' ')\n"
"    ds.convert_temp()\n"
"    time.sleep_ms(750)\n"
"    for rom in roms:\n"
"        print(ds.read_temp(rom), end=' ')\n"
"    print()"

#: ../../../esp8266/tutorial/onewire.rst:36
msgid ""
"Note that you must execute the ``convert_temp()`` function to initiate a "
"temperature reading, then wait at least 750ms before reading the value."
msgstr ""
"``convert_temp()`` 関数で温度の読み取りをするには、この関数を実行してから"
"値を読み取る前に少なくとも 750ms 待機してください。"

#: ../../../esp8266/tutorial/pins.rst:2
msgid "GPIO Pins"
msgstr "GPIO ピン"

#: ../../../esp8266/tutorial/pins.rst:4
msgid ""
"The way to connect your board to the external world, and control other "
"components, is through the GPIO pins.  Not all pins are available to use,"
" in most cases only pins 0, 2, 4, 5, 12, 13, 14, 15, and 16 can be used."
msgstr ""
"ボードを外部世界に接続し、他のコンポーネントを制御するには、GPIO ピンを使います。"
"すべてのピンを使えるわけではありません。ほとんどの場合、ピン 0, 2, 4, 5, 12, 13, "
"14, 15, 16 のみを使用できます。"

#: ../../../esp8266/tutorial/pins.rst:8
msgid ""
"The pins are available in the machine module, so make sure you import "
"that first.  Then you can create a pin using::"
msgstr ""
"ピンは machine モジュールで使えるので、最初に machine の import を確認して"
"ください。machine が使えれば、次のようにピンを作成できます::"

#: ../../../esp8266/tutorial/pins.rst:11
msgid ">>> pin = machine.Pin(0)"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:13
msgid ""
"Here, the \"0\" is the pin that you want to access.  Usually you want to "
"configure the pin to be input or output, and you do this when "
"constructing it.  To make an input pin use::"
msgstr ""
"ここで、\"0\" はアクセスしたいピンの番号です。通常は、ピンを入力または出力に設定する"
"必要があり、ピンを作成するときにこれを行います。入力ピンを使うには次のようにします::"

#: ../../../esp8266/tutorial/pins.rst:17
msgid ">>> pin = machine.Pin(0, machine.Pin.IN, machine.Pin.PULL_UP)"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:19
msgid ""
"You can either use PULL_UP or None for the input pull-mode.  If it's not "
"specified then it defaults to None, which is no pull resistor. GPIO16 has"
" no pull-up mode. You can read the value on the pin using::"
msgstr ""
"入力プルモードとして PULL_UP または None を指定できます。指定されていない場合は、"
"デフォルトで None になり、プル抵抗なしになります。GPIO 16 にプルアップモードは"
"ありません。作成したピンを使って次のようにして値を読めます::"

#: ../../../esp8266/tutorial/pins.rst:24
msgid ""
">>> pin.value()\n"
"0"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:27
msgid ""
"The pin on your board may return 0 or 1 here, depending on what it's "
"connected to.  To make an output pin use::"
msgstr ""
"ボード上のピンは、接続されているものに応じてここで 0 または 1 を返します。"
"出力ピンを使うには次のようにピンを作成します::"

#: ../../../esp8266/tutorial/pins.rst:30
msgid ">>> pin = machine.Pin(0, machine.Pin.OUT)"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:32
msgid "Then set its value using::"
msgstr "次のようにして値を設定します::"

#: ../../../esp8266/tutorial/pins.rst:34
msgid ""
">>> pin.value(0)\n"
">>> pin.value(1)"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:37
msgid "Or::"
msgstr "または次のようにします::"

#: ../../../esp8266/tutorial/pins.rst:39
msgid ""
">>> pin.off()\n"
">>> pin.on()"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:43
msgid "External interrupts"
msgstr "外部割り込み"

#: ../../../esp8266/tutorial/pins.rst:45
msgid ""
"All pins except number 16 can be configured to trigger a hard interrupt "
"if their input changes.  You can set code (a callback function) to be "
"executed on the trigger."
msgstr ""
"16番を除くすべてのピンは、入力が変化するとハード割り込みを発生させるように設定"
"できます。トリガで実行されるコード(コールバック関数)を設定できます。"

#: ../../../esp8266/tutorial/pins.rst:49
msgid ""
"Let's first define a callback function, which must take a single "
"argument, being the pin that triggered the function.  We will make the "
"function just print the pin::"
msgstr ""
"コールバック関数を定義しましょう。コールバック関数は、関数をトリガしたピンを唯一の"
"引数としてとる必要があります。この関数ではピンを表紙するようにします::"

#: ../../../esp8266/tutorial/pins.rst:53
msgid ""
">>> def callback(p):\n"
"...     print('pin change', p)"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:56
msgid "Next we will create two pins and configure them as inputs::"
msgstr "次に、２つのピンを作成し、それらを入力として構築します::"

#: ../../../esp8266/tutorial/pins.rst:58
msgid ""
">>> from machine import Pin\n"
">>> p0 = Pin(0, Pin.IN)\n"
">>> p2 = Pin(2, Pin.IN)"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:62
msgid ""
"An finally we need to tell the pins when to trigger, and the function to "
"call when they detect an event::"
msgstr ""
"最後に、ピンをトリガするタイミングと、イベントを検出したときに呼び出す関数を"
"指定する必要があります::"

#: ../../../esp8266/tutorial/pins.rst:65
msgid ""
">>> p0.irq(trigger=Pin.IRQ_FALLING, handler=callback)\n"
">>> p2.irq(trigger=Pin.IRQ_RISING | Pin.IRQ_FALLING, handler=callback)"
msgstr ""

#: ../../../esp8266/tutorial/pins.rst:68
msgid ""
"We set pin 0 to trigger only on a falling edge of the input (when it goes"
" from high to low), and set pin 2 to trigger on both a rising and falling"
" edge.  After entering this code you can apply high and low voltages to "
"pins 0 and 2 to see the interrupt being executed."
msgstr ""
"ピン 0 は、入力の立ち下がりエッジでのみ(ハイからローに移行する場合)トリガするように"
"設定され、ピン 2 を立ち上がりエッジと立ち下がりエッジの両方でトリガするように"
"設定します。このコードを入力した後、ピン 0 とピン 2 にハイとローの電圧を与えて、"
"実行中の割り込みを確認することができます。

#: ../../../esp8266/tutorial/pins.rst:73
msgid ""
"A hard interrupt will trigger as soon as the event occurs and will "
"interrupt any running code, including Python code.  As such your callback"
" functions are limited in what they can do (they cannot allocate memory, "
"for example) and should be as short and simple as possible."
msgstr ""
"ハード割り込みは、イベントが発生するとすぐに起動し、実行中のコード(Python コードを"
"含む)を中断します。コールバック関数は、その中ででできることが限られているので"
"(たとえば、メモリを割り当てることはできません)、できるだけ短く簡単にする必要があります。"

#: ../../../esp8266/tutorial/powerctrl.rst:2
msgid "Power control"
msgstr "電源制御"

#: ../../../esp8266/tutorial/powerctrl.rst:4
msgid ""
"The ESP8266 provides the ability to change the CPU frequency on the fly, "
"and enter a deep-sleep state.  Both can be used to manage power "
"consumption."
msgstr ""
"ESP8266 は、臨機応変に CPU 周波数を変更できますし、ディープスリープ状態に入ることも"
"できます。どちらも消費電力の管理に使用できます。"

#: ../../../esp8266/tutorial/powerctrl.rst:8
msgid "Changing the CPU frequency"
msgstr "CPU 周波数の変更"

#: ../../../esp8266/tutorial/powerctrl.rst:10
msgid ""
"The machine module has a function to get and set the CPU frequency.  To "
"get the current frequency use::"
msgstr ""
"machine モジュールには、CPU 周波数を取得および設定する機能があります。"
"現在の周波数を取得するには次のようにします::"

#: ../../../esp8266/tutorial/powerctrl.rst:13
msgid ""
">>> import machine\n"
">>> machine.freq()\n"
"80000000"
msgstr ""

#: ../../../esp8266/tutorial/powerctrl.rst:17
msgid ""
"By default the CPU runs at 80MHz.  It can be changed to 160MHz if you "
"need more processing power, at the expense of current consumption::"
msgstr ""
"デフォルトで CPU は 80MHz で動作します。消費電流を犠牲にして、処理能力がさらに"
"必要な場合は、160MHz に変更できます。"

#: ../../../esp8266/tutorial/powerctrl.rst:20
msgid ""
">>> machine.freq(160000000)\n"
">>> machine.freq()\n"
"160000000"
msgstr ""

#: ../../../esp8266/tutorial/powerctrl.rst:24
msgid ""
"You can change to the higher frequency just while your code does the "
"heavy processing and then change back when it's finished."
msgstr ""
"コードが重い処理をしている間はより高い周波数に変更して、完了したら元に戻す"
"ようにもできます。"

#: ../../../esp8266/tutorial/powerctrl.rst:30
msgid ""
"The deep-sleep mode will shut down the ESP8266 and all its peripherals, "
"including the WiFi (but not including the real-time-clock, which is used "
"to wake the chip).  This drastically reduces current consumption and is a"
" good way to make devices that can run for a while on a battery."
msgstr ""
"ディープ・スリープモードは、WiFi を含む ESP8266 とその周辺機器をすべてシャットダウン"
"します(ただし、チップを起動するために使用されるリアルタイムクロックは含みません)。"
"これにより、消費電流が大幅に削減され、バッテリで長時間にわたって動かせるデバイスを"
"作れるようになります。"

#: ../../../esp8266/tutorial/powerctrl.rst:35
msgid ""
"To be able to use the deep-sleep feature you must connect GPIO16 to the "
"reset pin (RST on the Adafruit Feather HUZZAH board).  Then the following"
" code can be used to sleep and wake the device::"
msgstr ""
"ディープスリープ機能を使用するには、GPIO16 をリセットピン(Adafruit Feather HUZZAH "
"ボードの RST)に接続する必要があります。次のコードを使うと、デバイスを動作状態から"
"スリープ状態にすることができます。"

#: ../../../esp8266/tutorial/powerctrl.rst:39
msgid ""
"import machine\n"
"\n"
"# configure RTC.ALARM0 to be able to wake the device\n"
"rtc = machine.RTC()\n"
"rtc.irq(trigger=rtc.ALARM0, wake=machine.DEEPSLEEP)\n"
"\n"
"# set RTC.ALARM0 to fire after 10 seconds (waking the device)\n"
"rtc.alarm(rtc.ALARM0, 10000)\n"
"\n"
"# put the device to sleep\n"
"machine.deepsleep()"
msgstr ""

#: ../../../esp8266/tutorial/powerctrl.rst:51
msgid ""
"Note that when the chip wakes from a deep-sleep it is completely reset, "
"including all of the memory.  The boot scripts will run as usual and you "
"can put code in them to check the reset cause to perhaps do something "
"different if the device just woke from a deep-sleep.  For example, to "
"print the reset cause you can use::"
msgstr ""
"チップがディープスリープから復帰したとき、チップはすべてのメモリを含めて完全に"
"リセットされることに注意してください。ブートスクリプトは通常どおりに実行されます。"
"ブートスクリプトには、リセット原因がディープスリープから目を覚ましたことであるかの"
"チェックを入れておけます。たとえば、リセット原因を表示するには、次のコマンドを"
"使います。"

#: ../../../<rst_epilog>:57
msgid ""
"if machine.reset_cause() == machine.DEEPSLEEP_RESET:\n"
"    print('woke from a deep sleep')\n"
"else:\n"
"    print('power on or hard reset')"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:2
msgid "Pulse Width Modulation"
msgstr "パルス幅変調"

#: ../../../esp8266/tutorial/pwm.rst:4
msgid ""
"Pulse width modulation (PWM) is a way to get an artificial analog output "
"on a digital pin.  It achieves this by rapidly toggling the pin from low "
"to high. There are two parameters associated with this: the frequency of "
"the toggling, and the duty cycle.  The duty cycle is defined to be how "
"long the pin is high compared with the length of a single period (low "
"plus high time).  Maximum duty cycle is when the pin is high all of the "
"time, and minimum is when it is low all of the time."
msgstr ""
"パルス幅変調(PWM: Pulse Width Modulation)は、デジタルピンで疑似アナログ出力を"
"得る方法です。これは、ピンをローからハイにすばやく切り替えることで実現します。"
"これに関連するパラメータには、トグル回数とデューティサイクルがあります。"
"デューティサイクルは、ピンが１周期の長さ(low plus high time)の長さと比較して"
"どれくらい長いかを定義します。最大デューティサイクルはピンが常にハイレベルで、"
"最小は常にローレベルです。"

#: ../../../esp8266/tutorial/pwm.rst:12
msgid ""
"On the ESP8266 the pins 0, 2, 4, 5, 12, 13, 14 and 15 all support PWM.  "
"The limitation is that they must all be at the same frequency, and the "
"frequency must be between 1Hz and 1kHz."
msgstr ""
"ESP8266 では、ピン 0, 2, 4, 5, 12, 13, 14, 15 はすべて PWM をサポートして"
"います。制限はすべて同じ周波数でなければならず、周波数は 1Hz と 1kHz の間で"
"なければなりません。"

#: ../../../esp8266/tutorial/pwm.rst:16
msgid "To use PWM on a pin you must first create the pin object, for example::"
msgstr ""
"ピンで PWM を使用するには、まずピンオブジェクトを作成する必要があります。"
"たとえば次のようにします::"

#: ../../../esp8266/tutorial/pwm.rst:18
msgid ""
">>> import machine\n"
">>> p12 = machine.Pin(12)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:21
msgid "Then create the PWM object using::"
msgstr ""
"次に、以下を使用してPWMオブジェクトを作成します。"

#: ../../../esp8266/tutorial/pwm.rst:23
msgid ">>> pwm12 = machine.PWM(p12)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:25
msgid "You can set the frequency and duty cycle using::"
msgstr ""
"次のように周波数とデューティサイクルを設定できます。"

#: ../../../esp8266/tutorial/pwm.rst:27
msgid ""
">>> pwm12.freq(500)\n"
">>> pwm12.duty(512)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:30
#, python-format
msgid ""
"Note that the duty cycle is between 0 (all off) and 1023 (all on), with "
"512 being a 50% duty. Values beyond this min/max will be clipped. If you "
"print the PWM object then it will tell you its current configuration::"
msgstr ""
"デューティサイクルは 0 (全オフ)と 1023 (全オン)の間であり、512 は 50% のデューティ"
"となります。この最小値/最大値を超える値は切り捨てられます。PWM オブジェクトを表示"
"すると、現在の設定が表示されます。"

#: ../../../esp8266/tutorial/pwm.rst:34
msgid ""
">>> pwm12\n"
"PWM(12, freq=500, duty=512)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:37
msgid ""
"You can also call the ``freq()`` and ``duty()`` methods with no arguments"
" to get their current values."
msgstr ""
"また、引数を持たない ``freq()`` や ``duty()`` を呼び出すのでも現在の値を取得"
"できます。"

#: ../../../esp8266/tutorial/pwm.rst:40
msgid "The pin will continue to be in PWM mode until you deinitialise it using::"
msgstr "ピンは、以下を使用して初期化を解除するまで、PWMモードになります::"

#: ../../../esp8266/tutorial/pwm.rst:42
msgid ">>> pwm12.deinit()"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:45
msgid "Fading an LED"
msgstr "LEDの減光"

#: ../../../esp8266/tutorial/pwm.rst:47
msgid ""
"Let's use the PWM feature to fade an LED.  Assuming your board has an LED"
" connected to pin 2 (ESP-12 modules do) we can create an LED-PWM object "
"using::"
msgstr ""
"PWM 機能を使って LED を徐々に減光してみましょう。ボードのピン2に接続された LED が"
"あるとすると(ESP-12 モジュールではそうなっています)、次の方法で LED-PWM "
"オブジェクトを作成できます。"

#: ../../../esp8266/tutorial/pwm.rst:50
msgid ">>> led = machine.PWM(machine.Pin(2), freq=1000)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:52
msgid "Notice that we can set the frequency in the PWM constructor."
msgstr "PWM コンストラクタで周波数を設定できることに注意してください。"

#: ../../../esp8266/tutorial/pwm.rst:54
msgid ""
"For the next part we will use timing and some math, so import these "
"modules::"
msgstr ""
"次の部分ではタイミングと数学関数を使うので、これらのモジュールを import "
"してください::"

#: ../../../esp8266/tutorial/pwm.rst:56
msgid ">>> import time, math"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:58
msgid "Then create a function to pulse the LED::"
msgstr "次に、LED をパルスする関数を作成します::"

#: ../../../esp8266/tutorial/pwm.rst:60
msgid ""
">>> def pulse(l, t):\n"
"...     for i in range(20):\n"
"...         l.duty(int(math.sin(i / 10 * math.pi) * 500 + 500))\n"
"...         time.sleep_ms(t)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:65
msgid "You can try this function out using::"
msgstr "この関数を実行してみてください::"

#: ../../../esp8266/tutorial/pwm.rst:67
msgid ">>> pulse(led, 50)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:69
msgid "For a nice effect you can pulse many times in a row::"
msgstr "すてきな効果を出すために、連続して何度もパルスするようにもできます::"

#: ../../../esp8266/tutorial/pwm.rst:71
msgid ""
">>> for i in range(10):\n"
"...     pulse(led, 20)"
msgstr ""

#: ../../../esp8266/tutorial/pwm.rst:74
msgid "Remember you can use ctrl-C to interrupt the code."
msgstr "コードの実行を中断するには ctrl-C を使ってください。"

#: ../../../esp8266/tutorial/pwm.rst:77
msgid "Control a hobby servo"
msgstr "ホビー用サーボを制御する"

#: ../../../esp8266/tutorial/pwm.rst:79
msgid ""
"Hobby servo motors can be controlled using PWM.  They require a frequency"
" of 50Hz and then a duty between about 40 and 115, with 77 being the "
"centre value. If you connect a servo to the power and ground pins, and "
"then the signal line to pin 12 (other pins will work just as well), you "
"can control the motor using::"
msgstr ""
"ホビー用サーボモータは、PWM を使って制御できます。それらは 50Hz の周波数を必要とし、"
"次に約 40〜115 のデューティを必要とし、77 を中心値とします。サーボを電源ピンと"
"グランドピンに接続し、信号線をピン12に接続すると(他のピンも同様に機能します)、"
"次のようにしてモータを制御できます::"

#: ../../../<rst_epilog>:84
msgid ""
">>> servo = machine.PWM(machine.Pin(12), freq=50)\n"
">>> servo.duty(40)\n"
">>> servo.duty(115)\n"
">>> servo.duty(77)"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:2
msgid "Getting a MicroPython REPL prompt"
msgstr "MicroPython REPL プロンプトの始め方"

#: ../../../esp8266/tutorial/repl.rst:4
msgid ""
"REPL stands for Read Evaluate Print Loop, and is the name given to the "
"interactive MicroPython prompt that you can access on the ESP8266.  Using"
" the REPL is by far the easiest way to test out your code and run "
"commands."
msgstr ""
"REPL は Read Evaluate Print Loop の略で、ESP8266 でアクセスできる"
"対話的な MicroPython プロンプトに与えられた名前です。"
"REPL を使うことは、コードをテストしてコマンドを実行する"
"最も簡単な方法です。"

#: ../../../esp8266/tutorial/repl.rst:8
msgid ""
"There are two ways to access the REPL: either via a wired connection "
"through the UART serial port, or via WiFi."
msgstr ""
"REPL にアクセスするには、UART シリアルポート経由の有線接続を使う方法と、"
"WiFi を使う方法があります。"

#: ../../../esp8266/tutorial/repl.rst:12
msgid "REPL over the serial port"
msgstr "シリアルポート経由の REPL"

#: ../../../esp8266/tutorial/repl.rst:14
msgid ""
"The REPL is always available on the UART0 serial peripheral, which is "
"connected to the pins GPIO1 for TX and GPIO3 for RX.  The baudrate of the"
" REPL is 115200. If your board has a USB-serial convertor on it then you "
"should be able to access the REPL directly from your PC.  Otherwise you "
"will need to have a way of communicating with the UART."
msgstr ""
"REPL は、UART 0 シリアルペリフェラルで常に使えます。これは、TX 用の "
"GPIO 1 ピンと RX 用の GPIO 3 ピンに接続されています。REPL の"
"ボーレートは 115200 です。ボード上に USB シリアルコンバータが搭載"
"されている場合は、PC から REPL に直接アクセスできます。それ以外の"
"場合は、UART と通信する方法が必要です。"

#: ../../../esp8266/tutorial/repl.rst:20
msgid ""
"To access the prompt over USB-serial you need to use a terminal emulator "
"program. On Windows TeraTerm is a good choice, on Mac you can use the "
"built-in screen program, and Linux has picocom and minicom.  Of course, "
"there are many other terminal programs that will work, so pick your "
"favourite!"
msgstr ""
"USB シリアル経由のプロンプトにアクセスするには、ターミナルエミュレータ"
"プログラムを使用する必要があります。Windows では TeraTerm を使うのがよい"
"でしょう。Mac ではOSに組み込まれている screen プログラムが使えます。"
"Linux には picocom や minicom があります。もちろん、他にも多くの端末"
"プログラムがありますので、好きなものを選んでください！"

#: ../../../esp8266/tutorial/repl.rst:25
msgid "For example, on Linux you can try running::"
msgstr "たとえば、Linux では次のコマンドを実行できます。"

#: ../../../esp8266/tutorial/repl.rst:27
msgid "picocom /dev/ttyUSB0 -b115200"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:29
msgid ""
"Once you have made the connection over the serial port you can test if it"
" is working by hitting enter a few times.  You should see the Python REPL"
" prompt, indicated by ``>>>``."
msgstr ""
"シリアルポート経由で接続を確立したら、enter キーを数回押して"
"動作しているかどうかをテストできます。Python REPL プロンプト "
"``>>>`` が表示されます。"

#: ../../../esp8266/tutorial/repl.rst:34
msgid "WebREPL - a prompt over WiFi"
msgstr "WebREPL - WiFi 経由のプロンプト"

#: ../../../esp8266/tutorial/repl.rst:36
msgid ""
"WebREPL allows you to use the Python prompt over WiFi, connecting through"
" a browser. The latest versions of Firefox and Chrome are supported."
msgstr ""
"WebREPLを使うと、Web ブラウザから WiFi 経由で Python プロンプトを"
"使えます。Firefox と Chrome の最新バージョンがサポートされています。"

#: ../../../esp8266/tutorial/repl.rst:39
msgid ""
"For your convenience, WebREPL client is hosted at "
"`<http://micropython.org/webrepl>`__ . Alternatively, you can install it "
"locally from the the GitHub repository "
"`<https://github.com/micropython/webrepl>`__ ."
msgstr ""
"便宜上、WebREPL クライアントは `<http://micropython.org/webrepl>`__ で"
"ホストされてい ます。また、GitHubリポジトリ "
"`<https://github.com/micropython/webrepl>`__ からローカルにインストール"
"することもできます。"

#: ../../../esp8266/tutorial/repl.rst:44
msgid ""
"Before connecting to WebREPL, you should set a password and enable it via"
" a normal serial connection. Initial versions of MicroPython for ESP8266 "
"came with WebREPL automatically enabled on the boot and with the ability "
"to set a password via WiFi on the first connection, but as WebREPL was "
"becoming more widely known and popular, the initial setup has switched to"
" a wired connection for improved security::"
msgstr ""
"WebREPL に接続する前に、パスワードを設定し、通常のシリアル接続で有効に"
"する必要があります。ESP8266 用 MicropPython の初期バージョンでは、"
"起動時に自動的に WebREPL が有効になり、最初の接続で WiFi 経由で"
"パスワードを設定できるようになりましたが、WebREPL が広く普及したため、"
"セキュリティ向上の観点から、初期設定は有線接続で次を実行するよう変更に"
"なりました::"

#: ../../../esp8266/tutorial/repl.rst:53
msgid ""
"Follow the on-screen instructions and prompts. To make any changes "
"active, you will need to reboot your device."
msgstr ""
"画面上の指示とプロンプトにしたがってください。設定の変更を有効に"
"するには、デバイスを再起動する必要があります。"

#: ../../../esp8266/tutorial/repl.rst:56
msgid ""
"To use WebREPL connect your computer to the ESP8266's access point "
"(MicroPython-xxxxxx, see the previous section about this).  If you have "
"already reconfigured your ESP8266 to connect to a router then you can "
"skip this part."
msgstr ""
"WebREPL を使用するには、コンピュータを ESP8266 のアクセスポイント"
"(MicroPython-xxxxxx、前のセクションを参照)に接続します。すでにルータに"
"接続するように ESP8266 を再設定している場合は、この部分をスキップできます。"

#: ../../../esp8266/tutorial/repl.rst:61
msgid ""
"Once you are on the same network as the ESP8266 you click the \"Connect\""
" button (if you are connecting via a router then you may need to change "
"the IP address, by default the IP address is correct when connected to "
"the ESP8266's access point).  If the connection succeeds then you should "
"see a password prompt."
msgstr ""
"ESP8266 と同じネットワーク上にある場合は、\"Connect\" ボタンを"
"クリックします(ルータ経由で接続する場合は IP アドレスを変更する"
"必要があります)。デフォルトでは ESP8266 のアクセスポイントに"
"接続したIPアドレスとなります)。接続が成功すると、パスワード"
"プロンプトが表示されます。"

#: ../../../esp8266/tutorial/repl.rst:66
msgid ""
"Once you type the password configured at the setup step above, press "
"Enter once more and you should get a prompt looking like ``>>>``.  You "
"can now start typing Python commands!"
msgstr ""
"上記の設定ステップで設定したパスワードを入力したら、もう一度 Enter "
"キーを押すと、プロンプト ``>>>`` が表示されます。これで、Python コマンドの"
"入力を開始できます！"

#: ../../../esp8266/tutorial/repl.rst:71
msgid "Using the REPL"
msgstr "REPL の使い方"

#: ../../../esp8266/tutorial/repl.rst:73
msgid ""
"Once you have a prompt you can start experimenting!  Anything you type at"
" the prompt will be executed after you press the Enter key.  MicroPython "
"will run the code that you enter and print the result (if there is one)."
"  If there is an error with the text that you enter then an error message"
" is printed."
msgstr ""
"プロンプトが出たら、実験を始めることができます！　プロンプトで入力した"
"ものは、Enter キーを押した後に実行されます。MicroPython は入力した"
"コードを実行し、結果があればそれを印刷します。入力したテキストに"
"エラーがある場合は、エラーメッセージが表示されます。"

#: ../../../esp8266/tutorial/repl.rst:78
msgid "Try typing the following at the prompt::"
msgstr "プロンプトで次のように入力してください。"

#: ../../../esp8266/tutorial/repl.rst:80
msgid ""
">>> print('hello esp8266!')\n"
"hello esp8266!"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:83
msgid ""
"Note that you shouldn't type the ``>>>`` arrows, they are there to "
"indicate that you should type the text after it at the prompt.  And then "
"the line following is what the device should respond with.  In the end, "
"once you have entered the text ``print(\"hello esp8266!\")`` and pressed "
"the Enter key, the output on your screen should look exactly like it does"
" above."
msgstr ""
"``>>>`` 矢印を入力してはならないことに注意してください。これはプロンプト"
"であり、この後ろにテキストを入力する必要があることを示しています。"
"そして次の行は、デバイスが応答してきたものです。つまりは、テキスト"
"print("hello esp8266!") を入力して Enter キーを押すと、画面上の"
"出力が上のようになるということです。"

#: ../../../esp8266/tutorial/repl.rst:89
msgid ""
"If you already know some python you can now try some basic commands here."
"   For example::"
msgstr ""
"すでにいくらかでも python を知っているなら、ここでいくつかの基本的なコマンドを"
"試すことができます。たとえば::"

#: ../../../esp8266/tutorial/repl.rst:92
msgid ""
">>> 1 + 2\n"
"3\n"
">>> 1 / 2\n"
"0.5\n"
">>> 12**34\n"
"4922235242952026704037113243122008064"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:99
msgid ""
"If your board has an LED attached to GPIO2 (the ESP-12 modules do) then "
"you can turn it on and off using the following code::"
msgstr ""
"ボードの GPIO 2 にLEDが接続されている場合(ESP-12 モジュールの場合)、"
"次のコードを使用して点灯/消灯を切り替えることができます。"

#: ../../../esp8266/tutorial/repl.rst:102
msgid ""
">>> import machine\n"
">>> pin = machine.Pin(2, machine.Pin.OUT)\n"
">>> pin.on()\n"
">>> pin.off()"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:107
msgid ""
"Note that ``on`` method of a Pin might turn the LED off and ``off`` might"
" turn it on (or vice versa), depending on how the LED is wired on your "
"board. To resolve this, machine.Signal class is provided."
msgstr ""
"Pin の ``on`` メソッドが LED を消灯し、 ``off`` メソッドが LED を点灯する"可能性"
"があります(またはその逆の可能性もあります)。これは、ボード上の LED が配線されている"
"方法に依存します。これを解決するために、machine.Signal クラスが用意されています。

#: ../../../esp8266/tutorial/repl.rst:112
msgid "Line editing"
msgstr "ライン 編集"

#: ../../../esp8266/tutorial/repl.rst:114
msgid ""
"You can edit the current line that you are entering using the left and "
"right arrow keys to move the cursor, as well as the delete and backspace "
"keys.  Also, pressing Home or ctrl-A moves the cursor to the start of the"
" line, and pressing End or ctrl-E moves to the end of the line."
msgstr ""
"左矢印キーと右矢印キーを使用してカーソルを移動し、delete キーと backspace キーを"
"使って入力している現在の行を編集できます。また、Home または Ctrl-A を押すと、"
"カーソルが行の先頭に移動し、End または Ctrl-E を押すと行末に移動します。"

#: ../../../esp8266/tutorial/repl.rst:120
msgid "Input history"
msgstr "履歴からの入力"

#: ../../../esp8266/tutorial/repl.rst:122
msgid ""
"The REPL remembers a certain number of previous lines of text that you "
"entered (up to 8 on the ESP8266).  To recall previous lines use the up "
"and down arrow keys."
msgstr ""
"REPL は入力したテキストを最新から一定行数だけ記憶します(ESP8266では最大8行まで)。"
"前の行を呼び出すには、上下の矢印キーを使います。"

#: ../../../esp8266/tutorial/repl.rst:127
msgid "Tab completion"
msgstr "タブ補完"

#: ../../../esp8266/tutorial/repl.rst:129
msgid ""
"Pressing the Tab key will do an auto-completion of the current word that "
"you are entering.  This can be very useful to find out functions and "
"methods that a module or object has.  Try it out by typing \"ma\" and "
"then pressing Tab.  It should complete to \"machine\" (assuming you "
"imported machine in the above example).  Then type \".\" and press Tab "
"again to see a list of all the functions that the machine module has."
msgstr ""
"Tab キーを押すと、入力中の現在の単語の自動補完が行われます。これは、モジュールや"
"オブジェクトが持つ関数やメソッドを見つけるのに非常に便利です。\"ma\" と入力して "
"Tab キーを押して試してください。上記の例で machine を import していれば、"
"\"machine\" と補完されます。その後、\".\" とタイプして Tab キーをもう一度押すと、"
"machine モジュールが持つすべての関数のリストが表示されます。"

#: ../../../esp8266/tutorial/repl.rst:137
msgid "Line continuation and auto-indent"
msgstr "行の継続と自動インデント"

#: ../../../esp8266/tutorial/repl.rst:139
msgid ""
"Certain things that you type will need \"continuing\", that is, will need"
" more lines of text to make a proper Python statement.  In this case the "
"prompt will change to ``...`` and the cursor will auto-indent the correct"
" amount so you can start typing the next line straight away.  Try this by"
" defining the following function::"
msgstr ""
"入力する内容によっては「継続」が必要な場合があります。つまり、適切な Python "
"ステートメントを作成するために、より多くの行のテキストが必要になる場合があるということ"
"です。この場合、プロンプトは ``...`` に変わり、カーソルが自動的に正しい量だけ"
"インデントされ、次の行をすぐに入力し始めることができます。次の関数を定義してこれを"
"試してください::"

#: ../../../esp8266/tutorial/repl.rst:145
msgid ""
">>> def toggle(p):\n"
"...    p.value(not p.value())\n"
"...\n"
"...\n"
"...\n"
">>>"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:152
msgid ""
"In the above, you needed to press the Enter key three times in a row to "
"finish the compound statement (that's the three lines with just dots on "
"them).  The other way to finish a compound statement is to press "
"backspace to get to the start of the line, then press the Enter key.  (If"
" you did something wrong and want to escape the continuation mode then "
"press ctrl-C; all lines will be ignored.)"
msgstr ""
"上の例では、複合文を完成させるために Enter キーを3回続けて押す必要がありました"
"(ドットだけの３行がそれです)。複合文を完成させる別の方法は、バックスペースを押して"
"行の先頭に移動し、Enter キーを押すことです。(間違えてしまい、継続モードから抜けたい"
"場合は、Ctrl-Cを押してください。すべての行が無視されます。)"

#: ../../../esp8266/tutorial/repl.rst:159
msgid ""
"The function you just defined allows you to toggle a pin.  The pin object"
" you created earlier should still exist (recreate it if it doesn't) and "
"you can toggle the LED using::"
msgstr ""
"今定義した関数を使うと、Pin のオン/オフを切り替えることができます。前に作成したPin "
"オブジェクトはまだ存在するはずです(そうでない場合は再作成してください)。次のように"
"すると LED を点灯/消灯を切り替えられます。"

#: ../../../esp8266/tutorial/repl.rst:163
msgid ">>> toggle(pin)"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:165
msgid ""
"Let's now toggle the LED in a loop (if you don't have an LED then you can"
" just print some text instead of calling toggle, to see the effect)::"
msgstr ""
"ループで LED の点灯/消灯を切り替えましょう。(LEDがない場合は、toggle を呼び出す"
"代わりに何かテキストを表示させるようにして効果を確認してください)::"

#: ../../../esp8266/tutorial/repl.rst:168
msgid ""
">>> import time\n"
">>> while True:\n"
"...     toggle(pin)\n"
"...     time.sleep_ms(500)\n"
"...\n"
"...\n"
"...\n"
">>>"
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:177
msgid ""
"This will toggle the LED at 1Hz (half a second on, half a second off).  "
"To stop the toggling press ctrl-C, which will raise a KeyboardInterrupt "
"exception and break out of the loop."
msgstr ""
"これは 1Hz で LED の点灯/消灯を切り替えます(0.5秒点灯、0.5秒消灯)。"
"切り替えを止めるには、ctrl-C を押します。これは KeyboardInterrupt "
"例外を発生させ、ループから抜け出します。"

#: ../../../esp8266/tutorial/repl.rst:181
msgid ""
"The time module provides some useful functions for making delays and "
"doing timing.  Use tab completion to find out what they are and play "
"around with them!"
msgstr ""
"time モジュールは、遅延やタイミングをとるための便利な機能を提供します。"
"Tab キーによる補完機能を使って、何があるのかを調べて、使って遊んでみて"
"ください！"

#: ../../../esp8266/tutorial/repl.rst:185
msgid "Paste mode"
msgstr "貼付けモード"

#: ../../../esp8266/tutorial/repl.rst:187
msgid ""
"Pressing ctrl-E will enter a special paste mode.  This allows you to copy"
" and paste a chunk of text into the REPL.  If you press ctrl-E you will "
"see the paste-mode prompt::"
msgstr ""
"ctrl-E を押すと、特別な貼付けモードになります。これにより、テキストの"
"塊をコピーしてREPLに貼り付けることができます。ctrl-E を押すと、貼付け"
"モードのプロンプトが表示されます::"

#: ../../../esp8266/tutorial/repl.rst:191
msgid ""
"paste mode; Ctrl-C to cancel, Ctrl-D to finish\n"
"==="
msgstr ""

#: ../../../esp8266/tutorial/repl.rst:194
msgid ""
"You can then paste (or type) your text in.  Note that none of the special"
" keys or commands work in paste mode (eg Tab or backspace), they are just"
" accepted as-is.  Press ctrl-D to finish entering the text and execute "
"it."
msgstr ""
"この状態でテキストを貼り付ける(または入力する)ことができます。特別なキーやコマンド"
"(Tab や backspace など)は、貼付けモードでは機能せず、そのまま受け入れられます。"
"ctrl-D を押すと、テキストの入力が完了し、入力したテキストを実行します。"

#: ../../../esp8266/tutorial/repl.rst:199
msgid "Other control commands"
msgstr "その他の制御コマンド"

#: ../../../esp8266/tutorial/repl.rst:201
msgid "There are four other control commands:"
msgstr "その他にも４つの制御コマンドがあります:"

#: ../../../esp8266/tutorial/repl.rst:203
msgid ""
"Ctrl-A on a blank line will enter raw REPL mode.  This is like a "
"permanent paste mode, except that characters are not echoed back."
msgstr ""
"空白行で Ctrl-A を押すと、raw REPL モードになります。これは、文字が"
"エコーバックされないという点を除いて、永続的な貼付けモードのようなものです。"

#: ../../../esp8266/tutorial/repl.rst:206
msgid "Ctrl-B on a blank like goes to normal REPL mode."
msgstr "空白行で Ctrl-B を押すと、通常のREPLモードになります。"

#: ../../../esp8266/tutorial/repl.rst:208
msgid "Ctrl-C cancels any input, or interrupts the currently running code."
msgstr "Ctrl-C は入力をキャンセルしたり、現在実行中のコードを中断したりします。"

#: ../../../esp8266/tutorial/repl.rst:210
msgid "Ctrl-D on a blank line will do a soft reset."
msgstr "空白行で Ctrl-D を押すと、ソフトリセットを行います。"

#: ../../../esp8266/tutorial/repl.rst:212
msgid "Note that ctrl-A and ctrl-D do not work with WebREPL."
msgstr "ctrl-A と ctrl-D は WebREPL では機能しません。"

