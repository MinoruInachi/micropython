# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2018, Damien P. George, Paul Sokolovsky, and
# contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.9.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-03 14:13+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../../library/_thread.rst:2
msgid ":mod:`_thread` -- multithreading support"
msgstr ""

#: ../../../library/_thread.rst:7
msgid "|see_cpython_module| :mod:`python:_thread`."
msgstr ""

#: ../../../library/_thread.rst:9
msgid "This module implements multithreading support."
msgstr ""

#: ../../../library/_thread.rst:11
msgid ""
"This module is highly experimental and its API is not yet fully settled "
"and not yet described in this documentation."
msgstr ""

#: ../../../library/array.rst:2
msgid ":mod:`array` -- arrays of numeric data"
msgstr ":mod:`array` -- 数値データの配列"

#: ../../../library/array.rst:7
msgid "|see_cpython_module| :mod:`python:array`."
msgstr ""

#: ../../../library/array.rst:9
msgid ""
"Supported format codes: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``, "
"``L``, ``q``, ``Q``, ``f``, ``d`` (the latter 2 depending on the "
"floating-point support)."
msgstr ""
"サポートする書式コード: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``, "
"``L``, ``q``, ``Q``, ``f``, ``d`` (最後の２つは浮動小数点サポートに依存します)。"

#: ../../../library/array.rst:14 ../../../library/machine.rst:141
#: ../../../library/pyb.rst:291 ../../../library/ucollections.rst:13
#: ../../../library/ucryptolib.rst:8 ../../../library/uio.rst:87
msgid "Classes"
msgstr "クラス"

#: ../../../library/array.rst:18
msgid ""
"Create array with elements of given type. Initial contents of the array "
"are given by *iterable*. If it is not provided, an empty array is "
"created."
msgstr ""
"与えたデータ型の要素を持つ配列を作成します。配列の初期値は *iterable* に与えます。"
"これを与えない場合は空の配列が作成されます。"

#: ../../../library/array.rst:24
msgid "Append new element *val* to the end of array, growing it."
msgstr "配列の最後に新しい要素 *val* を追加します。"

#: ../../../library/array.rst:28
msgid ""
"Append new elements as contained in *iterable* to the end of array, "
"growing it."
msgstr ""
"配列の最後に *iterable* に含まれる新しい要素を追加します。"

#: ../../../library/btree.rst:2
msgid ":mod:`btree` -- simple BTree database"
msgstr ""

#: ../../../library/btree.rst:7
msgid ""
"The ``btree`` module implements a simple key-value database using "
"external storage (disk files, or in general case, a random-access "
"`stream`). Keys are stored sorted in the database, and besides efficient "
"retrieval by a key value, a database also supports efficient ordered "
"range scans (retrieval of values with the keys in a given range). On the "
"application interface side, BTree database work as close a possible to a "
"way standard `dict` type works, one notable difference is that both keys "
"and values must be `bytes` objects (so, if you want to store objects of "
"other types, you need to serialize them to `bytes` first)."
msgstr ""

#: ../../../library/btree.rst:17
msgid "The module is based on the well-known BerkelyDB library, version 1.xx."
msgstr ""

#: ../../../library/btree.rst:19 ../../../library/machine.Signal.rst:19
#: ../../../library/pyb.ADC.rst:164 ../../../library/pyb.I2C.rst:13
#: ../../../library/pyb.Switch.rst:18 ../../../library/pyb.rst:51
#: ../../../library/pyb.rst:64
msgid "Example::"
msgstr ""

#: ../../../library/btree.rst:21
msgid ""
"import btree\n"
"\n"
"# First, we need to open a stream which holds a database\n"
"# This is usually a file, but can be in-memory database\n"
"# using uio.BytesIO, a raw flash partition, etc.\n"
"# Oftentimes, you want to create a database file if it doesn't\n"
"# exist and open if it exists. Idiom below takes care of this.\n"
"# DO NOT open database with \"a+b\" access mode.\n"
"try:\n"
"    f = open(\"mydb\", \"r+b\")\n"
"except OSError:\n"
"    f = open(\"mydb\", \"w+b\")\n"
"\n"
"# Now open a database itself\n"
"db = btree.open(f)\n"
"\n"
"# The keys you add will be sorted internally in the database\n"
"db[b\"3\"] = b\"three\"\n"
"db[b\"1\"] = b\"one\"\n"
"db[b\"2\"] = b\"two\"\n"
"\n"
"# Assume that any changes are cached in memory unless\n"
"# explicitly flushed (or database closed). Flush database\n"
"# at the end of each \"transaction\".\n"
"db.flush()\n"
"\n"
"# Prints b'two'\n"
"print(db[b\"2\"])\n"
"\n"
"# Iterate over sorted keys in the database, starting from b\"2\"\n"
"# until the end of the database, returning only values.\n"
"# Mind that arguments passed to values() method are *key* values.\n"
"# Prints:\n"
"#   b'two'\n"
"#   b'three'\n"
"for word in db.values(b\"2\"):\n"
"    print(word)\n"
"\n"
"del db[b\"2\"]\n"
"\n"
"# No longer true, prints False\n"
"print(b\"2\" in db)\n"
"\n"
"# Prints:\n"
"#  b\"1\"\n"
"#  b\"3\"\n"
"for key in db:\n"
"    print(key)\n"
"\n"
"db.close()\n"
"\n"
"# Don't forget to close the underlying stream!\n"
"f.close()"
msgstr ""

#: ../../../library/btree.rst:77 ../../../library/cmath.rst:16
#: ../../../library/esp.rst:11 ../../../library/gc.rst:10
#: ../../../library/math.rst:18 ../../../library/micropython.rst:8
#: ../../../library/sys.rst:10 ../../../library/ubinascii.rst:13
#: ../../../library/uheapq.rst:14 ../../../library/uio.rst:78
#: ../../../library/ujson.rst:13 ../../../library/ure.rst:56
#: ../../../library/uselect.rst:13 ../../../library/usocket.rst:67
#: ../../../library/ussl.rst:14 ../../../library/ustruct.rst:16
#: ../../../library/utime.rst:37 ../../../library/uzlib.rst:15
#: ../../../library/wipy.rst:12
msgid "Functions"
msgstr "関数"

#: ../../../library/btree.rst:81
msgid ""
"Open a database from a random-access `stream` (like an open file). All "
"other parameters are optional and keyword-only, and allow to tweak "
"advanced parameters of the database operation (most users will not need "
"them):"
msgstr ""

#: ../../../library/btree.rst:85
msgid "*flags* - Currently unused."
msgstr ""

#: ../../../library/btree.rst:86
msgid ""
"*pagesize* - Page size used for the nodes in BTree. Acceptable range is "
"512-65536. If 0, a port-specific default will be used, optimized for "
"port's memory usage and/or performance."
msgstr ""

#: ../../../library/btree.rst:89
msgid ""
"*cachesize* - Suggested memory cache size in bytes. For a board with "
"enough memory using larger values may improve performance. Cache policy "
"is as follows: entire cache is not allocated at once; instead, accessing "
"a new page in database will allocate a memory buffer for it, until value "
"specified by *cachesize* is reached. Then, these buffers will be managed "
"using LRU (least recently used) policy. More buffers may still be "
"allocated if needed (e.g., if a database contains big keys and/or "
"values). Allocated cache buffers aren't reclaimed."
msgstr ""

#: ../../../library/btree.rst:97
msgid ""
"*minkeypage* - Minimum number of keys to store per page. Default value of"
" 0 equivalent to 2."
msgstr ""

#: ../../../library/btree.rst:100
msgid ""
"Returns a BTree object, which implements a dictionary protocol (set of "
"methods), and some additional methods described below."
msgstr ""

#: ../../../library/btree.rst:104 ../../../library/machine.ADC.rst:33
#: ../../../library/machine.Pin.rst:107 ../../../library/machine.RTC.rst:25
#: ../../../library/machine.SD.rst:38 ../../../library/machine.SPI.rst:30
#: ../../../library/machine.Signal.rst:97 ../../../library/machine.Timer.rst:36
#: ../../../library/machine.TimerWiPy.rst:40
#: ../../../library/machine.TimerWiPy.rst:114
#: ../../../library/machine.UART.rst:44 ../../../library/machine.WDT.rst:30
#: ../../../library/network.CC3K.rst:52
#: ../../../library/network.WIZNET5K.rst:52
#: ../../../library/network.WLAN.rst:27
#: ../../../library/network.WLANWiPy.rst:44 ../../../library/pyb.ADC.rst:32
#: ../../../library/pyb.Accel.rst:24 ../../../library/pyb.CAN.rst:50
#: ../../../library/pyb.DAC.rst:77 ../../../library/pyb.ExtInt.rst:81
#: ../../../library/pyb.I2C.rst:81 ../../../library/pyb.LCD.rst:51
#: ../../../library/pyb.LED.rst:21 ../../../library/pyb.Pin.rst:99
#: ../../../library/pyb.Pin.rst:250 ../../../library/pyb.RTC.rst:26
#: ../../../library/pyb.SPI.rst:48 ../../../library/pyb.Servo.rst:39
#: ../../../library/pyb.Switch.rst:32 ../../../library/pyb.Timer.rst:63
#: ../../../library/pyb.Timer.rst:229 ../../../library/pyb.UART.rst:70
#: ../../../library/pyb.USB_HID.rst:22 ../../../library/pyb.USB_VCP.rst:21
#: ../../../library/uhashlib.rst:43 ../../../library/uselect.rst:32
#: ../../../library/usocket.rst:180
msgid "Methods"
msgstr ""

#: ../../../library/btree.rst:108
msgid ""
"Close the database. It's mandatory to close the database at the end of "
"processing, as some unwritten data may be still in the cache. Note that "
"this does not close underlying stream with which the database was opened,"
" it should be closed separately (which is also mandatory to make sure "
"that data flushed from buffer to the underlying storage)."
msgstr ""

#: ../../../library/btree.rst:116
msgid "Flush any data in cache to the underlying stream."
msgstr ""

#: ../../../library/btree.rst:124
msgid "Standard dictionary methods."
msgstr ""

#: ../../../library/btree.rst:128
msgid ""
"A BTree object can be iterated over directly (similar to a dictionary) to"
" get access to all keys in order."
msgstr ""

#: ../../../library/btree.rst:135
msgid ""
"These methods are similar to standard dictionary methods, but also can "
"take optional parameters to iterate over a key sub-range, instead of the "
"entire database. Note that for all 3 methods, *start_key* and *end_key* "
"arguments represent key values. For example, `values()` method will "
"iterate over values corresponding to they key range given. None values "
"for *start_key* means \"from the first key\", no *end_key* or its value "
"of None means \"until the end of database\". By default, range is "
"inclusive of *start_key* and exclusive of *end_key*, you can include "
"*end_key* in iteration by passing *flags* of `btree.INCL`. You can "
"iterate in descending key direction by passing *flags* of `btree.DESC`. "
"The flags values can be ORed together."
msgstr ""

#: ../../../library/btree.rst:149 ../../../library/cmath.rst:55
#: ../../../library/framebuf.rst:118 ../../../library/lcd160cr.rst:380
#: ../../../library/machine.Pin.rst:223 ../../../library/machine.RTC.rst:65
#: ../../../library/machine.SPI.rst:89 ../../../library/machine.Timer.rst:59
#: ../../../library/machine.TimerWiPy.rst:154
#: ../../../library/machine.UART.rst:146 ../../../library/machine.rst:118
#: ../../../library/math.rst:177 ../../../library/network.CC3K.rst:83
#: ../../../library/network.WLANWiPy.rst:145 ../../../library/pyb.CAN.rst:278
#: ../../../library/pyb.ExtInt.rst:102 ../../../library/pyb.I2C.rst:157
#: ../../../library/pyb.Pin.rst:181 ../../../library/pyb.SPI.rst:112
#: ../../../library/pyb.UART.rst:163 ../../../library/sys.rst:34
#: ../../../library/uerrno.rst:13 ../../../library/usocket.rst:139
#: ../../../library/ussl.rst:42
msgid "Constants"
msgstr "定数"

#: ../../../library/btree.rst:153
msgid ""
"A flag for `keys()`, `values()`, `items()` methods to specify that "
"scanning should be inclusive of the end key."
msgstr ""

#: ../../../library/btree.rst:158
msgid ""
"A flag for `keys()`, `values()`, `items()` methods to specify that "
"scanning should be in descending direction of keys."
msgstr ""

#: ../../../library/builtins.rst:2
msgid "Builtin functions and exceptions"
msgstr "組込みの関数と例外"

#: ../../../library/builtins.rst:4
msgid ""
"All builtin functions and exceptions are described here. They are also "
"available via ``builtins`` module."
msgstr ""
"組込みの関数と例外のすべては、ここで説明します。これらは"
"``builtins`` モジュール経由でも利用できます。"

#: ../../../library/builtins.rst:8
msgid "Functions and types"
msgstr "関数とデータ型"

#: ../../../library/builtins.rst:24
msgid "|see_cpython| `python:bytes`."
msgstr ""

#: ../../../library/builtins.rst:38
msgid ""
"The argument *name* should be a string, and this function deletes the "
"named attribute from the object given by *obj*."
msgstr ""
"引数 *name* は文字列でなければならず、この関数は *obj* で与えたオブジェクトから、"
"指定された名前の属性を削除します。"

#: ../../../library/builtins.rst:77 ../../../library/builtins.rst:82
msgid ""
"In MicroPython, `byteorder` parameter must be positional (this is "
"compatible with CPython)."
msgstr ""
"MicroPython では、 `byteorder` は位置パラメータでなければなりません(位置"
"パラメータとすることは CPython でも可能です)。"

#: ../../../library/builtins.rst:135
msgid "The *slice* builtin is the type that slice objects have."
msgstr "*slice* 組込み型は、スライスオブジェクトが持つデータ型です。"

#: ../../../library/builtins.rst:155 ../../../library/ussl.rst:35
msgid "Exceptions"
msgstr "例外"

#: ../../../library/builtins.rst:179
msgid ""
"|see_cpython| `python:OSError`. MicroPython doesn't implement ``errno`` "
"attribute, instead use the standard way to access exception arguments: "
"``exc.args[0]``."
msgstr ""
"|see_cpython| `python:OSError` 。MicroPython は ``errno`` 属性を実装しておらず、"
"代わりに標準的な方法 ``exc.args[0]`` で例外引数にアクセスします。"

#: ../../../library/builtins.rst:191
msgid "|see_cpython| `python:SystemExit`."
msgstr ""

#: ../../../library/builtins.rst:195
msgid "|see_cpython| `python:TypeError`."
msgstr ""

#: ../../../library/cmath.rst:2
msgid ":mod:`cmath` -- mathematical functions for complex numbers"
msgstr ":mod:`cmath` -- 複素数のための数学関数"

#: ../../../library/cmath.rst:7
msgid "|see_cpython_module| :mod:`python:cmath`."
msgstr ""

#: ../../../library/cmath.rst:9
msgid ""
"The ``cmath`` module provides some basic mathematical functions for "
"working with complex numbers."
msgstr ""
"``cmath`` モジュールは、複素数を扱うための基本的な数学関数を提供します。"

#: ../../../library/cmath.rst:12
msgid ""
"Availability: not available on WiPy and ESP8266. Floating point support "
"required for this module."
msgstr ""
"可用性: WiPy および ESP8266 では利用できません。このモジュールには浮動小数点数の"
"サポートが必要です。"

#: ../../../library/cmath.rst:20
msgid "Return the cosine of ``z``."
msgstr "``z`` の余弦を返すます。"

#: ../../../library/cmath.rst:24
msgid "Return the exponential of ``z``."
msgstr "``z`` の指数を返します。"

#: ../../../library/cmath.rst:28
msgid ""
"Return the natural logarithm of ``z``.  The branch cut is along the "
"negative real axis."
msgstr ""
"``z`` の自然対数を返します。分岐截線は負の実軸を使います。"

#: ../../../library/cmath.rst:32
msgid ""
"Return the base-10 logarithm of ``z``.  The branch cut is along the "
"negative real axis."
msgstr ""
"``z`` の常用対数を返します。分岐截線は負の実軸を使います。"

#: ../../../library/cmath.rst:36
msgid "Returns the phase of the number ``z``, in the range (-pi, +pi]."
msgstr "``z`` の位相を (-pi, pi) の範囲内で返します。"

#: ../../../library/cmath.rst:40
msgid "Returns, as a tuple, the polar form of ``z``."
msgstr "``z`` の極座標をタプルで返します。"

#: ../../../library/cmath.rst:44
msgid "Returns the complex number with modulus ``r`` and phase ``phi``."
msgstr "モジュラス ``r`` と位相 ``phi`` を持つ複素数を返します。"

#: ../../../library/cmath.rst:48
msgid "Return the sine of ``z``."
msgstr "``z`` の正弦を返します。"

#: ../../../library/cmath.rst:52
msgid "Return the square-root of ``z``."
msgstr "``z`` の平方根を返します。"

#: ../../../library/cmath.rst:59 ../../../library/math.rst:181
msgid "base of the natural logarithm"
msgstr "自然対数の底"

#: ../../../library/cmath.rst:63 ../../../library/math.rst:185
msgid "the ratio of a circle's circumference to its diameter"
msgstr "円の円周と直径の比(円周率)"

#: ../../../library/esp.rst:2
msgid ":mod:`esp` --- functions related to the ESP8266"
msgstr ""

#: ../../../library/esp.rst:7
msgid ""
"The ``esp`` module contains specific functions related to the ESP8266 "
"module."
msgstr ""

#: ../../../library/esp.rst:15
msgid "Get or set the sleep type."
msgstr ""

#: ../../../library/esp.rst:17
msgid ""
"If the *sleep_type* parameter is provided, sets the sleep type to its "
"value. If the function is called without parameters, returns the current "
"sleep type."
msgstr ""

#: ../../../library/esp.rst:21
msgid "The possible sleep types are defined as constants:"
msgstr ""

#: ../../../library/esp.rst:23
msgid "``SLEEP_NONE`` -- all functions enabled,"
msgstr ""

#: ../../../library/esp.rst:24
msgid "``SLEEP_MODEM`` -- modem sleep, shuts down the WiFi Modem circuit."
msgstr ""

#: ../../../library/esp.rst:25
msgid ""
"``SLEEP_LIGHT`` -- light sleep, shuts down the WiFi Modem circuit and "
"suspends the processor periodically."
msgstr ""

#: ../../../library/esp.rst:28
msgid "The system enters the set sleep mode automatically when possible."
msgstr ""

#: ../../../library/esp.rst:32
msgid "Enter deep sleep."
msgstr ""

#: ../../../library/esp.rst:34
msgid ""
"The whole module powers down, except for the RTC clock circuit, which can"
" be used to restart the module after the specified time if the pin 16 is "
"connected to the reset pin. Otherwise the module will sleep until "
"manually reset."
msgstr ""

#: ../../../library/esp.rst:41
msgid "Read the device ID of the flash memory."
msgstr ""

#: ../../../library/esp.rst:51
msgid ""
"Set the location that native code will be placed for execution after it "
"is compiled.  Native code is emitted when the ``@micropython.native``, "
"``@micropython.viper`` and ``@micropython.asm_xtensa`` decorators are "
"applied to a function.  The ESP8266 must execute code from either iRAM or"
" the lower 1MByte of flash (which is memory mapped), and this function "
"controls the location."
msgstr ""

#: ../../../library/esp.rst:58
msgid ""
"If *start* and *length* are both ``None`` then the native code location "
"is set to the unused portion of memory at the end of the iRAM1 region.  "
"The size of this unused portion depends on the firmware and is typically "
"quite small (around 500 bytes), and is enough to store a few very small "
"functions.  The advantage of using this iRAM1 region is that it does not "
"get worn out by writing to it."
msgstr ""

#: ../../../library/esp.rst:65
msgid ""
"If neither *start* nor *length* are ``None`` then they should be "
"integers. *start* should specify the byte offset from the beginning of "
"the flash at which native code should be stored.  *length* specifies how "
"many bytes of flash from *start* can be used to store native code.  "
"*start* and *length* should be multiples of the sector size (being 4096 "
"bytes).  The flash will be automatically erased before writing to it so "
"be sure to use a region of flash that is not otherwise used, for example "
"by the firmware or the filesystem."
msgstr ""

#: ../../../library/esp.rst:74
msgid ""
"When using the flash to store native code *start+length* must be less "
"than or equal to 1MByte.  Note that the flash can be worn out if repeated"
" erasures (and writes) are made so use this feature sparingly. In "
"particular, native code needs to be recompiled and rewritten to flash on "
"each boot (including wake from deepsleep)."
msgstr ""

#: ../../../library/esp.rst:80
msgid ""
"In both cases above, using iRAM1 or flash, if there is no more room left "
"in the specified region then the use of a native decorator on a function "
"will lead to `MemoryError` exception being raised during compilation of "
"that function."
msgstr ""

#: ../../../library/framebuf.rst:2
msgid ":mod:`framebuf` --- Frame buffer manipulation"
msgstr ""

#: ../../../library/framebuf.rst:7
msgid ""
"This module provides a general frame buffer which can be used to create "
"bitmap images, which can then be sent to a display."
msgstr ""

#: ../../../library/framebuf.rst:11
msgid "class FrameBuffer"
msgstr ""

#: ../../../library/framebuf.rst:13
msgid ""
"The FrameBuffer class provides a pixel buffer which can be drawn upon "
"with pixels, lines, rectangles, text and even other FrameBuffer's. It is "
"useful when generating output for displays."
msgstr ""

#: ../../../library/framebuf.rst:17 ../../../library/lcd160cr.rst:25
#: ../../../library/network.rst:15
msgid "For example::"
msgstr ""

#: ../../../library/framebuf.rst:19
msgid ""
"import framebuf\n"
"\n"
"# FrameBuffer needs 2 bytes for every RGB565 pixel\n"
"fbuf = FrameBuffer(bytearray(10 * 100 * 2), 10, 100, framebuf.RGB565)\n"
"\n"
"fbuf.fill(0)\n"
"fbuf.text('MicroPython!', 0, 0, 0xffff)\n"
"fbuf.hline(0, 10, 96, 0xffff)"
msgstr ""

#: ../../../library/framebuf.rst:29 ../../../library/lcd160cr.rst:38
#: ../../../library/machine.ADC.rst:16 ../../../library/machine.I2C.rst:34
#: ../../../library/machine.Pin.rst:43 ../../../library/machine.RTC.rst:18
#: ../../../library/machine.SD.rst:31 ../../../library/machine.SPI.rst:15
#: ../../../library/machine.Signal.rst:75 ../../../library/machine.Timer.rst:28
#: ../../../library/machine.TimerWiPy.rst:32
#: ../../../library/machine.UART.rst:37 ../../../library/machine.WDT.rst:21
#: ../../../library/network.CC3K.rst:31
#: ../../../library/network.WIZNET5K.rst:32
#: ../../../library/network.WLAN.rst:17
#: ../../../library/network.WLANWiPy.rst:29 ../../../library/pyb.ADC.rst:24
#: ../../../library/pyb.Accel.rst:17 ../../../library/pyb.CAN.rst:23
#: ../../../library/pyb.DAC.rst:50 ../../../library/pyb.ExtInt.rst:52
#: ../../../library/pyb.I2C.rst:57 ../../../library/pyb.LCD.rst:42
#: ../../../library/pyb.LED.rst:11 ../../../library/pyb.Pin.rst:75
#: ../../../library/pyb.RTC.rst:18 ../../../library/pyb.SPI.rst:29
#: ../../../library/pyb.Servo.rst:31 ../../../library/pyb.Switch.rst:24
#: ../../../library/pyb.Timer.rst:54 ../../../library/pyb.UART.rst:47
#: ../../../library/pyb.USB_HID.rst:14 ../../../library/pyb.USB_VCP.rst:13
#: ../../../library/uhashlib.rst:28
msgid "Constructors"
msgstr ""

#: ../../../library/framebuf.rst:33
msgid "Construct a FrameBuffer object.  The parameters are:"
msgstr ""

#: ../../../library/framebuf.rst:35
msgid ""
"*buffer* is an object with a buffer protocol which must be large enough "
"to contain every pixel defined by the width, height and format of the "
"FrameBuffer."
msgstr ""

#: ../../../library/framebuf.rst:38
msgid "*width* is the width of the FrameBuffer in pixels"
msgstr ""

#: ../../../library/framebuf.rst:39
msgid "*height* is the height of the FrameBuffer in pixels"
msgstr ""

#: ../../../library/framebuf.rst:40
msgid ""
"*format* specifies the type of pixel used in the FrameBuffer; permissible"
" values are listed under Constants below. These set the number of bits "
"used to encode a color value and the layout of these bits in *buffer*. "
"Where a color value c is passed to a method, c is a small integer with an"
" encoding that is dependent on the format of the FrameBuffer."
msgstr ""

#: ../../../library/framebuf.rst:46
msgid ""
"*stride* is the number of pixels between each horizontal line of pixels "
"in the FrameBuffer. This defaults to *width* but may need adjustments "
"when implementing a FrameBuffer within another larger FrameBuffer or "
"screen. The *buffer* size must accommodate an increased step size."
msgstr ""

#: ../../../library/framebuf.rst:52
msgid ""
"One must specify valid *buffer*, *width*, *height*, *format* and "
"optionally *stride*.  Invalid *buffer* size or dimensions may lead to "
"unexpected errors."
msgstr ""

#: ../../../library/framebuf.rst:57 ../../../library/lcd160cr.rst:212
msgid "Drawing primitive shapes"
msgstr ""

#: ../../../library/framebuf.rst:59
msgid "The following methods draw shapes onto the FrameBuffer."
msgstr ""

#: ../../../library/framebuf.rst:63
msgid "Fill the entire FrameBuffer with the specified color."
msgstr ""

#: ../../../library/framebuf.rst:67
msgid ""
"If *c* is not given, get the color value of the specified pixel. If *c* "
"is given, set the specified pixel to the given color."
msgstr ""

#: ../../../library/framebuf.rst:74
msgid ""
"Draw a line from a set of coordinates using the given color and a "
"thickness of 1 pixel. The `line` method draws the line up to a second set"
" of coordinates whereas the `hline` and `vline` methods draw horizontal "
"and vertical lines respectively up to a given length."
msgstr ""

#: ../../../library/framebuf.rst:83
msgid ""
"Draw a rectangle at the given location, size and color. The `rect` method"
" draws only a 1 pixel outline whereas the `fill_rect` method draws both "
"the outline and interior."
msgstr ""

#: ../../../library/framebuf.rst:88 ../../../library/lcd160cr.rst:172
msgid "Drawing text"
msgstr ""

#: ../../../library/framebuf.rst:92
msgid ""
"Write text to the FrameBuffer using the the coordinates as the upper-left"
" corner of the text. The color of the text can be defined by the optional"
" argument but is otherwise a default value of 1. All characters have "
"dimensions of 8x8 pixels and there is currently no way to change the "
"font."
msgstr ""

#: ../../../library/framebuf.rst:99
msgid "Other methods"
msgstr ""

#: ../../../library/framebuf.rst:103
msgid ""
"Shift the contents of the FrameBuffer by the given vector. This may leave"
" a footprint of the previous colors in the FrameBuffer."
msgstr ""

#: ../../../library/framebuf.rst:108
msgid ""
"Draw another FrameBuffer on top of the current one at the given "
"coordinates. If *key* is specified then it should be a color integer and "
"the corresponding color will be considered transparent: all pixels with "
"that color value will not be drawn."
msgstr ""

#: ../../../library/framebuf.rst:113
msgid ""
"This method works between FrameBuffer instances utilising different "
"formats, but the resulting colors may be unexpected due to the mismatch "
"in color formats."
msgstr ""

#: ../../../library/framebuf.rst:122
msgid ""
"Monochrome (1-bit) color format This defines a mapping where the bits in "
"a byte are vertically mapped with bit 0 being nearest the top of the "
"screen. Consequently each byte occupies 8 vertical pixels. Subsequent "
"bytes appear at successive horizontal locations until the rightmost edge "
"is reached. Further bytes are rendered at locations starting at the "
"leftmost edge, 8 pixels lower."
msgstr ""

#: ../../../library/framebuf.rst:131
msgid ""
"Monochrome (1-bit) color format This defines a mapping where the bits in "
"a byte are horizontally mapped. Each byte occupies 8 horizontal pixels "
"with bit 0 being the leftmost. Subsequent bytes appear at successive "
"horizontal locations until the rightmost edge is reached. Further bytes "
"are rendered on the next row, one pixel lower."
msgstr ""

#: ../../../library/framebuf.rst:140
msgid ""
"Monochrome (1-bit) color format This defines a mapping where the bits in "
"a byte are horizontally mapped. Each byte occupies 8 horizontal pixels "
"with bit 7 being the leftmost. Subsequent bytes appear at successive "
"horizontal locations until the rightmost edge is reached. Further bytes "
"are rendered on the next row, one pixel lower."
msgstr ""

#: ../../../library/framebuf.rst:149
msgid "Red Green Blue (16-bit, 5+6+5) color format"
msgstr ""

#: ../../../library/framebuf.rst:153
msgid "Grayscale (2-bit) color format"
msgstr ""

#: ../../../library/framebuf.rst:157
msgid "Grayscale (4-bit) color format"
msgstr ""

#: ../../../library/framebuf.rst:161
msgid "Grayscale (8-bit) color format"
msgstr ""

#: ../../../library/gc.rst:2
msgid ":mod:`gc` -- control the garbage collector"
msgstr ":mod:`gc` -- ガベージコレクションの制御"

#: ../../../library/gc.rst:7
msgid "|see_cpython_module| :mod:`python:gc`."
msgstr ""

#: ../../../library/gc.rst:14
msgid "Enable automatic garbage collection."
msgstr "自動ガベージコレクションを有効にします。"

#: ../../../library/gc.rst:18
msgid ""
"Disable automatic garbage collection.  Heap memory can still be "
"allocated, and garbage collection can still be initiated manually using "
":meth:`gc.collect`."
msgstr ""
"自動ガベージコレクションを無効にします。無効にしてもヒープメモリの割り当ては"
"可能であり、ガベージコレクションも :meth:`gc.collect` を使って手動で開始できます。"

#: ../../../library/gc.rst:23
msgid "Run a garbage collection."
msgstr "ガベージコレクションを実行します。"

#: ../../../library/gc.rst:27
msgid "Return the number of bytes of heap RAM that are allocated."
msgstr "割り当てられているヒープ RAM のバイト数を返します。"

#: ../../../library/gc.rst:29 ../../../library/gc.rst:39
#: ../../../library/gc.rst:61 ../../../library/sys.rst:23
#: ../../../library/sys.rst:56 ../../../library/ubinascii.rst:19
#: ../../../library/uio.rst:15 ../../../library/uio.rst:126
#: ../../../library/uselect.rst:79 ../../../library/uselect.rst:96
#: ../../../library/usocket.rst:12 ../../../library/usocket.rst:109
#: ../../../library/usocket.rst:278 ../../../library/usocket.rst:302
#: ../../../library/usocket.rst:308 ../../../library/usocket.rst:349
#: ../../../library/utime.rst:217 ../../../library/uzlib.rst:34
msgid "Difference to CPython"
msgstr "CPython との違い"

#: ../../../library/gc.rst:32 ../../../library/gc.rst:42
msgid "This function is MicroPython extension."
msgstr "この関数は、MicroPythonの拡張機能です。"

#: ../../../library/gc.rst:36
msgid ""
"Return the number of bytes of available heap RAM, or -1 if this amount is"
" not known."
msgstr ""
"使用可能なヒープ RAM のバイト数を返します。この量がわからない場合は -1 を返します。"

#: ../../../library/gc.rst:46
msgid ""
"Set or query the additional GC allocation threshold. Normally, a "
"collection is triggered only when a new allocation cannot be satisfied, "
"i.e. on an out-of-memory (OOM) condition. If this function is called, in "
"addition to OOM, a collection will be triggered each time after *amount* "
"bytes have been allocated (in total, since the previous time such an "
"amount of bytes have been allocated). *amount* is usually specified as "
"less than the full heap size, with the intention to trigger a collection "
"earlier than when the heap becomes exhausted, and in the hope that an "
"early collection will prevent excessive memory fragmentation. This is a "
"heuristic measure, the effect of which will vary from application to "
"application, as well as the optimal value of the *amount* parameter."
msgstr ""
"GC 割り当てしきい値を追加で設定または照会します。通常、ガベージコレクションは、"
"新しい割り当てを満たすことができない場合、つまりメモリー不足(OOM: Out-Of-Memory)"
"状態でのみトリガーされます。この関数が呼び出された場合は、OOMに加えて、 *amount* "
"バイトが(以前に割り当てられているものと合計で)割り当てられた後にガベージコレクション"
"がトリガーされます量は通常、ヒープが使い尽くされたときよりも早くガベージコレクション"
"をトリガーすることが目的であり、全ヒープサイズよりも小さく指定します。また、早めの"
"ガベージコレクションによって過剰なメモリー断片化が防止されることを期待しています。"
"これは、ヒューリスティックな尺度であり、その効果はアプリケーションごとに異なり、 "
"*amount* パラメータの最適値も異なります。"

#: ../../../library/gc.rst:58
msgid ""
"Calling the function without argument will return the current value of "
"the threshold. A value of -1 means a disabled allocation threshold."
msgstr ""
"引数なしで関数を呼び出すと、しきい値の現在の値が返されます。値が -1 の場合は"
"無効な割り当てしきい値であることを意味します。"

#: ../../../library/gc.rst:64
msgid ""
"This function is a MicroPython extension. CPython has a similar function "
"- ``set_threshold()``, but due to different GC implementations, its "
"signature and semantics are different."
msgstr ""
"この関数は、MicroPython の拡張機能です。CPython も同様の機能 ``set_threshold()`` "
"を持っていますが、GCの実装が異なるため、シグネチャとセマンティクスが異なります。"

#: ../../../library/index.rst:4
msgid "MicroPython libraries"
msgstr "MicroPython ライブラリ"

#: ../../../library/index.rst:8
msgid "Important summary of this section"
msgstr "この章の重要な要約"

#: ../../../library/index.rst:10
msgid "MicroPython implements a subset of Python functionality for each module."
msgstr "MicroPythonは各モジュールにPythonの機能のサブセットを実装しています。"

#: ../../../library/index.rst:11
msgid ""
"To ease extensibility, MicroPython versions of standard Python modules "
"usually have ``u`` (\"micro\") prefix."
msgstr ""
"拡張性を容易にするために、標準の Python モジュールの MicroPython 版には通常、 "
"``u`` (\"micro\")接頭辞が付いています。"

#: ../../../library/index.rst:13
msgid ""
"Any particular MicroPython variant or port may miss any feature/function "
"described in this general documentation (due to resource constraints or "
"other limitations)."
msgstr ""
"特定の MicroPython の亜種またはポートには、(リソースの制約またはその他の制限のために)"
"この一般的なドキュメンテーションに記載されている機能/関数がサポートされていないことが"
"あります。"

#: ../../../library/index.rst:18
msgid ""
"This chapter describes modules (function and class libraries) which are "
"built into MicroPython. There are a few categories of such modules:"
msgstr ""
"この章では、MicroPython に組み込まれているモジュール(関数とクラスのライブラリ)に"
"ついて説明します。このようなモジュールにはいくつかのカテゴリがあります。"

#: ../../../library/index.rst:21
msgid ""
"Modules which implement a subset of standard Python functionality and are"
" not intended to be extended by the user."
msgstr ""
"標準の Python 機能のサブセットを実装し、ユーザが拡張することを意図していないモジュール。"

#: ../../../library/index.rst:23
msgid ""
"Modules which implement a subset of Python functionality, with a "
"provision for extension by the user (via Python code)."
msgstr ""
"Python の機能のサブセットを実装するモジュールで、Python コードを介して"
"ユーザーが拡張を提供します。"

#: ../../../library/index.rst:25
msgid ""
"Modules which implement MicroPython extensions to the Python standard "
"libraries."
msgstr ""
"Python 標準ライブラリへの MicroPython 拡張を実装するモジュール。"

#: ../../../library/index.rst:26
msgid "Modules specific to a particular `MicroPython port` and thus not portable."
msgstr ""
"特定の `MicroPython ポート` に固有のモジュールで、移植性がありません。"

#: ../../../library/index.rst:28
msgid ""
"Note about the availability of the modules and their contents: This "
"documentation in general aspires to describe all modules and "
"functions/classes which are implemented in MicroPython project. However, "
"MicroPython is highly configurable, and each port to a particular "
"board/embedded system makes available only a subset of MicroPython "
"libraries. For officially supported ports, there is an effort to either "
"filter out non-applicable items, or mark individual descriptions with "
"\"Availability:\" clauses describing which ports provide a given feature."
msgstr ""
"モジュールとその内容の可能性に関する注意: このドキュメンテーションは、"
"MicroPython プロジェクトで実装されているすべてのモジュールと関数/クラスについて"
"記述することを目指しています。しかし、MicroPython は高度に構成可能であり、"
"特定のボード/組み込みシステムへの各ポートは、MicroPython ライブラリのサブセット"
"のみを使用可能にします。正式にサポートされているポートの場合、適用不可能な項目を"
"除外するか、ポートが提供する機能の個々の説明に \"Availability:\" 節を付けるか"
"しています。"

#: ../../../library/index.rst:36
msgid ""
"With that in mind, please still be warned that some functions/classes in "
"a module (or even the entire module) described in this documentation "
"**may be unavailable** in a particular build of MicroPython on a "
"particular system. The best place to find general information of the "
"availability/non-availability of a particular feature is the \"General "
"Information\" section which contains information pertaining to a specific"
" `MicroPython port`."
msgstr ""
"これを念頭に置いて、特定のシステム上の MicroPython の特定のビルドでは、"
"このドキュメントで説明されているモジュールの一部の機能/クラス(またはモジュール全体)が"
"使えない可能性があります。特定の機能の可用性/非可用性に関する一般的な情報を"
"見つける最良の場所は、特定の `MicroPython ポート` に関連する情報を含む「一般情報」"
"の章です。"

#: ../../../library/index.rst:43
msgid ""
"On some ports you are able to discover the available, built-in libraries "
"that can be imported by entering the following at the REPL::"
msgstr ""
"いくつかのポートでは、REPL に次のように入力することで import できる、利用可能な"
"組込みライブラリを検出できます。"

#: ../../../library/index.rst:46
msgid "help('modules')"
msgstr ""

#: ../../../library/index.rst:48
msgid ""
"Beyond the built-in libraries described in this documentation, many more "
"modules from the Python standard library, as well as further MicroPython "
"extensions to it, can be found in `micropython-lib`."
msgstr ""
"このドキュメントで説明されている組込みライブラリ以外にも、Python 標準ライブラリからの"
"多くのモジュール、さらに MicroPython の拡張もあります。それらは `micropython-lib` "
"で見つけることができます。"

#: ../../../library/index.rst:53
msgid "Python standard libraries and micro-libraries"
msgstr "Python 標準ライブラリとマイクロライブラリ"

#: ../../../library/index.rst:55
msgid ""
"The following standard Python libraries have been \"micro-ified\" to fit "
"in with the philosophy of MicroPython.  They provide the core "
"functionality of that module and are intended to be a drop-in replacement"
" for the standard Python library.  Some modules below use a standard "
"Python name, but prefixed with \"u\", e.g. ``ujson`` instead of ``json``."
" This is to signify that such a module is micro-library, i.e. implements "
"only a subset of CPython module functionality. By naming them "
"differently, a user has a choice to write a Python-level module to extend"
" functionality for better compatibility with CPython (indeed, this is "
"what done by the `micropython-lib` project mentioned above)."
msgstr ""
"以下の標準的な Python ライブラリは、MicroPython の哲学に適合するように「マイクロ化」"
"されています。これらは、そのモジュールの中核となる機能を提供し、標準の Python ライブラリを"
"置き換えるものです。後述のモジュールいつくはか、標準的な Python の名前を使いますが、"
"接頭辞 \"u\" がついています。たとえば ``json`` の代わりに ``ujson`` となっています。"
"これは、そのようなモジュールがマイクロライブラリであることを示しています。すなわち、"
"CPython モジュールの機能のサブセットのみを実装しています。異なる名前を付けることによって、"
"ユーザーは Python レベルのモジュールを作成して、CPythonとの互換性を高める機能を拡張"
"できます(実際に、これは前述の `micropython-lib` プロジェクトによって行われます)。"

#: ../../../library/index.rst:65
msgid ""
"On some embedded platforms, where it may be cumbersome to add Python-"
"level wrapper modules to achieve naming compatibility with CPython, "
"micro-modules are available both by their u-name, and also by their "
"non-u-name.  The non-u-name can be overridden by a file of that name in "
"your library path (``sys.path``). For example, ``import json`` will first"
" search for a file ``json.py`` (or package directory ``json``) and load "
"that module if it is found.  If nothing is found, it will fallback to "
"loading the built-in ``ujson`` module."
msgstr ""
"CPython とのネーミングの互換性を実現するために Python レベルのラッパーモジュールを"
"追加するのは面倒な一部の組み込みプラットフォームでは、マイクロモジュールは u 付きの"
"と u なしの名前の両方を使えます。u なしの名前は、ライブラリパス(``sys.path``)内の"
"同名のファイルで上書きできます。たとえば ``import json`` はまず、ファイル "
"``json.py`` (あるいはパッケージディレクトリ ``json``)を検索し、見つかった場合は"
"そのモジュールをロードします。何も見つからなければ、組込みの ``ujson`` モジュール"
"をロードします。"

#: ../../../library/index.rst:101
msgid "MicroPython-specific libraries"
msgstr "MicroPython 固有のライブラリ"

#: ../../../library/index.rst:103
msgid ""
"Functionality specific to the MicroPython implementation is available in "
"the following libraries."
msgstr "MicroPython 処理系に固有の機能は、以下のライブラリで利用できます。"

#: ../../../library/index.rst:119
msgid "Libraries specific to the pyboard"
msgstr "pyboard 固有のライブラリ"

#: ../../../library/index.rst:121
msgid "The following libraries are specific to the pyboard."
msgstr "以下のライブラリは pyboard に固有のものです。"

#: ../../../library/index.rst:131
msgid "Libraries specific to the WiPy"
msgstr "WiPy 固有のライブラリ"

#: ../../../library/index.rst:133
msgid "The following libraries and classes are specific to the WiPy."
msgstr "以下のライブラリとクラスは WiPy に固有のものです。"

#: ../../../library/index.rst:143
msgid "Libraries specific to the ESP8266"
msgstr "ESP8266 固有のライブラリ"

#: ../../../library/index.rst:145
msgid "The following libraries are specific to the ESP8266."
msgstr "以下のライブラリは ESP8266 に固有のものです。"

#: ../../../library/lcd160cr.rst:2
msgid ":mod:`lcd160cr` --- control of LCD160CR display"
msgstr ""

#: ../../../library/lcd160cr.rst:7
msgid "This module provides control of the MicroPython LCD160CR display."
msgstr ""

msgid ""
".. image:: http://micropython.org/resources/LCD160CRv10-persp.jpg\n"
"   :alt: LCD160CRv1.0 picture"
msgstr ""

#: ../../../library/lcd160cr.rst:13
msgid "Further resources are available via the following links:"
msgstr ""

#: ../../../library/lcd160cr.rst:15
msgid ""
"`LCD160CRv1.0 reference manual "
"<http://micropython.org/resources/LCD160CRv10-refmanual.pdf>`_ (100KiB "
"PDF)"
msgstr ""

#: ../../../library/lcd160cr.rst:16
msgid ""
"`LCD160CRv1.0 schematics "
"<http://micropython.org/resources/LCD160CRv10-schematics.pdf>`_ (1.6MiB "
"PDF)"
msgstr ""

#: ../../../library/lcd160cr.rst:19
msgid "class LCD160CR"
msgstr ""

#: ../../../library/lcd160cr.rst:21
msgid ""
"The LCD160CR class provides an interface to the display.  Create an "
"instance of this class and use its methods to draw to the LCD and get the"
" status of the touch panel."
msgstr ""

#: ../../../library/lcd160cr.rst:27
msgid ""
"import lcd160cr\n"
"\n"
"lcd = lcd160cr.LCD160CR('X')\n"
"lcd.set_orient(lcd160cr.PORTRAIT)\n"
"lcd.set_pos(0, 0)\n"
"lcd.set_text_color(lcd.rgb(255, 0, 0), lcd.rgb(0, 0, 0))\n"
"lcd.set_font(1)\n"
"lcd.write('Hello MicroPython!')\n"
"print('touch:', lcd.get_touch())"
msgstr ""

#: ../../../library/lcd160cr.rst:42
msgid "Construct an LCD160CR object.  The parameters are:"
msgstr ""

#: ../../../library/lcd160cr.rst:44
msgid ""
"*connect* is a string specifying the physical connection of the LCD "
"display to the board; valid values are \"X\", \"Y\", \"XY\", \"YX\". Use "
"\"X\" when the display is connected to a pyboard in the X-skin position, "
"and \"Y\" when connected in the Y-skin position.  \"XY\" and \"YX\" are "
"used when the display is connected to the right or left side of the "
"pyboard, respectively."
msgstr ""

#: ../../../library/lcd160cr.rst:50
msgid "*pwr* is a Pin object connected to the LCD's power/enabled pin."
msgstr ""

#: ../../../library/lcd160cr.rst:51
msgid "*i2c* is an I2C object connected to the LCD's I2C interface."
msgstr ""

#: ../../../library/lcd160cr.rst:52
msgid "*spi* is an SPI object connected to the LCD's SPI interface."
msgstr ""

#: ../../../library/lcd160cr.rst:53
msgid "*i2c_addr* is the I2C address of the display."
msgstr ""

#: ../../../library/lcd160cr.rst:55
msgid ""
"One must specify either a valid *connect* or all of *pwr*, *i2c* and "
"*spi*. If a valid *connect* is given then any of *pwr*, *i2c* or *spi* "
"which are not passed as parameters (i.e. they are ``None``) will be "
"created based on the value of *connect*.  This allows to override the "
"default interface to the display if needed."
msgstr ""

#: ../../../library/lcd160cr.rst:61
msgid "The default values are:"
msgstr ""

#: ../../../library/lcd160cr.rst:63
msgid ""
"\"X\" is for the X-skin and uses: ``pwr=Pin(\"X4\")``, "
"``i2c=I2C(\"X\")``, ``spi=SPI(\"X\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:65
msgid ""
"\"Y\" is for the Y-skin and uses: ``pwr=Pin(\"Y4\")``, "
"``i2c=I2C(\"Y\")``, ``spi=SPI(\"Y\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:67
msgid ""
"\"XY\" is for the right-side and uses: ``pwr=Pin(\"X4\")``, "
"``i2c=I2C(\"Y\")``, ``spi=SPI(\"X\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:69
msgid ""
"\"YX\" is for the left-side and uses: ``pwr=Pin(\"Y4\")``, "
"``i2c=I2C(\"X\")``, ``spi=SPI(\"Y\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:72
msgid ""
"See `this image "
"<http://micropython.org/resources/LCD160CRv10-positions.jpg>`_ for how "
"the display can be connected to the pyboard."
msgstr ""

#: ../../../library/lcd160cr.rst:76
msgid "Static methods"
msgstr ""

#: ../../../library/lcd160cr.rst:80
msgid ""
"Return a 16-bit integer representing the given rgb color values.  The "
"16-bit value can be used to set the font color (see "
":meth:`LCD160CR.set_text_color`) pen color (see :meth:`LCD160CR.set_pen`)"
" and draw individual pixels."
msgstr ""

#: ../../../library/lcd160cr.rst:87
msgid "Clip the given line data.  This is for internal use."
msgstr ""

#: ../../../library/lcd160cr.rst:90
msgid "Instance members"
msgstr ""

#: ../../../library/lcd160cr.rst:92
msgid "The following instance members are publicly accessible."
msgstr ""

#: ../../../library/lcd160cr.rst:97
msgid ""
"The width and height of the display, respectively, in pixels.  These "
"members are updated when calling :meth:`LCD160CR.set_orient` and should "
"be considered read-only."
msgstr ""

#: ../../../library/lcd160cr.rst:102
msgid "Setup commands"
msgstr ""

#: ../../../library/lcd160cr.rst:106
msgid ""
"Turn the display on or off, depending on the given value of *on*: 0 or "
"``False`` will turn the display off, and 1 or ``True`` will turn it on."
msgstr ""

#: ../../../library/lcd160cr.rst:111
msgid ""
"Set the orientation of the display.  The *orient* parameter can be one of"
" `PORTRAIT`, `LANDSCAPE`, `PORTRAIT_UPSIDEDOWN`, `LANDSCAPE_UPSIDEDOWN`."
msgstr ""

#: ../../../library/lcd160cr.rst:116
msgid "Set the brightness of the display, between 0 and 31."
msgstr ""

#: ../../../library/lcd160cr.rst:120
msgid ""
"Set the I2C address of the display.  The *addr* value must have the lower"
" 2 bits cleared."
msgstr ""

#: ../../../library/lcd160cr.rst:125
msgid "Set the baudrate of the UART interface."
msgstr ""

#: ../../../library/lcd160cr.rst:129
msgid ""
"Set the start-up decoration of the display.  The *value* parameter can be"
" a logical or of `STARTUP_DECO_NONE`, `STARTUP_DECO_MLOGO`, "
"`STARTUP_DECO_INFO`."
msgstr ""

#: ../../../library/lcd160cr.rst:134
msgid ""
"Save the following parameters to flash so they persist on restart and "
"power up: initial decoration, orientation, brightness, UART baud rate, "
"I2C address."
msgstr ""

#: ../../../library/lcd160cr.rst:138
msgid "Pixel access methods"
msgstr ""

#: ../../../library/lcd160cr.rst:140
msgid "The following methods manipulate individual pixels on the display."
msgstr ""

#: ../../../library/lcd160cr.rst:144
msgid ""
"Set the specified pixel to the given color.  The color should be a 16-bit"
" integer and can be created by :meth:`LCD160CR.rgb`."
msgstr ""

#: ../../../library/lcd160cr.rst:149
msgid "Get the 16-bit value of the specified pixel."
msgstr ""

#: ../../../library/lcd160cr.rst:153
msgid ""
"Low-level method to get a line of pixels into the given buffer. To read "
"*n* pixels *buf* should be *2*n+1* bytes in length.  The first byte is a "
"dummy byte and should be ignored, and subsequent bytes represent the "
"pixels in the line starting at coordinate *(x, y)*."
msgstr ""

#: ../../../library/lcd160cr.rst:160
msgid ""
"Dump the contents of the screen to the given buffer.  The parameters *x* "
"and *y* specify the starting coordinate, and *w* and *h* the size of the "
"region.  If *w* or *h* are ``None`` then they will take on their maximum "
"values, set by the size of the screen minus the given *x* and *y* values."
"  *buf* should be large enough to hold ``2*w*h`` bytes.  If it's smaller "
"then only the initial horizontal lines will be stored."
msgstr ""

#: ../../../library/lcd160cr.rst:169
msgid "Load the entire screen from the given buffer."
msgstr ""

#: ../../../library/lcd160cr.rst:174
msgid ""
"To draw text one sets the position, color and font, and then uses "
"`LCD160CR.write` to draw the text."
msgstr ""

#: ../../../library/lcd160cr.rst:179
msgid ""
"Set the position for text output using :meth:`LCD160CR.write`.  The "
"position is the upper-left corner of the text."
msgstr ""

#: ../../../library/lcd160cr.rst:184
msgid "Set the foreground and background color of the text."
msgstr ""

#: ../../../library/lcd160cr.rst:188
msgid ""
"Set the font for the text.  Subsequent calls to `write` will use the "
"newly configured font.  The parameters are:"
msgstr ""

#: ../../../library/lcd160cr.rst:191
msgid "*font* is the font family to use, valid values are 0, 1, 2, 3."
msgstr ""

#: ../../../library/lcd160cr.rst:192
msgid ""
"*scale* is a scaling value for each character pixel, where the pixels are"
" drawn as a square with side length equal to *scale + 1*.  The value can "
"be between 0 and 63."
msgstr ""

#: ../../../library/lcd160cr.rst:195
msgid ""
"*bold* controls the number of pixels to overdraw each character pixel, "
"making a bold effect.  The lower 2 bits of *bold* are the number of "
"pixels to overdraw in the horizontal direction, and the next 2 bits are "
"for the vertical direction.  For example, a *bold* value of 5 will "
"overdraw 1 pixel in both the horizontal and vertical directions."
msgstr ""

#: ../../../library/lcd160cr.rst:200
msgid ""
"*trans* can be either 0 or 1 and if set to 1 the characters will be drawn"
" with a transparent background."
msgstr ""

#: ../../../library/lcd160cr.rst:202
msgid ""
"*scroll* can be either 0 or 1 and if set to 1 the display will do a soft "
"scroll if the text moves to the next line."
msgstr ""

#: ../../../library/lcd160cr.rst:207
msgid ""
"Write text to the display, using the current position, color and font. As"
" text is written the position is automatically incremented.  The display "
"supports basic VT100 control codes such as newline and backspace."
msgstr ""

#: ../../../library/lcd160cr.rst:214
msgid ""
"Primitive drawing commands use a foreground and background color set by "
"the `set_pen` method."
msgstr ""

#: ../../../library/lcd160cr.rst:219
msgid "Set the line and fill color for primitive shapes."
msgstr ""

#: ../../../library/lcd160cr.rst:223
msgid "Erase the entire display to the pen fill color."
msgstr ""

#: ../../../library/lcd160cr.rst:227
msgid "Draw a single pixel at the given location using the pen line color."
msgstr ""

#: ../../../library/lcd160cr.rst:233
msgid ""
"Draw a rectangle at the given location and size using the pen line color "
"for the outline, and the pen fill color for the interior. The `rect` "
"method draws the outline and interior, while the other methods just draw "
"one or the other."
msgstr ""

#: ../../../library/lcd160cr.rst:240
msgid "Draw a line between the given coordinates using the pen line color."
msgstr ""

#: ../../../library/lcd160cr.rst:248
msgid ""
"These methods are as above but don't do any clipping on the input "
"coordinates.  They are faster than the clipping versions and can be used "
"when you know that the coordinates are within the display."
msgstr ""

#: ../../../library/lcd160cr.rst:254
msgid ""
"Draw a sequence of dots using the pen line color. The *data* should be a "
"buffer of bytes, with each successive pair of bytes corresponding to "
"coordinate pairs (x, y)."
msgstr ""

#: ../../../library/lcd160cr.rst:260
msgid "Similar to :meth:`LCD160CR.poly_dot` but draws lines between the dots."
msgstr ""

#: ../../../library/lcd160cr.rst:263
msgid "Touch screen methods"
msgstr ""

#: ../../../library/lcd160cr.rst:267
msgid "Configure the touch panel:"
msgstr ""

#: ../../../library/lcd160cr.rst:269
msgid ""
"If *calib* is ``True`` then the call will trigger a touch calibration of "
"the resistive touch sensor.  This requires the user to touch various "
"parts of the screen."
msgstr ""

#: ../../../library/lcd160cr.rst:272
msgid ""
"If *save* is ``True`` then the touch parameters will be saved to NVRAM to"
" persist across reset/power up."
msgstr ""

#: ../../../library/lcd160cr.rst:274
msgid ""
"If *irq* is ``True`` then the display will be configured to pull the IRQ "
"line low when a touch force is detected.  If *irq* is ``False`` then this"
" feature is disabled.  If *irq* is ``None`` (the default value) then no "
"change is made to this setting."
msgstr ""

#: ../../../library/lcd160cr.rst:281
msgid ""
"Returns a boolean: ``True`` if there is currently a touch force on the "
"screen, ``False`` otherwise."
msgstr ""

#: ../../../library/lcd160cr.rst:286
msgid ""
"Returns a 3-tuple of: *(active, x, y)*.  If there is currently a touch "
"force on the screen then *active* is 1, otherwise it is 0.  The *x* and "
"*y* values indicate the position of the current or most recent touch."
msgstr ""

#: ../../../library/lcd160cr.rst:291
msgid "Advanced commands"
msgstr ""

#: ../../../library/lcd160cr.rst:295
msgid "Set the window that SPI data is written to."
msgstr ""

#: ../../../library/lcd160cr.rst:299
msgid ""
"Ready the display to accept RGB pixel data on the SPI bus, resetting the "
"location of the first byte to go to the top-left corner of the window set"
" by :meth:`LCD160CR.set_spi_win`. The method returns an SPI object which "
"can be used to write the pixel data."
msgstr ""

#: ../../../library/lcd160cr.rst:304
msgid ""
"Pixels should be sent as 16-bit RGB values in the 5-6-5 format.  The "
"destination counter will increase as data is sent, and data can be sent "
"in arbitrary sized chunks.  Once the destination counter reaches the end "
"of the window specified by :meth:`LCD160CR.set_spi_win` it will wrap "
"around to the top-left corner of that window."
msgstr ""

#: ../../../library/lcd160cr.rst:311
msgid ""
"Show the given buffer on the display.  *buf* should be an array of bytes "
"containing the 16-bit RGB values for the pixels, and they will be written"
" to the area specified by :meth:`LCD160CR.set_spi_win`, starting from the"
" top-left corner."
msgstr ""

#: ../../../library/lcd160cr.rst:315
msgid ""
"The `framebuf <framebuf.html>`_ module can be used to construct frame "
"buffers and provides drawing primitives. Using a frame buffer will "
"improve performance of animations when compared to drawing directly to "
"the screen."
msgstr ""

#: ../../../library/lcd160cr.rst:321
msgid ""
"Turn scrolling on or off.  This controls globally whether any window "
"regions will scroll."
msgstr ""

#: ../../../library/lcd160cr.rst:326
msgid "Configure a window region for scrolling:"
msgstr ""

#: ../../../library/lcd160cr.rst:328
msgid ""
"*win* is the window id to configure.  There are 0..7 standard windows for"
" general purpose use.  Window 8 is the text scroll window (the ticker)."
msgstr ""

#: ../../../library/lcd160cr.rst:330
msgid "*x*, *y*, *w*, *h* specify the location of the window in the display."
msgstr ""

#: ../../../library/lcd160cr.rst:331
msgid ""
"*vec* specifies the direction and speed of scroll: it is a 16-bit value "
"of the form ``0bF.ddSSSSSSSSSSSS``.  *dd* is 0, 1, 2, 3 for +x, +y, -x, "
"-y scrolling. *F* sets the speed format, with 0 meaning that the window "
"is shifted *S % 256* pixel every frame, and 1 meaning that the window is "
"shifted 1 pixel every *S* frames."
msgstr ""

#: ../../../library/lcd160cr.rst:336
msgid "*pat* is a 16-bit pattern mask for the background."
msgstr ""

#: ../../../library/lcd160cr.rst:337
msgid "*fill* is the fill color."
msgstr ""

#: ../../../library/lcd160cr.rst:338
msgid "*color* is the extra color, either of the text or pattern foreground."
msgstr ""

#: ../../../library/lcd160cr.rst:342
msgid "Set a single parameter of a scrolling window region:"
msgstr ""

#: ../../../library/lcd160cr.rst:344
msgid "*win* is the window id, 0..8."
msgstr ""

#: ../../../library/lcd160cr.rst:345
msgid ""
"*param* is the parameter number to configure, 0..7, and corresponds to "
"the parameters in the `set_scroll_win` method."
msgstr ""

#: ../../../library/lcd160cr.rst:347
msgid "*value* is the value to set."
msgstr ""

#: ../../../library/lcd160cr.rst:351
msgid ""
"Set the string for scrolling in window 8.  The parameter *s* must be a "
"string with length 32 or less."
msgstr ""

#: ../../../library/lcd160cr.rst:356
msgid ""
"Display a JPEG.  *buf* should contain the entire JPEG data. JPEG data "
"should not include EXIF information. The following encodings are "
"supported: Baseline DCT, Huffman coding, 8 bits per sample, 3 color "
"components, YCbCr4:2:2. The origin of the JPEG is set by "
":meth:`LCD160CR.set_pos`."
msgstr ""

#: ../../../library/lcd160cr.rst:364
msgid ""
"Display a JPEG with the data split across multiple buffers.  There must "
"be a single call to `jpeg_start` to begin with, specifying the total "
"number of bytes in the JPEG.  Then this number of bytes must be "
"transferred to the display using one or more calls to the `jpeg_data` "
"command."
msgstr ""

#: ../../../library/lcd160cr.rst:371
msgid ""
"The first call to this method will start the display's internal watchdog "
"timer.  Subsequent calls will feed the watchdog.  The timeout is roughly "
"30 seconds."
msgstr ""

#: ../../../library/lcd160cr.rst:377
msgid "Reset the display."
msgstr ""

#: ../../../library/lcd160cr.rst:387
msgid "Orientations of the display, used by :meth:`LCD160CR.set_orient`."
msgstr ""

#: ../../../library/lcd160cr.rst:393
msgid ""
"Types of start-up decoration, can be OR'ed together, used by "
":meth:`LCD160CR.set_startup_deco`."
msgstr ""

#: ../../../library/machine.rst:2
msgid ":mod:`machine` --- functions related to the hardware"
msgstr ""

#: ../../../library/machine.rst:7
msgid ""
"The ``machine`` module contains specific functions related to the "
"hardware on a particular board. Most functions in this module allow to "
"achieve direct and unrestricted access to and control of hardware blocks "
"on a system (like CPU, timers, buses, etc.). Used incorrectly, this can "
"lead to malfunction, lockups, crashes of your board, and in extreme "
"cases, hardware damage."
msgstr ""

#: ../../../library/machine.rst:16
msgid ""
"A note of callbacks used by functions and class methods of :mod:`machine`"
" module: all these callbacks should be considered as executing in an "
"interrupt context. This is true for both physical devices with IDs >= 0 "
"and \"virtual\" devices with negative IDs like -1 (these \"virtual\" "
"devices are still thin shims on top of real hardware and real hardware "
"interrupts). See :ref:`isr_rules`."
msgstr ""

#: ../../../library/machine.rst:23 ../../../library/pyb.rst:72
msgid "Reset related functions"
msgstr ""

#: ../../../library/machine.rst:27
msgid ""
"Resets the device in a manner similar to pushing the external RESET "
"button."
msgstr ""

#: ../../../library/machine.rst:32
msgid ""
"Get the reset cause. See :ref:`constants <machine_constants>` for the "
"possible return values."
msgstr ""

#: ../../../library/machine.rst:35 ../../../library/pyb.rst:97
msgid "Interrupt related functions"
msgstr ""

#: ../../../library/machine.rst:39
msgid ""
"Disable interrupt requests. Returns the previous IRQ state which should "
"be considered an opaque value. This return value should be passed to the "
"`enable_irq()` function to restore interrupts to their original state, "
"before `disable_irq()` was called."
msgstr ""

#: ../../../library/machine.rst:46
msgid ""
"Re-enable interrupt requests. The *state* parameter should be the value "
"that was returned from the most recent call to the `disable_irq()` "
"function."
msgstr ""

#: ../../../library/machine.rst:51 ../../../library/pyb.rst:115
msgid "Power related functions"
msgstr ""

#: ../../../library/machine.rst:55
msgid "Returns CPU frequency in hertz."
msgstr ""

#: ../../../library/machine.rst:59
msgid ""
"Gates the clock to the CPU, useful to reduce power consumption at any "
"time during short or long periods. Peripherals continue working and "
"execution resumes as soon as any interrupt is triggered (on many ports "
"this includes system timer interrupt occurring at regular intervals on "
"the order of millisecond)."
msgstr ""

#: ../../../library/machine.rst:66
msgid ""
"Stops the CPU and disables all peripherals except for WLAN. Execution is "
"resumed from the point where the sleep was requested. For wake up to "
"actually happen, wake sources should be configured first."
msgstr ""

#: ../../../library/machine.rst:72
msgid ""
"Stops the CPU and all peripherals (including networking interfaces, if "
"any). Execution is resumed from the main script, just as with a reset. "
"The reset cause can be checked to know that we are coming from "
"`machine.DEEPSLEEP`. For wake up to actually happen, wake sources should "
"be configured first, like `Pin` change or `RTC` timeout."
msgstr ""

#: ../../../library/machine.rst:79
msgid ""
"Get the wake reason. See :ref:`constants <machine_constants>` for the "
"possible return values."
msgstr ""

#: ../../../library/machine.rst:81
msgid "Availability: ESP32, WiPy."
msgstr ""

#: ../../../library/machine.rst:84 ../../../library/pyb.rst:187
msgid "Miscellaneous functions"
msgstr ""

#: ../../../library/machine.rst:88
msgid ""
"Returns a byte string with a unique identifier of a board/SoC. It will "
"vary from a board/SoC instance to another, if underlying hardware allows."
" Length varies by hardware (so use substring of a full value if you "
"expect a short ID). In some MicroPython ports, ID corresponds to the "
"network MAC address."
msgstr ""

#: ../../../library/machine.rst:95
msgid ""
"Time a pulse on the given *pin*, and return the duration of the pulse in "
"microseconds.  The *pulse_level* argument should be 0 to time a low pulse"
" or 1 to time a high pulse."
msgstr ""

#: ../../../library/machine.rst:99
msgid ""
"If the current input value of the pin is different to *pulse_level*, the "
"function first (*) waits until the pin input becomes equal to "
"*pulse_level*, then (**) times the duration that the pin is equal to "
"*pulse_level*. If the pin is already equal to *pulse_level* then timing "
"starts straight away."
msgstr ""

#: ../../../library/machine.rst:104
msgid ""
"The function will return -2 if there was timeout waiting for condition "
"marked (*) above, and -1 if there was timeout during the main "
"measurement, marked (**) above. The timeout is the same for both cases "
"and given by *timeout_us* (which is in microseconds)."
msgstr ""

#: ../../../library/machine.rst:111
msgid "Return a 24-bit software generated random number."
msgstr ""

#: ../../../library/machine.I2C.rst:67 ../../../library/machine.Pin.rst:180
#: ../../../library/machine.UART.rst:143 ../../../library/machine.UART.rst:152
#: ../../../library/machine.rst:113
msgid "Availability: WiPy."
msgstr ""

#: ../../../library/machine.rst:124
msgid "IRQ wake values."
msgstr ""

#: ../../../library/machine.rst:132
msgid "Reset causes."
msgstr ""

#: ../../../library/machine.rst:138
msgid "Wake-up reasons."
msgstr ""

#: ../../../library/machine.ADC.rst:5 ../../../library/pyb.ADC.rst:5
msgid "class ADC -- analog to digital conversion"
msgstr ""

#: ../../../library/machine.ADC.rst:7 ../../../library/pyb.ADC.rst:7
#: ../../../library/pyb.Switch.rst:9
msgid "Usage::"
msgstr ""

#: ../../../library/machine.ADC.rst:9
msgid ""
"import machine\n"
"\n"
"adc = machine.ADC()             # create an ADC object\n"
"apin = adc.channel(pin='GP3')   # create an analog pin on GP3\n"
"val = apin()                    # read an analog value"
msgstr ""

#: ../../../library/machine.ADC.rst:20
msgid ""
"Create an ADC object associated with the given pin. This allows you to "
"then read analog values on that pin. For more info check the `pinout and "
"alternate functions table. "
"<https://raw.githubusercontent.com/wipy/wipy/master/docs/PinOUT.png>`_"
msgstr ""

#: ../../../library/machine.ADC.rst:27
msgid ""
"ADC pin input range is 0-1.4V (being 1.8V the absolute maximum that it "
"can withstand). When GP2, GP3, GP4 or GP5 are remapped to the ADC block, "
"1.8 V is the maximum. If these pins are used in digital mode, then the "
"maximum allowed input is 3.6V."
msgstr ""

#: ../../../library/machine.ADC.rst:37
msgid ""
"Create an analog pin. If only channel ID is given, the correct pin will "
"be selected. Alternatively, only the pin can be passed and the correct "
"channel will be selected. Examples::"
msgstr ""

#: ../../../library/machine.ADC.rst:41
msgid ""
"# all of these are equivalent and enable ADC channel 1 on GP3\n"
"apin = adc.channel(1)\n"
"apin = adc.channel(pin='GP3')\n"
"apin = adc.channel(id=1, pin='GP3')"
msgstr ""

#: ../../../library/machine.ADC.rst:48
msgid "Enable the ADC block."
msgstr ""

#: ../../../library/machine.ADC.rst:52
msgid "Disable the ADC block."
msgstr ""

#: ../../../library/machine.ADC.rst:55
msgid "class ADCChannel --- read analog values from internal or external sources"
msgstr ""

#: ../../../library/machine.ADC.rst:57
msgid ""
"ADC channels can be connected to internal points of the MCU or to GPIO "
"pins. ADC channels are created using the ADC.channel method."
msgstr ""

#: ../../../library/machine.ADC.rst:62
msgid "Fast method to read the channel value."
msgstr ""

#: ../../../library/machine.ADC.rst:66
msgid "Read the channel value."
msgstr ""

#: ../../../library/machine.ADC.rst:70
msgid "Re-init (and effectively enable) the ADC channel."
msgstr ""

#: ../../../library/machine.ADC.rst:74
msgid "Disable the ADC channel."
msgstr ""

#: ../../../library/machine.I2C.rst:5 ../../../library/pyb.I2C.rst:5
msgid "class I2C -- a two-wire serial protocol"
msgstr ""

#: ../../../library/machine.I2C.rst:7 ../../../library/pyb.I2C.rst:7
msgid ""
"I2C is a two-wire protocol for communicating between devices.  At the "
"physical level it consists of 2 wires: SCL and SDA, the clock and data "
"lines respectively."
msgstr ""

#: ../../../library/machine.I2C.rst:10 ../../../library/pyb.I2C.rst:10
msgid ""
"I2C objects are created attached to a specific bus.  They can be "
"initialised when created, or initialised later on."
msgstr ""

#: ../../../library/machine.I2C.rst:13
msgid "Printing the I2C object gives you information about its configuration."
msgstr ""

#: ../../../library/machine.I2C.rst:15 ../../../library/machine.RTC.rst:10
#: ../../../library/machine.SD.rst:20 ../../../library/machine.WDT.rst:12
#: ../../../library/network.WIZNET5K.rst:12 ../../../library/pyb.DAC.rst:12
#: ../../../library/pyb.RTC.rst:10 ../../../library/pyb.Servo.rst:12
msgid "Example usage::"
msgstr ""

#: ../../../library/machine.I2C.rst:17
msgid ""
"from machine import I2C\n"
"\n"
"i2c = I2C(freq=400000)          # create I2C peripheral at frequency of "
"400kHz\n"
"                                # depending on the port, extra parameters"
" may be required\n"
"                                # to select the peripheral and/or pins to"
" use\n"
"\n"
"i2c.scan()                      # scan for slaves, returning a list of "
"7-bit addresses\n"
"\n"
"i2c.writeto(42, b'123')         # write 3 bytes to slave with 7-bit "
"address 42\n"
"i2c.readfrom(42, 4)             # read 4 bytes from slave with 7-bit "
"address 42\n"
"\n"
"i2c.readfrom_mem(42, 8, 3)      # read 3 bytes from memory of slave 42,\n"
"                                #   starting at memory-address 8 in the "
"slave\n"
"i2c.writeto_mem(42, 2, b'\\x10') # write 1 byte to memory of slave 42\n"
"                                #   starting at address 2 in the slave"
msgstr ""

#: ../../../library/machine.I2C.rst:38
msgid "Construct and return a new I2C object using the following parameters:"
msgstr ""

#: ../../../library/machine.I2C.rst:40
msgid ""
"*id* identifies a particular I2C peripheral.  The default value of -1 "
"selects a software implementation of I2C which can work (in most cases) "
"with arbitrary pins for SCL and SDA. If *id* is -1 then *scl* and *sda* "
"must be specified.  Other allowed values for *id* depend on the "
"particular port/board, and specifying *scl* and *sda* may or may not be "
"required or allowed in this case."
msgstr ""

#: ../../../library/machine.I2C.rst:47
msgid "*scl* should be a pin object specifying the pin to use for SCL."
msgstr ""

#: ../../../library/machine.I2C.rst:48
msgid "*sda* should be a pin object specifying the pin to use for SDA."
msgstr ""

#: ../../../library/machine.I2C.rst:49
msgid "*freq* should be an integer which sets the maximum frequency for SCL."
msgstr ""

#: ../../../library/machine.I2C.rst:53
msgid "General Methods"
msgstr ""

#: ../../../library/machine.I2C.rst:57
msgid "Initialise the I2C bus with the given arguments:"
msgstr ""

#: ../../../library/machine.I2C.rst:59
msgid "*scl* is a pin object for the SCL line"
msgstr ""

#: ../../../library/machine.I2C.rst:60
msgid "*sda* is a pin object for the SDA line"
msgstr ""

#: ../../../library/machine.I2C.rst:61
msgid "*freq* is the SCL clock rate"
msgstr ""

#: ../../../library/machine.I2C.rst:65 ../../../library/pyb.I2C.rst:85
msgid "Turn off the I2C bus."
msgstr ""

#: ../../../library/machine.I2C.rst:71
msgid ""
"Scan all I2C addresses between 0x08 and 0x77 inclusive and return a list "
"of those that respond.  A device responds if it pulls the SDA line low "
"after its address (including a write bit) is sent on the bus."
msgstr ""

#: ../../../library/machine.I2C.rst:76
msgid "Primitive I2C operations"
msgstr ""

#: ../../../library/machine.I2C.rst:78
msgid ""
"The following methods implement the primitive I2C master bus operations "
"and can be combined to make any I2C transaction.  They are provided if "
"you need more control over the bus, otherwise the standard methods (see "
"below) can be used."
msgstr ""

#: ../../../library/machine.I2C.rst:82
msgid "These methods are available on software I2C only."
msgstr ""

#: ../../../library/machine.I2C.rst:86
msgid ""
"Generate a START condition on the bus (SDA transitions to low while SCL "
"is high)."
msgstr ""

#: ../../../library/machine.I2C.rst:90
msgid ""
"Generate a STOP condition on the bus (SDA transitions to high while SCL "
"is high)."
msgstr ""

#: ../../../library/machine.I2C.rst:94
msgid ""
"Reads bytes from the bus and stores them into *buf*.  The number of bytes"
" read is the length of *buf*.  An ACK will be sent on the bus after "
"receiving all but the last byte.  After the last byte is received, if "
"*nack* is true then a NACK will be sent, otherwise an ACK will be sent "
"(and in this case the slave assumes more bytes are going to be read in a "
"later call)."
msgstr ""

#: ../../../library/machine.I2C.rst:102
msgid ""
"Write the bytes from *buf* to the bus.  Checks that an ACK is received "
"after each byte and stops transmitting the remaining bytes if a NACK is "
"received.  The function returns the number of ACKs that were received."
msgstr ""

#: ../../../library/machine.I2C.rst:107
msgid "Standard bus operations"
msgstr ""

#: ../../../library/machine.I2C.rst:109
msgid ""
"The following methods implement the standard I2C master read and write "
"operations that target a given slave device."
msgstr ""

#: ../../../library/machine.I2C.rst:114
msgid ""
"Read *nbytes* from the slave specified by *addr*. If *stop* is true then "
"a STOP condition is generated at the end of the transfer. Returns a "
"`bytes` object with the data read."
msgstr ""

#: ../../../library/machine.I2C.rst:120
msgid ""
"Read into *buf* from the slave specified by *addr*. The number of bytes "
"read will be the length of *buf*. If *stop* is true then a STOP condition"
" is generated at the end of the transfer."
msgstr ""

#: ../../../library/machine.I2C.rst:124 ../../../library/machine.I2C.rst:157
#: ../../../library/machine.I2C.rst:166
msgid "The method returns ``None``."
msgstr ""

#: ../../../library/machine.I2C.rst:128
msgid ""
"Write the bytes from *buf* to the slave specified by *addr*.  If a NACK "
"is received following the write of a byte from *buf* then the remaining "
"bytes are not sent.  If *stop* is true then a STOP condition is generated"
" at the end of the transfer, even if a NACK is received. The function "
"returns the number of ACKs that were received."
msgstr ""

#: ../../../library/machine.I2C.rst:135
msgid "Memory operations"
msgstr ""

#: ../../../library/machine.I2C.rst:137
msgid ""
"Some I2C devices act as a memory device (or set of registers) that can be"
" read from and written to.  In this case there are two addresses "
"associated with an I2C transaction: the slave address and the memory "
"address.  The following methods are convenience functions to communicate "
"with such devices."
msgstr ""

#: ../../../library/machine.I2C.rst:144
msgid ""
"Read *nbytes* from the slave specified by *addr* starting from the memory"
" address specified by *memaddr*. The argument *addrsize* specifies the "
"address size in bits. Returns a `bytes` object with the data read."
msgstr ""

#: ../../../library/machine.I2C.rst:151
msgid ""
"Read into *buf* from the slave specified by *addr* starting from the "
"memory address specified by *memaddr*.  The number of bytes read is the "
"length of *buf*. The argument *addrsize* specifies the address size in "
"bits (on ESP8266 this argument is not recognised and the address size is "
"always 8 bits)."
msgstr ""

#: ../../../library/machine.I2C.rst:161
msgid ""
"Write *buf* to the slave specified by *addr* starting from the memory "
"address specified by *memaddr*. The argument *addrsize* specifies the "
"address size in bits (on ESP8266 this argument is not recognised and the "
"address size is always 8 bits)."
msgstr ""

#: ../../../library/machine.Pin.rst:5 ../../../library/pyb.Pin.rst:5
msgid "class Pin -- control I/O pins"
msgstr ""

#: ../../../library/machine.Pin.rst:7
msgid ""
"A pin object is used to control I/O pins (also known as GPIO - general-"
"purpose input/output).  Pin objects are commonly associated with a "
"physical pin that can drive an output voltage and read input voltages.  "
"The pin class has methods to set the mode of the pin (IN, OUT, etc) and "
"methods to get and set the digital logic level. For analog control of a "
"pin, see the :class:`ADC` class."
msgstr ""

#: ../../../library/machine.Pin.rst:13
msgid ""
"A pin object is constructed by using an identifier which unambiguously "
"specifies a certain I/O pin.  The allowed forms of the identifier and the"
" physical pin that the identifier maps to are port-specific.  "
"Possibilities for the identifier are an integer, a string or a tuple with"
" port and pin number."
msgstr ""

#: ../../../library/machine.Pin.rst:19 ../../../library/pyb.Pin.rst:226
msgid "Usage Model::"
msgstr ""

#: ../../../library/machine.Pin.rst:21
msgid ""
"from machine import Pin\n"
"\n"
"# create an output pin on pin #0\n"
"p0 = Pin(0, Pin.OUT)\n"
"\n"
"# set the value low then high\n"
"p0.value(0)\n"
"p0.value(1)\n"
"\n"
"# create an input pin on pin #2, with a pull up resistor\n"
"p2 = Pin(2, Pin.IN, Pin.PULL_UP)\n"
"\n"
"# read and print the pin value\n"
"print(p2.value())\n"
"\n"
"# reconfigure pin #0 in input mode\n"
"p0.mode(p0.IN)\n"
"\n"
"# configure an irq callback\n"
"p0.irq(lambda p:print(p))"
msgstr ""

#: ../../../library/machine.Pin.rst:47
msgid ""
"Access the pin peripheral (GPIO pin) associated with the given ``id``.  "
"If additional arguments are given in the constructor then they are used "
"to initialise the pin.  Any settings that are not specified will remain "
"in their previous state."
msgstr ""

#: ../../../library/machine.Pin.rst:51 ../../../library/machine.Pin.rst:191
#: ../../../library/machine.Signal.rst:88
msgid "The arguments are:"
msgstr ""

#: ../../../library/machine.Pin.rst:53
msgid ""
"``id`` is mandatory and can be an arbitrary object.  Among possible value"
" types are: int (an internal Pin identifier), str (a Pin name), and tuple"
" (pair of [port, pin])."
msgstr ""

#: ../../../library/machine.Pin.rst:57
msgid "``mode`` specifies the pin mode, which can be one of:"
msgstr ""

#: ../../../library/machine.Pin.rst:59
msgid ""
"``Pin.IN`` - Pin is configured for input.  If viewed as an output the pin"
" is in high-impedance state."
msgstr ""

#: ../../../library/machine.Pin.rst:62
msgid "``Pin.OUT`` - Pin is configured for (normal) output."
msgstr ""

#: ../../../library/machine.Pin.rst:64
msgid ""
"``Pin.OPEN_DRAIN`` - Pin is configured for open-drain output. Open-drain "
"output works in the following way: if the output value is set to 0 the "
"pin is active at a low level; if the output value is 1 the pin is in a "
"high-impedance state.  Not all ports implement this mode, or some might "
"only on certain pins."
msgstr ""

#: ../../../library/machine.Pin.rst:69
msgid ""
"``Pin.ALT`` - Pin is configured to perform an alternative function, which"
" is port specific.  For a pin configured in such a way any other Pin "
"methods (except :meth:`Pin.init`) are not applicable (calling them will "
"lead to undefined, or a hardware-specific, result).  Not all ports "
"implement this mode."
msgstr ""

#: ../../../library/machine.Pin.rst:74
msgid ""
"``Pin.ALT_OPEN_DRAIN`` - The Same as ``Pin.ALT``, but the pin is "
"configured as open-drain.  Not all ports implement this mode."
msgstr ""

#: ../../../library/machine.Pin.rst:77
msgid ""
"``pull`` specifies if the pin has a (weak) pull resistor attached, and "
"can be one of:"
msgstr ""

#: ../../../library/machine.Pin.rst:80
msgid "``None`` - No pull up or down resistor."
msgstr ""

#: ../../../library/machine.Pin.rst:81
msgid "``Pin.PULL_UP`` - Pull up resistor enabled."
msgstr ""

#: ../../../library/machine.Pin.rst:82
msgid "``Pin.PULL_DOWN`` - Pull down resistor enabled."
msgstr ""

#: ../../../library/machine.Pin.rst:84
msgid ""
"``value`` is valid only for Pin.OUT and Pin.OPEN_DRAIN modes and "
"specifies initial output pin value if given, otherwise the state of the "
"pin peripheral remains unchanged."
msgstr ""

#: ../../../library/machine.Pin.rst:88
msgid ""
"``drive`` specifies the output power of the pin and can be one of: "
"``Pin.LOW_POWER``, ``Pin.MED_POWER`` or ``Pin.HIGH_POWER``.  The actual "
"current driving capabilities are port dependent.  Not all ports implement"
" this argument."
msgstr ""

#: ../../../library/machine.Pin.rst:92
msgid ""
"``alt`` specifies an alternate function for the pin and the values it can"
" take are port dependent.  This argument is valid only for ``Pin.ALT`` "
"and ``Pin.ALT_OPEN_DRAIN`` modes.  It may be used when a pin supports "
"more than one alternate function.  If only one pin alternate function is "
"supported the this argument is not required.  Not all ports implement "
"this argument."
msgstr ""

#: ../../../library/machine.Pin.rst:98
msgid ""
"As specified above, the Pin class allows to set an alternate function for"
" a particular pin, but it does not specify any further operations on such"
" a pin.  Pins configured in alternate-function mode are usually not used "
"as GPIO but are instead driven by other hardware peripherals.  The only "
"operation supported on such a pin is re-initialising, by calling the "
"constructor or :meth:`Pin.init` method.  If a pin that is configured in "
"alternate-function mode is re-initialised with ``Pin.IN``, ``Pin.OUT``, "
"or ``Pin.OPEN_DRAIN``, the alternate function will be removed from the "
"pin."
msgstr ""

#: ../../../library/machine.Pin.rst:111
msgid ""
"Re-initialise the pin using the given parameters.  Only those arguments "
"that are specified will be set.  The rest of the pin peripheral state "
"will remain unchanged.  See the constructor documentation for details of "
"the arguments."
msgstr ""

#: ../../../library/machine.Pin.rst:115
msgid "Returns ``None``."
msgstr ""

#: ../../../library/machine.Pin.rst:119
msgid ""
"This method allows to set and get the value of the pin, depending on "
"whether the argument ``x`` is supplied or not."
msgstr ""

#: ../../../library/machine.Pin.rst:122
msgid ""
"If the argument is omitted then this method gets the digital logic level "
"of the pin, returning 0 or 1 corresponding to low and high voltage "
"signals respectively.  The behaviour of this method depends on the mode "
"of the pin:"
msgstr ""

#: ../../../library/machine.Pin.rst:126
msgid ""
"``Pin.IN`` - The method returns the actual input value currently present "
"on the pin."
msgstr ""

#: ../../../library/machine.Pin.rst:128
msgid "``Pin.OUT`` - The behaviour and return value of the method is undefined."
msgstr ""

#: ../../../library/machine.Pin.rst:129
msgid ""
"``Pin.OPEN_DRAIN`` - If the pin is in state '0' then the behaviour and "
"return value of the method is undefined.  Otherwise, if the pin is in "
"state '1', the method returns the actual input value currently present on"
" the pin."
msgstr ""

#: ../../../library/machine.Pin.rst:134
msgid ""
"If the argument is supplied then this method sets the digital logic level"
" of the pin.  The argument ``x`` can be anything that converts to a "
"boolean. If it converts to ``True``, the pin is set to state '1', "
"otherwise it is set to state '0'.  The behaviour of this method depends "
"on the mode of the pin:"
msgstr ""

#: ../../../library/machine.Pin.rst:139
msgid ""
"``Pin.IN`` - The value is stored in the output buffer for the pin.  The "
"pin state does not change, it remains in the high-impedance state.  The "
"stored value will become active on the pin as soon as it is changed to "
"``Pin.OUT`` or ``Pin.OPEN_DRAIN`` mode."
msgstr ""

#: ../../../library/machine.Pin.rst:143
msgid "``Pin.OUT`` - The output buffer is set to the given value immediately."
msgstr ""

#: ../../../library/machine.Pin.rst:144
msgid ""
"``Pin.OPEN_DRAIN`` - If the value is '0' the pin is set to a low voltage "
"state.  Otherwise the pin is set to high-impedance state."
msgstr ""

#: ../../../library/machine.Pin.rst:147
msgid "When setting the value this method returns ``None``."
msgstr ""

#: ../../../library/machine.Pin.rst:151
msgid ""
"Pin objects are callable.  The call method provides a (fast) shortcut to "
"set and get the value of the pin.  It is equivalent to Pin.value([x]). "
"See :meth:`Pin.value` for more details."
msgstr ""

#: ../../../library/machine.Pin.rst:157
msgid "Set pin to \"1\" output level."
msgstr ""

#: ../../../library/machine.Pin.rst:161
msgid "Set pin to \"0\" output level."
msgstr ""

#: ../../../library/machine.Pin.rst:165
msgid ""
"Get or set the pin mode. See the constructor documentation for details of"
" the ``mode`` argument."
msgstr ""

#: ../../../library/machine.Pin.rst:170
msgid ""
"Get or set the pin pull state. See the constructor documentation for "
"details of the ``pull`` argument."
msgstr ""

#: ../../../library/machine.Pin.rst:175
msgid ""
"Get or set the pin drive strength. See the constructor documentation for "
"details of the ``drive`` argument."
msgstr ""

#: ../../../library/machine.Pin.rst:178
msgid "Not all ports implement this method."
msgstr ""

#: ../../../library/machine.Pin.rst:184
msgid ""
"Configure an interrupt handler to be called when the trigger source of "
"the pin is active.  If the pin mode is ``Pin.IN`` then the trigger source"
" is the external value on the pin.  If the pin mode is ``Pin.OUT`` then "
"the trigger source is the output buffer of the pin.  Otherwise, if the "
"pin mode is ``Pin.OPEN_DRAIN`` then the trigger source is the output "
"buffer for state '0' and the external pin value for state '1'."
msgstr ""

#: ../../../library/machine.Pin.rst:193
msgid ""
"``handler`` is an optional function to be called when the interrupt "
"triggers. The handler must take exactly one argument which is the ``Pin``"
" instance."
msgstr ""

#: ../../../library/machine.Pin.rst:197
msgid ""
"``trigger`` configures the event which can generate an interrupt. "
"Possible values are:"
msgstr ""

#: ../../../library/machine.Pin.rst:200
msgid "``Pin.IRQ_FALLING`` interrupt on falling edge."
msgstr ""

#: ../../../library/machine.Pin.rst:201
msgid "``Pin.IRQ_RISING`` interrupt on rising edge."
msgstr ""

#: ../../../library/machine.Pin.rst:202
msgid "``Pin.IRQ_LOW_LEVEL`` interrupt on low level."
msgstr ""

#: ../../../library/machine.Pin.rst:203
msgid "``Pin.IRQ_HIGH_LEVEL`` interrupt on high level."
msgstr ""

#: ../../../library/machine.Pin.rst:205
msgid "These values can be OR'ed together to trigger on multiple events."
msgstr ""

#: ../../../library/machine.Pin.rst:207
msgid ""
"``priority`` sets the priority level of the interrupt.  The values it can"
" take are port-specific, but higher values always represent higher "
"priorities."
msgstr ""

#: ../../../library/machine.Pin.rst:211
msgid ""
"``wake`` selects the power mode in which this interrupt can wake up the "
"system.  It can be ``machine.IDLE``, ``machine.SLEEP`` or "
"``machine.DEEPSLEEP``. These values can also be OR'ed together to make a "
"pin generate interrupts in more than one power mode."
msgstr ""

#: ../../../library/machine.Pin.rst:216
msgid ""
"``hard`` if true a hardware interrupt is used. This reduces the delay "
"between the pin change and the handler being called. Hard interrupt "
"handlers may not allocate memory; see :ref:`isr_rules`."
msgstr ""

#: ../../../library/machine.Pin.rst:220
msgid "This method returns a callback object."
msgstr ""

#: ../../../library/machine.Pin.rst:225
msgid ""
"The following constants are used to configure the pin objects.  Note that"
" not all constants are available on all ports."
msgstr ""

#: ../../../library/machine.Pin.rst:234
msgid "Selects the pin mode."
msgstr ""

#: ../../../library/machine.Pin.rst:239
msgid ""
"Selects whether there is a pull up/down resistor.  Use the value ``None``"
" for no pull."
msgstr ""

#: ../../../library/machine.Pin.rst:246
msgid "Selects the pin drive strength."
msgstr ""

#: ../../../library/machine.Pin.rst:253
msgid "Selects the IRQ trigger type."
msgstr ""

#: ../../../library/machine.RTC.rst:5 ../../../library/pyb.RTC.rst:5
msgid "class RTC -- real time clock"
msgstr ""

#: ../../../library/machine.RTC.rst:7 ../../../library/pyb.RTC.rst:7
msgid "The RTC is and independent clock that keeps track of the date and time."
msgstr ""

#: ../../../library/machine.RTC.rst:12
msgid ""
"rtc = machine.RTC()\n"
"rtc.init((2014, 5, 1, 4, 13, 0, 0, 0))\n"
"print(rtc.now())"
msgstr ""

#: ../../../library/machine.RTC.rst:22
msgid "Create an RTC object. See init for parameters of initialization."
msgstr ""

#: ../../../library/machine.RTC.rst:29
msgid "Initialise the RTC. Datetime is a tuple of the form:"
msgstr ""

#: ../../../library/machine.RTC.rst:31
msgid ""
"``(year, month, day[, hour[, minute[, second[, microsecond[, "
"tzinfo]]]]])``"
msgstr ""

#: ../../../library/machine.RTC.rst:35
msgid "Get get the current datetime tuple."
msgstr ""

#: ../../../library/machine.RTC.rst:39
msgid "Resets the RTC to the time of January 1, 2015 and starts running it again."
msgstr ""

#: ../../../library/machine.RTC.rst:43
msgid ""
"Set the RTC alarm. Time might be either a millisecond value to program "
"the alarm to current time + time_in_ms in the future, or a datetimetuple."
" If the time passed is in milliseconds, repeat can be set to ``True`` to "
"make the alarm periodic."
msgstr ""

#: ../../../library/machine.RTC.rst:49
msgid "Get the number of milliseconds left before the alarm expires."
msgstr ""

#: ../../../library/machine.RTC.rst:53
msgid "Cancel a running alarm."
msgstr ""

#: ../../../library/machine.RTC.rst:57
msgid "Create an irq object triggered by a real time clock alarm."
msgstr ""

#: ../../../library/machine.RTC.rst:59
msgid "``trigger`` must be ``RTC.ALARM0``"
msgstr ""

#: ../../../library/machine.RTC.rst:60
msgid "``handler`` is the function to be called when the callback is triggered."
msgstr ""

#: ../../../library/machine.RTC.rst:61
msgid ""
"``wake`` specifies the sleep mode from where this interrupt can wake up "
"the system."
msgstr ""

#: ../../../library/machine.RTC.rst:69
msgid "irq trigger source"
msgstr ""

#: ../../../library/machine.SD.rst:5
msgid "class SD -- secure digital memory card"
msgstr ""

#: ../../../library/machine.SD.rst:9
msgid "This is a non-standard class and is only available on the cc3200 port."
msgstr ""

#: ../../../library/machine.SD.rst:12
msgid ""
"The SD card class allows to configure and enable the memory card module "
"of the WiPy and automatically mount it as ``/sd`` as part of the file "
"system. There are several pin combinations that can be used to wire the "
"SD card socket to the WiPy and the pins used can be specified in the "
"constructor. Please check the `pinout and alternate functions table. "
"<https://raw.githubusercontent.com/wipy/wipy/master/docs/PinOUT.png>`_ "
"for more info regarding the pins which can be remapped to be used with a "
"SD card."
msgstr ""

#: ../../../library/machine.SD.rst:22
msgid ""
"from machine import SD\n"
"import os\n"
"# clk cmd and dat0 pins must be passed along with\n"
"# their respective alternate functions\n"
"sd = machine.SD(pins=('GP10', 'GP11', 'GP15'))\n"
"os.mount(sd, '/sd')\n"
"# do normal file operations"
msgstr ""

#: ../../../library/machine.SD.rst:35
msgid "Create a SD card object. See ``init()`` for parameters if initialization."
msgstr ""

#: ../../../library/machine.SD.rst:42
msgid ""
"Enable the SD card. In order to initialize the card, give it a 3-tuple: "
"``(clk_pin, cmd_pin, dat0_pin)``."
msgstr ""

#: ../../../library/machine.SD.rst:47
msgid "Disable the SD card."
msgstr ""

#: ../../../library/machine.SPI.rst:5
msgid "class SPI -- a Serial Peripheral Interface bus protocol (master side)"
msgstr ""

#: ../../../library/machine.SPI.rst:7
msgid ""
"SPI is a synchronous serial protocol that is driven by a master. At the "
"physical level, a bus consists of 3 lines: SCK, MOSI, MISO. Multiple "
"devices can share the same bus. Each device should have a separate, 4th "
"signal, SS (Slave Select), to select a particular device on a bus with "
"which communication takes place. Management of an SS signal should happen"
" in user code (via machine.Pin class)."
msgstr ""

#: ../../../library/machine.SPI.rst:19
msgid ""
"Construct an SPI object on the given bus, ``id``. Values of ``id`` depend"
" on a particular port and its hardware. Values 0, 1, etc. are commonly "
"used to select hardware SPI block #0, #1, etc. Value -1 can be used for "
"bitbanging (software) implementation of SPI (if supported by a port)."
msgstr ""

#: ../../../library/machine.SPI.rst:24
msgid ""
"With no additional parameters, the SPI object is created but not "
"initialised (it has the settings from the last initialisation of the bus,"
" if any).  If extra arguments are given, the bus is initialised. See "
"``init`` for parameters of initialisation."
msgstr ""

#: ../../../library/machine.SPI.rst:34 ../../../library/pyb.SPI.rst:56
msgid "Initialise the SPI bus with the given parameters:"
msgstr ""

#: ../../../library/machine.SPI.rst:36
msgid "``baudrate`` is the SCK clock rate."
msgstr ""

#: ../../../library/machine.SPI.rst:37 ../../../library/pyb.SPI.rst:62
msgid "``polarity`` can be 0 or 1, and is the level the idle clock line sits at."
msgstr ""

#: ../../../library/machine.SPI.rst:38 ../../../library/pyb.SPI.rst:63
msgid ""
"``phase`` can be 0 or 1 to sample data on the first or second clock edge "
"respectively."
msgstr ""

#: ../../../library/machine.SPI.rst:40
msgid ""
"``bits`` is the width in bits of each transfer. Only 8 is guaranteed to "
"be supported by all hardware."
msgstr ""

#: ../../../library/machine.SPI.rst:41 ../../../library/pyb.SPI.rst:66
msgid "``firstbit`` can be ``SPI.MSB`` or ``SPI.LSB``."
msgstr ""

#: ../../../library/machine.SPI.rst:42
msgid ""
"``sck``, ``mosi``, ``miso`` are pins (machine.Pin) objects to use for bus"
" signals. For most hardware SPI blocks (as selected by ``id`` parameter "
"to the constructor), pins are fixed and cannot be changed. In some cases,"
" hardware blocks allow 2-3 alternative pin sets for a hardware SPI block."
" Arbitrary pin assignments are possible only for a bitbanging SPI driver "
"(``id`` = -1)."
msgstr ""

#: ../../../library/machine.SPI.rst:47
msgid ""
"``pins`` - WiPy port doesn't ``sck``, ``mosi``, ``miso`` arguments, and "
"instead allows to specify them as a tuple of ``pins`` parameter."
msgstr ""

#: ../../../library/machine.SPI.rst:50
msgid ""
"In the case of hardware SPI the actual clock frequency may be lower than "
"the requested baudrate. This is dependant on the platform hardware. The "
"actual rate may be determined by printing the SPI object."
msgstr ""

#: ../../../library/machine.SPI.rst:56 ../../../library/pyb.SPI.rst:52
msgid "Turn off the SPI bus."
msgstr ""

#: ../../../library/machine.SPI.rst:60
msgid ""
"Read a number of bytes specified by ``nbytes`` while continuously writing"
" the single byte given by ``write``. Returns a ``bytes`` object with the "
"data that was read."
msgstr ""

#: ../../../library/machine.SPI.rst:66
msgid ""
"Read into the buffer specified by ``buf`` while continuously writing the "
"single byte given by ``write``. Returns ``None``."
msgstr ""

#: ../../../library/machine.SPI.rst:70
msgid "Note: on WiPy this function returns the number of bytes read."
msgstr ""

#: ../../../library/machine.SPI.rst:74
msgid "Write the bytes contained in ``buf``. Returns ``None``."
msgstr ""

#: ../../../library/machine.SPI.rst:77 ../../../library/machine.SPI.rst:86
msgid "Note: on WiPy this function returns the number of bytes written."
msgstr ""

#: ../../../library/machine.SPI.rst:81
msgid ""
"Write the bytes from ``write_buf`` while reading into ``read_buf``.  The "
"buffers can be the same or different, but both buffers must have the same"
" length. Returns ``None``."
msgstr ""

#: ../../../library/machine.SPI.rst:93
msgid "for initialising the SPI bus to master; this is only used for the WiPy"
msgstr ""

#: ../../../library/machine.SPI.rst:97
msgid "set the first bit to be the most significant bit"
msgstr ""

#: ../../../library/machine.SPI.rst:101
msgid "set the first bit to be the least significant bit"
msgstr ""

#: ../../../library/machine.Signal.rst:5
msgid "class Signal -- control and sense external I/O devices"
msgstr ""

#: ../../../library/machine.Signal.rst:7
msgid ""
"The Signal class is a simple extension of the `Pin` class. Unlike Pin, "
"which can be only in \"absolute\" 0 and 1 states, a Signal can be in "
"\"asserted\" (on) or \"deasserted\" (off) states, while being inverted "
"(active-low) or not. In other words, it adds logical inversion support to"
" Pin functionality. While this may seem a simple addition, it is exactly "
"what is needed to support wide array of simple digital devices in a way "
"portable across different boards, which is one of the major MicroPython "
"goals. Regardless of whether different users have an active-high or "
"active-low LED, a normally open or normally closed relay - you can "
"develop a single, nicely looking application which works with each of "
"them, and capture hardware configuration differences in few lines in the "
"config file of your app."
msgstr ""

#: ../../../library/machine.Signal.rst:21
msgid ""
"from machine import Pin, Signal\n"
"\n"
"# Suppose you have an active-high LED on pin 0\n"
"led1_pin = Pin(0, Pin.OUT)\n"
"# ... and active-low LED on pin 1\n"
"led2_pin = Pin(1, Pin.OUT)\n"
"\n"
"# Now to light up both of them using Pin class, you'll need to set\n"
"# them to different values\n"
"led1_pin.value(1)\n"
"led2_pin.value(0)\n"
"\n"
"# Signal class allows to abstract away active-high/active-low\n"
"# difference\n"
"led1 = Signal(led1_pin, invert=False)\n"
"led2 = Signal(led2_pin, invert=True)\n"
"\n"
"# Now lighting up them looks the same\n"
"led1.value(1)\n"
"led2.value(1)\n"
"\n"
"# Even better:\n"
"led1.on()\n"
"led2.on()"
msgstr ""

#: ../../../library/machine.Signal.rst:46
msgid "Following is the guide when Signal vs Pin should be used:"
msgstr ""

#: ../../../library/machine.Signal.rst:48
msgid ""
"Use Signal: If you want to control a simple on/off (including software "
"PWM!) devices like LEDs, multi-segment indicators, relays, buzzers, or "
"read simple binary sensors, like normally open or normally closed "
"buttons, pulled high or low, Reed switches, moisture/flame detectors, "
"etc. etc. Summing up, if you have a real physical device/sensor requiring"
" GPIO access, you likely should use a Signal."
msgstr ""

#: ../../../library/machine.Signal.rst:55
msgid ""
"Use Pin: If you implement a higher-level protocol or bus to communicate "
"with more complex devices."
msgstr ""

#: ../../../library/machine.Signal.rst:58
msgid ""
"The split between Pin and Signal come from the usecases above and the "
"architecture of MicroPython: Pin offers the lowest overhead, which may be"
" important when bit-banging protocols. But Signal adds additional "
"flexibility on top of Pin, at the cost of minor overhead (much smaller "
"than if you implemented active-high vs active-low device differences in "
"Python manually!). Also, Pin is a low-level object which needs to be "
"implemented for each support board, while Signal is a high-level object "
"which comes for free once Pin is implemented."
msgstr ""

#: ../../../library/machine.Signal.rst:67
msgid ""
"If in doubt, give the Signal a try! Once again, it is offered to save "
"developers from the need to handle unexciting differences like active-low"
" vs active-high signals, and allow other users to share and enjoy your "
"application, instead of being frustrated by the fact that it doesn't work"
" for them simply because their LEDs or relays are wired in a slightly "
"different way."
msgstr ""

#: ../../../library/machine.Signal.rst:80
msgid "Create a Signal object. There're two ways to create it:"
msgstr ""

#: ../../../library/machine.Signal.rst:82
msgid ""
"By wrapping existing Pin object - universal method which works for any "
"board."
msgstr ""

#: ../../../library/machine.Signal.rst:84
msgid ""
"By passing required Pin parameters directly to Signal constructor, "
"skipping the need to create intermediate Pin object. Available on many, "
"but not all boards."
msgstr ""

#: ../../../library/machine.Signal.rst:90
msgid "``pin_obj`` is existing Pin object."
msgstr ""

#: ../../../library/machine.Signal.rst:92
msgid ""
"``pin_arguments`` are the same arguments as can be passed to Pin "
"constructor."
msgstr ""

#: ../../../library/machine.Signal.rst:94
msgid "``invert`` - if True, the signal will be inverted (active low)."
msgstr ""

#: ../../../library/machine.Signal.rst:101
msgid ""
"This method allows to set and get the value of the signal, depending on "
"whether the argument ``x`` is supplied or not."
msgstr ""

#: ../../../library/machine.Signal.rst:104
msgid ""
"If the argument is omitted then this method gets the signal level, 1 "
"meaning signal is asserted (active) and 0 - signal inactive."
msgstr ""

#: ../../../library/machine.Signal.rst:107
msgid ""
"If the argument is supplied then this method sets the signal level. The "
"argument ``x`` can be anything that converts to a boolean. If it converts"
" to ``True``, the signal is active, otherwise it is inactive."
msgstr ""

#: ../../../library/machine.Signal.rst:111
msgid ""
"Correspondence between signal being active and actual logic level on the "
"underlying pin depends on whether signal is inverted (active-low) or not."
" For non-inverted signal, active status corresponds to logical 1, "
"inactive - to logical 0. For inverted/active-low signal, active status "
"corresponds to logical 0, while inactive - to logical 1."
msgstr ""

#: ../../../library/machine.Signal.rst:119
msgid "Activate signal."
msgstr ""

#: ../../../library/machine.Signal.rst:123
msgid "Deactivate signal."
msgstr ""

#: ../../../library/machine.Timer.rst:5
msgid "class Timer -- control hardware timers"
msgstr ""

#: ../../../library/machine.Timer.rst:7
#: ../../../library/machine.TimerWiPy.rst:14
msgid ""
"Hardware timers deal with timing of periods and events. Timers are "
"perhaps the most flexible and heterogeneous kind of hardware in MCUs and "
"SoCs, differently greatly from a model to a model. MicroPython's Timer "
"class defines a baseline operation of executing a callback with a given "
"period (or once after some delay), and allow specific boards to define "
"more non-standard behavior (which thus won't be portable to other "
"boards)."
msgstr ""

#: ../../../library/machine.Timer.rst:14
#: ../../../library/machine.TimerWiPy.rst:21
msgid ""
"See discussion of :ref:`important constraints <machine_callbacks>` on "
"Timer callbacks."
msgstr ""

#: ../../../library/machine.Timer.rst:19
#: ../../../library/machine.TimerWiPy.rst:26
msgid ""
"Memory can't be allocated inside irq handlers (an interrupt) and so "
"exceptions raised within a handler don't give much information.  See "
":func:`micropython.alloc_emergency_exception_buf` for how to get around "
"this limitation."
msgstr ""

#: ../../../library/machine.Timer.rst:24
msgid ""
"If you are using a WiPy board please refer to :ref:`machine.TimerWiPy "
"<machine.TimerWiPy>` instead of this class."
msgstr ""

#: ../../../library/machine.Timer.rst:32
#: ../../../library/machine.TimerWiPy.rst:36
msgid ""
"Construct a new timer object of the given id. Id of -1 constructs a "
"virtual timer (if supported by a board)."
msgstr ""

#: ../../../library/machine.Timer.rst:40
#: ../../../library/machine.TimerWiPy.rst:44
msgid "Initialise the timer. Example::"
msgstr ""

#: ../../../library/machine.Timer.rst:42
msgid ""
"tim.init(period=100)                         # periodic with 100ms period"
"\n"
"tim.init(mode=Timer.ONE_SHOT, period=1000)   # one shot firing after "
"1000ms"
msgstr ""

#: ../../../library/machine.Timer.rst:45
#: ../../../library/machine.TimerWiPy.rst:49 ../../../library/pyb.Timer.rst:73
#: ../../../library/pyb.Timer.rst:138
msgid "Keyword arguments:"
msgstr ""

#: ../../../library/machine.Timer.rst:47
#: ../../../library/machine.TimerWiPy.rst:51 ../../../library/pyb.Pin.rst:105
#: ../../../library/pyb.Timer.rst:90 ../../../library/pyb.Timer.rst:140
msgid "``mode`` can be one of:"
msgstr ""

#: ../../../library/machine.Timer.rst:49
msgid ""
"``Timer.ONE_SHOT`` - The timer runs once until the configured period of "
"the channel expires."
msgstr ""

#: ../../../library/machine.Timer.rst:51
msgid ""
"``Timer.PERIODIC`` - The timer runs periodically at the configured "
"frequency of the channel."
msgstr ""

#: ../../../library/machine.Timer.rst:56
#: ../../../library/machine.TimerWiPy.rst:65
msgid ""
"Deinitialises the timer. Stops the timer, and disables the timer "
"peripheral."
msgstr ""

#: ../../../library/machine.Timer.rst:64
#: ../../../library/machine.TimerWiPy.rst:159
msgid "Timer operating mode."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:5
msgid "class TimerWiPy -- control hardware timers"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:9
msgid ""
"This class is a non-standard Timer implementation for the WiPy. It is "
"available simply as ``machine.Timer`` on the WiPy but is named in the "
"documentation below as ``machine.TimerWiPy`` to distinguish it from the "
"more general :ref:`machine.Timer <machine.Timer>` class."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:46
msgid ""
"tim.init(Timer.PERIODIC)             # periodic 16-bit timer\n"
"tim.init(Timer.ONE_SHOT, width=32)   # one shot 32-bit timer"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:53
msgid ""
"``TimerWiPy.ONE_SHOT`` - The timer runs once until the configured period "
"of the channel expires."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:55
msgid ""
"``TimerWiPy.PERIODIC`` - The timer runs periodically at the configured "
"frequency of the channel."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:57
msgid "``TimerWiPy.PWM``      - Output a PWM signal on a pin."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:59
msgid ""
"``width`` must be either 16 or 32 (bits). For really low frequencies < "
"5Hz (or large periods), 32-bit timers should be used. 32-bit mode is only"
" available for ``ONE_SHOT`` AND ``PERIODIC`` modes."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:69
msgid ""
"If only a channel identifier passed, then a previously initialized "
"channel object is returned (or ``None`` if there is no previous channel)."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:72 ../../../library/pyb.Timer.rst:132
msgid "Otherwise, a TimerChannel object is initialized and returned."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:74
msgid ""
"The operating mode is is the one configured to the Timer object that was "
"used to create the channel."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:77
msgid ""
"``channel`` if the width of the timer is 16-bit, then must be either "
"``TIMER.A``, ``TIMER.B``. If the width is 32-bit then it **must be** "
"``TIMER.A | TIMER.B``."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:80
msgid "Keyword only arguments:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:82
msgid "``freq`` sets the frequency in Hz."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:83
msgid "``period`` sets the period in microseconds."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:87
msgid "Either ``freq`` or ``period`` must be given, never both."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:89
msgid ""
"``polarity`` this is applicable for ``PWM``, and defines the polarity of "
"the duty cycle"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:90
msgid ""
"``duty_cycle`` only applicable to ``PWM``. It's a percentage "
"(0.00-100.00). Since the WiPy doesn't support floating point numbers the "
"duty cycle must be specified in the range 0-10000, where 10000 would "
"represent 100.00, 5050 represents 50.50, and so on."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:96
msgid ""
"When the channel is in PWM mode, the corresponding pin is assigned "
"automatically, therefore there's no need to assign the alternate function"
" of the pin via the ``Pin`` class. The pins which support PWM "
"functionality are the following:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:100
msgid "``GP24`` on Timer 0 channel A."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:101
msgid "``GP25`` on Timer 1 channel A."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:102
msgid "``GP9``  on Timer 2 channel B."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:103
msgid "``GP10`` on Timer 3 channel A."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:104
msgid "``GP11`` on Timer 3 channel B."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:107
#: ../../../library/pyb.Timer.rst:222
msgid "class TimerChannel --- setup a channel for a timer"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:109
#: ../../../library/pyb.Timer.rst:224
msgid "Timer channels are used to generate/capture a signal using a timer."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:111
#: ../../../library/pyb.Timer.rst:226
msgid "TimerChannel objects are created using the Timer.channel() method."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:118
msgid ""
"The behavior of this callback is heavily dependent on the operating mode "
"of the timer channel:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:121
msgid ""
"If mode is ``TimerWiPy.PERIODIC`` the callback is executed periodically "
"with the configured frequency or period."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:123
msgid ""
"If mode is ``TimerWiPy.ONE_SHOT`` the callback is executed once when the "
"configured timer expires."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:125
msgid ""
"If mode is ``TimerWiPy.PWM`` the callback is executed when reaching the "
"duty cycle value."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:128
msgid "The accepted params are:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:130
msgid ""
"``priority`` level of the interrupt. Can take values in the range 1-7. "
"Higher values represent higher priorities."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:132
msgid ""
"``handler`` is an optional function to be called when the interrupt is "
"triggered."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:133
msgid ""
"``trigger`` must be ``TimerWiPy.TIMEOUT`` when the operating mode is "
"either ``TimerWiPy.PERIODIC`` or ``TimerWiPy.ONE_SHOT``. In the case that"
" mode is ``TimerWiPy.PWM`` then trigger must be equal to "
"``TimerWiPy.MATCH``."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:137
msgid "Returns a callback object."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:141
msgid "Get or set the timer channel frequency (in Hz)."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:145
msgid "Get or set the timer channel period (in microseconds)."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:149
msgid ""
"Get or set the duty cycle of the PWM signal. It's a percentage "
"(0.00-100.00). Since the WiPy doesn't support floating point numbers the "
"duty cycle must be specified in the range 0-10000, where 10000 would "
"represent 100.00, 5050 represents 50.50, and so on."
msgstr ""

#: ../../../library/machine.UART.rst:5 ../../../library/pyb.UART.rst:5
msgid "class UART -- duplex serial communication bus"
msgstr ""

#: ../../../library/machine.UART.rst:7 ../../../library/pyb.UART.rst:7
msgid ""
"UART implements the standard UART/USART duplex serial communications "
"protocol.  At the physical level it consists of 2 lines: RX and TX.  The "
"unit of communication is a character (not to be confused with a string "
"character) which can be 8 or 9 bits wide."
msgstr ""

#: ../../../library/machine.UART.rst:12 ../../../library/pyb.UART.rst:12
msgid "UART objects can be created and initialised using::"
msgstr ""

#: ../../../library/machine.UART.rst:14
msgid ""
"from machine import UART\n"
"\n"
"uart = UART(1, 9600)                         # init with given baudrate\n"
"uart.init(9600, bits=8, parity=None, stop=1) # init with given parameters"
msgstr ""

#: ../../../library/machine.UART.rst:19
msgid "Supported parameters differ on a board:"
msgstr ""

#: ../../../library/machine.UART.rst:21
msgid ""
"Pyboard: Bits can be 7, 8 or 9. Stop can be 1 or 2. With *parity=None*, "
"only 8 and 9 bits are supported.  With parity enabled, only 7 and 8 bits "
"are supported."
msgstr ""

#: ../../../library/machine.UART.rst:25
msgid "WiPy/CC3200: Bits can be 5, 6, 7, 8. Stop can be 1 or 2."
msgstr ""

#: ../../../library/machine.UART.rst:27 ../../../library/pyb.UART.rst:24
msgid ""
"A UART object acts like a `stream` object and reading and writing is done"
" using the standard stream methods::"
msgstr ""

#: ../../../library/machine.UART.rst:30 ../../../library/pyb.UART.rst:27
msgid ""
"uart.read(10)       # read 10 characters, returns a bytes object\n"
"uart.read()         # read all available characters\n"
"uart.readline()     # read a line\n"
"uart.readinto(buf)  # read and store into the given buffer\n"
"uart.write('abc')   # write the 3 characters"
msgstr ""

#: ../../../library/machine.UART.rst:41
msgid "Construct a UART object of the given id."
msgstr ""

#: ../../../library/machine.UART.rst:48 ../../../library/pyb.UART.rst:74
msgid "Initialise the UART bus with the given parameters:"
msgstr ""

#: ../../../library/machine.UART.rst:50
msgid "*baudrate* is the clock rate."
msgstr ""

#: ../../../library/machine.UART.rst:51
msgid "*bits* is the number of bits per character, 7, 8 or 9."
msgstr ""

#: ../../../library/machine.UART.rst:52
msgid "*parity* is the parity, ``None``, 0 (even) or 1 (odd)."
msgstr ""

#: ../../../library/machine.UART.rst:53
msgid "*stop* is the number of stop bits, 1 or 2."
msgstr ""

#: ../../../library/machine.UART.rst:55
msgid "Additional keyword-only parameters that may be supported by a port are:"
msgstr ""

#: ../../../library/machine.UART.rst:57
msgid "*tx* specifies the TX pin to use."
msgstr ""

#: ../../../library/machine.UART.rst:58
msgid "*rx* specifies the RX pin to use."
msgstr ""

#: ../../../library/machine.UART.rst:59
msgid "*txbuf* specifies the length in characters of the TX buffer."
msgstr ""

#: ../../../library/machine.UART.rst:60
msgid "*rxbuf* specifies the length in characters of the RX buffer."
msgstr ""

#: ../../../library/machine.UART.rst:62
msgid "On the WiPy only the following keyword-only parameter is supported:"
msgstr ""

#: ../../../library/machine.UART.rst:64
msgid ""
"*pins* is a 4 or 2 item list indicating the TX, RX, RTS and CTS pins (in "
"that order). Any of the pins can be None if one wants the UART to operate"
" with limited functionality. If the RTS pin is given the the RX pin must "
"be given as well. The same applies to CTS. When no pins are given, then "
"the default set of TX and RX pins is taken, and hardware flow control "
"will be disabled. If *pins* is ``None``, no pin assignment will be made."
msgstr ""

#: ../../../library/machine.UART.rst:72 ../../../library/pyb.UART.rst:98
msgid "Turn off the UART bus."
msgstr ""

#: ../../../library/machine.UART.rst:76
msgid ""
"Returns an integer counting the number of characters that can be read "
"without blocking.  It will return 0 if there are no characters available "
"and a positive number if there are characters.  The method may return 1 "
"even if there is more than one character available for reading."
msgstr ""

#: ../../../library/machine.UART.rst:81
msgid "For more sophisticated querying of available characters use select.poll::"
msgstr ""

#: ../../../library/machine.UART.rst:83
msgid ""
"poll = select.poll()\n"
"poll.register(uart, select.POLLIN)\n"
"poll.poll(timeout)"
msgstr ""

#: ../../../library/machine.UART.rst:89
msgid ""
"Read characters.  If ``nbytes`` is specified then read at most that many "
"bytes, otherwise read as much data as possible."
msgstr ""

#: ../../../library/machine.UART.rst:92 ../../../library/pyb.UART.rst:116
msgid ""
"Return value: a bytes object containing the bytes read in.  Returns "
"``None`` on timeout."
msgstr ""

#: ../../../library/machine.UART.rst:97 ../../../library/pyb.UART.rst:127
msgid ""
"Read bytes into the ``buf``.  If ``nbytes`` is specified then read at "
"most that many bytes.  Otherwise, read at most ``len(buf)`` bytes."
msgstr ""

#: ../../../library/machine.UART.rst:100 ../../../library/pyb.UART.rst:130
msgid ""
"Return value: number of bytes read and stored into ``buf`` or ``None`` on"
" timeout."
msgstr ""

#: ../../../library/machine.UART.rst:105 ../../../library/usocket.rst:332
msgid "Read a line, ending in a newline character."
msgstr ""

#: ../../../library/machine.UART.rst:107
msgid "Return value: the line read or ``None`` on timeout."
msgstr ""

#: ../../../library/machine.UART.rst:111
msgid "Write the buffer of bytes to the bus."
msgstr ""

#: ../../../library/machine.UART.rst:113
msgid "Return value: number of bytes written or ``None`` on timeout."
msgstr ""

#: ../../../library/machine.UART.rst:117
msgid ""
"Send a break condition on the bus. This drives the bus low for a duration"
" longer than required for a normal transmission of a character."
msgstr ""

#: ../../../library/machine.UART.rst:122
msgid "Create a callback to be triggered when data is received on the UART."
msgstr ""

#: ../../../library/machine.UART.rst:124
msgid "*trigger* can only be ``UART.RX_ANY``"
msgstr ""

#: ../../../library/machine.UART.rst:125
msgid ""
"*priority* level of the interrupt. Can take values in the range 1-7. "
"Higher values represent higher priorities."
msgstr ""

#: ../../../library/machine.UART.rst:127
msgid "*handler* an optional function to be called when new characters arrive."
msgstr ""

#: ../../../library/machine.UART.rst:128
msgid "*wake* can only be ``machine.IDLE``."
msgstr ""

#: ../../../library/machine.UART.rst:132
msgid ""
"The handler will be called whenever any of the following two conditions "
"are met:"
msgstr ""

#: ../../../library/machine.UART.rst:134
msgid "8 new characters have been received."
msgstr ""

#: ../../../library/machine.UART.rst:135
msgid ""
"At least 1 new character is waiting in the Rx buffer and the Rx line has "
"been silent for the duration of 1 complete frame."
msgstr ""

#: ../../../library/machine.UART.rst:138
msgid ""
"This means that when the handler function is called there will be between"
" 1 to 8 characters waiting."
msgstr ""

#: ../../../library/machine.UART.rst:141
msgid "Returns an irq object."
msgstr ""

#: ../../../library/machine.UART.rst:150
msgid "IRQ trigger sources"
msgstr ""

#: ../../../library/machine.WDT.rst:5
msgid "class WDT -- watchdog timer"
msgstr ""

#: ../../../library/machine.WDT.rst:7
msgid ""
"The WDT is used to restart the system when the application crashes and "
"ends up into a non recoverable state. Once started it cannot be stopped "
"or reconfigured in any way. After enabling, the application must \"feed\""
" the watchdog periodically to prevent it from expiring and resetting the "
"system."
msgstr ""

#: ../../../library/machine.WDT.rst:14
msgid ""
"from machine import WDT\n"
"wdt = WDT(timeout=2000)  # enable it with a timeout of 2s\n"
"wdt.feed()"
msgstr ""

#: ../../../library/machine.WDT.rst:18
msgid "Availability of this class: pyboard, WiPy."
msgstr ""

#: ../../../library/machine.WDT.rst:25
msgid ""
"Create a WDT object and start it. The timeout must be given in seconds "
"and the minimum value that is accepted is 1 second. Once it is running "
"the timeout cannot be changed and the WDT cannot be stopped either."
msgstr ""

#: ../../../library/machine.WDT.rst:34
msgid ""
"Feed the WDT to prevent it from resetting the system. The application "
"should place this call in a sensible place ensuring that the WDT is only "
"fed after verifying that everything is functioning correctly."
msgstr ""

#: ../../../library/math.rst:2
msgid ":mod:`math` -- mathematical functions"
msgstr ":mod:`math` -- 数学関数"

#: ../../../library/math.rst:7
msgid "|see_cpython_module| :mod:`python:math`."
msgstr ""

#: ../../../library/math.rst:9
msgid ""
"The ``math`` module provides some basic mathematical functions for "
"working with floating-point numbers."
msgstr ""
"``math`` モジュールは浮動小数点数を扱うための基本的な数学関数を提供します。"

#: ../../../library/math.rst:12
msgid "*Note:* On the pyboard, floating-point numbers have 32-bit precision."
msgstr "*注記:* pyboard では、浮動小数点は 32 ビット精度(単精度)です。"

#: ../../../library/math.rst:14
msgid ""
"Availability: not available on WiPy. Floating point support required for "
"this module."
msgstr ""
"可用性: WiPy では利用できません。このモジュールには浮動小数点数の"
"サポートが必要です。"

#: ../../../library/math.rst:22
msgid "Return the inverse cosine of ``x``."
msgstr "``x`` の逆余弦を返します。"

#: ../../../library/math.rst:26
msgid "Return the inverse hyperbolic cosine of ``x``."
msgstr "``x`` の双曲線逆余弦を返します。"

#: ../../../library/math.rst:30
msgid "Return the inverse sine of ``x``."
msgstr "``x`` の逆正弦を返します。"

#: ../../../library/math.rst:34
msgid "Return the inverse hyperbolic sine of ``x``."
msgstr "``x`` の双曲線逆正弦を返します。"

#: ../../../library/math.rst:38
msgid "Return the inverse tangent of ``x``."
msgstr "``x`` の逆正接を返します。"

#: ../../../library/math.rst:42
msgid "Return the principal value of the inverse tangent of ``y/x``."
msgstr "``y/x`` の逆正接の主値を返します。"

#: ../../../library/math.rst:46
msgid "Return the inverse hyperbolic tangent of ``x``."
msgstr "``x`` の双曲線逆正接を返します。"

#: ../../../library/math.rst:50
msgid "Return an integer, being ``x`` rounded towards positive infinity."
msgstr "``x`` の正の無限大方法に丸めた整数値を返します。"

#: ../../../library/math.rst:54
msgid "Return ``x`` with the sign of ``y``."
msgstr "``x`` を ``y`` の符号で返します。"

#: ../../../library/math.rst:58
msgid "Return the cosine of ``x``."
msgstr "``x`` の余弦を返します。"

#: ../../../library/math.rst:62
msgid "Return the hyperbolic cosine of ``x``."
msgstr "``x`` の双曲線余弦を返します。"

#: ../../../library/math.rst:66
msgid "Return radians ``x`` converted to degrees."
msgstr "ラジアン ``x`` を度に変換して返します。"

#: ../../../library/math.rst:70
msgid "Return the error function of ``x``."
msgstr "``x`` の誤差関数を返します。"

#: ../../../library/math.rst:74
msgid "Return the complementary error function of ``x``."
msgstr "``x`` の相補誤差関数を返します。"

#: ../../../library/math.rst:78
msgid "Return the exponential of ``x``."
msgstr "``x`` の指数を返します。"

#: ../../../library/math.rst:82
msgid "Return ``exp(x) - 1``."
msgstr "``exp(x) - 1`` を返します。"

#: ../../../library/math.rst:86
msgid "Return the absolute value of ``x``."
msgstr "``x`` の絶対値を返します。"

#: ../../../library/math.rst:90
msgid "Return an integer, being ``x`` rounded towards negative infinity."
msgstr "``x`` の負の無限大方向に丸めた整数を返します。"

#: ../../../library/math.rst:94
msgid "Return the remainder of ``x/y``."
msgstr "``x/y`` の剰余を返します。"

#: ../../../library/math.rst:98
msgid ""
"Decomposes a floating-point number into its mantissa and exponent. The "
"returned value is the tuple ``(m, e)`` such that ``x == m * 2**e`` "
"exactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise"
" the relation ``0.5 <= abs(m) < 1`` holds."
msgstr ""
"浮動小数点数を仮数部と指数部に分解します。返される値は ``x == m * 2**e`` "
"となる ``(m, e)`` のタプルです。 ``x == 0`` の場合、関数は ``(0.0, 0)`` "
"を返します。さもなければ ``0.5 <= abs(m) < 1`` の関係が成り立ちます。"

#: ../../../library/math.rst:105
msgid "Return the gamma function of ``x``."
msgstr "``x`` のガンマ関数を返します。"

#: ../../../library/math.rst:109
msgid "Return ``True`` if ``x`` is finite."
msgstr "``x`` が有限数であれば ``True`` を返します。"

#: ../../../library/math.rst:113
msgid "Return ``True`` if ``x`` is infinite."
msgstr "``x`` が無限数であれば ``True`` を返します。"

#: ../../../library/math.rst:117
msgid "Return ``True`` if ``x`` is not-a-number"
msgstr "``x`` が非数(NaN: Not-a-Number)であれば ``True`` を返します。"

#: ../../../library/math.rst:121
msgid "Return ``x * (2**exp)``."
msgstr "``x * (2**exp)`` を返します。"

#: ../../../library/math.rst:125
msgid "Return the natural logarithm of the gamma function of ``x``."
msgstr "``x`` のガンマ関数の自然対数を返します。"

#: ../../../library/math.rst:129
msgid "Return the natural logarithm of ``x``."
msgstr "``x`` の自然対数を返します。"

#: ../../../library/math.rst:133
msgid "Return the base-10 logarithm of ``x``."
msgstr "``x`` の常用対数を返します。"

#: ../../../library/math.rst:137
msgid "Return the base-2 logarithm of ``x``."
msgstr "``x`` の２進対数を返します。"

#: ../../../library/math.rst:141
msgid ""
"Return a tuple of two floats, being the fractional and integral parts of "
"``x``.  Both return values have the same sign as ``x``."
msgstr ""
"``x`` の小数部分と整数部分の２つの浮動小数点数のタプルを返します。"
"両方の戻り値は ``x`` と同じ符号を持ちます。"

#: ../../../library/math.rst:146
msgid "Returns ``x`` to the power of ``y``."
msgstr "``x`` の ``y`` 乗を返します。"

#: ../../../library/math.rst:150
msgid "Return degrees ``x`` converted to radians."
msgstr "度 ``x`` をラジアンに変換して返します。"

#: ../../../library/math.rst:154
msgid "Return the sine of ``x``."
msgstr "``x`` の正弦を返します。"

#: ../../../library/math.rst:158
msgid "Return the hyperbolic sine of ``x``."
msgstr "``x`` の双曲線正弦を返します。"

#: ../../../library/math.rst:162
msgid "Return the square root of ``x``."
msgstr "``x`` の平方根を返します。"

#: ../../../library/math.rst:166
msgid "Return the tangent of ``x``."
msgstr "``x`` の正接を返します。"

#: ../../../library/math.rst:170
msgid "Return the hyperbolic tangent of ``x``."
msgstr "``x`` の双曲線正接を返します。"

#: ../../../library/math.rst:174
msgid "Return an integer, being ``x`` rounded towards 0."
msgstr "``x`` の 0 方向に丸めた整数を返します。"

#: ../../../library/micropython.rst:2
msgid ":mod:`micropython` -- access and control MicroPython internals"
msgstr ""

#: ../../../library/micropython.rst:12
msgid ""
"Used to declare that the expression is a constant so that the compile can"
" optimise it.  The use of this function should be as follows::"
msgstr ""

#: ../../../library/micropython.rst:15
msgid ""
"from micropython import const\n"
"\n"
"CONST_X = const(123)\n"
"CONST_Y = const(2 * CONST_X + 1)"
msgstr ""

#: ../../../library/micropython.rst:20
msgid ""
"Constants declared this way are still accessible as global variables from"
" outside the module they are declared in.  On the other hand, if a "
"constant begins with an underscore then it is hidden, it is not available"
" as a global variable, and does not take up any memory during execution."
msgstr ""

#: ../../../library/micropython.rst:25
msgid ""
"This `const` function is recognised directly by the MicroPython parser "
"and is provided as part of the :mod:`micropython` module mainly so that "
"scripts can be written which run under both CPython and MicroPython, by "
"following the above pattern."
msgstr ""

#: ../../../library/micropython.rst:32
msgid ""
"If *level* is given then this function sets the optimisation level for "
"subsequent compilation of scripts, and returns ``None``.  Otherwise it "
"returns the current optimisation level."
msgstr ""

#: ../../../library/micropython.rst:36
msgid "The optimisation level controls the following compilation features:"
msgstr ""

#: ../../../library/micropython.rst:38
msgid ""
"Assertions: at level 0 assertion statements are enabled and compiled into"
" the bytecode; at levels 1 and higher assertions are not compiled."
msgstr ""

#: ../../../library/micropython.rst:40
msgid ""
"Built-in ``__debug__`` variable: at level 0 this variable expands to "
"``True``; at levels 1 and higher it expands to ``False``."
msgstr ""

#: ../../../library/micropython.rst:42
msgid ""
"Source-code line numbers: at levels 0, 1 and 2 source-code line number "
"are stored along with the bytecode so that exceptions can report the line"
" number they occurred at; at levels 3 and higher line numbers are not "
"stored."
msgstr ""

#: ../../../library/micropython.rst:46
msgid "The default optimisation level is usually level 0."
msgstr ""

#: ../../../library/micropython.rst:50
msgid ""
"Allocate *size* bytes of RAM for the emergency exception buffer (a good "
"size is around 100 bytes).  The buffer is used to create exceptions in "
"cases when normal RAM allocation would fail (eg within an interrupt "
"handler) and therefore give useful traceback information in these "
"situations."
msgstr ""

#: ../../../library/micropython.rst:55
msgid ""
"A good way to use this function is to put it at the start of your main "
"script (eg ``boot.py`` or ``main.py``) and then the emergency exception "
"buffer will be active for all the code following it."
msgstr ""

#: ../../../library/micropython.rst:61
msgid ""
"Print information about currently used memory.  If the *verbose* argument"
" is given then extra information is printed."
msgstr ""

#: ../../../library/micropython.rst:64
msgid ""
"The information that is printed is implementation dependent, but "
"currently includes the amount of stack and heap used.  In verbose mode it"
" prints out the entire heap indicating which blocks are used and which "
"are free."
msgstr ""

#: ../../../library/micropython.rst:70
msgid ""
"Print information about currently interned strings.  If the *verbose* "
"argument is given then extra information is printed."
msgstr ""

#: ../../../library/micropython.rst:73
msgid ""
"The information that is printed is implementation dependent, but "
"currently includes the number of interned strings and the amount of RAM "
"they use.  In verbose mode it prints out the names of all RAM-interned "
"strings."
msgstr ""

#: ../../../library/micropython.rst:79
msgid ""
"Return an integer representing the current amount of stack that is being "
"used.  The absolute value of this is not particularly useful, rather it "
"should be used to compute differences in stack usage at different points."
msgstr ""

#: ../../../library/micropython.rst:86
msgid ""
"Lock or unlock the heap.  When locked no memory allocation can occur and "
"a `MemoryError` will be raised if any heap allocation is attempted."
msgstr ""

#: ../../../library/micropython.rst:89
msgid ""
"These functions can be nested, ie `heap_lock()` can be called multiple "
"times in a row and the lock-depth will increase, and then `heap_unlock()`"
" must be called the same number of times to make the heap available "
"again."
msgstr ""

#: ../../../library/micropython.rst:93
msgid ""
"If the REPL becomes active with the heap locked then it will be "
"forcefully unlocked."
msgstr ""

#: ../../../library/micropython.rst:98
msgid ""
"Set the character that will raise a `KeyboardInterrupt` exception.  By "
"default this is set to 3 during script execution, corresponding to "
"Ctrl-C. Passing -1 to this function will disable capture of Ctrl-C, and "
"passing 3 will restore it."
msgstr ""

#: ../../../library/micropython.rst:103
msgid ""
"This function can be used to prevent the capturing of Ctrl-C on the "
"incoming stream of characters that is usually used for the REPL, in case "
"that stream is used for other purposes."
msgstr ""

#: ../../../library/micropython.rst:109
msgid ""
"Schedule the function *func* to be executed \"very soon\".  The function "
"is passed the value *arg* as its single argument.  \"Very soon\" means "
"that the MicroPython runtime will do its best to execute the function at "
"the earliest possible time, given that it is also trying to be efficient,"
" and that the following conditions hold:"
msgstr ""

#: ../../../library/micropython.rst:115
msgid "A scheduled function will never preempt another scheduled function."
msgstr ""

#: ../../../library/micropython.rst:116
msgid ""
"Scheduled functions are always executed \"between opcodes\" which means "
"that all fundamental Python operations (such as appending to a list) are "
"guaranteed to be atomic."
msgstr ""

#: ../../../library/micropython.rst:119
msgid ""
"A given port may define \"critical regions\" within which scheduled "
"functions will never be executed.  Functions may be scheduled within a "
"critical region but they will not be executed until that region is "
"exited.  An example of a critical region is a preempting interrupt "
"handler (an IRQ)."
msgstr ""

#: ../../../library/micropython.rst:125
msgid ""
"A use for this function is to schedule a callback from a preempting IRQ. "
"Such an IRQ puts restrictions on the code that runs in the IRQ (for "
"example the heap may be locked) and scheduling a function to call later "
"will lift those restrictions."
msgstr ""

#: ../../../library/micropython.rst:130
msgid ""
"Note: If `schedule()` is called from a preempting IRQ, when memory "
"allocation is not allowed and the callback to be passed to `schedule()` "
"is a bound method, passing this directly will fail. This is because "
"creating a reference to a bound method causes memory allocation. A "
"solution is to create a reference to the method in the class constructor "
"and to pass that reference to `schedule()`. This is discussed in detail "
"here :ref:`reference documentation <isr_rules>` under \"Creation of "
"Python objects\"."
msgstr ""

#: ../../../library/micropython.rst:139
msgid ""
"There is a finite stack to hold the scheduled functions and `schedule()` "
"will raise a `RuntimeError` if the stack is full."
msgstr ""

#: ../../../library/network.rst:3
msgid ":mod:`network` --- network configuration"
msgstr ""

#: ../../../library/network.rst:8
msgid ""
"This module provides network drivers and routing configuration. To use "
"this module, a MicroPython variant/build with network capabilities must "
"be installed. Network drivers for specific hardware are available within "
"this module and are used to configure hardware network interface(s). "
"Network services provided by configured interfaces are then available for"
" use via the :mod:`usocket` module."
msgstr ""

#: ../../../library/network.rst:17
msgid ""
"# connect/ show IP config a specific network interface\n"
"# see below for examples of specific drivers\n"
"import network\n"
"import utime\n"
"nic = network.Driver(...)\n"
"if not nic.isconnected():\n"
"    nic.connect()\n"
"    print(\"Waiting for connection...\")\n"
"    while not nic.isconnected():\n"
"        utime.sleep(1)\n"
"print(nic.ifconfig())\n"
"\n"
"# now use usocket as usual\n"
"import usocket as socket\n"
"addr = socket.getaddrinfo('micropython.org', 80)[0][-1]\n"
"s = socket.socket()\n"
"s.connect(addr)\n"
"s.send(b'GET / HTTP/1.1\\r\\nHost: micropython.org\\r\\n\\r\\n')\n"
"data = s.recv(1000)\n"
"s.close()"
msgstr ""

#: ../../../library/network.rst:39
msgid "Common network adapter interface"
msgstr ""

#: ../../../library/network.rst:41
msgid ""
"This section describes an (implied) abstract base class for all network "
"interface classes implemented by `MicroPython ports <MicroPython port>` "
"for different hardware. This means that MicroPython does not actually "
"provide ``AbstractNIC`` class, but any actual NIC class, as described in "
"the following sections, implements methods as described here."
msgstr ""

#: ../../../library/network.rst:49
msgid ""
"Instantiate a network interface object. Parameters are network interface "
"dependent. If there are more than one interface of the same type, the "
"first parameter should be `id`."
msgstr ""

#: ../../../library/network.rst:55
msgid ""
"Activate (\"up\") or deactivate (\"down\") the network interface, if a "
"boolean argument is passed. Otherwise, query current state if no argument"
" is provided. Most other methods require an active interface (behavior of"
" calling them on inactive interface is undefined)."
msgstr ""

#: ../../../library/network.rst:63
msgid ""
"Connect the interface to a network. This method is optional, and "
"available only for interfaces which are not \"always connected\". If no "
"parameters are given, connect to the default (or the only) service. If a "
"single parameter is given, it is the primary identifier of a service to "
"connect to. It may be accompanied by a key (password) required to access "
"said service. There can be further arbitrary keyword-only parameters, "
"depending on the networking medium type and/or particular device. "
"Parameters can be used to: a) specify alternative service identifer "
"types; b) provide additional connection parameters. For various medium "
"types, there are different sets of predefined/recommended parameters, "
"among them:"
msgstr ""

#: ../../../library/network.rst:75
msgid "WiFi: *bssid* keyword to connect to a specific BSSID (MAC address)"
msgstr ""

#: ../../../library/network.rst:79
msgid "Disconnect from network."
msgstr ""

#: ../../../library/network.rst:83
msgid "Returns ``True`` if connected to network, otherwise returns ``False``."
msgstr ""

#: ../../../library/network.rst:87
msgid ""
"Scan for the available network services/connections. Returns a list of "
"tuples with discovered service parameters. For various network media, "
"there are different variants of predefined/ recommended tuple formats, "
"among them:"
msgstr ""

#: ../../../library/network.rst:92
msgid ""
"WiFi: (ssid, bssid, channel, RSSI, authmode, hidden). There may be "
"further fields, specific to a particular device."
msgstr ""

#: ../../../library/network.rst:95
msgid ""
"The function may accept additional keyword arguments to filter scan "
"results (e.g. scan for a particular service, on a particular channel, for"
" services of a particular set, etc.), and to affect scan duration and "
"other parameters. Where possible, parameter names should match those in "
"connect()."
msgstr ""

#: ../../../library/network.rst:103
msgid ""
"Query dynamic status information of the interface.  When called with no "
"argument the return value describes the network link status.  Otherwise "
"*param* should be a string naming the particular status parameter to "
"retrieve."
msgstr ""

#: ../../../library/network.rst:108
msgid ""
"The return types and values are dependent on the network "
"medium/technology.  Some of the parameters that may be supported are:"
msgstr ""

#: ../../../library/network.rst:111
msgid "WiFi STA: use ``'rssi'`` to retrieve the RSSI of the AP signal"
msgstr ""

#: ../../../library/network.rst:112
msgid ""
"WiFi AP: use ``'stations'`` to retrieve a list of all the STAs connected "
"to the AP.  The list contains tuples of the form (MAC, RSSI)."
msgstr ""

#: ../../../library/network.WLAN.rst:96 ../../../library/network.rst:118
msgid ""
"Get/set IP-level network interface parameters: IP address, subnet mask, "
"gateway and DNS server. When called with no arguments, this method "
"returns a 4-tuple with the above information. To set the above values, "
"pass a 4-tuple with the required information.  For example::"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:67
#: ../../../library/network.WLAN.rst:101 ../../../library/network.rst:123
msgid "nic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))"
msgstr ""

#: ../../../library/network.rst:128
msgid ""
"Get or set general network interface parameters. These methods allow to "
"work with additional parameters beyond standard IP configuration (as "
"dealt with by `ifconfig()`). These include network-specific and hardware-"
"specific parameters. For setting parameters, the keyword argument syntax "
"should be used, and multiple parameters can be set at once. For querying,"
" a parameter name should be quoted as a string, and only one parameter "
"can be queried at a time::"
msgstr ""

#: ../../../library/network.WLAN.rst:113 ../../../library/network.rst:136
msgid ""
"# Set WiFi access point name (formally known as ESSID) and WiFi channel\n"
"ap.config(essid='My AP', channel=11)\n"
"# Query params one by one\n"
"print(ap.config('essid'))\n"
"print(ap.config('channel'))"
msgstr ""

#: ../../../library/network.rst:143
msgid "Specific network class implementations"
msgstr ""

#: ../../../library/network.rst:145
msgid ""
"The following concrete classes implement the AbstractNIC interface and "
"provide a way to control networking interfaces of various kinds."
msgstr ""

#: ../../../library/network.rst:157
msgid "Network functions"
msgstr ""

#: ../../../library/network.rst:159
msgid "The following are functions available in the network module."
msgstr ""

#: ../../../library/network.rst:163
msgid "Get or set the PHY mode."
msgstr ""

#: ../../../library/network.rst:165
msgid ""
"If the *mode* parameter is provided, sets the mode to its value. If the "
"function is called without parameters, returns the current mode."
msgstr ""

#: ../../../library/network.rst:171
msgid "The possible modes are defined as constants:"
msgstr ""

#: ../../../library/network.rst:169
msgid "``MODE_11B`` -- IEEE 802.11b,"
msgstr ""

#: ../../../library/network.rst:170
msgid "``MODE_11G`` -- IEEE 802.11g,"
msgstr ""

#: ../../../library/network.rst:171
msgid "``MODE_11N`` -- IEEE 802.11n."
msgstr ""

#: ../../../library/network.rst:173
msgid "Availability: ESP8266."
msgstr ""

#: ../../../library/network.CC3K.rst:5
msgid "class CC3K -- control CC3000 WiFi modules"
msgstr ""

#: ../../../library/network.CC3K.rst:7
msgid "This class provides a driver for CC3000 WiFi modules.  Example usage::"
msgstr ""

#: ../../../library/network.CC3K.rst:9
msgid ""
"import network\n"
"nic = network.CC3K(pyb.SPI(2), pyb.Pin.board.Y5, pyb.Pin.board.Y4, "
"pyb.Pin.board.Y3)\n"
"nic.connect('your-ssid', 'your-password')\n"
"while not nic.isconnected():\n"
"    pyb.delay(50)\n"
"print(nic.ifconfig())\n"
"\n"
"# now use socket as usual\n"
"..."
msgstr ""

#: ../../../library/network.CC3K.rst:19
msgid ""
"For this example to work the CC3000 module must have the following "
"connections:"
msgstr ""

#: ../../../library/network.CC3K.rst:21
msgid "MOSI connected to Y8"
msgstr ""

#: ../../../library/network.CC3K.rst:22
msgid "MISO connected to Y7"
msgstr ""

#: ../../../library/network.CC3K.rst:23
msgid "CLK connected to Y6"
msgstr ""

#: ../../../library/network.CC3K.rst:24
msgid "CS connected to Y5"
msgstr ""

#: ../../../library/network.CC3K.rst:25
msgid "VBEN connected to Y4"
msgstr ""

#: ../../../library/network.CC3K.rst:26
msgid "IRQ connected to Y3"
msgstr ""

#: ../../../library/network.CC3K.rst:28
msgid ""
"It is possible to use other SPI busses and other pins for CS, VBEN and "
"IRQ."
msgstr ""

#: ../../../library/network.CC3K.rst:35
msgid ""
"Create a CC3K driver object, initialise the CC3000 module using the given"
" SPI bus and pins, and return the CC3K object."
msgstr ""

#: ../../../library/network.CC3K.rst:38
#: ../../../library/network.WIZNET5K.rst:39
#: ../../../library/network.WLANWiPy.rst:50
msgid "Arguments are:"
msgstr ""

#: ../../../library/network.CC3K.rst:40
msgid ""
"*spi* is an :ref:`SPI object <pyb.SPI>` which is the SPI bus that the "
"CC3000 is connected to (the MOSI, MISO and CLK pins)."
msgstr ""

#: ../../../library/network.CC3K.rst:42
msgid ""
"*pin_cs* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"CC3000 CS pin."
msgstr ""

#: ../../../library/network.CC3K.rst:43
msgid ""
"*pin_en* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"CC3000 VBEN pin."
msgstr ""

#: ../../../library/network.CC3K.rst:44
msgid ""
"*pin_irq* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"CC3000 IRQ pin."
msgstr ""

#: ../../../library/network.CC3K.rst:46
#: ../../../library/network.WIZNET5K.rst:46
msgid ""
"All of these objects will be initialised by the driver, so there is no "
"need to initialise them yourself.  For example, you can use::"
msgstr ""

#: ../../../library/network.CC3K.rst:49
msgid ""
"nic = network.CC3K(pyb.SPI(2), pyb.Pin.board.Y5, pyb.Pin.board.Y4, "
"pyb.Pin.board.Y3)"
msgstr ""

#: ../../../library/network.CC3K.rst:56
#: ../../../library/network.WLANWiPy.rst:74
msgid ""
"Connect to a WiFi access point using the given SSID, and other security "
"parameters."
msgstr ""

#: ../../../library/network.CC3K.rst:61
#: ../../../library/network.WLANWiPy.rst:92
msgid "Disconnect from the WiFi access point."
msgstr ""

#: ../../../library/network.CC3K.rst:65
msgid ""
"Returns True if connected to a WiFi access point and has a valid IP "
"address, False otherwise."
msgstr ""

#: ../../../library/network.CC3K.rst:70
msgid ""
"Returns a 7-tuple with (ip, subnet mask, gateway, DNS server, DHCP "
"server, MAC address, SSID)."
msgstr ""

#: ../../../library/network.CC3K.rst:75
msgid "Return the version of the patch program (firmware) on the CC3000."
msgstr ""

#: ../../../library/network.CC3K.rst:79
msgid ""
"Upload the current firmware to the CC3000.  You must pass 'pgm' as the "
"first argument in order for the upload to proceed."
msgstr ""

#: ../../../library/network.CC3K.rst:89
msgid "security type to use"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:5
msgid "class WIZNET5K -- control WIZnet5x00 Ethernet modules"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:7
msgid ""
"This class allows you to control WIZnet5x00 Ethernet adaptors based on "
"the W5200 and W5500 chipsets.  The particular chipset that is supported "
"by the firmware is selected at compile-time via the MICROPY_PY_WIZNET5K "
"option."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:14
msgid ""
"import network\n"
"nic = network.WIZNET5K(pyb.SPI(1), pyb.Pin.board.X5, pyb.Pin.board.X4)\n"
"print(nic.ifconfig())\n"
"\n"
"# now use socket as usual\n"
"..."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:21
msgid ""
"For this example to work the WIZnet5x00 module must have the following "
"connections:"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:23
msgid "MOSI connected to X8"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:24
msgid "MISO connected to X7"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:25
msgid "SCLK connected to X6"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:26
msgid "nSS connected to X5"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:27
msgid "nRESET connected to X4"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:29
msgid "It is possible to use other SPI busses and other pins for nSS and nRESET."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:36
msgid ""
"Create a WIZNET5K driver object, initialise the WIZnet5x00 module using "
"the given SPI bus and pins, and return the WIZNET5K object."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:41
msgid ""
"*spi* is an :ref:`SPI object <pyb.SPI>` which is the SPI bus that the "
"WIZnet5x00 is connected to (the MOSI, MISO and SCLK pins)."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:43
msgid ""
"*pin_cs* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"WIZnet5x00 nSS pin."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:44
msgid ""
"*pin_rst* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"WIZnet5x00 nRESET pin."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:49
msgid "nic = network.WIZNET5K(pyb.SPI(1), pyb.Pin.board.X5, pyb.Pin.board.X4)"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:56
msgid ""
"Returns ``True`` if the physical Ethernet link is connected and up. "
"Returns ``False`` otherwise."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:61
msgid "Get/set IP address, subnet mask, gateway and DNS."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:63
msgid ""
"When called with no arguments, this method returns a 4-tuple with the "
"above information."
msgstr ""

#: ../../../library/network.WIZNET5K.rst:65
msgid ""
"To set the above values, pass a 4-tuple with the required information.  "
"For example::"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:71
msgid "Dump the WIZnet5x00 registers.  Useful for debugging."
msgstr ""

#: ../../../library/network.WLAN.rst:5
msgid "class WLAN -- control built-in WiFi interfaces"
msgstr ""

#: ../../../library/network.WLAN.rst:7
msgid "This class provides a driver for WiFi network processors.  Example usage::"
msgstr ""

#: ../../../library/network.WLAN.rst:9
msgid ""
"import network\n"
"# enable station interface and connect to WiFi access point\n"
"nic = network.WLAN(network.STA_IF)\n"
"nic.active(True)\n"
"nic.connect('your-ssid', 'your-password')\n"
"# now use sockets as usual"
msgstr ""

#: ../../../library/network.WLAN.rst:20
msgid ""
"Create a WLAN network interface object. Supported interfaces are "
"``network.STA_IF`` (station aka client, connects to upstream WiFi access "
"points) and ``network.AP_IF`` (access point, allows other WiFi clients to"
" connect). Availability of the methods below depends on interface type. "
"For example, only STA interface may `WLAN.connect()` to an access point."
msgstr ""

#: ../../../library/network.WLAN.rst:31
msgid ""
"Activate (\"up\") or deactivate (\"down\") network interface, if boolean "
"argument is passed. Otherwise, query current state if no argument is "
"provided. Most other methods require active interface."
msgstr ""

#: ../../../library/network.WLAN.rst:37
msgid ""
"Connect to the specified wireless network, using the specified password. "
"If *bssid* is given then the connection will be restricted to the access-"
"point with that MAC address (the *ssid* must also be specified in this "
"case)."
msgstr ""

#: ../../../library/network.WLAN.rst:44
msgid "Disconnect from the currently connected wireless network."
msgstr ""

#: ../../../library/network.WLAN.rst:48
msgid "Scan for the available wireless networks."
msgstr ""

#: ../../../library/network.WLAN.rst:50
msgid ""
"Scanning is only possible on STA interface. Returns list of tuples with "
"the information about WiFi access points:"
msgstr ""

#: ../../../library/network.WLAN.rst:53
msgid "(ssid, bssid, channel, RSSI, authmode, hidden)"
msgstr ""

#: ../../../library/network.WLAN.rst:55
msgid ""
"*bssid* is hardware address of an access point, in binary form, returned "
"as bytes object. You can use `ubinascii.hexlify()` to convert it to ASCII"
" form."
msgstr ""

#: ../../../library/network.WLAN.rst:58
msgid "There are five values for authmode:"
msgstr ""

#: ../../../library/network.WLAN.rst:60
msgid "0 -- open"
msgstr ""

#: ../../../library/network.WLAN.rst:61
msgid "1 -- WEP"
msgstr ""

#: ../../../library/network.WLAN.rst:62
msgid "2 -- WPA-PSK"
msgstr ""

#: ../../../library/network.WLAN.rst:63
msgid "3 -- WPA2-PSK"
msgstr ""

#: ../../../library/network.WLAN.rst:64
msgid "4 -- WPA/WPA2-PSK"
msgstr ""

#: ../../../library/network.WLAN.rst:66
msgid "and two for hidden:"
msgstr ""

#: ../../../library/network.WLAN.rst:68
msgid "0 -- visible"
msgstr ""

#: ../../../library/network.WLAN.rst:69
msgid "1 -- hidden"
msgstr ""

#: ../../../library/network.WLAN.rst:73
msgid "Return the current status of the wireless connection."
msgstr ""

#: ../../../library/network.WLAN.rst:75
msgid ""
"When called with no argument the return value describes the network link "
"status. The possible statuses are defined as constants:"
msgstr ""

#: ../../../library/network.WLAN.rst:78
msgid "``STAT_IDLE`` -- no connection and no activity,"
msgstr ""

#: ../../../library/network.WLAN.rst:79
msgid "``STAT_CONNECTING`` -- connecting in progress,"
msgstr ""

#: ../../../library/network.WLAN.rst:80
msgid "``STAT_WRONG_PASSWORD`` -- failed due to incorrect password,"
msgstr ""

#: ../../../library/network.WLAN.rst:81
msgid "``STAT_NO_AP_FOUND`` -- failed because no access point replied,"
msgstr ""

#: ../../../library/network.WLAN.rst:82
msgid "``STAT_CONNECT_FAIL`` -- failed due to other problems,"
msgstr ""

#: ../../../library/network.WLAN.rst:83
msgid "``STAT_GOT_IP`` -- connection successful."
msgstr ""

#: ../../../library/network.WLAN.rst:85
msgid ""
"When called with one argument *param* should be a string naming the "
"status parameter to retrieve.  Supported parameters in WiFI STA mode are:"
" ``'rssi'``."
msgstr ""

#: ../../../library/network.WLAN.rst:90
msgid ""
"In case of STA mode, returns ``True`` if connected to a WiFi access point"
" and has a valid IP address.  In AP mode returns ``True`` when a station "
"is connected. Returns ``False`` otherwise."
msgstr ""

#: ../../../library/network.WLAN.rst:106
msgid ""
"Get or set general network interface parameters. These methods allow to "
"work with additional parameters beyond standard IP configuration (as "
"dealt with by `WLAN.ifconfig()`). These include network-specific and "
"hardware-specific parameters. For setting parameters, keyword argument "
"syntax should be used, multiple parameters can be set at once. For "
"querying, parameters name should be quoted as a string, and only one "
"parameter can be queries at time::"
msgstr ""

#: ../../../library/network.WLAN.rst:119
msgid ""
"Following are commonly supported parameters (availability of a specific "
"parameter depends on network technology type, driver, and `MicroPython "
"port`)."
msgstr ""

#: ../../../library/network.WLAN.rst:123
msgid "Parameter"
msgstr ""

#: ../../../library/network.WLAN.rst:123
msgid "Description"
msgstr ""

#: ../../../library/network.WLAN.rst:125
msgid "mac"
msgstr ""

#: ../../../library/network.WLAN.rst:125
msgid "MAC address (bytes)"
msgstr ""

#: ../../../library/network.WLAN.rst:126
msgid "essid"
msgstr ""

#: ../../../library/network.WLAN.rst:126
msgid "WiFi access point name (string)"
msgstr ""

#: ../../../library/network.WLAN.rst:127
msgid "channel"
msgstr ""

#: ../../../library/network.WLAN.rst:127
msgid "WiFi channel (integer)"
msgstr ""

#: ../../../library/network.WLAN.rst:128
msgid "hidden"
msgstr ""

#: ../../../library/network.WLAN.rst:128
msgid "Whether ESSID is hidden (boolean)"
msgstr ""

#: ../../../library/network.WLAN.rst:129
msgid "authmode"
msgstr ""

#: ../../../library/network.WLAN.rst:129
msgid "Authentication mode supported (enumeration, see module constants)"
msgstr ""

#: ../../../library/network.WLAN.rst:130
msgid "password"
msgstr ""

#: ../../../library/network.WLAN.rst:130
msgid "Access password (string)"
msgstr ""

#: ../../../library/network.WLAN.rst:131
msgid "dhcp_hostname"
msgstr ""

#: ../../../library/network.WLAN.rst:131
msgid "The DHCP hostname to use"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:5
msgid "class WLANWiPy -- WiPy specific WiFi control"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:9
msgid ""
"This class is a non-standard WLAN implementation for the WiPy. It is "
"available simply as ``network.WLAN`` on the WiPy but is named in the "
"documentation below as ``network.WLANWiPy`` to distinguish it from the "
"more general :ref:`network.WLAN <network.WLAN>` class."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:14
msgid ""
"This class provides a driver for the WiFi network processor in the WiPy. "
"Example usage::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:16
msgid ""
"import network\n"
"import time\n"
"# setup as a station\n"
"wlan = network.WLAN(mode=WLAN.STA)\n"
"wlan.connect('your-ssid', auth=(WLAN.WPA2, 'your-key'))\n"
"while not wlan.isconnected():\n"
"    time.sleep_ms(50)\n"
"print(wlan.ifconfig())\n"
"\n"
"# now use socket as usual\n"
"..."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:33
msgid ""
"Create a WLAN object, and optionally configure it. See `init()` for "
"params of configuration."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:37
msgid ""
"The ``WLAN`` constructor is special in the sense that if no arguments "
"besides the id are given, it will return the already existing ``WLAN`` "
"instance without re-configuring it. This is because ``WLAN`` is a system "
"feature of the WiPy. If the already existing instance is not initialized "
"it will do the same as the other constructors an will initialize it with "
"default values."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:48
msgid "Set or get the WiFi network processor configuration."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:52
msgid "*mode* can be either ``WLAN.STA`` or ``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:53
msgid ""
"*ssid* is a string with the ssid name. Only needed when mode is "
"``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:54
msgid ""
"*auth* is a tuple with (sec, key). Security can be ``None``, "
"``WLAN.WEP``, ``WLAN.WPA`` or ``WLAN.WPA2``. The key is a string with the"
" network password. If ``sec`` is ``WLAN.WEP`` the key must be a string "
"representing hexadecimal values (e.g. 'ABC1DE45BF'). Only needed when "
"mode is ``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:58
msgid ""
"*channel* a number in the range 1-11. Only needed when mode is "
"``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:59
msgid ""
"*antenna* selects between the internal and the external antenna. Can be "
"either ``WLAN.INT_ANT`` or ``WLAN.EXT_ANT``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:62
msgid "For example, you can do::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:64
msgid ""
"# create and configure as an access point\n"
"wlan.init(mode=WLAN.AP, ssid='wipy-wlan', auth=(WLAN.WPA2,'www.wipy.io'),"
" channel=7, antenna=WLAN.INT_ANT)"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:67 ../../../library/pyb.Pin.rst:245
msgid "or::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:69
msgid ""
"# configure as an station\n"
"wlan.init(mode=WLAN.STA)"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:77
msgid ""
"*auth* is a tuple with (sec, key). Security can be ``None``, "
"``WLAN.WEP``, ``WLAN.WPA`` or ``WLAN.WPA2``. The key is a string with the"
" network password. If ``sec`` is ``WLAN.WEP`` the key must be a string "
"representing hexadecimal values (e.g. 'ABC1DE45BF')."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:81
msgid ""
"*bssid* is the MAC address of the AP to connect to. Useful when there are"
" several APs with the same ssid."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:83
msgid ""
"*timeout* is the maximum time in milliseconds to wait for the connection "
"to succeed."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:87
msgid ""
"Performs a network scan and returns a list of named tuples with (ssid, "
"bssid, sec, channel, rssi). Note that channel is always ``None`` since "
"this info is not provided by the WiPy."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:96
msgid ""
"In case of STA mode, returns ``True`` if connected to a WiFi access point"
" and has a valid IP address. In AP mode returns ``True`` when a station "
"is connected, ``False`` otherwise."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:101
msgid ""
"With no parameters given returns a 4-tuple of *(ip, subnet_mask, gateway,"
" DNS_server)*."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:103
msgid ""
"if ``'dhcp'`` is passed as a parameter then the DHCP client is enabled "
"and the IP params are negotiated with the AP."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:106
msgid ""
"If the 4-tuple config is given then a static IP is configured. For "
"instance::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:108
msgid ""
"wlan.ifconfig(config=('192.168.0.4', '255.255.255.0', '192.168.0.1', "
"'8.8.8.8'))"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:112
msgid "Get or set the WLAN mode."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:116
msgid "Get or set the SSID when in AP mode."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:120
msgid "Get or set the authentication type when in AP mode."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:124
msgid "Get or set the channel (only applicable in AP mode)."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:128
msgid "Get or set the antenna type (external or internal)."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:132
msgid "Get or set a 6-byte long bytes object with the MAC address."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:136
msgid ""
"Create a callback to be triggered when a WLAN event occurs during "
"``machine.SLEEP`` mode. Events are triggered by socket activity or by "
"WLAN connection/disconnection."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:139
msgid "*handler* is the function that gets called when the IRQ is triggered."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:140
msgid "*wake* must be ``machine.SLEEP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:142
msgid "Returns an IRQ object."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:150
msgid "selects the WLAN mode"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:156
msgid "selects the network security"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:161
msgid "selects the antenna type"
msgstr ""

#: ../../../library/pyb.rst:2
msgid ":mod:`pyb` --- functions related to the board"
msgstr ""

#: ../../../library/pyb.rst:7
msgid "The ``pyb`` module contains specific functions related to the board."
msgstr ""

#: ../../../library/pyb.rst:10
msgid "Time related functions"
msgstr ""

#: ../../../library/pyb.rst:14
msgid "Delay for the given number of milliseconds."
msgstr ""

#: ../../../library/pyb.rst:18
msgid "Delay for the given number of microseconds."
msgstr ""

#: ../../../library/pyb.rst:22
msgid "Returns the number of milliseconds since the board was last reset."
msgstr ""

#: ../../../library/pyb.rst:24
msgid ""
"The result is always a MicroPython smallint (31-bit signed number), so "
"after 2^30 milliseconds (about 12.4 days) this will start to return "
"negative numbers."
msgstr ""

#: ../../../library/pyb.rst:28
msgid ""
"Note that if :meth:`pyb.stop()` is issued the hardware counter supporting"
" this function will pause for the duration of the \"sleeping\" state. "
"This will affect the outcome of :meth:`pyb.elapsed_millis()`."
msgstr ""

#: ../../../library/pyb.rst:34
msgid "Returns the number of microseconds since the board was last reset."
msgstr ""

#: ../../../library/pyb.rst:36
msgid ""
"The result is always a MicroPython smallint (31-bit signed number), so "
"after 2^30 microseconds (about 17.8 minutes) this will start to return "
"negative numbers."
msgstr ""

#: ../../../library/pyb.rst:40
msgid ""
"Note that if :meth:`pyb.stop()` is issued the hardware counter supporting"
" this function will pause for the duration of the \"sleeping\" state. "
"This will affect the outcome of :meth:`pyb.elapsed_micros()`."
msgstr ""

#: ../../../library/pyb.rst:46
msgid "Returns the number of milliseconds which have elapsed since ``start``."
msgstr ""

#: ../../../library/pyb.rst:48
msgid ""
"This function takes care of counter wrap, and always returns a positive "
"number. This means it can be used to measure periods up to about 12.4 "
"days."
msgstr ""

#: ../../../library/pyb.rst:53
msgid ""
"start = pyb.millis()\n"
"while pyb.elapsed_millis(start) < 1000:\n"
"    # Perform some operation"
msgstr ""

#: ../../../library/pyb.rst:59
msgid "Returns the number of microseconds which have elapsed since ``start``."
msgstr ""

#: ../../../library/pyb.rst:61
msgid ""
"This function takes care of counter wrap, and always returns a positive "
"number. This means it can be used to measure periods up to about 17.8 "
"minutes."
msgstr ""

#: ../../../library/pyb.rst:66
msgid ""
"start = pyb.micros()\n"
"while pyb.elapsed_micros(start) < 1000:\n"
"    # Perform some operation\n"
"    pass"
msgstr ""

#: ../../../library/pyb.rst:76
msgid ""
"Resets the pyboard in a manner similar to pushing the external RESET "
"button."
msgstr ""

#: ../../../library/pyb.rst:81
msgid "Activate the bootloader without BOOT\\* pins."
msgstr ""

#: ../../../library/pyb.rst:85
msgid ""
"Enable or disable hard-fault debugging.  A hard-fault is when there is a "
"fatal error in the underlying system, like an invalid memory access."
msgstr ""

#: ../../../library/pyb.rst:88
msgid ""
"If the *value* argument is ``False`` then the board will automatically "
"reset if there is a hard fault."
msgstr ""

#: ../../../library/pyb.rst:91
msgid ""
"If *value* is ``True`` then, when the board has a hard fault, it will "
"print the registers and the stack trace, and then cycle the LEDs "
"indefinitely."
msgstr ""

#: ../../../library/pyb.rst:94
msgid "The default value is disabled, i.e. to automatically reset."
msgstr ""

#: ../../../library/pyb.rst:101
msgid ""
"Disable interrupt requests. Returns the previous IRQ state: "
"``False``/``True`` for disabled/enabled IRQs respectively.  This return "
"value can be passed to enable_irq to restore the IRQ to its original "
"state."
msgstr ""

#: ../../../library/pyb.rst:108
msgid ""
"Enable interrupt requests. If ``state`` is ``True`` (the default value) "
"then IRQs are enabled. If ``state`` is ``False`` then IRQs are disabled."
"  The most common use of this function is to pass it the value returned "
"by ``disable_irq`` to exit a critical section."
msgstr ""

#: ../../../library/pyb.rst:119
msgid ""
"If given no arguments, returns a tuple of clock frequencies: (sysclk, "
"hclk, pclk1, pclk2). These correspond to:"
msgstr ""

#: ../../../library/pyb.rst:123
msgid "sysclk: frequency of the CPU"
msgstr ""

#: ../../../library/pyb.rst:124
msgid "hclk: frequency of the AHB bus, core memory and DMA"
msgstr ""

#: ../../../library/pyb.rst:125
msgid "pclk1: frequency of the APB1 bus"
msgstr ""

#: ../../../library/pyb.rst:126
msgid "pclk2: frequency of the APB2 bus"
msgstr ""

#: ../../../library/pyb.rst:128
msgid ""
"If given any arguments then the function sets the frequency of the CPU, "
"and the busses if additional arguments are given.  Frequencies are given "
"in Hz.  Eg freq(120000000) sets sysclk (the CPU frequency) to 120MHz.  "
"Note that not all values are supported and the largest supported "
"frequency not greater than the given value will be selected."
msgstr ""

#: ../../../library/pyb.rst:134
msgid ""
"Supported sysclk frequencies are (in MHz): 8, 16, 24, 30, 32, 36, 40, 42,"
" 48, 54, 56, 60, 64, 72, 84, 96, 108, 120, 144, 168."
msgstr ""

#: ../../../library/pyb.rst:137
msgid ""
"The maximum frequency of hclk is 168MHz, of pclk1 is 42MHz, and of pclk2 "
"is 84MHz.  Be sure not to set frequencies above these values."
msgstr ""

#: ../../../library/pyb.rst:140
msgid ""
"The hclk, pclk1 and pclk2 frequencies are derived from the sysclk "
"frequency using a prescaler (divider).  Supported prescalers for hclk "
"are: 1, 2, 4, 8, 16, 64, 128, 256, 512.  Supported prescalers for pclk1 "
"and pclk2 are: 1, 2, 4, 8.  A prescaler will be chosen to best match the "
"requested frequency."
msgstr ""

#: ../../../library/pyb.rst:145
msgid ""
"A sysclk frequency of 8MHz uses the HSE (external crystal) directly and "
"16MHz uses the HSI (internal oscillator) directly.  The higher "
"frequencies use the HSE to drive the PLL (phase locked loop), and then "
"use the output of the PLL."
msgstr ""

#: ../../../library/pyb.rst:150
msgid ""
"Note that if you change the frequency while the USB is enabled then the "
"USB may become unreliable.  It is best to change the frequency in "
"boot.py, before the USB peripheral is started.  Also note that sysclk "
"frequencies below 36MHz do not allow the USB to function correctly."
msgstr ""

#: ../../../library/pyb.rst:157
msgid "Wait for an internal or external interrupt."
msgstr ""

#: ../../../library/pyb.rst:159
msgid ""
"This executes a ``wfi`` instruction which reduces power consumption of "
"the MCU until any interrupt occurs (be it internal or external), at which"
" point execution continues.  Note that the system-tick interrupt occurs "
"once every millisecond (1000Hz) so this function will block for at most "
"1ms."
msgstr ""

#: ../../../library/pyb.rst:167
msgid "Put the pyboard in a \"sleeping\" state."
msgstr ""

#: ../../../library/pyb.rst:169
msgid ""
"This reduces power consumption to less than 500 uA.  To wake from this "
"sleep state requires an external interrupt or a real-time-clock event. "
"Upon waking execution continues where it left off."
msgstr ""

#: ../../../library/pyb.rst:173 ../../../library/pyb.rst:184
msgid "See :meth:`rtc.wakeup` to configure a real-time-clock wakeup event."
msgstr ""

#: ../../../library/pyb.rst:177
msgid "Put the pyboard into a \"deep sleep\" state."
msgstr ""

#: ../../../library/pyb.rst:179
msgid ""
"This reduces power consumption to less than 50 uA.  To wake from this "
"sleep state requires a real-time-clock event, or an external interrupt on"
" X1 (PA0=WKUP) or X18 (PC13=TAMP1). Upon waking the system undergoes a "
"hard reset."
msgstr ""

#: ../../../library/pyb.rst:191
msgid "Return True if USB is connected as a serial device, False otherwise."
msgstr ""

#: ../../../library/pyb.rst:193
msgid "This function is deprecated.  Use pyb.USB_VCP().isconnected() instead."
msgstr ""

#: ../../../library/pyb.rst:197
msgid ""
"Takes a 4-tuple (or list) and sends it to the USB host (the PC) to signal"
" a HID mouse-motion event."
msgstr ""

#: ../../../library/pyb.rst:200
msgid "This function is deprecated.  Use :meth:`pyb.USB_HID.send()` instead."
msgstr ""

#: ../../../library/pyb.rst:204
msgid "Print out lots of information about the board."
msgstr ""

#: ../../../library/pyb.rst:208
msgid ""
"Set the filename of the main script to run after boot.py is finished.  If"
" this function is not called then the default file main.py will be "
"executed."
msgstr ""

#: ../../../library/pyb.rst:211
msgid "It only makes sense to call this function from within boot.py."
msgstr ""

#: ../../../library/pyb.rst:215
msgid ""
"This function is deprecated. Mounting and unmounting devices should be "
"performed by :meth:`uos.mount` and :meth:`uos.umount` instead."
msgstr ""

#: ../../../library/pyb.rst:218
msgid ""
"Mount a block device and make it available as part of the filesystem. "
"``device`` must be an object that provides the block protocol. (The "
"following is also deprecated. See :class:`uos.AbstractBlockDev` for the "
"correct way to create a block device.)"
msgstr ""

#: ../../../library/pyb.rst:223
msgid "``readblocks(self, blocknum, buf)``"
msgstr ""

#: ../../../library/pyb.rst:224
msgid "``writeblocks(self, blocknum, buf)`` (optional)"
msgstr ""

#: ../../../library/pyb.rst:225
msgid "``count(self)``"
msgstr ""

#: ../../../library/pyb.rst:226
msgid "``sync(self)`` (optional)"
msgstr ""

#: ../../../library/pyb.rst:228
msgid ""
"``readblocks`` and ``writeblocks`` should copy data between ``buf`` and "
"the block device, starting from block number ``blocknum`` on the device. "
"``buf`` will be a bytearray with length a multiple of 512.  If "
"``writeblocks`` is not defined then the device is mounted read-only. The "
"return value of these two functions is ignored."
msgstr ""

#: ../../../library/pyb.rst:234
msgid ""
"``count`` should return the number of blocks available on the device. "
"``sync``, if implemented, should sync the data on the device."
msgstr ""

#: ../../../library/pyb.rst:237
msgid ""
"The parameter ``mountpoint`` is the location in the root of the "
"filesystem to mount the device.  It must begin with a forward-slash."
msgstr ""

#: ../../../library/pyb.rst:240
msgid ""
"If ``readonly`` is ``True``, then the device is mounted read-only, "
"otherwise it is mounted read-write."
msgstr ""

#: ../../../library/pyb.rst:243
msgid ""
"If ``mkfs`` is ``True``, then a new filesystem is created if one does not"
" already exist."
msgstr ""

#: ../../../library/pyb.rst:248
msgid "Get or set the UART object where the REPL is repeated on."
msgstr ""

#: ../../../library/pyb.rst:252
msgid "Return a 30-bit hardware generated random number."
msgstr ""

#: ../../../library/pyb.rst:256
msgid "Sync all file systems."
msgstr ""

#: ../../../library/pyb.rst:260
msgid "Returns a string of 12 bytes (96 bits), which is the unique ID of the MCU."
msgstr ""

#: ../../../library/pyb.rst:264
msgid "If called with no arguments, return the current USB mode as a string."
msgstr ""

#: ../../../library/pyb.rst:266
msgid ""
"If called with ``modestr`` provided, attempts to set USB mode. This can "
"only be done when called from ``boot.py`` before :meth:`pyb.main()` has "
"been called.  The following values of ``modestr`` are understood:"
msgstr ""

#: ../../../library/pyb.rst:271
msgid "``None``: disables USB"
msgstr ""

#: ../../../library/pyb.rst:272
msgid "``'VCP'``: enable with VCP (Virtual COM Port) interface"
msgstr ""

#: ../../../library/pyb.rst:273
msgid "``'MSC'``: enable with MSC (mass storage device class) interface"
msgstr ""

#: ../../../library/pyb.rst:274
msgid "``'VCP+MSC'``: enable with VCP and MSC"
msgstr ""

#: ../../../library/pyb.rst:275
msgid "``'VCP+HID'``: enable with VCP and HID (human interface device)"
msgstr ""

#: ../../../library/pyb.rst:277
msgid ""
"For backwards compatibility, ``'CDC'`` is understood to mean ``'VCP'`` "
"(and similarly for ``'CDC+MSC'`` and ``'CDC+HID'``)."
msgstr ""

#: ../../../library/pyb.rst:280
msgid ""
"The ``vid`` and ``pid`` parameters allow you to specify the VID (vendor "
"id) and PID (product id)."
msgstr ""

#: ../../../library/pyb.rst:283
msgid ""
"If enabling HID mode, you may also specify the HID details by passing the"
" ``hid`` keyword parameter.  It takes a tuple of (subclass, protocol, max"
" packet length, polling interval, report descriptor).  By default it will"
" set appropriate values for a USB mouse.  There is also a "
"``pyb.hid_keyboard`` constant, which is an appropriate tuple for a USB "
"keyboard."
msgstr ""

#: ../../../library/pyb.ADC.rst:9
msgid ""
"import pyb\n"
"\n"
"adc = pyb.ADC(pin)                  # create an analog object from a pin\n"
"val = adc.read()                    # read an analog value\n"
"\n"
"adc = pyb.ADCAll(resolution)        # create an ADCAll object\n"
"adc = pyb.ADCAll(resolution, mask)  # create an ADCAll object for "
"selected analog channels\n"
"val = adc.read_channel(channel)     # read the given channel\n"
"val = adc.read_core_temp()          # read MCU temperature\n"
"val = adc.read_core_vbat()          # read MCU VBAT\n"
"val = adc.read_core_vref()          # read MCU VREF\n"
"val = adc.read_vref()               # read MCU supply voltage"
msgstr ""

#: ../../../library/pyb.ADC.rst:28
msgid ""
"Create an ADC object associated with the given pin. This allows you to "
"then read analog values on that pin."
msgstr ""

#: ../../../library/pyb.ADC.rst:36
msgid ""
"Read the value on the analog pin and return it.  The returned value will "
"be between 0 and 4095."
msgstr ""

#: ../../../library/pyb.ADC.rst:41
msgid "Read analog values into ``buf`` at a rate set by the ``timer`` object."
msgstr ""

#: ../../../library/pyb.ADC.rst:43
msgid ""
"``buf`` can be bytearray or array.array for example.  The ADC values have"
" 12-bit resolution and are stored directly into ``buf`` if its element "
"size is 16 bits or greater.  If ``buf`` has only 8-bit elements (eg a "
"bytearray) then the sample resolution will be reduced to 8 bits."
msgstr ""

#: ../../../library/pyb.ADC.rst:48
msgid ""
"``timer`` should be a Timer object, and a sample is read each time the "
"timer triggers.  The timer must already be initialised and running at the"
" desired sampling frequency."
msgstr ""

#: ../../../library/pyb.ADC.rst:52
msgid ""
"To support previous behaviour of this function, ``timer`` can also be an "
"integer which specifies the frequency (in Hz) to sample at.  In this case"
" Timer(6) will be automatically configured to run at the given frequency."
msgstr ""

#: ../../../library/pyb.ADC.rst:56
msgid "Example using a Timer object (preferred way)::"
msgstr ""

#: ../../../library/pyb.ADC.rst:58
msgid ""
"adc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\n"
"tim = pyb.Timer(6, freq=10)         # create a timer running at 10Hz\n"
"buf = bytearray(100)                # creat a buffer to store the samples"
"\n"
"adc.read_timed(buf, tim)            # sample 100 values, taking 10s"
msgstr ""

#: ../../../library/pyb.ADC.rst:63
msgid "Example using an integer for the frequency::"
msgstr ""

#: ../../../library/pyb.ADC.rst:65
msgid ""
"adc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\n"
"buf = bytearray(100)                # create a buffer of 100 bytes\n"
"adc.read_timed(buf, 10)             # read analog values into buf at 10Hz"
"\n"
"                                    #   this will take 10 seconds to "
"finish\n"
"for val in buf:                     # loop over all values\n"
"    print(val)                      # print the value out"
msgstr ""

#: ../../../library/pyb.ADC.rst:72
msgid ""
"This function does not allocate any heap memory. It has blocking "
"behaviour: it does not return to the calling program until the buffer is "
"full."
msgstr ""

#: ../../../library/pyb.ADC.rst:77
msgid ""
"This is a static method. It can be used to extract relative timing or "
"phase data from multiple ADC's."
msgstr ""

#: ../../../library/pyb.ADC.rst:80
msgid ""
"It reads analog values from multiple ADC's into buffers at a rate set by "
"the *timer* object. Each time the timer triggers a sample is rapidly read"
" from each ADC in turn."
msgstr ""

#: ../../../library/pyb.ADC.rst:84
msgid ""
"ADC and buffer instances are passed in tuples with each ADC having an "
"associated buffer. All buffers must be of the same type and length and "
"the number of buffers must equal the number of ADC's."
msgstr ""

#: ../../../library/pyb.ADC.rst:88
msgid ""
"Buffers can be ``bytearray`` or ``array.array`` for example. The ADC "
"values have 12-bit resolution and are stored directly into the buffer if "
"its element size is 16 bits or greater.  If buffers have only 8-bit "
"elements (eg a ``bytearray``) then the sample resolution will be reduced "
"to 8 bits."
msgstr ""

#: ../../../library/pyb.ADC.rst:93
msgid ""
"*timer* must be a Timer object. The timer must already be initialised and"
" running at the desired sampling frequency."
msgstr ""

#: ../../../library/pyb.ADC.rst:96
msgid "Example reading 3 ADC's::"
msgstr ""

#: ../../../library/pyb.ADC.rst:98
msgid ""
"adc0 = pyb.ADC(pyb.Pin.board.X1)    # Create ADC's\n"
"adc1 = pyb.ADC(pyb.Pin.board.X2)\n"
"adc2 = pyb.ADC(pyb.Pin.board.X3)\n"
"tim = pyb.Timer(8, freq=100)        # Create timer\n"
"rx0 = array.array('H', (0 for i in range(100))) # ADC buffers of\n"
"rx1 = array.array('H', (0 for i in range(100))) # 100 16-bit words\n"
"rx2 = array.array('H', (0 for i in range(100)))\n"
"# read analog values into buffers at 100Hz (takes one second)\n"
"pyb.ADC.read_timed_multi((adc0, adc1, adc2), (rx0, rx1, rx2), tim)\n"
"for n in range(len(rx0)):\n"
"    print(rx0[n], rx1[n], rx2[n])"
msgstr ""

#: ../../../library/pyb.ADC.rst:110
msgid ""
"This function does not allocate any heap memory. It has blocking "
"behaviour: it does not return to the calling program until the buffers "
"are full."
msgstr ""

#: ../../../library/pyb.ADC.rst:113
msgid ""
"The function returns ``True`` if all samples were acquired with correct "
"timing. At high sample rates the time taken to acquire a set of samples "
"can exceed the timer period. In this case the function returns ``False``,"
" indicating a loss of precision in the sample interval. In extreme cases "
"samples may be missed."
msgstr ""

#: ../../../library/pyb.ADC.rst:119
msgid ""
"The maximum rate depends on factors including the data width and the "
"number of ADC's being read. In testing two ADC's were sampled at a timer "
"rate of 210kHz without overrun. Samples were missed at 215kHz.  For three"
" ADC's the limit is around 140kHz, and for four it is around 110kHz. At "
"high sample rates disabling interrupts for the duration can reduce the "
"risk of sporadic data loss."
msgstr ""

#: ../../../library/pyb.ADC.rst:127
msgid "The ADCAll Object"
msgstr ""

#: ../../../library/pyb.ADC.rst:129
msgid ""
"Instantiating this changes all masked ADC pins to analog inputs. The "
"preprocessed MCU temperature, VREF and VBAT data can be accessed on ADC "
"channels 16, 17 and 18 respectively. Appropriate scaling is handled "
"according to reference voltage used (usually 3.3V). The temperature "
"sensor on the chip is factory calibrated and allows to read the die "
"temperature to +/- 1 degree centigrade. Although this sounds pretty "
"accurate, don't forget that the MCU's internal temperature is measured. "
"Depending on processing loads and I/O subsystems active the die "
"temperature may easily be tens of degrees above ambient temperature. On "
"the other hand a pyboard woken up after a long standby period will show "
"correct ambient temperature within limits mentioned above."
msgstr ""

#: ../../../library/pyb.ADC.rst:138
msgid ""
"The ``ADCAll`` ``read_core_vbat()``, ``read_vref()`` and "
"``read_core_vref()`` methods read the backup battery voltage, reference "
"voltage and the (1.21V nominal) reference voltage using the actual supply"
" as a reference. All results are floating point numbers giving direct "
"voltage values."
msgstr ""

#: ../../../library/pyb.ADC.rst:142
msgid ""
"``read_core_vbat()`` returns the voltage of the backup battery. This "
"voltage is also adjusted according to the actual supply voltage. To avoid"
" analog input overload the battery voltage is measured via a voltage "
"divider and scaled according to the divider value. To prevent excessive "
"loads to the backup battery, the voltage divider is only active during "
"ADC conversion."
msgstr ""

#: ../../../library/pyb.ADC.rst:147
msgid ""
"``read_vref()`` is evaluated by measuring the internal voltage reference "
"and backscale it using factory calibration value of the internal voltage "
"reference. In most cases the reading would be close to 3.3V. If the "
"pyboard is operated from a battery, the supply voltage may drop to values"
" below 3.3V. The pyboard will still operate fine as long as the operating"
" conditions are met. With proper settings of MCU clock, flash access "
"speed and programming mode it is possible to run the pyboard down to 2 V "
"and still get useful ADC conversion."
msgstr ""

#: ../../../library/pyb.ADC.rst:154
msgid ""
"It is very important to make sure analog input voltages never exceed "
"actual supply voltage."
msgstr ""

#: ../../../library/pyb.ADC.rst:156
msgid ""
"Other analog input channels (0..15) will return unscaled integer values "
"according to the selected precision."
msgstr ""

#: ../../../library/pyb.ADC.rst:159
msgid ""
"To avoid unwanted activation of analog inputs (channel 0..15) a second "
"parameter can be specified. This parameter is a binary pattern where each"
" requested analog input has the corresponding bit set. The default value "
"is 0xffffffff which means all analog inputs are active. If just the "
"internal channels (16..18) are required, the mask value should be "
"0x70000."
msgstr ""

#: ../../../<rst_epilog>:166
msgid ""
"adcall = pyb.ADCAll(12, 0x70000) # 12 bit resolution, internal channels\n"
"temp = adcall.read_core_temp()"
msgstr ""

#: ../../../library/pyb.Accel.rst:5
msgid "class Accel -- accelerometer control"
msgstr ""

#: ../../../library/pyb.Accel.rst:7
msgid "Accel is an object that controls the accelerometer.  Example usage::"
msgstr ""

#: ../../../library/pyb.Accel.rst:9
msgid ""
"accel = pyb.Accel()\n"
"for i in range(10):\n"
"    print(accel.x(), accel.y(), accel.z())"
msgstr ""

#: ../../../library/pyb.Accel.rst:13
msgid "Raw values are between -32 and 31."
msgstr ""

#: ../../../library/pyb.Accel.rst:21
msgid "Create and return an accelerometer object."
msgstr ""

#: ../../../library/pyb.Accel.rst:28
msgid "Get a 3-tuple of filtered x, y and z values."
msgstr ""

#: ../../../library/pyb.Accel.rst:30
msgid ""
"Implementation note: this method is currently implemented as taking the "
"sum of 4 samples, sampled from the 3 previous calls to this function "
"along with the sample from the current call.  Returned values are "
"therefore 4 times the size of what they would be from the raw x(), y() "
"and z() calls."
msgstr ""

#: ../../../library/pyb.Accel.rst:37
msgid "Get the tilt register."
msgstr ""

#: ../../../library/pyb.Accel.rst:41
msgid "Get the x-axis value."
msgstr ""

#: ../../../library/pyb.Accel.rst:45
msgid "Get the y-axis value."
msgstr ""

#: ../../../library/pyb.Accel.rst:49
msgid "Get the z-axis value."
msgstr ""

#: ../../../library/pyb.Accel.rst:52
msgid "Hardware Note"
msgstr ""

#: ../../../library/pyb.Accel.rst:54
msgid ""
"The accelerometer uses I2C bus 1 to communicate with the processor. "
"Consequently when readings are being taken pins X9 and X10 should be "
"unused (other than for I2C). Other devices using those pins, and which "
"therefore cannot be used concurrently, are UART 1 and Timer 4 channels 1 "
"and 2."
msgstr ""

#: ../../../library/pyb.CAN.rst:5
msgid "class CAN -- controller area network communication bus"
msgstr ""

#: ../../../library/pyb.CAN.rst:7
msgid ""
"CAN implements the standard CAN communications protocol.  At the physical"
" level it consists of 2 lines: RX and TX.  Note that to connect the "
"pyboard to a CAN bus you must use a CAN transceiver to convert the CAN "
"logic signals from the pyboard to the correct voltage levels on the bus."
msgstr ""

#: ../../../library/pyb.CAN.rst:13
msgid "Example usage (works without anything connected)::"
msgstr ""

#: ../../../library/pyb.CAN.rst:15
msgid ""
"from pyb import CAN\n"
"can = CAN(1, CAN.LOOPBACK)\n"
"can.setfilter(0, CAN.LIST16, 0, (123, 124, 125, 126))  # set a filter to "
"receive messages with id=123, 124, 125 and 126\n"
"can.send('message!', 123)   # send a message with id 123\n"
"can.recv(0)                 # receive message on FIFO 0"
msgstr ""

#: ../../../library/pyb.CAN.rst:27
msgid ""
"Construct a CAN object on the given bus.  *bus* can be 1-2, or ``'YA'`` "
"or ``'YB'``. With no additional parameters, the CAN object is created but"
" not initialised (it has the settings from the last initialisation of the"
" bus, if any).  If extra arguments are given, the bus is initialised. See"
" :meth:`CAN.init` for parameters of initialisation."
msgstr ""

#: ../../../library/pyb.CAN.rst:33
msgid "The physical pins of the CAN busses are:"
msgstr ""

#: ../../../library/pyb.CAN.rst:35
msgid "``CAN(1)`` is on ``YA``: ``(RX, TX) = (Y3, Y4) = (PB8, PB9)``"
msgstr ""

#: ../../../library/pyb.CAN.rst:36
msgid "``CAN(2)`` is on ``YB``: ``(RX, TX) = (Y5, Y6) = (PB12, PB13)``"
msgstr ""

#: ../../../library/pyb.CAN.rst:39
msgid "Class Methods"
msgstr ""

#: ../../../library/pyb.CAN.rst:42
msgid ""
"Reset and disable all filter banks and assign how many banks should be "
"available for CAN(1)."
msgstr ""

#: ../../../library/pyb.CAN.rst:44
msgid ""
"STM32F405 has 28 filter banks that are shared between the two available "
"CAN bus controllers. This function configures how many filter banks "
"should be assigned to each. *nr* is the number of banks that will be "
"assigned to CAN(1), the rest of the 28 are assigned to CAN(2). At boot, "
"14 banks are assigned to each controller."
msgstr ""

#: ../../../library/pyb.CAN.rst:54
msgid "Initialise the CAN bus with the given parameters:"
msgstr ""

#: ../../../library/pyb.CAN.rst:56
msgid "*mode* is one of:  NORMAL, LOOPBACK, SILENT, SILENT_LOOPBACK"
msgstr ""

#: ../../../library/pyb.CAN.rst:57
msgid ""
"if *extframe* is True then the bus uses extended identifiers in the "
"frames (29 bits); otherwise it uses standard 11 bit identifiers"
msgstr ""

#: ../../../library/pyb.CAN.rst:59
msgid ""
"*prescaler* is used to set the duration of 1 time quanta; the time quanta"
" will be the input clock (PCLK1, see :meth:`pyb.freq()`) divided by the "
"prescaler"
msgstr ""

#: ../../../library/pyb.CAN.rst:61
msgid ""
"*sjw* is the resynchronisation jump width in units of the time quanta; it"
" can be 1, 2, 3, 4"
msgstr ""

#: ../../../library/pyb.CAN.rst:63
msgid ""
"*bs1* defines the location of the sample point in units of the time "
"quanta; it can be between 1 and 1024 inclusive"
msgstr ""

#: ../../../library/pyb.CAN.rst:65
msgid ""
"*bs2* defines the location of the transmit point in units of the time "
"quanta; it can be between 1 and 16 inclusive"
msgstr ""

#: ../../../library/pyb.CAN.rst:67
msgid ""
"*auto_restart* sets whether the controller will automatically try and "
"restart communications after entering the bus-off state; if this is "
"disabled then :meth:`~CAN.restart()` can be used to leave the bus-off "
"state"
msgstr ""

#: ../../../library/pyb.CAN.rst:71
msgid ""
"The time quanta tq is the basic unit of time for the CAN bus.  tq is the "
"CAN prescaler value divided by PCLK1 (the frequency of internal "
"peripheral bus 1); see :meth:`pyb.freq()` to determine PCLK1."
msgstr ""

#: ../../../library/pyb.CAN.rst:75
msgid ""
"A single bit is made up of the synchronisation segment, which is always 1"
" tq. Then follows bit segment 1, then bit segment 2.  The sample point is"
" after bit segment 1 finishes.  The transmit point is after bit segment 2"
" finishes. The baud rate will be 1/bittime, where the bittime is 1 + BS1 "
"+ BS2 multiplied by the time quanta tq."
msgstr ""

#: ../../../library/pyb.CAN.rst:81
msgid ""
"For example, with PCLK1=42MHz, prescaler=100, sjw=1, bs1=6, bs2=8, the "
"value of tq is 2.38 microseconds.  The bittime is 35.7 microseconds, and "
"the baudrate is 28kHz."
msgstr ""

#: ../../../library/pyb.CAN.rst:85
msgid "See page 680 of the STM32F405 datasheet for more details."
msgstr ""

#: ../../../library/pyb.CAN.rst:89
msgid "Turn off the CAN bus."
msgstr ""

#: ../../../library/pyb.CAN.rst:93
msgid ""
"Force a software restart of the CAN controller without resetting its "
"configuration."
msgstr ""

#: ../../../library/pyb.CAN.rst:96
msgid ""
"If the controller enters the bus-off state then it will no longer "
"participate in bus activity.  If the controller is not configured to "
"automatically restart (see :meth:`~CAN.init()`) then this method can be "
"used to trigger a restart, and the controller will follow the CAN "
"protocol to leave the bus-off state and go into the error active state."
msgstr ""

#: ../../../library/pyb.CAN.rst:104
msgid "Return the state of the controller.  The return value can be one of:"
msgstr ""

#: ../../../library/pyb.CAN.rst:106
msgid "``CAN.STOPPED`` -- the controller is completely off and reset;"
msgstr ""

#: ../../../library/pyb.CAN.rst:107
msgid ""
"``CAN.ERROR_ACTIVE`` -- the controller is on and in the Error Active "
"state (both TEC and REC are less than 96);"
msgstr ""

#: ../../../library/pyb.CAN.rst:109
msgid ""
"``CAN.ERROR_WARNING`` -- the controller is on and in the Error Warning "
"state (at least one of TEC or REC is 96 or greater);"
msgstr ""

#: ../../../library/pyb.CAN.rst:111
msgid ""
"``CAN.ERROR_PASSIVE`` -- the controller is on and in the Error Passive "
"state (at least one of TEC or REC is 128 or greater);"
msgstr ""

#: ../../../library/pyb.CAN.rst:113
msgid ""
"``CAN.BUS_OFF`` -- the controller is on but not participating in bus "
"activity (TEC overflowed beyond 255)."
msgstr ""

#: ../../../library/pyb.CAN.rst:118
msgid ""
"Get information about the controller's error states and TX and RX "
"buffers. If *list* is provided then it should be a list object with at "
"least 8 entries, which will be filled in with the information.  Otherwise"
" a new list will be created and filled in.  In both cases the return "
"value of the method is the populated list."
msgstr ""

#: ../../../library/pyb.CAN.rst:124
msgid "The values in the list are:"
msgstr ""

#: ../../../library/pyb.CAN.rst:126
msgid "TEC value"
msgstr ""

#: ../../../library/pyb.CAN.rst:127
msgid "REC value"
msgstr ""

#: ../../../library/pyb.CAN.rst:128
msgid ""
"number of times the controller enterted the Error Warning state (wrapped "
"around to 0 after 65535)"
msgstr ""

#: ../../../library/pyb.CAN.rst:130
msgid ""
"number of times the controller enterted the Error Passive state (wrapped "
"around to 0 after 65535)"
msgstr ""

#: ../../../library/pyb.CAN.rst:132
msgid ""
"number of times the controller enterted the Bus Off state (wrapped around"
" to 0 after 65535)"
msgstr ""

#: ../../../library/pyb.CAN.rst:134
msgid "number of pending TX messages"
msgstr ""

#: ../../../library/pyb.CAN.rst:135
msgid "number of pending RX messages on fifo 0"
msgstr ""

#: ../../../library/pyb.CAN.rst:136
msgid "number of pending RX messages on fifo 1"
msgstr ""

#: ../../../library/pyb.CAN.rst:140
msgid "Configure a filter bank:"
msgstr ""

#: ../../../library/pyb.CAN.rst:142
msgid "*bank* is the filter bank that is to be configured."
msgstr ""

#: ../../../library/pyb.CAN.rst:143
msgid "*mode* is the mode the filter should operate in."
msgstr ""

#: ../../../library/pyb.CAN.rst:144
msgid ""
"*fifo* is which fifo (0 or 1) a message should be stored in, if it is "
"accepted by this filter."
msgstr ""

#: ../../../library/pyb.CAN.rst:145
msgid ""
"*params* is an array of values the defines the filter. The contents of "
"the array depends on the *mode* argument."
msgstr ""

#: ../../../library/pyb.CAN.rst:148 ../../../library/pyb.CAN.rst:169
msgid "*mode*"
msgstr ""

#: ../../../library/pyb.CAN.rst:148
msgid "contents of *params* array"
msgstr ""

#: ../../../library/pyb.CAN.rst:150 ../../../library/pyb.CAN.rst:171
msgid "CAN.LIST16"
msgstr ""

#: ../../../library/pyb.CAN.rst:150
msgid "Four 16 bit ids that will be accepted"
msgstr ""

#: ../../../library/pyb.CAN.rst:152 ../../../library/pyb.CAN.rst:173
msgid "CAN.LIST32"
msgstr ""

#: ../../../library/pyb.CAN.rst:152
msgid "Two 32 bit ids that will be accepted"
msgstr ""

#: ../../../library/pyb.CAN.rst:154 ../../../library/pyb.CAN.rst:175
msgid "CAN.MASK16"
msgstr ""

#: ../../../library/pyb.CAN.rst:157
msgid "Two 16 bit id/mask pairs. E.g. (1, 3, 4, 4)"
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "The first pair, 1 and 3 will accept all ids"
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "that have bit 0 = 1 and bit 1 = 0."
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "The second pair, 4 and 4, will accept all ids"
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "that have bit 2 = 1."
msgstr ""

#: ../../../library/pyb.CAN.rst:160 ../../../library/pyb.CAN.rst:177
msgid "CAN.MASK32"
msgstr ""

#: ../../../library/pyb.CAN.rst:160
msgid "As with CAN.MASK16 but with only one 32 bit id/mask pair."
msgstr ""

#: ../../../library/pyb.CAN.rst:163
msgid ""
"*rtr* is an array of booleans that states if a filter should accept a "
"remote transmission request message.  If this argument is not given then "
"it defaults to ``False`` for all entries.  The length of the array "
"depends on the *mode* argument."
msgstr ""

#: ../../../library/pyb.CAN.rst:169
msgid "length of *rtr* array"
msgstr ""

#: ../../../library/pyb.CAN.rst:171
msgid "4"
msgstr ""

#: ../../../library/pyb.CAN.rst:173 ../../../library/pyb.CAN.rst:175
#: ../../../library/pyb.CAN.rst:260
msgid "2"
msgstr ""

#: ../../../library/pyb.CAN.rst:177 ../../../library/pyb.CAN.rst:258
msgid "1"
msgstr ""

#: ../../../library/pyb.CAN.rst:182
msgid "Clear and disables a filter bank:"
msgstr ""

#: ../../../library/pyb.CAN.rst:184
msgid "*bank* is the filter bank that is to be cleared."
msgstr ""

#: ../../../library/pyb.CAN.rst:188
msgid "Return ``True`` if any message waiting on the FIFO, else ``False``."
msgstr ""

#: ../../../library/pyb.CAN.rst:192 ../../../library/pyb.I2C.rst:131
#: ../../../library/pyb.SPI.rst:81 ../../../library/pyb.USB_HID.rst:26
#: ../../../library/pyb.USB_VCP.rst:87
msgid "Receive data on the bus:"
msgstr ""

#: ../../../library/pyb.CAN.rst:194
msgid "*fifo* is an integer, which is the FIFO to receive on"
msgstr ""

#: ../../../library/pyb.CAN.rst:195
msgid "*list* is an optional list object to be used as the return value"
msgstr ""

#: ../../../library/pyb.CAN.rst:196
msgid "*timeout* is the timeout in milliseconds to wait for the receive."
msgstr ""

#: ../../../library/pyb.CAN.rst:198
msgid "Return value: A tuple containing four values."
msgstr ""

#: ../../../library/pyb.CAN.rst:200
msgid "The id of the message."
msgstr ""

#: ../../../library/pyb.CAN.rst:201
msgid "A boolean that indicates if the message is an RTR message."
msgstr ""

#: ../../../library/pyb.CAN.rst:202
msgid "The FMI (Filter Match Index) value."
msgstr ""

#: ../../../library/pyb.CAN.rst:203
msgid "An array containing the data."
msgstr ""

#: ../../../library/pyb.CAN.rst:205
msgid ""
"If *list* is ``None`` then a new tuple will be allocated, as well as a "
"new bytes object to contain the data (as the fourth element in the "
"tuple)."
msgstr ""

#: ../../../library/pyb.CAN.rst:208
msgid ""
"If *list* is not ``None`` then it should be a list object with a least "
"four elements.  The fourth element should be a memoryview object which is"
" created from either a bytearray or an array of type 'B' or 'b', and this"
" array must have enough room for at least 8 bytes.  The list object will "
"then be populated with the first three return values above, and the "
"memoryview object will be resized inplace to the size of the data and "
"filled in with that data. The same list and memoryview objects can be "
"reused in subsequent calls to this method, providing a way of receiving "
"data without using the heap. For example::"
msgstr ""

#: ../../../library/pyb.CAN.rst:218
msgid ""
"buf = bytearray(8)\n"
"lst = [0, 0, 0, memoryview(buf)]\n"
"# No heap memory is allocated in the following call\n"
"can.recv(0, lst)"
msgstr ""

#: ../../../library/pyb.CAN.rst:225
msgid "Send a message on the bus:"
msgstr ""

#: ../../../library/pyb.CAN.rst:227
msgid "*data* is the data to send (an integer to send, or a buffer object)."
msgstr ""

#: ../../../library/pyb.CAN.rst:228
msgid "*id* is the id of the message to be sent."
msgstr ""

#: ../../../library/pyb.CAN.rst:229
msgid "*timeout* is the timeout in milliseconds to wait for the send."
msgstr ""

#: ../../../library/pyb.CAN.rst:230
msgid ""
"*rtr* is a boolean that specifies if the message shall be sent as a "
"remote transmission request.  If *rtr* is True then only the length of "
"*data* is used to fill in the DLC slot of the frame; the actual bytes in "
"*data* are unused."
msgstr ""

#: ../../../library/pyb.CAN.rst:235
msgid ""
"If timeout is 0 the message is placed in a buffer in one of three "
"hardware buffers and the method returns immediately. If all three buffers"
" are in use an exception is thrown. If timeout is not 0, the method waits"
" until the message is transmitted. If the message can't be transmitted "
"within the specified time an exception is thrown."
msgstr ""

#: ../../../library/pyb.CAN.rst:241 ../../../library/pyb.I2C.rst:149
#: ../../../library/pyb.SPI.rst:97
msgid "Return value: ``None``."
msgstr ""

#: ../../../library/pyb.CAN.rst:245
msgid ""
"Register a function to be called when a message is accepted into a empty "
"fifo:"
msgstr ""

#: ../../../library/pyb.CAN.rst:247
msgid "*fifo* is the receiving fifo."
msgstr ""

#: ../../../library/pyb.CAN.rst:248
msgid "*fun* is the function to be called when the fifo becomes non empty."
msgstr ""

#: ../../../library/pyb.CAN.rst:250
msgid ""
"The callback function takes two arguments the first is the can object it "
"self the second is a integer that indicates the reason for the callback."
msgstr ""

#: ../../../library/pyb.CAN.rst:254
msgid "Reason"
msgstr ""

#: ../../../library/pyb.CAN.rst:256
msgid "0"
msgstr ""

#: ../../../library/pyb.CAN.rst:256
msgid "A message has been accepted into a empty FIFO."
msgstr ""

#: ../../../library/pyb.CAN.rst:258
msgid "The FIFO is full"
msgstr ""

#: ../../../library/pyb.CAN.rst:260
msgid "A message has been lost due to a full FIFO"
msgstr ""

#: ../../../library/pyb.CAN.rst:263
msgid "Example use of rxcallback::"
msgstr ""

#: ../../../library/pyb.CAN.rst:265
msgid ""
"def cb0(bus, reason):\n"
"  print('cb0')\n"
"  if reason == 0:\n"
"      print('pending')\n"
"  if reason == 1:\n"
"      print('full')\n"
"  if reason == 2:\n"
"      print('overflow')\n"
"\n"
"can = CAN(1, CAN.LOOPBACK)\n"
"can.rxcallback(0, cb0)"
msgstr ""

#: ../../../library/pyb.CAN.rst:285
msgid "The mode of the CAN bus used in :meth:`~CAN.init()`."
msgstr ""

#: ../../../library/pyb.CAN.rst:293
msgid "Possible states of the CAN controller returned from :meth:`~CAN.state()`."
msgstr ""

#: ../../../library/pyb.CAN.rst:300
msgid "The operation mode of a filter used in :meth:`~CAN.setfilter()`."
msgstr ""

#: ../../../library/pyb.DAC.rst:5
msgid "class DAC -- digital to analog conversion"
msgstr ""

#: ../../../library/pyb.DAC.rst:7
msgid ""
"The DAC is used to output analog values (a specific voltage) on pin X5 or"
" pin X6. The voltage will be between 0 and 3.3V."
msgstr ""

#: ../../../library/pyb.DAC.rst:10
msgid "*This module will undergo changes to the API.*"
msgstr ""

#: ../../../library/pyb.DAC.rst:14
msgid ""
"from pyb import DAC\n"
"\n"
"dac = DAC(1)            # create DAC 1 on pin X5\n"
"dac.write(128)          # write a value to the DAC (makes X5 1.65V)\n"
"\n"
"dac = DAC(1, bits=12)   # use 12 bit resolution\n"
"dac.write(4095)         # output maximum value, 3.3V"
msgstr ""

#: ../../../library/pyb.DAC.rst:22
msgid "To output a continuous sine-wave::"
msgstr ""

#: ../../../library/pyb.DAC.rst:24
msgid ""
"import math\n"
"from pyb import DAC\n"
"\n"
"# create a buffer containing a sine-wave\n"
"buf = bytearray(100)\n"
"for i in range(len(buf)):\n"
"    buf[i] = 128 + int(127 * math.sin(2 * math.pi * i / len(buf)))\n"
"\n"
"# output the sine-wave at 400Hz\n"
"dac = DAC(1)\n"
"dac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)"
msgstr ""

#: ../../../library/pyb.DAC.rst:36
msgid "To output a continuous sine-wave at 12-bit resolution::"
msgstr ""

#: ../../../library/pyb.DAC.rst:38
msgid ""
"import math\n"
"from array import array\n"
"from pyb import DAC\n"
"\n"
"# create a buffer containing a sine-wave, using half-word samples\n"
"buf = array('H', 2048 + int(2047 * math.sin(2 * math.pi * i / 128)) for i"
" in range(128))\n"
"\n"
"# output the sine-wave at 400Hz\n"
"dac = DAC(1, bits=12)\n"
"dac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)"
msgstr ""

#: ../../../library/pyb.DAC.rst:54
msgid "Construct a new DAC object."
msgstr ""

#: ../../../library/pyb.DAC.rst:56
msgid ""
"``port`` can be a pin object, or an integer (1 or 2). DAC(1) is on pin X5"
" and DAC(2) is on pin X6."
msgstr ""

#: ../../../library/pyb.DAC.rst:59
msgid ""
"``bits`` is an integer specifying the resolution, and can be 8 or 12. The"
" maximum value for the write and write_timed methods will be "
"2\\*\\*``bits``-1."
msgstr ""

#: ../../../library/pyb.DAC.rst:63
msgid ""
"The *buffering* parameter selects the behaviour of the DAC op-amp output "
"buffer, whose purpose is to reduce the output impedance.  It can be "
"``None`` to select the default (buffering enabled for :meth:`DAC.noise`, "
":meth:`DAC.triangle` and :meth:`DAC.write_timed`, and disabled for "
":meth:`DAC.write`), ``False`` to disable buffering completely, or "
"``True`` to enable output buffering."
msgstr ""

#: ../../../library/pyb.DAC.rst:70
msgid ""
"When buffering is enabled the DAC pin can drive loads down to 5KΩ. "
"Otherwise it has an output impedance of 15KΩ maximum: consequently to "
"achieve a 1% accuracy without buffering requires the applied load to be "
"less than 1.5MΩ.  Using the buffer incurs a penalty in accuracy, "
"especially near the extremes of range."
msgstr ""

#: ../../../library/pyb.DAC.rst:81
msgid ""
"Reinitialise the DAC.  *bits* can be 8 or 12.  *buffering* can be "
"``None``, ``False`` or ``True``; see above constructor for the meaning of"
" this parameter."
msgstr ""

#: ../../../library/pyb.DAC.rst:87
msgid "De-initialise the DAC making its pin available for other uses."
msgstr ""

#: ../../../library/pyb.DAC.rst:91
msgid ""
"Generate a pseudo-random noise signal.  A new random sample is written to"
" the DAC output at the given frequency."
msgstr ""

#: ../../../library/pyb.DAC.rst:96
msgid ""
"Generate a triangle wave.  The value on the DAC output changes at the "
"given frequency, and the frequency of the repeating triangle wave itself "
"is 2048 times smaller."
msgstr ""

#: ../../../library/pyb.DAC.rst:102
msgid ""
"Direct access to the DAC output.  The minimum value is 0.  The maximum "
"value is 2\\*\\*``bits``-1, where ``bits`` is set when creating the DAC "
"object or by using the ``init`` method."
msgstr ""

#: ../../../library/pyb.DAC.rst:108
msgid ""
"Initiates a burst of RAM to DAC using a DMA transfer. The input data is "
"treated as an array of bytes in 8-bit mode, and an array of unsigned "
"half-words (array typecode 'H') in 12-bit mode."
msgstr ""

#: ../../../library/pyb.DAC.rst:112
msgid ""
"``freq`` can be an integer specifying the frequency to write the DAC "
"samples at, using Timer(6).  Or it can be an already-initialised Timer "
"object which is used to trigger the DAC sample.  Valid timers are 2, 4, "
"5, 6, 7 and 8."
msgstr ""

#: ../../../library/pyb.DAC.rst:117
msgid "``mode`` can be ``DAC.NORMAL`` or ``DAC.CIRCULAR``."
msgstr ""

#: ../../../library/pyb.DAC.rst:119
msgid "Example using both DACs at the same time::"
msgstr ""

#: ../../../library/pyb.DAC.rst:121
msgid ""
"dac1 = DAC(1)\n"
"dac2 = DAC(2)\n"
"dac1.write_timed(buf1, pyb.Timer(6, freq=100), mode=DAC.CIRCULAR)\n"
"dac2.write_timed(buf2, pyb.Timer(7, freq=200), mode=DAC.CIRCULAR)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:5
msgid "class ExtInt -- configure I/O pins to interrupt on external events"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:7
msgid ""
"There are a total of 22 interrupt lines. 16 of these can come from GPIO "
"pins and the remaining 6 are from internal sources."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:10
msgid ""
"For lines 0 through 15, a given line can map to the corresponding line "
"from an arbitrary port. So line 0 can map to Px0 where x is A, B, C, ... "
"and line 1 can map to Px1 where x is A, B, C, ... ::"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:14
msgid ""
"def callback(line):\n"
"    print(\"line =\", line)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:17
msgid "Note: ExtInt will automatically configure the gpio line as an input. ::"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:19
msgid ""
"extint = pyb.ExtInt(pin, pyb.ExtInt.IRQ_FALLING, pyb.Pin.PULL_UP, "
"callback)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:21
msgid ""
"Now every time a falling edge is seen on the X1 pin, the callback will be"
" called. Caution: mechanical pushbuttons have \"bounce\" and pushing or "
"releasing a switch will often generate multiple edges. See: "
"http://www.eng.utah.edu/~cs5780/debouncing.pdf for a detailed "
"explanation, along with various techniques for debouncing."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:27
msgid "Trying to register 2 callbacks onto the same pin will throw an exception."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:29
msgid ""
"If pin is passed as an integer, then it is assumed to map to one of the "
"internal interrupt sources, and must be in the range 16 through 22."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:32
msgid ""
"All other pin objects go through the pin mapper to come up with one of "
"the gpio pins. ::"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:35
msgid "extint = pyb.ExtInt(pin, mode, pull, callback)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:37
msgid ""
"Valid modes are pyb.ExtInt.IRQ_RISING, pyb.ExtInt.IRQ_FALLING, "
"pyb.ExtInt.IRQ_RISING_FALLING, pyb.ExtInt.EVT_RISING, "
"pyb.ExtInt.EVT_FALLING, and pyb.ExtInt.EVT_RISING_FALLING."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:41
msgid ""
"Only the IRQ_xxx modes have been tested. The EVT_xxx modes have something"
" to do with sleep mode and the WFE instruction."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:44
msgid ""
"Valid pull values are pyb.Pin.PULL_UP, pyb.Pin.PULL_DOWN, "
"pyb.Pin.PULL_NONE."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:46
msgid ""
"There is also a C API, so that drivers which require EXTI interrupt lines"
" can also use this code. See extint.h for the available functions and "
"usrsw.h for an example of using this."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:56
msgid "Create an ExtInt object:"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:58
msgid ""
"``pin`` is the pin on which to enable the interrupt (can be a pin object "
"or any valid pin name)."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:59
msgid ""
"``mode`` can be one of: - ``ExtInt.IRQ_RISING`` - trigger on a rising "
"edge; - ``ExtInt.IRQ_FALLING`` - trigger on a falling edge; - "
"``ExtInt.IRQ_RISING_FALLING`` - trigger on a rising or falling edge."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:63
msgid ""
"``pull`` can be one of: - ``pyb.Pin.PULL_NONE`` - no pull up or down "
"resistors; - ``pyb.Pin.PULL_UP`` - enable the pull-up resistor; - "
"``pyb.Pin.PULL_DOWN`` - enable the pull-down resistor."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:67
msgid ""
"``callback`` is the function to call when the interrupt triggers.  The "
"callback function must accept exactly 1 argument, which is the line that "
"triggered the interrupt."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:73 ../../../library/pyb.Pin.rst:83
msgid "Class methods"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:77
msgid "Dump the values of the EXTI registers."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:85
msgid ""
"Disable the interrupt associated with the ExtInt object. This could be "
"useful for debouncing."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:90
msgid "Enable a disabled interrupt."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:94
msgid "Return the line number that the pin is mapped to."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:98
msgid "Trigger the callback from software."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:106
msgid "interrupt on a falling edge"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:110
msgid "interrupt on a rising edge"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:114
msgid "interrupt on a rising or falling edge"
msgstr ""

#: ../../../library/pyb.I2C.rst:15
msgid ""
"from pyb import I2C\n"
"\n"
"i2c = I2C(1)                         # create on bus 1\n"
"i2c = I2C(1, I2C.MASTER)             # create and init as a master\n"
"i2c.init(I2C.MASTER, baudrate=20000) # init as a master\n"
"i2c.init(I2C.SLAVE, addr=0x42)       # init as a slave with given address"
"\n"
"i2c.deinit()                         # turn off the peripheral"
msgstr ""

#: ../../../library/pyb.I2C.rst:23
msgid "Printing the i2c object gives you information about its configuration."
msgstr ""

#: ../../../library/pyb.I2C.rst:25
msgid "The basic methods are send and recv::"
msgstr ""

#: ../../../library/pyb.I2C.rst:27
msgid ""
"i2c.send('abc')      # send 3 bytes\n"
"i2c.send(0x42)       # send a single byte, given by the number\n"
"data = i2c.recv(3)   # receive 3 bytes"
msgstr ""

#: ../../../library/pyb.I2C.rst:31
msgid "To receive inplace, first create a bytearray::"
msgstr ""

#: ../../../library/pyb.I2C.rst:33
msgid ""
"data = bytearray(3)  # create a buffer\n"
"i2c.recv(data)       # receive 3 bytes, writing them into data"
msgstr ""

#: ../../../library/pyb.I2C.rst:36
msgid "You can specify a timeout (in ms)::"
msgstr ""

#: ../../../library/pyb.I2C.rst:38
msgid "i2c.send(b'123', timeout=2000)   # timeout after 2 seconds"
msgstr ""

#: ../../../library/pyb.I2C.rst:40
msgid "A master must specify the recipient's address::"
msgstr ""

#: ../../../library/pyb.I2C.rst:42
msgid ""
"i2c.init(I2C.MASTER)\n"
"i2c.send('123', 0x42)        # send 3 bytes to slave with address 0x42\n"
"i2c.send(b'456', addr=0x42)  # keyword for address"
msgstr ""

#: ../../../library/pyb.I2C.rst:46
msgid "Master also has other methods::"
msgstr ""

#: ../../../library/pyb.I2C.rst:48
msgid ""
"i2c.is_ready(0x42)           # check if slave 0x42 is ready\n"
"i2c.scan()                   # scan for slaves on the bus, returning\n"
"                             #   a list of valid addresses\n"
"i2c.mem_read(3, 0x42, 2)     # read 3 bytes from memory of slave 0x42,\n"
"                             #   starting at address 2 in the slave\n"
"i2c.mem_write('abc', 0x42, 2, timeout=1000) # write 'abc' (3 bytes) to "
"memory of slave 0x42\n"
"                                            # starting at address 2 in "
"the slave, timeout after 1 second"
msgstr ""

#: ../../../library/pyb.I2C.rst:61
msgid ""
"Construct an I2C object on the given bus.  ``bus`` can be 1 or 2, 'X' or "
"'Y'. With no additional parameters, the I2C object is created but not "
"initialised (it has the settings from the last initialisation of the bus,"
" if any).  If extra arguments are given, the bus is initialised. See "
"``init`` for parameters of initialisation."
msgstr ""

#: ../../../library/pyb.I2C.rst:67
msgid "The physical pins of the I2C busses on Pyboards V1.0 and V1.1 are:"
msgstr ""

#: ../../../library/pyb.I2C.rst:69 ../../../library/pyb.I2C.rst:74
msgid "``I2C(1)`` is on the X position: ``(SCL, SDA) = (X9, X10) = (PB6, PB7)``"
msgstr ""

#: ../../../library/pyb.I2C.rst:70
msgid "``I2C(2)`` is on the Y position: ``(SCL, SDA) = (Y9, Y10) = (PB10, PB11)``"
msgstr ""

#: ../../../library/pyb.I2C.rst:72
msgid "On the Pyboard Lite:"
msgstr ""

#: ../../../library/pyb.I2C.rst:75
msgid "``I2C(3)`` is on the Y position: ``(SCL, SDA) = (Y9, Y10) = (PA8, PB8)``"
msgstr ""

#: ../../../library/pyb.I2C.rst:77
msgid ""
"Calling the constructor with 'X' or 'Y' enables portability between "
"Pyboard types."
msgstr ""

#: ../../../library/pyb.I2C.rst:89
msgid "Initialise the I2C bus with the given parameters:"
msgstr ""

#: ../../../library/pyb.I2C.rst:91
msgid "``mode`` must be either ``I2C.MASTER`` or ``I2C.SLAVE``"
msgstr ""

#: ../../../library/pyb.I2C.rst:92
msgid "``addr`` is the 7-bit address (only sensible for a slave)"
msgstr ""

#: ../../../library/pyb.I2C.rst:93
msgid "``baudrate`` is the SCL clock rate (only sensible for a master)"
msgstr ""

#: ../../../library/pyb.I2C.rst:94
msgid "``gencall`` is whether to support general call mode"
msgstr ""

#: ../../../library/pyb.I2C.rst:95
msgid ""
"``dma`` is whether to allow the use of DMA for the I2C transfers (note "
"that DMA transfers have more precise timing but currently do not handle "
"bus errors properly)"
msgstr ""

#: ../../../library/pyb.I2C.rst:101
msgid ""
"Check if an I2C device responds to the given address.  Only valid when in"
" master mode."
msgstr ""

#: ../../../library/pyb.I2C.rst:105
msgid "Read from the memory of an I2C device:"
msgstr ""

#: ../../../library/pyb.I2C.rst:107
msgid ""
"``data`` can be an integer (number of bytes to read) or a buffer to read "
"into"
msgstr ""

#: ../../../library/pyb.I2C.rst:108 ../../../library/pyb.I2C.rst:121
msgid "``addr`` is the I2C device address"
msgstr ""

#: ../../../library/pyb.I2C.rst:109 ../../../library/pyb.I2C.rst:122
msgid "``memaddr`` is the memory location within the I2C device"
msgstr ""

#: ../../../library/pyb.I2C.rst:110
msgid "``timeout`` is the timeout in milliseconds to wait for the read"
msgstr ""

#: ../../../library/pyb.I2C.rst:111 ../../../library/pyb.I2C.rst:124
msgid "``addr_size`` selects width of memaddr: 8 or 16 bits"
msgstr ""

#: ../../../library/pyb.I2C.rst:113
msgid "Returns the read data. This is only valid in master mode."
msgstr ""

#: ../../../library/pyb.I2C.rst:118
msgid "Write to the memory of an I2C device:"
msgstr ""

#: ../../../library/pyb.I2C.rst:120
msgid "``data`` can be an integer or a buffer to write from"
msgstr ""

#: ../../../library/pyb.I2C.rst:123
msgid "``timeout`` is the timeout in milliseconds to wait for the write"
msgstr ""

#: ../../../library/pyb.I2C.rst:126
msgid "Returns ``None``. This is only valid in master mode."
msgstr ""

#: ../../../library/pyb.I2C.rst:133
msgid ""
"``recv`` can be an integer, which is the number of bytes to receive, or a"
" mutable buffer, which will be filled with received bytes"
msgstr ""

#: ../../../library/pyb.I2C.rst:135
msgid "``addr`` is the address to receive from (only required in master mode)"
msgstr ""

#: ../../../library/pyb.I2C.rst:136
msgid "``timeout`` is the timeout in milliseconds to wait for the receive"
msgstr ""

#: ../../../library/pyb.I2C.rst:138 ../../../library/pyb.SPI.rst:87
msgid ""
"Return value: if ``recv`` is an integer then a new buffer of the bytes "
"received, otherwise the same buffer that was passed in to ``recv``."
msgstr ""

#: ../../../library/pyb.I2C.rst:143 ../../../library/pyb.SPI.rst:92
msgid "Send data on the bus:"
msgstr ""

#: ../../../library/pyb.I2C.rst:145
msgid "``send`` is the data to send (an integer to send, or a buffer object)"
msgstr ""

#: ../../../library/pyb.I2C.rst:146
msgid "``addr`` is the address to send to (only required in master mode)"
msgstr ""

#: ../../../library/pyb.I2C.rst:147
msgid "``timeout`` is the timeout in milliseconds to wait for the send"
msgstr ""

#: ../../../library/pyb.I2C.rst:153
msgid ""
"Scan all I2C addresses from 0x01 to 0x7f and return a list of those that "
"respond. Only valid when in master mode."
msgstr ""

#: ../../../library/pyb.I2C.rst:161
msgid "for initialising the bus to master mode"
msgstr ""

#: ../../../library/pyb.I2C.rst:165
msgid "for initialising the bus to slave mode"
msgstr ""

#: ../../../library/pyb.LCD.rst:5
msgid "class LCD -- LCD control for the LCD touch-sensor pyskin"
msgstr ""

#: ../../../library/pyb.LCD.rst:7
msgid ""
"The LCD class is used to control the LCD on the LCD touch-sensor pyskin, "
"LCD32MKv1.0.  The LCD is a 128x32 pixel monochrome screen, part NHD-"
"C12832A1Z."
msgstr ""

#: ../../../library/pyb.LCD.rst:10
msgid ""
"The pyskin must be connected in either the X or Y positions, and then an "
"LCD object is made using::"
msgstr ""

#: ../../../library/pyb.LCD.rst:13
msgid ""
"lcd = pyb.LCD('X')      # if pyskin is in the X position\n"
"lcd = pyb.LCD('Y')      # if pyskin is in the Y position"
msgstr ""

#: ../../../library/pyb.LCD.rst:16
msgid "Then you can use::"
msgstr ""

#: ../../../library/pyb.LCD.rst:18
msgid ""
"lcd.light(True)                 # turn the backlight on\n"
"lcd.write('Hello world!\\n')     # print text to the screen"
msgstr ""

#: ../../../library/pyb.LCD.rst:21
msgid ""
"This driver implements a double buffer for setting/getting pixels. For "
"example, to make a bouncing dot, try::"
msgstr ""

#: ../../../library/pyb.LCD.rst:24
msgid ""
"x = y = 0\n"
"dx = dy = 1\n"
"while True:\n"
"    # update the dot's position\n"
"    x += dx\n"
"    y += dy\n"
"\n"
"    # make the dot bounce of the edges of the screen\n"
"    if x <= 0 or x >= 127: dx = -dx\n"
"    if y <= 0 or y >= 31: dy = -dy\n"
"\n"
"    lcd.fill(0)                 # clear the buffer\n"
"    lcd.pixel(x, y, 1)          # draw the dot\n"
"    lcd.show()                  # show the buffer\n"
"    pyb.delay(50)               # pause for 50ms"
msgstr ""

#: ../../../library/pyb.LCD.rst:46
msgid ""
"Construct an LCD object in the given skin position.  ``skin_position`` "
"can be 'X' or 'Y', and should match the position where the LCD pyskin is "
"plugged in."
msgstr ""

#: ../../../library/pyb.LCD.rst:55
msgid ""
"Send an arbitrary command to the LCD.  Pass 0 for ``instr_data`` to send "
"an instruction, otherwise pass 1 to send data.  ``buf`` is a buffer with "
"the instructions/data to send."
msgstr ""

#: ../../../library/pyb.LCD.rst:61
msgid "Set the contrast of the LCD.  Valid values are between 0 and 47."
msgstr ""

#: ../../../library/pyb.LCD.rst:65
msgid "Fill the screen with the given colour (0 or 1 for white or black)."
msgstr ""

#: ../../../library/pyb.LCD.rst:67 ../../../library/pyb.LCD.rst:83
#: ../../../library/pyb.LCD.rst:93
msgid ""
"This method writes to the hidden buffer.  Use ``show()`` to show the "
"buffer."
msgstr ""

#: ../../../library/pyb.LCD.rst:71
msgid "Get the pixel at the position ``(x, y)``.  Returns 0 or 1."
msgstr ""

#: ../../../library/pyb.LCD.rst:73
msgid "This method reads from the visible buffer."
msgstr ""

#: ../../../library/pyb.LCD.rst:77
msgid ""
"Turn the backlight on/off.  True or 1 turns it on, False or 0 turns it "
"off."
msgstr ""

#: ../../../library/pyb.LCD.rst:81
msgid "Set the pixel at ``(x, y)`` to the given colour (0 or 1)."
msgstr ""

#: ../../../library/pyb.LCD.rst:87
msgid "Show the hidden buffer on the screen."
msgstr ""

#: ../../../library/pyb.LCD.rst:91
msgid ""
"Draw the given text to the position ``(x, y)`` using the given colour (0 "
"or 1)."
msgstr ""

#: ../../../library/pyb.LCD.rst:97
msgid "Write the string ``str`` to the screen.  It will appear immediately."
msgstr ""

#: ../../../library/pyb.LED.rst:5
msgid "class LED -- LED object"
msgstr ""

#: ../../../library/pyb.LED.rst:7
msgid "The LED object controls an individual LED (Light Emitting Diode)."
msgstr ""

#: ../../../library/pyb.LED.rst:15
msgid "Create an LED object associated with the given LED:"
msgstr ""

#: ../../../library/pyb.LED.rst:17
msgid "``id`` is the LED number, 1-4."
msgstr ""

#: ../../../library/pyb.LED.rst:25
msgid ""
"Get or set the LED intensity.  Intensity ranges between 0 (off) and 255 "
"(full on). If no argument is given, return the LED intensity. If an "
"argument is given, set the LED intensity and return ``None``."
msgstr ""

#: ../../../library/pyb.LED.rst:29
msgid ""
"*Note:* Only LED(3) and LED(4) can have a smoothly varying intensity, and"
" they use timer PWM to implement it.  LED(3) uses Timer(2) and LED(4) "
"uses Timer(3).  These timers are only configured for PWM if the intensity"
" of the relevant LED is set to a value between 1 and 254.  Otherwise the "
"timers are free for general purpose use."
msgstr ""

#: ../../../library/pyb.LED.rst:37
msgid "Turn the LED off."
msgstr ""

#: ../../../library/pyb.LED.rst:41
msgid "Turn the LED on, to maximum intensity."
msgstr ""

#: ../../../library/pyb.LED.rst:45
msgid ""
"Toggle the LED between on (maximum intensity) and off.  If the LED is at "
"non-zero intensity then it is considered \"on\" and toggle will turn it "
"off."
msgstr ""

#: ../../../library/pyb.Pin.rst:7
msgid ""
"A pin is the basic object to control I/O pins.  It has methods to set the"
" mode of the pin (input, output, etc) and methods to get and set the "
"digital logic level. For analog control of a pin, see the ADC class."
msgstr ""

#: ../../../library/pyb.Pin.rst:11
msgid "Usage Model:"
msgstr ""

#: ../../../library/pyb.Pin.rst:13
msgid "All Board Pins are predefined as pyb.Pin.board.Name::"
msgstr ""

#: ../../../library/pyb.Pin.rst:15
msgid ""
"x1_pin = pyb.Pin.board.X1\n"
"\n"
"g = pyb.Pin(pyb.Pin.board.X1, pyb.Pin.IN)"
msgstr ""

#: ../../../library/pyb.Pin.rst:19
msgid ""
"CPU pins which correspond to the board pins are available as "
"``pyb.Pin.cpu.Name``. For the CPU pins, the names are the port letter "
"followed by the pin number. On the PYBv1.0, ``pyb.Pin.board.X1`` and "
"``pyb.Pin.cpu.A0`` are the same pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:24
msgid "You can also use strings::"
msgstr ""

#: ../../../library/pyb.Pin.rst:26
msgid "g = pyb.Pin('X1', pyb.Pin.OUT_PP)"
msgstr ""

#: ../../../library/pyb.Pin.rst:28
msgid "Users can add their own names::"
msgstr ""

#: ../../../library/pyb.Pin.rst:30
msgid ""
"MyMapperDict = { 'LeftMotorDir' : pyb.Pin.cpu.C12 }\n"
"pyb.Pin.dict(MyMapperDict)\n"
"g = pyb.Pin(\"LeftMotorDir\", pyb.Pin.OUT_OD)"
msgstr ""

#: ../../../library/pyb.Pin.rst:34
msgid "and can query mappings::"
msgstr ""

#: ../../../library/pyb.Pin.rst:36
msgid "pin = pyb.Pin(\"LeftMotorDir\")"
msgstr ""

#: ../../../library/pyb.Pin.rst:38
msgid "Users can also add their own mapping function::"
msgstr ""

#: ../../../library/pyb.Pin.rst:40
msgid ""
"def MyMapper(pin_name):\n"
"   if pin_name == \"LeftMotorDir\":\n"
"       return pyb.Pin.cpu.A0\n"
"\n"
"pyb.Pin.mapper(MyMapper)"
msgstr ""

#: ../../../library/pyb.Pin.rst:46
msgid ""
"So, if you were to call: ``pyb.Pin(\"LeftMotorDir\", pyb.Pin.OUT_PP)`` "
"then ``\"LeftMotorDir\"`` is passed directly to the mapper function."
msgstr ""

#: ../../../library/pyb.Pin.rst:49
msgid ""
"To summarise, the following order determines how things get mapped into "
"an ordinal pin number:"
msgstr ""

#: ../../../library/pyb.Pin.rst:52
msgid "Directly specify a pin object"
msgstr ""

#: ../../../library/pyb.Pin.rst:53
msgid "User supplied mapping function"
msgstr ""

#: ../../../library/pyb.Pin.rst:54
msgid "User supplied mapping (object must be usable as a dictionary key)"
msgstr ""

#: ../../../library/pyb.Pin.rst:55
msgid "Supply a string which matches a board pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:56
msgid "Supply a string which matches a CPU port/pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:58
msgid ""
"You can set ``pyb.Pin.debug(True)`` to get some debug information about "
"how a particular object gets mapped to a pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:61
msgid ""
"When a pin has the ``Pin.PULL_UP`` or ``Pin.PULL_DOWN`` pull-mode "
"enabled, that pin has an effective 40k Ohm resistor pulling it to 3V3 or "
"GND respectively (except pin Y5 which has 11k Ohm resistors)."
msgstr ""

#: ../../../library/pyb.Pin.rst:65
msgid ""
"Now every time a falling edge is seen on the gpio pin, the callback will "
"be executed. Caution: mechanical push buttons have \"bounce\" and pushing"
" or releasing a switch will often generate multiple edges. See: "
"http://www.eng.utah.edu/~cs5780/debouncing.pdf for a detailed "
"explanation, along with various techniques for debouncing."
msgstr ""

#: ../../../library/pyb.Pin.rst:71
msgid ""
"All pin objects go through the pin mapper to come up with one of the gpio"
" pins."
msgstr ""

#: ../../../library/pyb.Pin.rst:79
msgid ""
"Create a new Pin object associated with the id.  If additional arguments "
"are given, they are used to initialise the pin.  See :meth:`pin.init`."
msgstr ""

#: ../../../library/pyb.Pin.rst:87
msgid "Get or set the debugging state (``True`` or ``False`` for on or off)."
msgstr ""

#: ../../../library/pyb.Pin.rst:91
msgid "Get or set the pin mapper dictionary."
msgstr ""

#: ../../../library/pyb.Pin.rst:95
msgid "Get or set the pin mapper function."
msgstr ""

#: ../../../library/pyb.Pin.rst:103
msgid "Initialise the pin:"
msgstr ""

#: ../../../library/pyb.Pin.rst:107
msgid "``Pin.IN`` - configure the pin for input;"
msgstr ""

#: ../../../library/pyb.Pin.rst:108
msgid "``Pin.OUT_PP`` - configure the pin for output, with push-pull control;"
msgstr ""

#: ../../../library/pyb.Pin.rst:109
msgid "``Pin.OUT_OD`` - configure the pin for output, with open-drain control;"
msgstr ""

#: ../../../library/pyb.Pin.rst:110
msgid "``Pin.AF_PP`` - configure the pin for alternate function, pull-pull;"
msgstr ""

#: ../../../library/pyb.Pin.rst:111
msgid "``Pin.AF_OD`` - configure the pin for alternate function, open-drain;"
msgstr ""

#: ../../../library/pyb.Pin.rst:112
msgid "``Pin.ANALOG`` - configure the pin for analog."
msgstr ""

#: ../../../library/pyb.Pin.rst:114
msgid "``pull`` can be one of:"
msgstr ""

#: ../../../library/pyb.Pin.rst:116
msgid "``Pin.PULL_NONE`` - no pull up or down resistors;"
msgstr ""

#: ../../../library/pyb.Pin.rst:117
msgid "``Pin.PULL_UP`` - enable the pull-up resistor;"
msgstr ""

#: ../../../library/pyb.Pin.rst:118
msgid "``Pin.PULL_DOWN`` - enable the pull-down resistor."
msgstr ""

#: ../../../library/pyb.Pin.rst:120
msgid ""
"when mode is ``Pin.AF_PP`` or ``Pin.AF_OD``, then af can be the index or "
"name of one of the alternate functions associated with a pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:123
msgid "Returns: ``None``."
msgstr ""

#: ../../../library/pyb.Pin.rst:127
msgid "Get or set the digital logic level of the pin:"
msgstr ""

#: ../../../library/pyb.Pin.rst:129
msgid "With no argument, return 0 or 1 depending on the logic level of the pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:130
msgid ""
"With ``value`` given, set the logic level of the pin.  ``value`` can be "
"anything that converts to a boolean.  If it converts to ``True``, the pin"
" is set high, otherwise it is set low."
msgstr ""

#: ../../../library/pyb.Pin.rst:136
msgid "Return a string describing the pin object."
msgstr ""

#: ../../../library/pyb.Pin.rst:140
msgid ""
"Returns the currently configured alternate-function of the pin. The "
"integer returned will match one of the allowed constants for the af "
"argument to the init function."
msgstr ""

#: ../../../library/pyb.Pin.rst:146
msgid "Returns an array of alternate functions available for this pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:150
msgid "Returns the base address of the GPIO block associated with this pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:154
msgid ""
"Returns the currently configured mode of the pin. The integer returned "
"will match one of the allowed constants for the mode argument to the init"
" function."
msgstr ""

#: ../../../library/pyb.Pin.rst:160
msgid "Get the pin name."
msgstr ""

#: ../../../library/pyb.Pin.rst:164
msgid "Returns the cpu and board names for this pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:168
msgid "Get the pin number."
msgstr ""

#: ../../../library/pyb.Pin.rst:172
msgid "Get the pin port."
msgstr ""

#: ../../../library/pyb.Pin.rst:176
msgid ""
"Returns the currently configured pull of the pin. The integer returned "
"will match one of the allowed constants for the pull argument to the init"
" function."
msgstr ""

#: ../../../library/pyb.Pin.rst:185
msgid "initialise the pin to alternate-function mode with an open-drain drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:189
msgid "initialise the pin to alternate-function mode with a push-pull drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:193
msgid "initialise the pin to analog mode"
msgstr ""

#: ../../../library/pyb.Pin.rst:197
msgid "initialise the pin to input mode"
msgstr ""

#: ../../../library/pyb.Pin.rst:201
msgid "initialise the pin to output mode with an open-drain drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:205
msgid "initialise the pin to output mode with a push-pull drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:209
msgid "enable the pull-down resistor on the pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:213
msgid "don't enable any pull up or down resistors on the pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:217
msgid "enable the pull-up resistor on the pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:220
msgid "class PinAF -- Pin Alternate Functions"
msgstr ""

#: ../../../library/pyb.Pin.rst:222
msgid ""
"A Pin represents a physical pin on the microprocessor. Each pin can have "
"a variety of functions (GPIO, I2C SDA, etc). Each PinAF object represents"
" a particular function for a pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:228
msgid ""
"x3 = pyb.Pin.board.X3\n"
"x3_af = x3.af_list()"
msgstr ""

#: ../../../library/pyb.Pin.rst:231
msgid ""
"x3_af will now contain an array of PinAF objects which are available on "
"pin X3."
msgstr ""

#: ../../../library/pyb.Pin.rst:235
msgid "For the pyboard, x3_af would contain:"
msgstr ""

#: ../../../library/pyb.Pin.rst:235
msgid "[Pin.AF1_TIM2, Pin.AF2_TIM5, Pin.AF3_TIM9, Pin.AF7_USART2]"
msgstr ""

#: ../../../library/pyb.Pin.rst:237
msgid ""
"Normally, each peripheral would configure the af automatically, but "
"sometimes the same function is available on multiple pins, and having "
"more control is desired."
msgstr ""

#: ../../../library/pyb.Pin.rst:241
msgid "To configure X3 to expose TIM2_CH3, you could use::"
msgstr ""

#: ../../../library/pyb.Pin.rst:243
msgid "pin = pyb.Pin(pyb.Pin.board.X3, mode=pyb.Pin.AF_PP, af=pyb.Pin.AF1_TIM2)"
msgstr ""

#: ../../../library/pyb.Pin.rst:247
msgid "pin = pyb.Pin(pyb.Pin.board.X3, mode=pyb.Pin.AF_PP, af=1)"
msgstr ""

#: ../../../library/pyb.Pin.rst:254
msgid "Return a string describing the alternate function."
msgstr ""

#: ../../../library/pyb.Pin.rst:258
msgid "Return the alternate function index."
msgstr ""

#: ../../../library/pyb.Pin.rst:262
msgid "Return the name of the alternate function."
msgstr ""

#: ../../../library/pyb.Pin.rst:266
msgid ""
"Return the base register associated with the peripheral assigned to this "
"alternate function. For example, if the alternate function were TIM2_CH3 "
"this would return stm.TIM2"
msgstr ""

#: ../../../library/pyb.RTC.rst:12
msgid ""
"rtc = pyb.RTC()\n"
"rtc.datetime((2014, 5, 1, 4, 13, 0, 0, 0))\n"
"print(rtc.datetime())"
msgstr ""

#: ../../../library/pyb.RTC.rst:22
msgid "Create an RTC object."
msgstr ""

#: ../../../library/pyb.RTC.rst:30
msgid "Get or set the date and time of the RTC."
msgstr ""

#: ../../../library/pyb.RTC.rst:32
msgid ""
"With no arguments, this method returns an 8-tuple with the current date "
"and time.  With 1 argument (being an 8-tuple) it sets the date and time "
"(and ``subseconds`` is reset to 255)."
msgstr ""

#: ../../../library/pyb.RTC.rst:36
msgid "The 8-tuple has the following format:"
msgstr ""

#: ../../../library/pyb.RTC.rst:38
msgid "(year, month, day, weekday, hours, minutes, seconds, subseconds)"
msgstr ""

#: ../../../library/pyb.RTC.rst:40
msgid "``weekday`` is 1-7 for Monday through Sunday."
msgstr ""

#: ../../../library/pyb.RTC.rst:42
msgid "``subseconds`` counts down from 255 to 0"
msgstr ""

#: ../../../library/pyb.RTC.rst:46
msgid ""
"Set the RTC wakeup timer to trigger repeatedly at every ``timeout`` "
"milliseconds.  This trigger can wake the pyboard from both the sleep "
"states: :meth:`pyb.stop` and :meth:`pyb.standby`."
msgstr ""

#: ../../../library/pyb.RTC.rst:50
msgid "If ``timeout`` is ``None`` then the wakeup timer is disabled."
msgstr ""

#: ../../../library/pyb.RTC.rst:52
msgid ""
"If ``callback`` is given then it is executed at every trigger of the "
"wakeup timer.  ``callback`` must take exactly one argument."
msgstr ""

#: ../../../library/pyb.RTC.rst:57
msgid "Get information about the startup time and reset source."
msgstr ""

#: ../../../library/pyb.RTC.rst:59
msgid "The lower 0xffff are the number of milliseconds the RTC took to start up."
msgstr ""

#: ../../../library/pyb.RTC.rst:61
msgid "Bit 0x10000 is set if a power-on reset occurred."
msgstr ""

#: ../../../library/pyb.RTC.rst:62
msgid "Bit 0x20000 is set if an external reset occurred"
msgstr ""

#: ../../../library/pyb.RTC.rst:66
msgid "Get or set RTC calibration."
msgstr ""

#: ../../../library/pyb.RTC.rst:68
msgid ""
"With no arguments, ``calibration()`` returns the current calibration "
"value, which is an integer in the range [-511 : 512].  With one argument "
"it sets the RTC calibration."
msgstr ""

#: ../../../library/pyb.RTC.rst:72
msgid ""
"The RTC Smooth Calibration mechanism adjusts the RTC clock rate by adding"
" or subtracting the given number of ticks from the 32768 Hz clock over a "
"32 second period (corresponding to 2^20 clock ticks.) Each tick added "
"will speed up the clock by 1 part in 2^20, or 0.954 ppm; likewise the RTC"
" clock it slowed by negative values. The usable calibration range is: "
"(-511 * 0.954) ~= -487.5 ppm up to (512 * 0.954) ~= 488.5 ppm"
msgstr ""

#: ../../../library/pyb.SPI.rst:5
msgid "class SPI -- a master-driven serial protocol"
msgstr ""

#: ../../../library/pyb.SPI.rst:7
msgid ""
"SPI is a serial protocol that is driven by a master.  At the physical "
"level there are 3 lines: SCK, MOSI, MISO."
msgstr ""

#: ../../../library/pyb.SPI.rst:10
msgid ""
"See usage model of I2C; SPI is very similar.  Main difference is "
"parameters to init the SPI bus::"
msgstr ""

#: ../../../library/pyb.SPI.rst:13
msgid ""
"from pyb import SPI\n"
"spi = SPI(1, SPI.MASTER, baudrate=600000, polarity=1, phase=0, crc=0x7)"
msgstr ""

#: ../../../library/pyb.SPI.rst:16
msgid ""
"Only required parameter is mode, SPI.MASTER or SPI.SLAVE.  Polarity can "
"be 0 or 1, and is the level the idle clock line sits at.  Phase can be 0 "
"or 1 to sample data on the first or second clock edge respectively.  Crc "
"can be None for no CRC, or a polynomial specifier."
msgstr ""

#: ../../../library/pyb.SPI.rst:21
msgid "Additional methods for SPI::"
msgstr ""

#: ../../../library/pyb.SPI.rst:23
msgid ""
"data = spi.send_recv(b'1234')        # send 4 bytes and receive 4 bytes\n"
"buf = bytearray(4)\n"
"spi.send_recv(b'1234', buf)          # send 4 bytes and receive 4 into "
"buf\n"
"spi.send_recv(buf, buf)              # send/recv 4 bytes from/to buf"
msgstr ""

#: ../../../library/pyb.SPI.rst:33
msgid ""
"Construct an SPI object on the given bus.  ``bus`` can be 1 or 2, or 'X' "
"or 'Y'. With no additional parameters, the SPI object is created but not "
"initialised (it has the settings from the last initialisation of the bus,"
" if any).  If extra arguments are given, the bus is initialised. See "
"``init`` for parameters of initialisation."
msgstr ""

#: ../../../library/pyb.SPI.rst:39
msgid "The physical pins of the SPI busses are:"
msgstr ""

#: ../../../library/pyb.SPI.rst:41
msgid ""
"``SPI(1)`` is on the X position: ``(NSS, SCK, MISO, MOSI) = (X5, X6, X7, "
"X8) = (PA4, PA5, PA6, PA7)``"
msgstr ""

#: ../../../library/pyb.SPI.rst:42
msgid ""
"``SPI(2)`` is on the Y position: ``(NSS, SCK, MISO, MOSI) = (Y5, Y6, Y7, "
"Y8) = (PB12, PB13, PB14, PB15)``"
msgstr ""

#: ../../../library/pyb.SPI.rst:44
msgid ""
"At the moment, the NSS pin is not used by the SPI driver and is free for "
"other use."
msgstr ""

#: ../../../library/pyb.SPI.rst:58
msgid "``mode`` must be either ``SPI.MASTER`` or ``SPI.SLAVE``."
msgstr ""

#: ../../../library/pyb.SPI.rst:59
msgid "``baudrate`` is the SCK clock rate (only sensible for a master)."
msgstr ""

#: ../../../library/pyb.SPI.rst:60
msgid ""
"``prescaler`` is the prescaler to use to derive SCK from the APB bus "
"frequency; use of ``prescaler`` overrides ``baudrate``."
msgstr ""

#: ../../../library/pyb.SPI.rst:65
msgid ""
"``bits`` can be 8 or 16, and is the number of bits in each transferred "
"word."
msgstr ""

#: ../../../library/pyb.SPI.rst:67
msgid "``crc`` can be None for no CRC, or a polynomial specifier."
msgstr ""

#: ../../../library/pyb.SPI.rst:69
msgid ""
"Note that the SPI clock frequency will not always be the requested "
"baudrate. The hardware only supports baudrates that are the APB bus "
"frequency (see :meth:`pyb.freq`) divided by a prescaler, which can be 2, "
"4, 8, 16, 32, 64, 128 or 256.  SPI(1) is on AHB2, and SPI(2) is on AHB1."
"  For precise control over the SPI clock frequency, specify ``prescaler``"
" instead of ``baudrate``."
msgstr ""

#: ../../../library/pyb.SPI.rst:76
msgid ""
"Printing the SPI object will show you the computed baudrate and the "
"chosen prescaler."
msgstr ""

#: ../../../library/pyb.SPI.rst:83
msgid ""
"``recv`` can be an integer, which is the number of bytes to receive, or a"
" mutable buffer, which will be filled with received bytes."
msgstr ""

#: ../../../library/pyb.SPI.rst:85 ../../../library/pyb.SPI.rst:107
#: ../../../library/pyb.USB_HID.rst:30 ../../../library/pyb.USB_VCP.rst:91
msgid "``timeout`` is the timeout in milliseconds to wait for the receive."
msgstr ""

#: ../../../library/pyb.SPI.rst:94 ../../../library/pyb.SPI.rst:103
msgid "``send`` is the data to send (an integer to send, or a buffer object)."
msgstr ""

#: ../../../library/pyb.SPI.rst:95 ../../../library/pyb.USB_VCP.rst:101
msgid "``timeout`` is the timeout in milliseconds to wait for the send."
msgstr ""

#: ../../../library/pyb.SPI.rst:101
msgid "Send and receive data on the bus at the same time:"
msgstr ""

#: ../../../library/pyb.SPI.rst:104
msgid ""
"``recv`` is a mutable buffer which will be filled with received bytes. It"
" can be the same as ``send``, or omitted.  If omitted, a new buffer will "
"be created."
msgstr ""

#: ../../../library/pyb.SPI.rst:109
msgid "Return value: the buffer with the received bytes."
msgstr ""

#: ../../../library/pyb.SPI.rst:117
msgid "for initialising the SPI bus to master or slave mode"
msgstr ""

#: ../../../library/pyb.SPI.rst:122
msgid "set the first bit to be the least or most significant bit"
msgstr ""

#: ../../../library/pyb.Servo.rst:5
msgid "class Servo -- 3-wire hobby servo driver"
msgstr ""

#: ../../../library/pyb.Servo.rst:7
msgid ""
"Servo objects control standard hobby servo motors with 3-wires (ground, "
"power, signal).  There are 4 positions on the pyboard where these motors "
"can be plugged in: pins X1 through X4 are the signal pins, and next to "
"them are 4 sets of power and ground pins."
msgstr ""

#: ../../../library/pyb.Servo.rst:14
msgid ""
"import pyb\n"
"\n"
"s1 = pyb.Servo(1)   # create a servo object on position X1\n"
"s2 = pyb.Servo(2)   # create a servo object on position X2\n"
"\n"
"s1.angle(45)        # move servo 1 to 45 degrees\n"
"s2.angle(0)         # move servo 2 to 0 degrees\n"
"\n"
"# move servo1 and servo2 synchronously, taking 1500ms\n"
"s1.angle(-60, 1500)\n"
"s2.angle(30, 1500)"
msgstr ""

#: ../../../library/pyb.Servo.rst:26
msgid ""
"The Servo objects use Timer(5) to produce the PWM output.  You can use "
"Timer(5) for Servo control, or your own purposes, but not both at the "
"same time."
msgstr ""

#: ../../../library/pyb.Servo.rst:35
msgid ""
"Create a servo object.  ``id`` is 1-4, and corresponds to pins X1 through"
" X4."
msgstr ""

#: ../../../library/pyb.Servo.rst:43
msgid "If no arguments are given, this function returns the current angle."
msgstr ""

#: ../../../library/pyb.Servo.rst:45
msgid "If arguments are given, this function sets the angle of the servo:"
msgstr ""

#: ../../../library/pyb.Servo.rst:47
msgid "``angle`` is the angle to move to in degrees."
msgstr ""

#: ../../../library/pyb.Servo.rst:48
msgid ""
"``time`` is the number of milliseconds to take to get to the specified "
"angle.  If omitted, then the servo moves as quickly as possible to its "
"new position."
msgstr ""

#: ../../../library/pyb.Servo.rst:54
msgid "If no arguments are given, this function returns the current speed."
msgstr ""

#: ../../../library/pyb.Servo.rst:56
msgid "If arguments are given, this function sets the speed of the servo:"
msgstr ""

#: ../../../library/pyb.Servo.rst:58
msgid "``speed`` is the speed to change to, between -100 and 100."
msgstr ""

#: ../../../library/pyb.Servo.rst:59
msgid ""
"``time`` is the number of milliseconds to take to get to the specified "
"speed.  If omitted, then the servo accelerates as quickly as possible."
msgstr ""

#: ../../../library/pyb.Servo.rst:64
msgid ""
"If no arguments are given, this function returns the current raw pulse-"
"width value."
msgstr ""

#: ../../../library/pyb.Servo.rst:67
msgid "If an argument is given, this function sets the raw pulse-width value."
msgstr ""

#: ../../../library/pyb.Servo.rst:71
msgid ""
"If no arguments are given, this function returns the current calibration "
"data, as a 5-tuple."
msgstr ""

#: ../../../library/pyb.Servo.rst:74
msgid "If arguments are given, this function sets the timing calibration:"
msgstr ""

#: ../../../library/pyb.Servo.rst:76
msgid "``pulse_min`` is the minimum allowed pulse width."
msgstr ""

#: ../../../library/pyb.Servo.rst:77
msgid "``pulse_max`` is the maximum allowed pulse width."
msgstr ""

#: ../../../library/pyb.Servo.rst:78
msgid ""
"``pulse_centre`` is the pulse width corresponding to the centre/zero "
"position."
msgstr ""

#: ../../../library/pyb.Servo.rst:79
msgid "``pulse_angle_90`` is the pulse width corresponding to 90 degrees."
msgstr ""

#: ../../../library/pyb.Servo.rst:80
msgid "``pulse_speed_100`` is the pulse width corresponding to a speed of 100."
msgstr ""

#: ../../../library/pyb.Switch.rst:5
msgid "class Switch -- switch object"
msgstr ""

#: ../../../library/pyb.Switch.rst:7
msgid "A Switch object is used to control a push-button switch."
msgstr ""

#: ../../../library/pyb.Switch.rst:11
msgid ""
"sw = pyb.Switch()       # create a switch object\n"
"sw.value()              # get state (True if pressed, False otherwise)\n"
"sw()                    # shorthand notation to get the switch state\n"
"sw.callback(f)          # register a callback to be called when the\n"
"                        #   switch is pressed down\n"
"sw.callback(None)       # remove the callback"
msgstr ""

#: ../../../library/pyb.Switch.rst:20
msgid "pyb.Switch().callback(lambda: pyb.LED(1).toggle())"
msgstr ""

#: ../../../library/pyb.Switch.rst:28
msgid "Create and return a switch object."
msgstr ""

#: ../../../library/pyb.Switch.rst:36
msgid ""
"Call switch object directly to get its state: ``True`` if pressed down, "
"``False`` otherwise."
msgstr ""

#: ../../../library/pyb.Switch.rst:41
msgid ""
"Get the switch state.  Returns ``True`` if pressed down, otherwise "
"``False``."
msgstr ""

#: ../../../library/pyb.Switch.rst:45
msgid ""
"Register the given function to be called when the switch is pressed down."
" If ``fun`` is ``None``, then it disables the callback."
msgstr ""

#: ../../../library/pyb.Timer.rst:5
msgid "class Timer -- control internal timers"
msgstr ""

#: ../../../library/pyb.Timer.rst:7
msgid ""
"Timers can be used for a great variety of tasks.  At the moment, only the"
" simplest case is implemented: that of calling a function periodically."
msgstr ""

#: ../../../library/pyb.Timer.rst:10
msgid ""
"Each timer consists of a counter that counts up at a certain rate.  The "
"rate at which it counts is the peripheral clock frequency (in Hz) divided"
" by the timer prescaler.  When the counter reaches the timer period it "
"triggers an event, and the counter resets back to zero.  By using the "
"callback method, the timer event can call a Python function."
msgstr ""

#: ../../../library/pyb.Timer.rst:16
msgid "Example usage to toggle an LED at a fixed frequency::"
msgstr ""

#: ../../../library/pyb.Timer.rst:18
msgid ""
"tim = pyb.Timer(4)              # create a timer object using timer 4\n"
"tim.init(freq=2)                # trigger at 2Hz\n"
"tim.callback(lambda t:pyb.LED(1).toggle())"
msgstr ""

#: ../../../library/pyb.Timer.rst:22
msgid "Example using named function for the callback::"
msgstr ""

#: ../../../library/pyb.Timer.rst:24
msgid ""
"def tick(timer):                # we will receive the timer object when "
"being called\n"
"    print(timer.counter())      # show current timer's counter value\n"
"tim = pyb.Timer(4, freq=1)      # create a timer object using timer 4 - "
"trigger at 1Hz\n"
"tim.callback(tick)              # set the callback to our tick function"
msgstr ""

#: ../../../library/pyb.Timer.rst:29
msgid "Further examples::"
msgstr ""

#: ../../../library/pyb.Timer.rst:31
msgid ""
"tim = pyb.Timer(4, freq=100)    # freq in Hz\n"
"tim = pyb.Timer(4, prescaler=0, period=99)\n"
"tim.counter()                   # get counter (can also set)\n"
"tim.prescaler(2)                # set prescaler (can also get)\n"
"tim.period(199)                 # set period (can also get)\n"
"tim.callback(lambda t: ...)     # set callback for update interrupt "
"(t=tim instance)\n"
"tim.callback(None)              # clear callback"
msgstr ""

#: ../../../library/pyb.Timer.rst:39
msgid ""
"*Note:* Timer(2) and Timer(3) are used for PWM to set the intensity of "
"LED(3) and LED(4) respectively.  But these timers are only configured for"
" PWM if the intensity of the relevant LED is set to a value between 1 and"
" 254.  If the intensity feature of the LEDs is not used then these timers"
" are free for general purpose use.  Similarly, Timer(5) controls the "
"servo driver, and Timer(6) is used for timed ADC/DAC reading/writing.  It"
" is recommended to use the other timers in your programs."
msgstr ""

#: ../../../library/pyb.Timer.rst:47
msgid ""
"*Note:* Memory can't be allocated during a callback (an interrupt) and so"
" exceptions raised within a callback don't give much information.  See "
":func:`micropython.alloc_emergency_exception_buf` for how to get around "
"this limitation."
msgstr ""

#: ../../../library/pyb.Timer.rst:58
msgid ""
"Construct a new timer object of the given id.  If additional arguments "
"are given, then the timer is initialised by ``init(...)``. ``id`` can be "
"1 to 14."
msgstr ""

#: ../../../library/pyb.Timer.rst:67
msgid ""
"Initialise the timer.  Initialisation must be either by frequency (in Hz)"
" or by prescaler and period::"
msgstr ""

#: ../../../library/pyb.Timer.rst:70
msgid ""
"tim.init(freq=100)                  # set the timer to trigger at 100Hz\n"
"tim.init(prescaler=83, period=999)  # set the prescaler and period "
"directly"
msgstr ""

#: ../../../library/pyb.Timer.rst:75
msgid ""
"``freq`` --- specifies the periodic frequency of the timer. You might "
"also view this as the frequency with which the timer goes through one "
"complete cycle."
msgstr ""

#: ../../../library/pyb.Timer.rst:78
msgid ""
"``prescaler`` [0-0xffff] - specifies the value to be loaded into the "
"timer's Prescaler Register (PSC). The timer clock source is divided by "
"(``prescaler + 1``) to arrive at the timer clock. Timers 2-7 and 12-14 "
"have a clock source of 84 MHz (pyb.freq()[2] \\* 2), and Timers 1, and "
"8-11 have a clock source of 168 MHz (pyb.freq()[3] \\* 2)."
msgstr ""

#: ../../../library/pyb.Timer.rst:84
msgid ""
"``period`` [0-0xffff] for timers 1, 3, 4, and 6-15. [0-0x3fffffff] for "
"timers 2 & 5. Specifies the value to be loaded into the timer's "
"AutoReload Register (ARR). This determines the period of the timer (i.e. "
"when the counter cycles). The timer counter will roll-over after ``period"
" + 1`` timer clock cycles."
msgstr ""

#: ../../../library/pyb.Timer.rst:92
msgid "``Timer.UP`` - configures the timer to count from 0 to ARR (default)"
msgstr ""

#: ../../../library/pyb.Timer.rst:93
msgid "``Timer.DOWN`` - configures the timer to count from ARR down to 0."
msgstr ""

#: ../../../library/pyb.Timer.rst:94
msgid ""
"``Timer.CENTER`` - configures the timer to count from 0 to ARR and then "
"back down to 0."
msgstr ""

#: ../../../library/pyb.Timer.rst:97
msgid ""
"``div`` can be one of 1, 2, or 4. Divides the timer clock to determine "
"the sampling clock used by the digital filters."
msgstr ""

#: ../../../library/pyb.Timer.rst:100
msgid "``callback`` - as per Timer.callback()"
msgstr ""

#: ../../../library/pyb.Timer.rst:102
msgid ""
"``deadtime`` - specifies the amount of \"dead\" or inactive time between "
"transitions on complimentary channels (both channels will be inactive) "
"for this time). ``deadtime`` may be an integer between 0 and 1008, with "
"the following restrictions: 0-128 in steps of 1. 128-256 in steps of 2, "
"256-512 in steps of 8, and 512-1008 in steps of 16. ``deadtime`` measures"
" ticks of ``source_freq`` divided by ``div`` clock ticks. ``deadtime`` is"
" only available on timers 1 and 8."
msgstr ""

#: ../../../library/pyb.Timer.rst:110
msgid "You must either specify freq or both of period and prescaler."
msgstr ""

#: ../../../library/pyb.Timer.rst:114
msgid "Deinitialises the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:116
msgid "Disables the callback (and the associated irq)."
msgstr ""

#: ../../../library/pyb.Timer.rst:118
msgid ""
"Disables any channel callbacks (and the associated irq). Stops the timer,"
" and disables the timer peripheral."
msgstr ""

#: ../../../library/pyb.Timer.rst:123
msgid ""
"Set the function to be called when the timer triggers. ``fun`` is passed "
"1 argument, the timer object. If ``fun`` is ``None`` then the callback "
"will be disabled."
msgstr ""

#: ../../../library/pyb.Timer.rst:129
msgid ""
"If only a channel number is passed, then a previously initialized channel"
" object is returned (or ``None`` if there is no previous channel)."
msgstr ""

#: ../../../library/pyb.Timer.rst:134
msgid ""
"Each channel can be configured to perform pwm, output compare, or input "
"capture. All channels share the same underlying timer, which means that "
"they share the same timer clock."
msgstr ""

#: ../../../library/pyb.Timer.rst:142
msgid "``Timer.PWM`` --- configure the timer in PWM mode (active high)."
msgstr ""

#: ../../../library/pyb.Timer.rst:143
msgid "``Timer.PWM_INVERTED`` --- configure the timer in PWM mode (active low)."
msgstr ""

#: ../../../library/pyb.Timer.rst:144
msgid "``Timer.OC_TIMING`` --- indicates that no pin is driven."
msgstr ""

#: ../../../library/pyb.Timer.rst:145
msgid ""
"``Timer.OC_ACTIVE`` --- the pin will be made active when a compare match "
"occurs (active is determined by polarity)"
msgstr ""

#: ../../../library/pyb.Timer.rst:146
msgid ""
"``Timer.OC_INACTIVE`` --- the pin will be made inactive when a compare "
"match occurs."
msgstr ""

#: ../../../library/pyb.Timer.rst:147
msgid ""
"``Timer.OC_TOGGLE`` --- the pin will be toggled when an compare match "
"occurs."
msgstr ""

#: ../../../library/pyb.Timer.rst:148
msgid ""
"``Timer.OC_FORCED_ACTIVE`` --- the pin is forced active (compare match is"
" ignored)."
msgstr ""

#: ../../../library/pyb.Timer.rst:149
msgid ""
"``Timer.OC_FORCED_INACTIVE`` --- the pin is forced inactive (compare "
"match is ignored)."
msgstr ""

#: ../../../library/pyb.Timer.rst:150
msgid "``Timer.IC`` --- configure the timer in Input Capture mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:151
msgid ""
"``Timer.ENC_A`` --- configure the timer in Encoder mode. The counter only"
" changes when CH1 changes."
msgstr ""

#: ../../../library/pyb.Timer.rst:152
msgid ""
"``Timer.ENC_B`` --- configure the timer in Encoder mode. The counter only"
" changes when CH2 changes."
msgstr ""

#: ../../../library/pyb.Timer.rst:153
msgid ""
"``Timer.ENC_AB`` --- configure the timer in Encoder mode. The counter "
"changes when CH1 or CH2 changes."
msgstr ""

#: ../../../library/pyb.Timer.rst:155
msgid "``callback`` - as per TimerChannel.callback()"
msgstr ""

#: ../../../library/pyb.Timer.rst:157
msgid ""
"``pin`` None (the default) or a Pin object. If specified (and not None) "
"this will cause the alternate function of the the indicated pin to be "
"configured for this timer channel. An error will be raised if the pin "
"doesn't support any alternate functions for this timer channel."
msgstr ""

#: ../../../library/pyb.Timer.rst:162
msgid "Keyword arguments for Timer.PWM modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:164
msgid "``pulse_width`` - determines the initial pulse width value to use."
msgstr ""

#: ../../../library/pyb.Timer.rst:165
msgid ""
"``pulse_width_percent`` - determines the initial pulse width percentage "
"to use."
msgstr ""

#: ../../../library/pyb.Timer.rst:167
msgid "Keyword arguments for Timer.OC modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:169
msgid "``compare`` - determines the initial value of the compare register."
msgstr ""

#: ../../../library/pyb.Timer.rst:171 ../../../library/pyb.Timer.rst:178
msgid "``polarity`` can be one of:"
msgstr ""

#: ../../../library/pyb.Timer.rst:173
msgid "``Timer.HIGH`` - output is active high"
msgstr ""

#: ../../../library/pyb.Timer.rst:174
msgid "``Timer.LOW`` - output is active low"
msgstr ""

#: ../../../library/pyb.Timer.rst:176
msgid "Optional keyword arguments for Timer.IC modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:180
msgid "``Timer.RISING`` - captures on rising edge."
msgstr ""

#: ../../../library/pyb.Timer.rst:181
msgid "``Timer.FALLING`` - captures on falling edge."
msgstr ""

#: ../../../library/pyb.Timer.rst:182
msgid "``Timer.BOTH`` - captures on both edges."
msgstr ""

#: ../../../library/pyb.Timer.rst:184
msgid ""
"Note that capture only works on the primary channel, and not on the "
"complimentary channels."
msgstr ""

#: ../../../library/pyb.Timer.rst:187
msgid "Notes for Timer.ENC modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:189
msgid ""
"Requires 2 pins, so one or both pins will need to be configured to use "
"the appropriate timer AF using the Pin API."
msgstr ""

#: ../../../library/pyb.Timer.rst:191
msgid "Read the encoder value using the timer.counter() method."
msgstr ""

#: ../../../library/pyb.Timer.rst:192
msgid "Only works on CH1 and CH2 (and not on CH1N or CH2N)"
msgstr ""

#: ../../../library/pyb.Timer.rst:193
msgid "The channel number is ignored when setting the encoder mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:195
msgid "PWM Example::"
msgstr ""

#: ../../../library/pyb.Timer.rst:197
msgid ""
"timer = pyb.Timer(2, freq=1000)\n"
"ch2 = timer.channel(2, pyb.Timer.PWM, pin=pyb.Pin.board.X2, "
"pulse_width=8000)\n"
"ch3 = timer.channel(3, pyb.Timer.PWM, pin=pyb.Pin.board.X3, "
"pulse_width=16000)"
msgstr ""

#: ../../../library/pyb.Timer.rst:203
msgid "Get or set the timer counter."
msgstr ""

#: ../../../library/pyb.Timer.rst:207
msgid ""
"Get or set the frequency for the timer (changes prescaler and period if "
"set)."
msgstr ""

#: ../../../library/pyb.Timer.rst:211
msgid "Get or set the period of the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:215
msgid "Get or set the prescaler for the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:219
msgid "Get the frequency of the source of the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:233
msgid ""
"Set the function to be called when the timer channel triggers. ``fun`` is"
" passed 1 argument, the timer object. If ``fun`` is ``None`` then the "
"callback will be disabled."
msgstr ""

#: ../../../library/pyb.Timer.rst:239
msgid ""
"Get or set the capture value associated with a channel. capture, compare,"
" and pulse_width are all aliases for the same function. capture is the "
"logical name to use when the channel is in input capture mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:245
msgid ""
"Get or set the compare value associated with a channel. capture, compare,"
" and pulse_width are all aliases for the same function. compare is the "
"logical name to use when the channel is in output compare mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:251
msgid ""
"Get or set the pulse width value associated with a channel. capture, "
"compare, and pulse_width are all aliases for the same function. "
"pulse_width is the logical name to use when the channel is in PWM mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:255
msgid ""
"In edge aligned mode, a pulse_width of ``period + 1`` corresponds to a "
"duty cycle of 100% In center aligned mode, a pulse width of ``period`` "
"corresponds to a duty cycle of 100%"
msgstr ""

#: ../../../library/pyb.Timer.rst:260
msgid ""
"Get or set the pulse width percentage associated with a channel.  The "
"value is a number between 0 and 100 and sets the percentage of the timer "
"period for which the pulse is active.  The value can be an integer or "
"floating-point number for more accuracy.  For example, a value of 25 "
"gives a duty cycle of 25%."
msgstr ""

#: ../../../library/pyb.UART.rst:14
msgid ""
"from pyb import UART\n"
"\n"
"uart = UART(1, 9600)                         # init with given baudrate\n"
"uart.init(9600, bits=8, parity=None, stop=1) # init with given parameters"
msgstr ""

#: ../../../library/pyb.UART.rst:19
msgid ""
"Bits can be 7, 8 or 9.  Parity can be None, 0 (even) or 1 (odd).  Stop "
"can be 1 or 2."
msgstr ""

#: ../../../library/pyb.UART.rst:21 ../../../library/pyb.UART.rst:93
msgid ""
"*Note:* with parity=None, only 8 and 9 bits are supported.  With parity "
"enabled, only 7 and 8 bits are supported."
msgstr ""

#: ../../../library/pyb.UART.rst:33
msgid "Individual characters can be read/written using::"
msgstr ""

#: ../../../library/pyb.UART.rst:35
msgid ""
"uart.readchar()     # read 1 character and returns it as an integer\n"
"uart.writechar(42)  # write 1 character"
msgstr ""

#: ../../../library/pyb.UART.rst:38
msgid "To check if there is anything to be read, use::"
msgstr ""

#: ../../../library/pyb.UART.rst:40
msgid "uart.any()          # returns the number of characters waiting"
msgstr ""

#: ../../../library/pyb.UART.rst:43
msgid ""
"*Note:* The stream functions ``read``, ``write``, etc. are new in "
"MicroPython v1.3.4. Earlier versions use ``uart.send`` and ``uart.recv``."
msgstr ""

#: ../../../library/pyb.UART.rst:51
msgid ""
"Construct a UART object on the given bus.  ``bus`` can be 1-6, or 'XA', "
"'XB', 'YA', or 'YB'. With no additional parameters, the UART object is "
"created but not initialised (it has the settings from the last "
"initialisation of the bus, if any).  If extra arguments are given, the "
"bus is initialised. See ``init`` for parameters of initialisation."
msgstr ""

#: ../../../library/pyb.UART.rst:57
msgid "The physical pins of the UART busses are:"
msgstr ""

#: ../../../library/pyb.UART.rst:59
msgid "``UART(4)`` is on ``XA``: ``(TX, RX) = (X1, X2) = (PA0, PA1)``"
msgstr ""

#: ../../../library/pyb.UART.rst:60
msgid "``UART(1)`` is on ``XB``: ``(TX, RX) = (X9, X10) = (PB6, PB7)``"
msgstr ""

#: ../../../library/pyb.UART.rst:61
msgid "``UART(6)`` is on ``YA``: ``(TX, RX) = (Y1, Y2) = (PC6, PC7)``"
msgstr ""

#: ../../../library/pyb.UART.rst:62
msgid "``UART(3)`` is on ``YB``: ``(TX, RX) = (Y9, Y10) = (PB10, PB11)``"
msgstr ""

#: ../../../library/pyb.UART.rst:63
msgid "``UART(2)`` is on: ``(TX, RX) = (X3, X4) = (PA2, PA3)``"
msgstr ""

#: ../../../library/pyb.UART.rst:65
msgid ""
"The Pyboard Lite supports UART(1), UART(2) and UART(6) only. Pins are as "
"above except:"
msgstr ""

#: ../../../library/pyb.UART.rst:67
msgid "``UART(2)`` is on: ``(TX, RX) = (X1, X2) = (PA2, PA3)``"
msgstr ""

#: ../../../library/pyb.UART.rst:76
msgid "``baudrate`` is the clock rate."
msgstr ""

#: ../../../library/pyb.UART.rst:77
msgid "``bits`` is the number of bits per character, 7, 8 or 9."
msgstr ""

#: ../../../library/pyb.UART.rst:78
msgid "``parity`` is the parity, ``None``, 0 (even) or 1 (odd)."
msgstr ""

#: ../../../library/pyb.UART.rst:79
msgid "``stop`` is the number of stop bits, 1 or 2."
msgstr ""

#: ../../../library/pyb.UART.rst:80
msgid ""
"``flow`` sets the flow control type. Can be 0, ``UART.RTS``, ``UART.CTS``"
" or ``UART.RTS | UART.CTS``."
msgstr ""

#: ../../../library/pyb.UART.rst:82
msgid ""
"``timeout`` is the timeout in milliseconds to wait for writing/reading "
"the first character."
msgstr ""

#: ../../../library/pyb.UART.rst:83
msgid ""
"``timeout_char`` is the timeout in milliseconds to wait between "
"characters while writing or reading."
msgstr ""

#: ../../../library/pyb.UART.rst:84
msgid ""
"``read_buf_len`` is the character length of the read buffer (0 to "
"disable)."
msgstr ""

#: ../../../library/pyb.UART.rst:86
#, python-format
msgid ""
"This method will raise an exception if the baudrate could not be set "
"within 5% of the desired value.  The minimum baudrate is dictated by the "
"frequency of the bus that the UART is on; UART(1) and UART(6) are APB2, "
"the rest are on APB1.  The default bus frequencies give a minimum "
"baudrate of 1300 for UART(1) and UART(6) and 650 for the others.  Use "
":func:`pyb.freq <pyb.freq>` to reduce the bus frequencies to get lower "
"baudrates."
msgstr ""

#: ../../../library/pyb.UART.rst:102
msgid "Returns the number of bytes waiting (may be 0)."
msgstr ""

#: ../../../library/pyb.UART.rst:106
msgid ""
"Read characters.  If ``nbytes`` is specified then read at most that many "
"bytes. If ``nbytes`` are available in the buffer, returns immediately, "
"otherwise returns when sufficient characters arrive or the timeout "
"elapses."
msgstr ""

#: ../../../library/pyb.UART.rst:110
msgid ""
"If ``nbytes`` is not given then the method reads as much data as "
"possible.  It returns after the timeout has elapsed."
msgstr ""

#: ../../../library/pyb.UART.rst:113
msgid ""
"*Note:* for 9 bit characters each character takes two bytes, ``nbytes`` "
"must be even, and the number of characters is ``nbytes/2``."
msgstr ""

#: ../../../library/pyb.UART.rst:121
msgid "Receive a single character on the bus."
msgstr ""

#: ../../../library/pyb.UART.rst:123
msgid "Return value: The character read, as an integer.  Returns -1 on timeout."
msgstr ""

#: ../../../library/pyb.UART.rst:135
msgid ""
"Read a line, ending in a newline character. If such a line exists, return"
" is immediate. If the timeout elapses, all available data is returned "
"regardless of whether a newline exists."
msgstr ""

#: ../../../library/pyb.UART.rst:139
msgid ""
"Return value: the line read or ``None`` on timeout if no data is "
"available."
msgstr ""

#: ../../../library/pyb.UART.rst:143
msgid ""
"Write the buffer of bytes to the bus.  If characters are 7 or 8 bits wide"
" then each byte is one character.  If characters are 9 bits wide then two"
" bytes are used for each character (little endian), and ``buf`` must "
"contain an even number of bytes."
msgstr ""

#: ../../../library/pyb.UART.rst:148
msgid ""
"Return value: number of bytes written. If a timeout occurs and no bytes "
"were written returns ``None``."
msgstr ""

#: ../../../library/pyb.UART.rst:153
msgid ""
"Write a single character on the bus.  ``char`` is an integer to write. "
"Return value: ``None``. See note below if CTS flow control is used."
msgstr ""

#: ../../../library/pyb.UART.rst:158
msgid ""
"Send a break condition on the bus.  This drives the bus low for a "
"duration of 13 bits. Return value: ``None``."
msgstr ""

#: ../../../library/pyb.UART.rst:168
msgid "to select the flow control type."
msgstr ""

#: ../../../library/pyb.UART.rst:171
msgid "Flow Control"
msgstr ""

#: ../../../library/pyb.UART.rst:173
msgid ""
"On Pyboards V1 and V1.1 ``UART(2)`` and ``UART(3)`` support RTS/CTS "
"hardware flow control using the following pins:"
msgstr ""

#: ../../../library/pyb.UART.rst:176
msgid ""
"``UART(2)`` is on: ``(TX, RX, nRTS, nCTS) = (X3, X4, X2, X1) = (PA2, PA3,"
" PA1, PA0)``"
msgstr ""

#: ../../../library/pyb.UART.rst:177
msgid ""
"``UART(3)`` is on :``(TX, RX, nRTS, nCTS) = (Y9, Y10, Y7, Y6) = (PB10, "
"PB11, PB14, PB13)``"
msgstr ""

#: ../../../library/pyb.UART.rst:179
msgid "On the Pyboard Lite only ``UART(2)`` supports flow control on these pins:"
msgstr ""

#: ../../../library/pyb.UART.rst:181
msgid "``(TX, RX, nRTS, nCTS) = (X1, X2, X4, X3) = (PA2, PA3, PA1, PA0)``"
msgstr ""

#: ../../../library/pyb.UART.rst:183
msgid ""
"In the following paragraphs the term \"target\" refers to the device "
"connected to the UART."
msgstr ""

#: ../../../library/pyb.UART.rst:186
msgid ""
"When the UART's ``init()`` method is called with ``flow`` set to one or "
"both of ``UART.RTS`` and ``UART.CTS`` the relevant flow control pins are "
"configured. ``nRTS`` is an active low output, ``nCTS`` is an active low "
"input with pullup enabled. To achieve flow control the Pyboard's ``nCTS``"
" signal should be connected to the target's ``nRTS`` and the Pyboard's "
"``nRTS`` to the target's ``nCTS``."
msgstr ""

#: ../../../library/pyb.UART.rst:193
msgid "CTS: target controls Pyboard transmitter"
msgstr ""

#: ../../../library/pyb.UART.rst:195
msgid "If CTS flow control is enabled the write behaviour is as follows:"
msgstr ""

#: ../../../library/pyb.UART.rst:197
msgid ""
"If the Pyboard's ``UART.write(buf)`` method is called, transmission will "
"stall for any periods when ``nCTS`` is ``False``. This will result in a "
"timeout if the entire buffer was not transmitted in the timeout period. "
"The method returns the number of bytes written, enabling the user to "
"write the remainder of the data if required. In the event of a timeout, a"
" character will remain in the UART pending ``nCTS``. The number of bytes "
"composing this character will be included in the return value."
msgstr ""

#: ../../../library/pyb.UART.rst:204
msgid ""
"If ``UART.writechar()`` is called when ``nCTS`` is ``False`` the method "
"will time out unless the target asserts ``nCTS`` in time. If it times out"
" ``OSError 116`` will be raised. The character will be transmitted as "
"soon as the target asserts ``nCTS``."
msgstr ""

#: ../../../library/pyb.UART.rst:209
msgid "RTS: Pyboard controls target's transmitter"
msgstr ""

#: ../../../library/pyb.UART.rst:211
msgid "If RTS flow control is enabled, behaviour is as follows:"
msgstr ""

#: ../../../library/pyb.UART.rst:213
msgid ""
"If buffered input is used (``read_buf_len`` > 0), incoming characters are"
" buffered. If the buffer becomes full, the next character to arrive will "
"cause ``nRTS`` to go ``False``: the target should cease transmission. "
"``nRTS`` will go ``True`` when characters are read from the buffer."
msgstr ""

#: ../../../library/pyb.UART.rst:218
msgid ""
"Note that the ``any()`` method returns the number of bytes in the buffer."
" Assume a buffer length of ``N`` bytes. If the buffer becomes full, and "
"another character arrives, ``nRTS`` will be set False, and ``any()`` will"
" return the count ``N``. When characters are read the additional "
"character will be placed in the buffer and will be included in the result"
" of a subsequent ``any()`` call."
msgstr ""

#: ../../../library/pyb.UART.rst:224
msgid ""
"If buffered input is not used (``read_buf_len`` == 0) the arrival of a "
"character will cause ``nRTS`` to go ``False`` until the character is "
"read."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:5
msgid "class USB_HID -- USB Human Interface Device (HID)"
msgstr ""

#: ../../../library/pyb.USB_HID.rst:7
msgid ""
"The USB_HID class allows creation of an object representing the USB Human"
" Interface Device (HID) interface.  It can be used to emulate a "
"peripheral such as a mouse or keyboard."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:11
msgid ""
"Before you can use this class, you need to use :meth:`pyb.usb_mode()` to "
"set the USB mode to include the HID interface."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:18
msgid "Create a new USB_HID object."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:28 ../../../library/pyb.USB_VCP.rst:89
msgid ""
"``data`` can be an integer, which is the number of bytes to receive, or a"
" mutable buffer, which will be filled with received bytes."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:32 ../../../library/pyb.USB_VCP.rst:93
msgid ""
"Return value: if ``data`` is an integer then a new buffer of the bytes "
"received, otherwise the number of bytes read into ``data`` is returned."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:37
msgid "Send data over the USB HID interface:"
msgstr ""

#: ../../../library/pyb.USB_HID.rst:39
msgid "``data`` is the data to send (a tuple/list of integers, or a bytearray)."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:5
msgid "class USB_VCP -- USB virtual comm port"
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:7
msgid ""
"The USB_VCP class allows creation of a `stream`-like object representing "
"the USB virtual comm port.  It can be used to read and write data over "
"USB to the connected host."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:17
msgid "Create a new USB_VCP object."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:25
msgid ""
"Set the character which interrupts running Python code.  This is set to 3"
" (CTRL-C) by default, and when a CTRL-C character is received over the "
"USB VCP port, a KeyboardInterrupt exception is raised."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:29
msgid ""
"Set to -1 to disable this interrupt feature.  This is useful when you "
"want to send raw bytes over the USB VCP port."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:34
msgid "Return ``True`` if USB is connected as a serial device, else ``False``."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:38
msgid "Return ``True`` if any characters waiting, else ``False``."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:42
msgid ""
"This method does nothing.  It exists so the USB_VCP object can act as a "
"file."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:47
msgid ""
"Read at most ``nbytes`` from the serial device and return them as a bytes"
" object.  If ``nbytes`` is not specified then the method reads all "
"available bytes from the serial device. USB_VCP `stream` implicitly works"
" in non-blocking mode, so if no pending data available, this method will "
"return immediately with ``None`` value."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:56
msgid ""
"Read bytes from the serial device and store them into ``buf``, which "
"should be a buffer-like object.  At most ``len(buf)`` bytes are read. If "
"``maxlen`` is given and then at most ``min(maxlen, len(buf))`` bytes are "
"read."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:61
msgid ""
"Returns the number of bytes read and stored into ``buf`` or ``None`` if "
"no pending data available."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:66
msgid "Read a whole line from the serial device."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:68
msgid ""
"Returns a bytes object containing the data, including the trailing "
"newline character or ``None`` if no pending data available."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:73
msgid ""
"Read as much data as possible from the serial device, breaking it into "
"lines."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:76
msgid ""
"Returns a list of bytes objects, each object being one of the lines. Each"
" line will include the newline character."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:81
msgid "Write the bytes from ``buf`` to the serial device."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:83
msgid "Returns the number of bytes written."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:98
msgid "Send data over the USB VCP:"
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:100
msgid "``data`` is the data to send (an integer to send, or a buffer object)."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:103
msgid "Return value: number of bytes sent."
msgstr ""

#: ../../../library/sys.rst:2
msgid ":mod:`sys` -- system specific functions"
msgstr ":mod:`sys` -- システム固有関数"

#: ../../../library/sys.rst:7
msgid "|see_cpython_module| :mod:`python:sys`."
msgstr ""

#: ../../../library/sys.rst:14
msgid ""
"Terminate current program with a given exit code. Underlyingly, this "
"function raise as `SystemExit` exception. If an argument is given, its "
"value given as an argument to `SystemExit`."
msgstr ""
"与えた終了コードで現在のプログラムを終了します。基本的に、この関数は "
"`SystemExit` 例外を起こします。引数を与えた場合、その値は `SystemExit` "
"に引数として与えられます。"

#: ../../../library/sys.rst:20
msgid ""
"Print exception with a traceback to a file-like object *file* (or "
"`sys.stdout` by default)."
msgstr ""
"トレースバックを使用して例外をファイルライクなオブジェクト *file* (または"
"デフォルトの `sys.stdout`)に出力します。"

#: ../../../library/sys.rst:26
msgid ""
"This is simplified version of a function which appears in the "
"``traceback`` module in CPython. Unlike ``traceback.print_exception()``, "
"this function takes just exception value instead of exception type, "
"exception value, and traceback object; *file* argument should be "
"positional; further arguments are not supported. CPython-compatible "
"``traceback`` module can be found in `micropython-lib`."
msgstr ""
"これは CPython の ``traceback`` モジュールにある関数の簡略版です。"
"``traceback.print_exception()`` とは異なり、この関数は例外型、例外値、"
"トレースバックオブジェクトの代わりに例外値だけをとります。 *file* 引数は位置"
"パラメータでなければなりません。この他の引数はサポートされていません。"
"CPython 互換の ``traceback`` モジュールは `micropython-lib` にあります。"

#: ../../../library/sys.rst:38
msgid "A mutable list of arguments the current program was started with."
msgstr "現在のプログラム開始時の引数の変更可能なリスト。"

#: ../../../library/sys.rst:42
msgid "The byte order of the system (``\"little\"`` or ``\"big\"``)."
msgstr "システムのバイト順(``\"little\"`` または ``\"big\"``)。"

#: ../../../library/sys.rst:46
msgid ""
"Object with information about the current Python implementation. For "
"MicroPython, it has following attributes:"
msgstr ""
"現在の Python 実装に関する情報を持つオブジェクト。MicroPython では次の属性を持ちます:"

#: ../../../library/sys.rst:49
msgid "*name* - string \"micropython\""
msgstr "*name* - 文字列 \"micropython\""

#: ../../../library/sys.rst:50
msgid "*version* - tuple (major, minor, micro), e.g. (1, 7, 0)"
msgstr "*version* - タプル (major, minor, micro)。例: (1, 7, 0)"

#: ../../../library/sys.rst:52
msgid ""
"This object is the recommended way to distinguish MicroPython from other "
"Python implementations (note that it still may not exist in the very "
"minimal ports)."
msgstr ""
"このオブジェクトは、MicroPython を他の Python 実装と区別する推奨手段です(しかし、"
"最小限のポートには存在しないことに注意してください)。"

#: ../../../library/sys.rst:59
msgid ""
"CPython mandates more attributes for this object, but the actual useful "
"bare minimum is implemented in MicroPython."
msgstr ""
"CPython ではこのオブジェクトにもっと多くの属性がありますが、MicroPython では実際に"
"有用となる最低限のものだけを実装しています。"

#: ../../../library/sys.rst:64
msgid ""
"Maximum value which a native integer type can hold on the current "
"platform, or maximum value representable by MicroPython integer type, if "
"it's smaller than platform max value (that is the case for MicroPython "
"ports without long int support)."
msgstr ""
"現在のプラットフォームでネイティブ整数型が保持できる最大値、またはプラットフォームの"
"最大値より小さい場合は MicroPython 整数型で表現可能な最大値(MicroPython ポートで "
"long int をサポートしないとした場合)。"

#: ../../../library/sys.rst:69
msgid ""
"This attribute is useful for detecting \"bitness\" of a platform (32-bit "
"vs 64-bit, etc.). It's recommended to not compare this attribute to some "
"value directly, but instead count number of bits in it::"
msgstr ""
"この属性は、プラットフォームの「ビット数」(32ビットか64ビットかなど)を検出するのに"
"便利です。この属性をある値と直接比較するのよりも、その属性のビット数をカウントする"
"ことをお勧めします。"

#: ../../../library/sys.rst:73
msgid ""
"bits = 0\n"
"v = sys.maxsize\n"
"while v:\n"
"    bits += 1\n"
"    v >>= 1\n"
"if bits > 32:\n"
"    # 64-bit (or more) platform\n"
"    ...\n"
"else:\n"
"    # 32-bit (or less) platform\n"
"    # Note that on 32-bit platform, value of bits may be less than 32\n"
"    # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n"
"    # \"> 32\", \"> 64\" style of comparisons."
msgstr ""
"bits = 0\n"
"v = sys.maxsize\n"
"while v:\n"
"    bits += 1\n"
"    v >>= 1\n"
"if bits > 32:\n"
"    # 64ビット(以上)のプラットフォーム\n"
"    ...\n"
"else:\n"
"    # 32ビット(以下)のプラットフォーム\n"
"    # 32ビットプラットフォームでは、上記の特性によってビットの値が32未満\n"
"    # (たとえば31)になる可能性があるので、 \"> 16\", \"> 32\", \"> 64\" の\n"
"    # の比較スタイルを使用してください。"

#: ../../../library/sys.rst:89
msgid ""
"Dictionary of loaded modules. On some ports, it may not include builtin "
"modules."
msgstr ""
"読み込まれたモジュールの辞書。一部のポートでは、組込みモジュールが含まれていない"
"可能性があります。"

#: ../../../library/sys.rst:94
msgid "A mutable list of directories to search for imported modules."
msgstr "import するモジュールを検索するディレクトリの変更可能なリスト。"

#: ../../../library/sys.rst:98
msgid ""
"The platform that MicroPython is running on. For OS/RTOS ports, this is "
"usually an identifier of the OS, e.g. ``\"linux\"``. For baremetal ports "
"it is an identifier of a board, e.g. ``\"pyboard\"`` for the original "
"MicroPython reference board. It thus can be used to distinguish one board"
" from another. If you need to check whether your program runs on "
"MicroPython (vs other Python implementation), use `sys.implementation` "
"instead."
msgstr ""
"MicroPython が実行されているプラ​​ットフォーム。OS/RTOS ポートの場合、これは通常 "
"``\"linux\"`` など OS の識別子となります。ベアメタルポートの場合はボードの識別子"
"となります。オリジナルの MicroPython リファレンスボードでは ``\"pyboard\"`` "
"となります。したがって、これはあるボードを別のボードと区別するために使用できます。"
"あなたのプログラムが MicroPython 上で実行されているのか(それとも他の Python "
"実装で動いているのか)を確認する必要がある場合は代わりに ``sys.implementation`` "
"を使ってください。"

#: ../../../library/sys.rst:107
msgid "Standard error `stream`."
msgstr "標準エラーの `stream` 。"

#: ../../../library/sys.rst:111
msgid "Standard input `stream`."
msgstr "標準入力の `stream` 。"

#: ../../../library/sys.rst:115
msgid "Standard output `stream`."
msgstr "標準出力の `stream` 。"

#: ../../../library/sys.rst:119
msgid "Python language version that this implementation conforms to, as a string."
msgstr "この実装が準拠する Python 言語バージョン。"

#: ../../../library/sys.rst:123
msgid ""
"Python language version that this implementation conforms to, as a tuple "
"of ints."
msgstr ""
"この実装が準拠している Python 言語バージョンを表す int の タプル。"

#: ../../../library/ubinascii.rst:2
msgid ":mod:`ubinascii` -- binary/ASCII conversions"
msgstr ":mod:`ubinascii` -- バイナリ/ASCII 変換"

#: ../../../library/ubinascii.rst:7
msgid "|see_cpython_module| :mod:`python:binascii`."
msgstr ""

#: ../../../library/ubinascii.rst:9
msgid ""
"This module implements conversions between binary data and various "
"encodings of it in ASCII form (in both directions)."
msgstr ""
"このモジュールは、バイナリデータと ASCII 形式のさまざまなエンコーディングとの"
"間の変換(両方向)を実装します。"

#: ../../../library/ubinascii.rst:17
msgid "Convert binary data to hexadecimal representation. Returns bytes string."
msgstr "バイナリデータを16進表現に変換します。バイト列を返します。"

#: ../../../library/ubinascii.rst:22
msgid ""
"If additional argument, *sep* is supplied, it is used as a separator "
"between hexadecimal values."
msgstr ""
"追加の引数 *sep* が指定された場合、それは16進値の間のセパレータとして使われます。"

#: ../../../library/ubinascii.rst:27
msgid ""
"Convert hexadecimal data to binary representation. Returns bytes string. "
"(i.e. inverse of hexlify)"
msgstr ""
"16進データをバイナリ表現に変換します。バイト列を返します。(すなわち、hexlify の逆)"

#: ../../../library/ubinascii.rst:32
msgid ""
"Decode base64-encoded data, ignoring invalid characters in the input. "
"Conforms to `RFC 2045 s.6.8 "
"<https://tools.ietf.org/html/rfc2045#section-6.8>`_. Returns a bytes "
"object."
msgstr ""
"base64でエンコードされたデータをデコードします。入力中の無効な文字は無視します。"
"`RFC 2045 s.6.8 <https://tools.ietf.org/html/rfc2045#section-6.8>`_ "
"に準拠しています。バイト列を返します。"

#: ../../../library/ubinascii.rst:38
msgid ""
"Encode binary data in base64 format, as in `RFC 3548 "
"<https://tools.ietf.org/html/rfc3548.html>`_. Returns the encoded data "
"followed by a newline character, as a bytes object."
msgstr ""
"`RFC 3548 <https://tools.ietf.org/html/rfc3548.html>`_ "
"のように、バイナリデータをbase64形式でエンコードします。コード化されたデータの"
"後ろに改行文字を付けて、バイト列として返します。"

#: ../../../library/ucollections.rst:2
msgid ":mod:`ucollections` -- collection and container types"
msgstr ""

#: ../../../library/ucollections.rst:7
msgid "|see_cpython_module| :mod:`python:collections`."
msgstr ""

#: ../../../library/ucollections.rst:9
msgid ""
"This module implements advanced collection and container types to "
"hold/accumulate various objects."
msgstr ""

#: ../../../library/ucollections.rst:17
msgid ""
"Deques (double-ended queues) are a list-like container that support O(1) "
"appends and pops from either side of the deque.  New deques are created "
"using the following arguments:"
msgstr ""

#: ../../../library/ucollections.rst:21
msgid "*iterable* must be the empty tuple, and the new deque is created empty."
msgstr ""

#: ../../../library/ucollections.rst:23
msgid ""
"*maxlen* must be specified and the deque will be bounded to this maximum "
"length.  Once the deque is full, any new items added will discard items "
"from the opposite end."
msgstr ""

#: ../../../library/ucollections.rst:27
msgid "The optional *flags* can be 1 to check for overflow when adding items."
msgstr ""

#: ../../../library/ucollections.rst:29
msgid ""
"As well as supporting `bool` and `len`, deque objects have the following "
"methods:"
msgstr ""

#: ../../../library/ucollections.rst:34
msgid ""
"Add *x* to the right side of the deque. Raises IndexError if overflow "
"checking is enabled and there is no more room left."
msgstr ""

#: ../../../library/ucollections.rst:39
msgid ""
"Remove and return an item from the left side of the deque. Raises "
"IndexError if no items are present."
msgstr ""

#: ../../../library/ucollections.rst:44
msgid ""
"This is factory function to create a new namedtuple type with a specific "
"name and set of fields. A namedtuple is a subclass of tuple which allows "
"to access its fields not just by numeric index, but also with an "
"attribute access syntax using symbolic field names. Fields is a sequence "
"of strings specifying field names. For compatibility with CPython it can "
"also be a a string with space-separated field named (but this is less "
"efficient). Example of use::"
msgstr ""

#: ../../../library/ucollections.rst:52
msgid ""
"from ucollections import namedtuple\n"
"\n"
"MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\"))\n"
"t1 = MyTuple(1, \"foo\")\n"
"t2 = MyTuple(2, \"bar\")\n"
"print(t1.name)\n"
"assert t2.name == t2[1]"
msgstr ""

#: ../../../library/ucollections.rst:62
msgid ""
"``dict`` type subclass which remembers and preserves the order of keys "
"added. When ordered dict is iterated over, keys/items are returned in the"
" order they were added::"
msgstr ""

#: ../../../library/ucollections.rst:66
msgid ""
"from ucollections import OrderedDict\n"
"\n"
"# To make benefit of ordered keys, OrderedDict should be initialized\n"
"# from sequence of (key, value) pairs.\n"
"d = OrderedDict([(\"z\", 1), (\"a\", 2)])\n"
"# More items can be added as usual\n"
"d[\"w\"] = 5\n"
"d[\"b\"] = 3\n"
"for k, v in d.items():\n"
"    print(k, v)"
msgstr ""

#: ../../../library/ucollections.rst:77
msgid "Output::"
msgstr ""

#: ../../../library/ucollections.rst:79
msgid ""
"z 1\n"
"a 2\n"
"w 5\n"
"b 3"
msgstr ""

#: ../../../library/ucryptolib.rst:2
msgid ":mod:`ucryptolib` -- cryptographic ciphers"
msgstr ""

#: ../../../library/ucryptolib.rst:14
msgid ""
"Initialize cipher object, suitable for encryption/decryption. Note: after"
" initialization, cipher object can be use only either for encryption or "
"decryption. Running decrypt() operation after encrypt() or vice versa is "
"not supported."
msgstr ""

#: ../../../library/ucryptolib.rst:19
msgid "Parameters are:"
msgstr ""

#: ../../../library/ucryptolib.rst:21
msgid "*key* is an encryption/decryption key (bytes-like)."
msgstr ""

#: ../../../library/ucryptolib.rst:22
msgid "*mode* is:"
msgstr ""

#: ../../../library/ucryptolib.rst:24
msgid ""
"``1`` (or ``ucryptolib.MODE_ECB`` if it exists) for Electronic Code Book "
"(ECB)."
msgstr ""

#: ../../../library/ucryptolib.rst:25
msgid ""
"``2`` (or ``ucryptolib.MODE_CBC`` if it exists) for Cipher Block Chaining"
" (CBC)"
msgstr ""

#: ../../../library/ucryptolib.rst:27
msgid "*IV* is an initialization vector for CBC mode."
msgstr ""

#: ../../../library/ucryptolib.rst:31
msgid ""
"Encrypt *in_buf*. If no *out_buf* is given result is returned as a newly "
"allocated `bytes` object. Otherwise, result is written into mutable "
"buffer *out_buf*. *in_buf* and *out_buf* can also refer to the same "
"mutable buffer, in which case data is encrypted in-place."
msgstr ""

#: ../../../library/ucryptolib.rst:38
msgid "Like `encrypt()`, but for decryption."
msgstr ""

#: ../../../library/uctypes.rst:2
msgid ":mod:`uctypes` -- access binary data in a structured way"
msgstr ""

#: ../../../library/uctypes.rst:7
msgid ""
"This module implements \"foreign data interface\" for MicroPython. The "
"idea behind it is similar to CPython's ``ctypes`` modules, but the actual"
" API is different, streamlined and optimized for small size. The basic "
"idea of the module is to define data structure layout with about the same"
" power as the C language allows, and then access it using familiar dot-"
"syntax to reference sub-fields."
msgstr ""

#: ../../../library/uctypes.rst:16
msgid ""
"``uctypes`` module allows access to arbitrary memory addresses of the "
"machine (including I/O and control registers). Uncareful usage of it may "
"lead to crashes, data loss, and even hardware malfunction."
msgstr ""

#: ../../../library/uctypes.rst:23
msgid "Module :mod:`ustruct`"
msgstr ""

#: ../../../library/uctypes.rst:23
msgid ""
"Standard Python way to access binary data structures (doesn't scale well "
"to large and complex structures)."
msgstr ""

#: ../../../library/uctypes.rst:26
msgid "Usage examples::"
msgstr ""

#: ../../../library/uctypes.rst:28
msgid ""
"import uctypes\n"
"\n"
"# Example 1: Subset of ELF file header\n"
"# https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header\n"
"ELF_HEADER = {\n"
"    \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8),\n"
"    \"EI_DATA\": 0x5 | uctypes.UINT8,\n"
"    \"e_machine\": 0x12 | uctypes.UINT16,\n"
"}\n"
"\n"
"# \"f\" is an ELF file opened in binary mode\n"
"buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN))\n"
"header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, "
"uctypes.LITTLE_ENDIAN)\n"
"assert header.EI_MAG == b\"\\x7fELF\"\n"
"assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with "
"uctypes.BIG_ENDIAN.\"\n"
"print(\"machine:\", hex(header.e_machine))\n"
"\n"
"\n"
"# Example 2: In-memory data structure, with pointers\n"
"COORD = {\n"
"    \"x\": 0 | uctypes.FLOAT32,\n"
"    \"y\": 4 | uctypes.FLOAT32,\n"
"}\n"
"\n"
"STRUCT1 = {\n"
"    \"data1\": 0 | uctypes.UINT8,\n"
"    \"data2\": 4 | uctypes.UINT32,\n"
"    \"ptr\": (8 | uctypes.PTR, COORD),\n"
"}\n"
"\n"
"# Suppose you have address of a structure of type STRUCT1 in \"addr\"\n"
"# uctypes.NATIVE is optional (used by default)\n"
"struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE)\n"
"print(\"x:\", struct1.ptr[0].x)\n"
"\n"
"\n"
"# Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block\n"
"WWDG_LAYOUT = {\n"
"    \"WWDG_CR\": (0, {\n"
"        # BFUINT32 here means size of the WWDG_CR register\n"
"        \"WDGA\": 7 << uctypes.BF_POS | 1 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"        \"T\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"    }),\n"
"    \"WWDG_CFR\": (4, {\n"
"        \"EWI\": 9 << uctypes.BF_POS | 1 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"        \"WDGTB\": 7 << uctypes.BF_POS | 2 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"        \"W\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"    }),\n"
"}\n"
"\n"
"WWDG = uctypes.struct(0x40002c00, WWDG_LAYOUT)\n"
"\n"
"WWDG.WWDG_CFR.WDGTB = 0b10\n"
"WWDG.WWDG_CR.WDGA = 1\n"
"print(\"Current counter:\", WWDG.WWDG_CR.T)"
msgstr ""

#: ../../../library/uctypes.rst:85
msgid "Defining structure layout"
msgstr ""

#: ../../../library/uctypes.rst:87
msgid ""
"Structure layout is defined by a \"descriptor\" - a Python dictionary "
"which encodes field names as keys and other properties required to access"
" them as associated values::"
msgstr ""

#: ../../../library/uctypes.rst:91
msgid ""
"{\n"
"    \"field1\": <properties>,\n"
"    \"field2\": <properties>,\n"
"    ...\n"
"}"
msgstr ""

#: ../../../library/uctypes.rst:97
msgid ""
"Currently, ``uctypes`` requires explicit specification of offsets for "
"each field. Offset are given in bytes from the structure start."
msgstr ""

#: ../../../library/uctypes.rst:100
msgid "Following are encoding examples for various field types:"
msgstr ""

#: ../../../library/uctypes.rst:102
msgid "Scalar types::"
msgstr ""

#: ../../../library/uctypes.rst:104
msgid "\"field_name\": offset | uctypes.UINT32"
msgstr ""

#: ../../../library/uctypes.rst:106
msgid ""
"in other words, the value is a scalar type identifier ORed with a field "
"offset (in bytes) from the start of the structure."
msgstr ""

#: ../../../library/uctypes.rst:109
msgid "Recursive structures::"
msgstr ""

#: ../../../library/uctypes.rst:111
msgid ""
"\"sub\": (offset, {\n"
"    \"b0\": 0 | uctypes.UINT8,\n"
"    \"b1\": 1 | uctypes.UINT8,\n"
"})"
msgstr ""

#: ../../../library/uctypes.rst:116
msgid ""
"i.e. value is a 2-tuple, first element of which is an offset, and second "
"is a structure descriptor dictionary (note: offsets in recursive "
"descriptors are relative to the structure it defines). Of course, "
"recursive structures can be specified not just by a literal dictionary, "
"but by referring to a structure descriptor dictionary (defined earlier) "
"by name."
msgstr ""

#: ../../../library/uctypes.rst:122
msgid "Arrays of primitive types::"
msgstr ""

#: ../../../library/uctypes.rst:124
msgid "\"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8),"
msgstr ""

#: ../../../library/uctypes.rst:126
msgid ""
"i.e. value is a 2-tuple, first element of which is ARRAY flag ORed with "
"offset, and second is scalar element type ORed number of elements in the "
"array."
msgstr ""

#: ../../../library/uctypes.rst:130
msgid "Arrays of aggregate types::"
msgstr ""

#: ../../../library/uctypes.rst:132
msgid "\"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}),"
msgstr ""

#: ../../../library/uctypes.rst:134
msgid ""
"i.e. value is a 3-tuple, first element of which is ARRAY flag ORed with "
"offset, second is a number of elements in the array, and third is a "
"descriptor of element type."
msgstr ""

#: ../../../library/uctypes.rst:138
msgid "Pointer to a primitive type::"
msgstr ""

#: ../../../library/uctypes.rst:140
msgid "\"ptr\": (offset | uctypes.PTR, uctypes.UINT8),"
msgstr ""

#: ../../../library/uctypes.rst:142
msgid ""
"i.e. value is a 2-tuple, first element of which is PTR flag ORed with "
"offset, and second is a scalar element type."
msgstr ""

#: ../../../library/uctypes.rst:145
msgid "Pointer to an aggregate type::"
msgstr ""

#: ../../../library/uctypes.rst:147
msgid "\"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}),"
msgstr ""

#: ../../../library/uctypes.rst:149
msgid ""
"i.e. value is a 2-tuple, first element of which is PTR flag ORed with "
"offset, second is a descriptor of type pointed to."
msgstr ""

#: ../../../library/uctypes.rst:152
msgid "Bitfields::"
msgstr ""

#: ../../../library/uctypes.rst:154
msgid ""
"\"bitf0\": offset | uctypes.BFUINT16 | lsbit << uctypes.BF_POS | bitsize "
"<< uctypes.BF_LEN,"
msgstr ""

#: ../../../library/uctypes.rst:156
msgid ""
"i.e. value is a type of scalar value containing given bitfield (typenames"
" are similar to scalar types, but prefixes with ``BF``), ORed with offset"
" for scalar value containing the bitfield, and further ORed with values "
"for bit position and bit length of the bitfield within the scalar value, "
"shifted by BF_POS and BF_LEN bits, respectively. A bitfield position is "
"counted from the least significant bit of the scalar (having position of "
"0), and is the number of right-most bit of a field (in other words, it's "
"a number of bits a scalar needs to be shifted right to extract the "
"bitfield)."
msgstr ""

#: ../../../library/uctypes.rst:165
msgid ""
"In the example above, first a UINT16 value will be extracted at offset 0 "
"(this detail may be important when accessing hardware registers, where "
"particular access size and alignment are required), and then bitfield "
"whose rightmost bit is *lsbit* bit of this UINT16, and length is "
"*bitsize* bits, will be extracted. For example, if *lsbit* is 0 and "
"*bitsize* is 8, then effectively it will access least-significant byte of"
" UINT16."
msgstr ""

#: ../../../library/uctypes.rst:173
msgid ""
"Note that bitfield operations are independent of target byte endianness, "
"in particular, example above will access least-significant byte of UINT16"
" in both little- and big-endian structures. But it depends on the least "
"significant bit being numbered 0. Some targets may use different "
"numbering in their native ABI, but ``uctypes`` always uses the normalized"
" numbering described above."
msgstr ""

#: ../../../library/uctypes.rst:181
msgid "Module contents"
msgstr ""

#: ../../../library/uctypes.rst:185
msgid ""
"Instantiate a \"foreign data structure\" object based on structure "
"address in memory, descriptor (encoded as a dictionary), and layout type "
"(see below)."
msgstr ""

#: ../../../library/uctypes.rst:190
msgid ""
"Layout type for a little-endian packed structure. (Packed means that "
"every field occupies exactly as many bytes as defined in the descriptor, "
"i.e. the alignment is 1)."
msgstr ""

#: ../../../library/uctypes.rst:196
msgid "Layout type for a big-endian packed structure."
msgstr ""

#: ../../../library/uctypes.rst:200
msgid ""
"Layout type for a native structure - with data endianness and alignment "
"conforming to the ABI of the system on which MicroPython runs."
msgstr ""

#: ../../../library/uctypes.rst:205
msgid ""
"Return size of data structure in bytes. The *struct* argument can be "
"either a structure class or a specific instantiated structure object (or "
"its aggregate field)."
msgstr ""

#: ../../../library/uctypes.rst:211
msgid ""
"Return address of an object. Argument should be bytes, bytearray or other"
" object supporting buffer protocol (and address of this buffer is what "
"actually returned)."
msgstr ""

#: ../../../library/uctypes.rst:217
msgid ""
"Capture memory at the given address and size as bytes object. As bytes "
"object is immutable, memory is actually duplicated and copied into bytes "
"object, so if memory contents change later, created object retains "
"original value."
msgstr ""

#: ../../../library/uctypes.rst:224
msgid ""
"Capture memory at the given address and size as bytearray object. Unlike "
"bytes_at() function above, memory is captured by reference, so it can be "
"both written too, and you will access current value at the given memory "
"address."
msgstr ""

#: ../../../library/uctypes.rst:238
msgid ""
"Integer types for structure descriptors. Constants for 8, 16, 32, and 64 "
"bit types are provided, both signed and unsigned."
msgstr ""

#: ../../../library/uctypes.rst:244
msgid "Floating-point types for structure descriptors."
msgstr ""

#: ../../../library/uctypes.rst:248
msgid ""
"``VOID`` is an alias for ``UINT8``, and is provided to conviniently "
"define C's void pointers: ``(uctypes.PTR, uctypes.VOID)``."
msgstr ""

#: ../../../library/uctypes.rst:254
msgid ""
"Type constants for pointers and arrays. Note that there is no explicit "
"constant for structures, it's implicit: an aggregate type without ``PTR``"
" or ``ARRAY`` flags is a structure."
msgstr ""

#: ../../../library/uctypes.rst:259
msgid "Structure descriptors and instantiating structure objects"
msgstr ""

#: ../../../library/uctypes.rst:261
msgid ""
"Given a structure descriptor dictionary and its layout type, you can "
"instantiate a specific structure instance at a given memory address using"
" :class:`uctypes.struct()` constructor. Memory address usually comes from"
" following sources:"
msgstr ""

#: ../../../library/uctypes.rst:266
msgid ""
"Predefined address, when accessing hardware registers on a baremetal "
"system. Lookup these addresses in datasheet for a particular MCU/SoC."
msgstr ""

#: ../../../library/uctypes.rst:268
msgid ""
"As a return value from a call to some FFI (Foreign Function Interface) "
"function."
msgstr ""

#: ../../../library/uctypes.rst:270
msgid ""
"From `uctypes.addressof()`, when you want to pass arguments to an FFI "
"function, or alternatively, to access some data for I/O (for example, "
"data read from a file or network socket)."
msgstr ""

#: ../../../library/uctypes.rst:275
msgid "Structure objects"
msgstr ""

#: ../../../library/uctypes.rst:277
msgid ""
"Structure objects allow accessing individual fields using standard dot "
"notation: ``my_struct.substruct1.field1``. If a field is of scalar type, "
"getting it will produce a primitive value (Python integer or float) "
"corresponding to the value contained in a field. A scalar field can also "
"be assigned to."
msgstr ""

#: ../../../library/uctypes.rst:283
msgid ""
"If a field is an array, its individual elements can be accessed with the "
"standard subscript operator ``[]`` - both read and assigned to."
msgstr ""

#: ../../../library/uctypes.rst:286
msgid ""
"If a field is a pointer, it can be dereferenced using ``[0]`` syntax "
"(corresponding to C ``*`` operator, though ``[0]`` works in C too). "
"Subscripting a pointer with other integer values but 0 are also "
"supported, with the same semantics as in C."
msgstr ""

#: ../../../library/uctypes.rst:291
msgid ""
"Summing up, accessing structure fields generally follows the C syntax, "
"except for pointer dereference, when you need to use ``[0]`` operator "
"instead of ``*``."
msgstr ""

#: ../../../library/uctypes.rst:296
msgid "Limitations"
msgstr ""

#: ../../../library/uctypes.rst:298
msgid ""
"1. Accessing non-scalar fields leads to allocation of intermediate "
"objects to represent them. This means that special care should be taken "
"to layout a structure which needs to be accessed when memory allocation "
"is disabled (e.g. from an interrupt). The recommendations are:"
msgstr ""

#: ../../../library/uctypes.rst:303
msgid ""
"Avoid accessing nested structures. For example, instead of "
"``mcu_registers.peripheral_a.register1``, define separate layout "
"descriptors for each peripheral, to be accessed as "
"``peripheral_a.register1``. Or just cache a particular peripheral: "
"``peripheral_a = mcu_registers.peripheral_a``. If a register consists of "
"multiple bitfields, you would need to cache references to a particular "
"register: ``reg_a = mcu_registers.peripheral_a.reg_a``."
msgstr ""

#: ../../../library/uctypes.rst:310
msgid ""
"Avoid other non-scalar data, like arrays. For example, instead of "
"``peripheral_a.register[0]`` use ``peripheral_a.register0``. Again, an "
"alternative is to cache intermediate values, e.g. ``register0 = "
"peripheral_a.register[0]``."
msgstr ""

#: ../../../library/uctypes.rst:315
msgid ""
"2. Range of offsets supported by the ``uctypes`` module is limited. The "
"exact range supported is considered an implementation detail, and the "
"general suggestion is to split structure definitions to cover from a few "
"kilobytes to a few dozen of kilobytes maximum. In most cases, this is a "
"natural situation anyway, e.g. it doesn't make sense to define all "
"registers of an MCU (spread over 32-bit address space) in one structure, "
"but rather a peripheral block by peripheral block. In some extreme cases,"
" you may need to split a structure in several parts artificially (e.g. if"
" accessing native data structure with multi-megabyte array in the middle,"
" though that would be a very synthetic case)."
msgstr ""

#: ../../../library/uerrno.rst:2
msgid ":mod:`uerrno` -- system error codes"
msgstr ""

#: ../../../library/uerrno.rst:7
msgid "|see_cpython_module| :mod:`python:errno`."
msgstr ""

#: ../../../library/uerrno.rst:9
msgid ""
"This module provides access to symbolic error codes for `OSError` "
"exception. A particular inventory of codes depends on `MicroPython port`."
msgstr ""

#: ../../../library/uerrno.rst:17
msgid ""
"Error codes, based on ANSI C/POSIX standard. All error codes start with "
"\"E\". As mentioned above, inventory of the codes depends on `MicroPython"
" port`. Errors are usually accessible as ``exc.args[0]`` where ``exc`` is"
" an instance of `OSError`. Usage example::"
msgstr ""

#: ../../../library/uerrno.rst:22
msgid ""
"try:\n"
"    uos.mkdir(\"my_dir\")\n"
"except OSError as exc:\n"
"    if exc.args[0] == uerrno.EEXIST:\n"
"        print(\"Directory already exists\")"
msgstr ""

#: ../../../library/uerrno.rst:30
msgid ""
"Dictionary mapping numeric error codes to strings with symbolic error "
"code (see above)::"
msgstr ""

#: ../../../library/uerrno.rst:33
msgid ""
">>> print(uerrno.errorcode[uerrno.EEXIST])\n"
"EEXIST"
msgstr ""

#: ../../../library/uhashlib.rst:2
msgid ":mod:`uhashlib` -- hashing algorithms"
msgstr ""

#: ../../../library/uhashlib.rst:7
msgid "|see_cpython_module| :mod:`python:hashlib`."
msgstr ""

#: ../../../library/uhashlib.rst:9
msgid ""
"This module implements binary data hashing algorithms. The exact "
"inventory of available algorithms depends on a board. Among the "
"algorithms which may be implemented:"
msgstr ""

#: ../../../library/uhashlib.rst:13
msgid ""
"SHA256 - The current generation, modern hashing algorithm (of SHA2 "
"series). It is suitable for cryptographically-secure purposes. Included "
"in the MicroPython core and any board is recommended to provide this, "
"unless it has particular code size constraints."
msgstr ""

#: ../../../library/uhashlib.rst:18
msgid ""
"SHA1 - A previous generation algorithm. Not recommended for new usages, "
"but SHA1 is a part of number of Internet standards and existing "
"applications, so boards targeting network connectivity and "
"interoperatiability will try to provide this."
msgstr ""

#: ../../../library/uhashlib.rst:23
msgid ""
"MD5 - A legacy algorithm, not considered cryptographically secure. Only "
"selected boards, targeting interoperatibility with legacy applications, "
"will offer this."
msgstr ""

#: ../../../library/uhashlib.rst:32
msgid "Create an SHA256 hasher object and optionally feed ``data`` into it."
msgstr ""

#: ../../../library/uhashlib.rst:36
msgid "Create an SHA1 hasher object and optionally feed ``data`` into it."
msgstr ""

#: ../../../library/uhashlib.rst:40
msgid "Create an MD5 hasher object and optionally feed ``data`` into it."
msgstr ""

#: ../../../library/uhashlib.rst:47
msgid "Feed more binary data into hash."
msgstr ""

#: ../../../library/uhashlib.rst:51
msgid ""
"Return hash for all data passed through hash, as a bytes object. After "
"this method is called, more data cannot be fed into the hash any longer."
msgstr ""

#: ../../../library/uhashlib.rst:56
msgid ""
"This method is NOT implemented. Use ``ubinascii.hexlify(hash.digest())`` "
"to achieve a similar effect."
msgstr ""

#: ../../../library/uheapq.rst:2
msgid ":mod:`uheapq` -- heap queue algorithm"
msgstr ""

#: ../../../library/uheapq.rst:7
msgid "|see_cpython_module| :mod:`python:heapq`."
msgstr ""

#: ../../../library/uheapq.rst:9
msgid "This module implements the heap queue algorithm."
msgstr ""

#: ../../../library/uheapq.rst:11
msgid ""
"A heap queue is simply a list that has its elements stored in a certain "
"way."
msgstr ""

#: ../../../library/uheapq.rst:18
msgid "Push the ``item`` onto the ``heap``."
msgstr ""

#: ../../../library/uheapq.rst:22
msgid ""
"Pop the first item from the ``heap``, and return it.  Raises IndexError "
"if heap is empty."
msgstr ""

#: ../../../library/uheapq.rst:27
msgid "Convert the list ``x`` into a heap.  This is an in-place operation."
msgstr ""

#: ../../../library/uio.rst:2
msgid ":mod:`uio` -- input/output streams"
msgstr ""

#: ../../../library/uio.rst:7
msgid "|see_cpython_module| :mod:`python:io`."
msgstr ""

#: ../../../library/uio.rst:9
msgid ""
"This module contains additional types of `stream` (file-like) objects and"
" helper functions."
msgstr ""

#: ../../../library/uio.rst:13
msgid "Conceptual hierarchy"
msgstr ""

#: ../../../library/uio.rst:18
msgid ""
"Conceptual hierarchy of stream base classes is simplified in MicroPython,"
" as described in this section."
msgstr ""

#: ../../../library/uio.rst:21
msgid ""
"(Abstract) base stream classes, which serve as a foundation for behavior "
"of all the concrete classes, adhere to few dichotomies (pair-wise "
"classifications) in CPython. In MicroPython, they are somewhat simplified"
" and made implicit to achieve higher efficiencies and save resources."
msgstr ""

#: ../../../library/uio.rst:26
msgid ""
"An important dichotomy in CPython is unbuffered vs buffered streams. In "
"MicroPython, all streams are currently unbuffered. This is because all "
"modern OSes, and even many RTOSes and filesystem drivers already perform "
"buffering on their side. Adding another layer of buffering is counter- "
"productive (an issue known as \"bufferbloat\") and takes precious memory."
" Note that there still cases where buffering may be useful, so we may "
"introduce optional buffering support at a later time."
msgstr ""

#: ../../../library/uio.rst:34
msgid ""
"But in CPython, another important dichotomy is tied with \"bufferedness\""
" - it's whether a stream may incur short read/writes or not. A short read"
" is when a user asks e.g. 10 bytes from a stream, but gets less, "
"similarly for writes. In CPython, unbuffered streams are automatically "
"short operation susceptible, while buffered are guarantee against them. "
"The no short read/writes is an important trait, as it allows to develop "
"more concise and efficient programs - something which is highly desirable"
" for MicroPython. So, while MicroPython doesn't support buffered streams,"
" it still provides for no-short-operations streams. Whether there will be"
" short operations or not depends on each particular class' needs, but "
"developers are strongly advised to favor no-short-operations behavior for"
" the reasons stated above. For example, MicroPython sockets are "
"guaranteed to avoid short read/writes. Actually, at this time, there is "
"no example of a short-operations stream class in the core, and one would "
"be a port-specific class, where such a need is governed by hardware "
"peculiarities."
msgstr ""

#: ../../../library/uio.rst:51
msgid ""
"The no-short-operations behavior gets tricky in case of non-blocking "
"streams, blocking vs non-blocking behavior being another CPython "
"dichotomy, fully supported by MicroPython. Non-blocking streams never "
"wait for data either to arrive or be written - they read/write whatever "
"possible, or signal lack of data (or ability to write data). Clearly, "
"this conflicts with \"no-short-operations\" policy, and indeed, a case of"
" non-blocking buffered (and this no-short-ops) streams is convoluted in "
"CPython - in some places, such combination is prohibited, in some it's "
"undefined or just not documented, in some cases it raises verbose "
"exceptions. The matter is much simpler in MicroPython: non-blocking "
"stream are important for efficient asynchronous operations, so this "
"property prevails on the \"no-short-ops\" one. So, while blocking streams"
" will avoid short reads/writes whenever possible (the only case to get a "
"short read is if end of file is reached, or in case of error (but errors "
"don't return short data, but raise exceptions)), non-blocking streams may"
" produce short data to avoid blocking the operation."
msgstr ""

#: ../../../library/uio.rst:68
msgid ""
"The final dichotomy is binary vs text streams. MicroPython of course "
"supports these, but while in CPython text streams are inherently "
"buffered, they aren't in MicroPython. (Indeed, that's one of the cases "
"for which we may introduce buffering support.)"
msgstr ""

#: ../../../library/uio.rst:73
msgid ""
"Note that for efficiency, MicroPython doesn't provide abstract base "
"classes corresponding to the hierarchy above, and it's not possible to "
"implement, or subclass, a stream class in pure Python."
msgstr ""

#: ../../../library/uio.rst:82
msgid ""
"Open a file. Builtin ``open()`` function is aliased to this function. All"
" ports (which provide access to file system) are required to support "
"*mode* parameter, but support for other arguments vary by port."
msgstr ""

#: ../../../library/uio.rst:91
msgid ""
"This is type of a file open in binary mode, e.g. using ``open(name, "
"\"rb\")``. You should not instantiate this class directly."
msgstr ""

#: ../../../library/uio.rst:96
msgid ""
"This is type of a file open in text mode, e.g. using ``open(name, "
"\"rt\")``. You should not instantiate this class directly."
msgstr ""

#: ../../../library/uio.rst:102
msgid ""
"In-memory file-like objects for input/output. `StringIO` is used for "
"text-mode I/O (similar to a normal file opened with \"t\" modifier). "
"`BytesIO` is used for binary-mode I/O (similar to a normal file opened "
"with \"b\" modifier). Initial contents of file-like objects can be "
"specified with *string* parameter (should be normal string for `StringIO`"
" or bytes object for `BytesIO`). All the usual file methods like "
"``read()``, ``write()``, ``seek()``, ``flush()``, ``close()`` are "
"available on these objects, and additionally, a following method:"
msgstr ""

#: ../../../library/uio.rst:114
msgid "Get the current contents of the underlying buffer which holds data."
msgstr ""

#: ../../../library/uio.rst:119
msgid ""
"Create an empty `StringIO`/`BytesIO` object, preallocated to hold up to "
"*alloc_size* number of bytes. That means that writing that amount of "
"bytes won't lead to reallocation of the buffer, and thus won't hit out-"
"of-memory situation or lead to memory fragmentation. These constructors "
"are a MicroPython extension and are recommended for usage only in special"
" cases and in system-level libraries, not for end-user applications."
msgstr ""

#: ../../../library/uio.rst:129
msgid "These constructors are a MicroPython extension."
msgstr ""

#: ../../../library/ujson.rst:2
msgid ":mod:`ujson` -- JSON encoding and decoding"
msgstr ""

#: ../../../library/ujson.rst:7
msgid "|see_cpython_module| :mod:`python:json`."
msgstr ""

#: ../../../library/ujson.rst:9
msgid ""
"This modules allows to convert between Python objects and the JSON data "
"format."
msgstr ""

#: ../../../library/ujson.rst:17
msgid "Serialise *obj* to a JSON string, writing it to the given *stream*."
msgstr ""

#: ../../../library/ujson.rst:21
msgid "Return *obj* represented as a JSON string."
msgstr ""

#: ../../../library/ujson.rst:25
msgid ""
"Parse the given *stream*, interpreting it as a JSON string and "
"deserialising the data to a Python object.  The resulting object is "
"returned."
msgstr ""

#: ../../../library/ujson.rst:29
msgid ""
"Parsing continues until end-of-file is encountered. A :exc:`ValueError` "
"is raised if the data in *stream* is not correctly formed."
msgstr ""

#: ../../../library/ujson.rst:34
msgid ""
"Parse the JSON *str* and return an object.  Raises :exc:`ValueError` if "
"the string is not correctly formed."
msgstr ""

#: ../../../library/uos.rst:2
msgid ":mod:`uos` -- basic \"operating system\" services"
msgstr ""

#: ../../../library/uos.rst:7
msgid "|see_cpython_module| :mod:`python:os`."
msgstr ""

#: ../../../library/uos.rst:9
msgid ""
"The ``uos`` module contains functions for filesystem access and mounting,"
" terminal redirection and duplication, and the ``uname`` and ``urandom`` "
"functions."
msgstr ""

#: ../../../library/uos.rst:14
msgid "General functions"
msgstr ""

#: ../../../library/uos.rst:18
msgid ""
"Return a tuple (possibly a named tuple) containing information about the "
"underlying machine and/or its operating system.  The tuple has five "
"fields in the following order, each of them being a string:"
msgstr ""

#: ../../../library/uos.rst:22
msgid "``sysname`` -- the name of the underlying system"
msgstr ""

#: ../../../library/uos.rst:23
msgid "``nodename`` -- the network name (can be the same as ``sysname``)"
msgstr ""

#: ../../../library/uos.rst:24
msgid "``release`` -- the version of the underlying system"
msgstr ""

#: ../../../library/uos.rst:25
msgid "``version`` -- the MicroPython version and build date"
msgstr ""

#: ../../../library/uos.rst:26
msgid "``machine`` -- an identifier for the underlying hardware (eg board, CPU)"
msgstr ""

#: ../../../library/uos.rst:30
msgid ""
"Return a bytes object with *n* random bytes. Whenever possible, it is "
"generated by the hardware random number generator."
msgstr ""

#: ../../../library/uos.rst:34
msgid "Filesystem access"
msgstr ""

#: ../../../library/uos.rst:38
msgid "Change current directory."
msgstr ""

#: ../../../library/uos.rst:42
msgid "Get the current directory."
msgstr ""

#: ../../../library/uos.rst:46
msgid ""
"This function returns an iterator which then yields tuples corresponding "
"to the entries in the directory that it is listing.  With no argument it "
"lists the current directory, otherwise it lists the directory given by "
"*dir*."
msgstr ""

#: ../../../library/uos.rst:50
msgid "The tuples have the form *(name, type, inode[, size])*:"
msgstr ""

#: ../../../library/uos.rst:52
msgid ""
"*name* is a string (or bytes if *dir* is a bytes object) and is the name "
"of the entry;"
msgstr ""

#: ../../../library/uos.rst:54
msgid ""
"*type* is an integer that specifies the type of the entry, with 0x4000 "
"for directories and 0x8000 for regular files;"
msgstr ""

#: ../../../library/uos.rst:56
msgid ""
"*inode* is an integer corresponding to the inode of the file, and may be "
"0 for filesystems that don't have such a notion."
msgstr ""

#: ../../../library/uos.rst:58
msgid ""
"Some platforms may return a 4-tuple that includes the entry's *size*.  "
"For file entries, *size* is an integer representing the size of the file "
"or -1 if unknown.  Its meaning is currently undefined for directory "
"entries."
msgstr ""

#: ../../../library/uos.rst:65
msgid ""
"With no argument, list the current directory.  Otherwise list the given "
"directory."
msgstr ""

#: ../../../library/uos.rst:69
msgid "Create a new directory."
msgstr ""

#: ../../../library/uos.rst:73
msgid "Remove a file."
msgstr ""

#: ../../../library/uos.rst:77
msgid "Remove a directory."
msgstr ""

#: ../../../library/uos.rst:81
msgid "Rename a file."
msgstr ""

#: ../../../library/uos.rst:85
msgid "Get the status of a file or directory."
msgstr ""

#: ../../../library/uos.rst:89
msgid "Get the status of a fileystem."
msgstr ""

#: ../../../library/uos.rst:91
msgid "Returns a tuple with the filesystem information in the following order:"
msgstr ""

#: ../../../library/uos.rst:93
msgid "``f_bsize`` -- file system block size"
msgstr ""

#: ../../../library/uos.rst:94
msgid "``f_frsize`` -- fragment size"
msgstr ""

#: ../../../library/uos.rst:95
msgid "``f_blocks`` -- size of fs in f_frsize units"
msgstr ""

#: ../../../library/uos.rst:96
msgid "``f_bfree`` -- number of free blocks"
msgstr ""

#: ../../../library/uos.rst:97
msgid "``f_bavail`` -- number of free blocks for unpriviliged users"
msgstr ""

#: ../../../library/uos.rst:98
msgid "``f_files`` -- number of inodes"
msgstr ""

#: ../../../library/uos.rst:99
msgid "``f_ffree`` -- number of free inodes"
msgstr ""

#: ../../../library/uos.rst:100
msgid "``f_favail`` -- number of free inodes for unpriviliged users"
msgstr ""

#: ../../../library/uos.rst:101
msgid "``f_flag`` -- mount flags"
msgstr ""

#: ../../../library/uos.rst:102
msgid "``f_namemax`` -- maximum filename length"
msgstr ""

#: ../../../library/uos.rst:104
msgid ""
"Parameters related to inodes: ``f_files``, ``f_ffree``, ``f_avail`` and "
"the ``f_flags`` parameter may return ``0`` as they can be unavailable in "
"a port-specific implementation."
msgstr ""

#: ../../../library/uos.rst:110
msgid "Sync all filesystems."
msgstr ""

#: ../../../library/uos.rst:113
msgid "Terminal redirection and duplication"
msgstr ""

#: ../../../library/uos.rst:117
msgid ""
"Duplicate or switch the MicroPython terminal (the REPL) on the given "
"`stream`-like object. The *stream_object* argument must implement the "
"``readinto()`` and ``write()`` methods.  The stream should be in non-"
"blocking mode and ``readinto()`` should return ``None`` if there is no "
"data available for reading."
msgstr ""

#: ../../../library/uos.rst:122
msgid ""
"After calling this function all terminal output is repeated on this "
"stream, and any input that is available on the stream is passed on to the"
" terminal input."
msgstr ""

#: ../../../library/uos.rst:125
msgid ""
"The *index* parameter should be a non-negative integer and specifies "
"which duplication slot is set.  A given port may implement more than one "
"slot (slot 0 will always be available) and in that case terminal input "
"and output is duplicated on all the slots that are set."
msgstr ""

#: ../../../library/uos.rst:130
msgid ""
"If ``None`` is passed as the *stream_object* then duplication is "
"cancelled on the slot given by *index*."
msgstr ""

#: ../../../library/uos.rst:133
msgid "The function returns the previous stream-like object in the given slot."
msgstr ""

#: ../../../library/uos.rst:136
msgid "Filesystem mounting"
msgstr ""

#: ../../../library/uos.rst:138
msgid ""
"Some ports provide a Virtual Filesystem (VFS) and the ability to mount "
"multiple \"real\" filesystems within this VFS.  Filesystem objects can be"
" mounted at either the root of the VFS, or at a subdirectory that lives "
"in the root.  This allows dynamic and flexible configuration of the "
"filesystem that is seen by Python programs.  Ports that have this "
"functionality provide the :func:`mount` and :func:`umount` functions, and"
" possibly various filesystem implementations represented by VFS classes."
msgstr ""

#: ../../../library/uos.rst:148
msgid ""
"Mount the filesystem object *fsobj* at the location in the VFS given by "
"the *mount_point* string.  *fsobj* can be a a VFS object that has a "
"``mount()`` method, or a block device.  If it's a block device then the "
"filesystem type is automatically detected (an exception is raised if no "
"filesystem was recognised).  *mount_point* may be ``'/'`` to mount "
"*fsobj* at the root, or ``'/<name>'`` to mount it at a subdirectory under"
" the root."
msgstr ""

#: ../../../library/uos.rst:155
msgid "If *readonly* is ``True`` then the filesystem is mounted read-only."
msgstr ""

#: ../../../library/uos.rst:157
msgid ""
"During the mount process the method ``mount()`` is called on the "
"filesystem object."
msgstr ""

#: ../../../library/uos.rst:160
msgid "Will raise ``OSError(EPERM)`` if *mount_point* is already mounted."
msgstr ""

#: ../../../library/uos.rst:164
msgid ""
"Unmount a filesystem. *mount_point* can be a string naming the mount "
"location, or a previously-mounted filesystem object.  During the unmount "
"process the method ``umount()`` is called on the filesystem object."
msgstr ""

#: ../../../library/uos.rst:168
msgid "Will raise ``OSError(EINVAL)`` if *mount_point* is not found."
msgstr ""

#: ../../../library/uos.rst:172
msgid ""
"Create a filesystem object that uses the FAT filesystem format.  Storage "
"of the FAT filesystem is provided by *block_dev*. Objects created by this"
" constructor can be mounted using :func:`mount`."
msgstr ""

#: ../../../library/uos.rst:178
msgid "Build a FAT filesystem on *block_dev*."
msgstr ""

#: ../../../library/uos.rst:181
msgid "Block devices"
msgstr ""

#: ../../../library/uos.rst:183
msgid ""
"A block device is an object which implements the block protocol, which is"
" a set of methods described below by the :class:`AbstractBlockDev` class."
"  A concrete implementation of this class will usually allow access to "
"the memory-like functionality a piece of hardware (like flash memory).  A"
" block device can be used by a particular filesystem driver to store the "
"data for its filesystem."
msgstr ""

#: ../../../library/uos.rst:191
msgid ""
"Construct a block device object.  The parameters to the constructor are "
"dependent on the specific block device."
msgstr ""

#: ../../../library/uos.rst:196
msgid ""
"Starting at the block given by the index *block_num*, read blocks from "
"the device into *buf* (an array of bytes). The number of blocks to read "
"is given by the length of *buf*, which will be a multiple of the block "
"size."
msgstr ""

#: ../../../library/uos.rst:203
msgid ""
"Starting at the block given by the index *block_num*, write blocks from "
"*buf* (an array of bytes) to the device. The number of blocks to write is"
" given by the length of *buf*, which will be a multiple of the block "
"size."
msgstr ""

#: ../../../library/uos.rst:210
msgid ""
"Control the block device and query its parameters.  The operation to "
"perform is given by *op* which is one of the following integers:"
msgstr ""

#: ../../../library/uos.rst:213
msgid "1 -- initialise the device (*arg* is unused)"
msgstr ""

#: ../../../library/uos.rst:214
msgid "2 -- shutdown the device (*arg* is unused)"
msgstr ""

#: ../../../library/uos.rst:215
msgid "3 -- sync the device (*arg* is unused)"
msgstr ""

#: ../../../library/uos.rst:216
msgid ""
"4 -- get a count of the number of blocks, should return an integer (*arg*"
" is unused)"
msgstr ""

#: ../../../library/uos.rst:218
msgid ""
"5 -- get the number of bytes in a block, should return an integer, or "
"``None`` in which case the default value of 512 is used (*arg* is unused)"
msgstr ""

#: ../../../library/uos.rst:222
msgid ""
"By way of example, the following class will implement a block device that"
" stores its data in RAM using a ``bytearray``::"
msgstr ""

#: ../../../library/uos.rst:225
msgid ""
"class RAMBlockDev:\n"
"    def __init__(self, block_size, num_blocks):\n"
"        self.block_size = block_size\n"
"        self.data = bytearray(block_size * num_blocks)\n"
"\n"
"    def readblocks(self, block_num, buf):\n"
"        for i in range(len(buf)):\n"
"            buf[i] = self.data[block_num * self.block_size + i]\n"
"\n"
"    def writeblocks(self, block_num, buf):\n"
"        for i in range(len(buf)):\n"
"            self.data[block_num * self.block_size + i] = buf[i]\n"
"\n"
"    def ioctl(self, op, arg):\n"
"        if op == 4: # get number of blocks\n"
"            return len(self.data) // self.block_size\n"
"        if op == 5: # get block size\n"
"            return self.block_size"
msgstr ""

#: ../../../library/uos.rst:244
msgid "It can be used as follows::"
msgstr ""

#: ../../../<rst_epilog>:246
msgid ""
"import uos\n"
"\n"
"bdev = RAMBlockDev(512, 50)\n"
"uos.VfsFat.mkfs(bdev)\n"
"vfs = uos.VfsFat(bdev)\n"
"uos.mount(vfs, '/ramdisk')"
msgstr ""

#: ../../../library/ure.rst:2
msgid ":mod:`ure` -- simple regular expressions"
msgstr ""

#: ../../../library/ure.rst:7
msgid "|see_cpython_module| :mod:`python:re`."
msgstr ""

#: ../../../library/ure.rst:9
msgid ""
"This module implements regular expression operations. Regular expression "
"syntax supported is a subset of CPython ``re`` module (and actually is a "
"subset of POSIX extended regular expressions)."
msgstr ""

#: ../../../library/ure.rst:13
msgid "Supported operators are:"
msgstr ""

#: ../../../library/ure.rst:16
msgid "``'.'``"
msgstr ""

#: ../../../library/ure.rst:16
msgid "Match any character."
msgstr ""

#: ../../../library/ure.rst:20
msgid "``'[...]'``"
msgstr ""

#: ../../../library/ure.rst:19
msgid ""
"Match set of characters. Individual characters and ranges are supported, "
"including negated sets (e.g. ``[^a-c]``)."
msgstr ""

#: ../../../library/ure.rst:23
msgid "``'^'``"
msgstr ""

#: ../../../library/ure.rst:23
msgid "Match the start of the string."
msgstr ""

#: ../../../library/ure.rst:26
msgid "``'$'``"
msgstr ""

#: ../../../library/ure.rst:26
msgid "Match the end of the string."
msgstr ""

#: ../../../library/ure.rst:29
msgid "``'?'``"
msgstr ""

#: ../../../library/ure.rst:29
msgid "Match zero or one of the previous entity."
msgstr ""

#: ../../../library/ure.rst:32
msgid "``'*'``"
msgstr ""

#: ../../../library/ure.rst:32
msgid "Match zero or more of the previous entity."
msgstr ""

#: ../../../library/ure.rst:35
msgid "``'+'``"
msgstr ""

#: ../../../library/ure.rst:35
msgid "Match one or more of the previous entity."
msgstr ""

#: ../../../library/ure.rst:37
msgid "``'??'``"
msgstr ""

#: ../../../library/ure.rst:39
msgid "``'*?'``"
msgstr ""

#: ../../../library/ure.rst:41
msgid "``'+?'``"
msgstr ""

#: ../../../library/ure.rst:44
msgid "``'|'``"
msgstr ""

#: ../../../library/ure.rst:44
msgid "Match either the LHS or the RHS of this operator."
msgstr ""

#: ../../../library/ure.rst:48
msgid "``'(...)'``"
msgstr ""

#: ../../../library/ure.rst:47
msgid ""
"Grouping. Each group is capturing (a substring it captures can be "
"accessed with `match.group()` method)."
msgstr ""

#: ../../../library/ure.rst:50
msgid ""
"**NOT SUPPORTED**: Counted repetitions (``{m,n}``), more advanced "
"assertions (``\\b``, ``\\B``), named groups (``(?P<name>...)``), non-"
"capturing groups (``(?:...)``), etc."
msgstr ""

#: ../../../library/ure.rst:60
msgid "Compile regular expression, return `regex <regex>` object."
msgstr ""

#: ../../../library/ure.rst:64
msgid ""
"Compile *regex_str* and match against *string*. Match always happens from"
" starting position in a string."
msgstr ""

#: ../../../library/ure.rst:69
msgid ""
"Compile *regex_str* and search it in a *string*. Unlike `match`, this "
"will search string for first position which matches regex (which still "
"may be 0 if regex is anchored)."
msgstr ""

#: ../../../library/ure.rst:75
msgid ""
"Compile *regex_str* and search for it in *string*, replacing all matches "
"with *replace*, and returning the new string."
msgstr ""

#: ../../../library/ure.rst:78
msgid ""
"*replace* can be a string or a function.  If it is a string then escape "
"sequences of the form ``\\<number>`` and ``\\g<number>`` can be used to "
"expand to the corresponding group (or an empty string for unmatched "
"groups). If *replace* is a function then it must take a single argument "
"(the match) and should return a replacement string."
msgstr ""

#: ../../../library/ure.rst:84
msgid ""
"If *count* is specified and non-zero then substitution will stop after "
"this many substitutions are made.  The *flags* argument is ignored."
msgstr ""

#: ../../../library/ure.rst:87
msgid "Note: availability of this function depends on `MicroPython port`."
msgstr ""

#: ../../../library/ure.rst:91
msgid ""
"Flag value, display debug information about compiled expression. "
"(Availability depends on `MicroPython port`.)"
msgstr ""

#: ../../../library/ure.rst:98
msgid "Regex objects"
msgstr ""

#: ../../../library/ure.rst:100
msgid ""
"Compiled regular expression. Instances of this class are created using "
"`ure.compile()`."
msgstr ""

#: ../../../library/ure.rst:107
msgid ""
"Similar to the module-level functions :meth:`match`, :meth:`search` and "
":meth:`sub`. Using methods is (much) more efficient if the same regex is "
"applied to multiple strings."
msgstr ""

#: ../../../library/ure.rst:114
msgid ""
"Split a *string* using regex. If *max_split* is given, it specifies "
"maximum number of splits to perform. Returns list of strings (there may "
"be up to *max_split+1* elements if it's specified)."
msgstr ""

#: ../../../library/ure.rst:119
msgid "Match objects"
msgstr ""

#: ../../../library/ure.rst:121
msgid ""
"Match objects as returned by `match()` and `search()` methods, and passed"
" to the replacement function in `sub()`."
msgstr ""

#: ../../../library/ure.rst:126
msgid ""
"Return matching (sub)string. *index* is 0 for entire match, 1 and above "
"for each capturing group. Only numeric groups are supported."
msgstr ""

#: ../../../library/ure.rst:131
msgid "Return a tuple containing all the substrings of the groups of the match."
msgstr ""

#: ../../../library/ure.rst:133 ../../../library/ure.rst:148
msgid "Note: availability of this method depends on `MicroPython port`."
msgstr ""

#: ../../../library/ure.rst:138
msgid ""
"Return the index in the original string of the start or end of the "
"substring group that was matched.  *index* defaults to the entire group, "
"otherwise it will select a group."
msgstr ""

#: ../../../library/ure.rst:142
msgid "Note: availability of these methods depends on `MicroPython port`."
msgstr ""

#: ../../../library/ure.rst:146
msgid "Returns the 2-tuple ``(match.start(index), match.end(index))``."
msgstr ""

#: ../../../library/uselect.rst:2
msgid ":mod:`uselect` -- wait for events on a set of streams"
msgstr ""

#: ../../../library/uselect.rst:7
msgid "|see_cpython_module| :mod:`python:select`."
msgstr ""

#: ../../../library/uselect.rst:9
msgid ""
"This module provides functions to efficiently wait for events on multiple"
" `streams <stream>` (select streams which are ready for operations)."
msgstr ""

#: ../../../library/uselect.rst:17
msgid "Create an instance of the Poll class."
msgstr ""

#: ../../../library/uselect.rst:21
msgid "Wait for activity on a set of objects."
msgstr ""

#: ../../../library/uselect.rst:23
msgid ""
"This function is provided by some MicroPython ports for compatibility and"
" is not efficient. Usage of :class:`Poll` is recommended instead."
msgstr ""

#: ../../../library/uselect.rst:29
msgid "class ``Poll``"
msgstr ""

#: ../../../library/uselect.rst:36
msgid "Register `stream` *obj* for polling. *eventmask* is logical OR of:"
msgstr ""

#: ../../../library/uselect.rst:38
msgid "``uselect.POLLIN``  - data available for reading"
msgstr ""

#: ../../../library/uselect.rst:39
msgid "``uselect.POLLOUT`` - more data can be written"
msgstr ""

#: ../../../library/uselect.rst:41
msgid ""
"Note that flags like ``uselect.POLLHUP`` and ``uselect.POLLERR`` are "
"*not* valid as input eventmask (these are unsolicited events which will "
"be returned from `poll()` regardless of whether they are asked for). This"
" semantics is per POSIX."
msgstr ""

#: ../../../library/uselect.rst:46
msgid "*eventmask* defaults to ``uselect.POLLIN | uselect.POLLOUT``."
msgstr ""

#: ../../../library/uselect.rst:48
msgid ""
"It is OK to call this function multiple times for the same *obj*. "
"Successive calls will update *obj*'s eventmask to the value of "
"*eventmask* (i.e. will behave as `modify()`)."
msgstr ""

#: ../../../library/uselect.rst:54
msgid "Unregister *obj* from polling."
msgstr ""

#: ../../../library/uselect.rst:58
msgid ""
"Modify the *eventmask* for *obj*. If *obj* is not registered, `OSError` "
"is raised with error of ENOENT."
msgstr ""

#: ../../../library/uselect.rst:63
msgid ""
"Wait for at least one of the registered objects to become ready or have "
"an exceptional condition, with optional timeout in milliseconds (if "
"*timeout* arg is not specified or -1, there is no timeout)."
msgstr ""

#: ../../../library/uselect.rst:67
msgid ""
"Returns list of (``obj``, ``event``, ...) tuples. There may be other "
"elements in tuple, depending on a platform and version, so don't assume "
"that its size is 2. The ``event`` element specifies which events happened"
" with a stream and is a combination of ``uselect.POLL*`` constants "
"described above. Note that flags ``uselect.POLLHUP`` and "
"``uselect.POLLERR`` can be returned at any time (even if were not asked "
"for), and must be acted on accordingly (the corresponding stream "
"unregistered from poll and likely closed), because otherwise all further "
"invocations of `poll()` may return immediately with these flags set for "
"this stream again."
msgstr ""

#: ../../../library/uselect.rst:77
msgid "In case of timeout, an empty list is returned."
msgstr ""

#: ../../../library/uselect.rst:82
msgid "Tuples returned may contain more than 2 elements as described above."
msgstr ""

#: ../../../library/uselect.rst:86
msgid ""
"Like :meth:`poll.poll`, but instead returns an iterator which yields a "
"`callee-owned tuple`. This function provides an efficient, allocation-"
"free way to poll on streams."
msgstr ""

#: ../../../library/uselect.rst:90
msgid ""
"If *flags* is 1, one-shot behavior for events is employed: streams for "
"which events happened will have their event masks automatically reset "
"(equivalent to ``poll.modify(obj, 0)``), so new events for such a stream "
"won't be processed until new mask is set with `poll.modify()`. This "
"behavior is useful for asynchronous I/O schedulers."
msgstr ""

#: ../../../library/uselect.rst:99
msgid "This function is a MicroPython extension."
msgstr ""

#: ../../../library/usocket.rst:3
msgid ":mod:`usocket` -- socket module"
msgstr ""

#: ../../../library/usocket.rst:8
msgid "|see_cpython_module| :mod:`python:socket`."
msgstr ""

#: ../../../library/usocket.rst:10
msgid "This module provides access to the BSD socket interface."
msgstr ""

#: ../../../library/usocket.rst:15
msgid ""
"For efficiency and consistency, socket objects in MicroPython implement a"
" `stream` (file-like) interface directly. In CPython, you need to convert"
" a socket to a file-like object using `makefile()` method. This method is"
" still supported by MicroPython (but is a no-op), so where compatibility "
"with CPython matters, be sure to use it."
msgstr ""

#: ../../../library/usocket.rst:22
msgid "Socket address format(s)"
msgstr ""

#: ../../../library/usocket.rst:24
msgid ""
"The native socket address format of the ``usocket`` module is an opaque "
"data type returned by `getaddrinfo` function, which must be used to "
"resolve textual address (including numeric addresses)::"
msgstr ""

#: ../../../library/usocket.rst:28
msgid ""
"sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1]\n"
"# You must use getaddrinfo() even for numeric addresses\n"
"sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1]\n"
"# Now you can use that address\n"
"sock.connect(addr)"
msgstr ""

#: ../../../library/usocket.rst:34
msgid ""
"Using `getaddrinfo` is the most efficient (both in terms of memory and "
"processing power) and portable way to work with addresses."
msgstr ""

#: ../../../library/usocket.rst:37
msgid ""
"However, ``socket`` module (note the difference with native MicroPython "
"``usocket`` module described here) provides CPython-compatible way to "
"specify addresses using tuples, as described below. Note that depending "
"on a `MicroPython port`, ``socket`` module can be builtin or need to be "
"installed from `micropython-lib` (as in the case of `MicroPython Unix "
"port`), and some ports still accept only numeric addresses in the tuple "
"format, and require to use `getaddrinfo` function to resolve domain "
"names."
msgstr ""

#: ../../../library/usocket.rst:45
msgid "Summing up:"
msgstr ""

#: ../../../library/usocket.rst:47
msgid "Always use `getaddrinfo` when writing portable applications."
msgstr ""

#: ../../../library/usocket.rst:48
msgid ""
"Tuple addresses described below can be used as a shortcut for quick hacks"
" and interactive use, if your port supports them."
msgstr ""

#: ../../../library/usocket.rst:51
msgid "Tuple address format for ``socket`` module:"
msgstr ""

#: ../../../library/usocket.rst:53
msgid ""
"IPv4: *(ipv4_address, port)*, where *ipv4_address* is a string with dot-"
"notation numeric IPv4 address, e.g. ``\"8.8.8.8\"``, and *port* is and "
"integer port number in the range 1-65535. Note the domain names are not "
"accepted as *ipv4_address*, they should be resolved first using "
"`usocket.getaddrinfo()`."
msgstr ""

#: ../../../library/usocket.rst:58
msgid ""
"IPv6: *(ipv6_address, port, flowinfo, scopeid)*, where *ipv6_address* is "
"a string with colon-notation numeric IPv6 address, e.g. "
"``\"2001:db8::1\"``, and *port* is an integer port number in the range "
"1-65535. *flowinfo* must be 0. *scopeid* is the interface scope "
"identifier for link-local addresses. Note the domain names are not "
"accepted as *ipv6_address*, they should be resolved first using "
"`usocket.getaddrinfo()`. Availability of IPv6 support depends on a "
"`MicroPython port`."
msgstr ""

#: ../../../library/usocket.rst:71
msgid ""
"Create a new socket using the given address family, socket type and "
"protocol number. Note that specifying *proto* in most cases is not "
"required (and not recommended, as some MicroPython ports may omit "
"``IPPROTO_*`` constants). Instead, *type* argument will select needed "
"protocol automatically::"
msgstr ""

#: ../../../library/usocket.rst:77
msgid ""
"# Create STREAM TCP socket\n"
"socket(AF_INET, SOCK_STREAM)\n"
"# Create DGRAM UDP socket\n"
"socket(AF_INET, SOCK_DGRAM)"
msgstr ""

#: ../../../library/usocket.rst:84
msgid ""
"Translate the host/port argument into a sequence of 5-tuples that contain"
" all the necessary arguments for creating a socket connected to that "
"service. Arguments *af*, *type*, and *proto* (which have the same meaning"
" as for the `socket()` function) can be used to filter which kind of "
"addresses are returned. If a parameter is not specified or zero, all "
"combinations of addresses can be returned (requiring filtering on the "
"user side)."
msgstr ""

#: ../../../library/usocket.rst:91
msgid "The resulting list of 5-tuples has the following structure::"
msgstr ""

#: ../../../library/usocket.rst:93
msgid "(family, type, proto, canonname, sockaddr)"
msgstr ""

#: ../../../library/usocket.rst:95
msgid "The following example shows how to connect to a given url::"
msgstr ""

#: ../../../library/usocket.rst:97
msgid ""
"s = usocket.socket()\n"
"# This assumes that if \"type\" is not specified, an address for\n"
"# SOCK_STREAM will be returned, which may be not true\n"
"s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1])"
msgstr ""

#: ../../../library/usocket.rst:102
msgid "Recommended use of filtering params::"
msgstr ""

#: ../../../library/usocket.rst:104
msgid ""
"s = usocket.socket()\n"
"# Guaranteed to return an address which can be connect'ed to for\n"
"# stream operation.\n"
"s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, "
"SOCK_STREAM)[0][-1])"
msgstr ""

#: ../../../library/usocket.rst:112
msgid ""
"CPython raises a ``socket.gaierror`` exception (`OSError` subclass) in "
"case of error in this function. MicroPython doesn't have "
"``socket.gaierror`` and raises OSError directly. Note that error numbers "
"of `getaddrinfo()` form a separate namespace and may not match error "
"numbers from the :mod:`uerrno` module. To distinguish `getaddrinfo()` "
"errors, they are represented by negative numbers, whereas standard system"
" errors are positive numbers (error numbers are accessible using "
"``e.args[0]`` property from an exception object). The use of negative "
"values is a provisional detail which may change in the future."
msgstr ""

#: ../../../library/usocket.rst:124
msgid ""
"Convert a binary network address *bin_addr* of the given address family "
"*af* to a textual representation::"
msgstr ""

#: ../../../library/usocket.rst:127
msgid ""
">>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\")\n"
"'127.0.0.1'"
msgstr ""

#: ../../../library/usocket.rst:132
msgid ""
"Convert a textual network address *txt_addr* of the given address family "
"*af* to a binary representation::"
msgstr ""

#: ../../../library/usocket.rst:135
msgid ""
">>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\")\n"
"b'\\x01\\x02\\x03\\x04'"
msgstr ""

#: ../../../library/usocket.rst:144
msgid ""
"Address family types. Availability depends on a particular `MicroPython "
"port`."
msgstr ""

#: ../../../library/usocket.rst:149
msgid "Socket types."
msgstr ""

#: ../../../library/usocket.rst:154
msgid ""
"IP protocol numbers. Availability depends on a particular `MicroPython "
"port`. Note that you don't need to specify these in a call to "
"`usocket.socket()`, because `SOCK_STREAM` socket type automatically "
"selects `IPPROTO_TCP`, and `SOCK_DGRAM` - `IPPROTO_UDP`. Thus, the only "
"real use of these constants is as an argument to `setsockopt()`."
msgstr ""

#: ../../../library/usocket.rst:162
msgid ""
"Socket option levels (an argument to `setsockopt()`). The exact inventory"
" depends on a `MicroPython port`."
msgstr ""

#: ../../../library/usocket.rst:167
msgid ""
"Socket options (an argument to `setsockopt()`). The exact inventory "
"depends on a `MicroPython port`."
msgstr ""

#: ../../../library/usocket.rst:170
msgid "Constants specific to WiPy:"
msgstr ""

#: ../../../library/usocket.rst:174
msgid "Special protocol value to create SSL-compatible socket."
msgstr ""

#: ../../../library/usocket.rst:177
msgid "class socket"
msgstr ""

#: ../../../library/usocket.rst:184
msgid ""
"Mark the socket closed and release all resources. Once that happens, all "
"future operations on the socket object will fail. The remote end will "
"receive EOF indication if supported by protocol."
msgstr ""

#: ../../../library/usocket.rst:188
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it "
"is recommended to `close()` them explicitly as soon you finished working "
"with them."
msgstr ""

#: ../../../library/usocket.rst:193
msgid "Bind the socket to *address*. The socket must not already be bound."
msgstr ""

#: ../../../library/usocket.rst:197
msgid ""
"Enable a server to accept connections. If *backlog* is specified, it must"
" be at least 0 (if it's lower, it will be set to 0); and specifies the "
"number of unaccepted connections that the system will allow before "
"refusing new connections. If not specified, a default reasonable value is"
" chosen."
msgstr ""

#: ../../../library/usocket.rst:204
msgid ""
"Accept a connection. The socket must be bound to an address and listening"
" for connections. The return value is a pair (conn, address) where conn "
"is a new socket object usable to send and receive data on the connection,"
" and address is the address bound to the socket on the other end of the "
"connection."
msgstr ""

#: ../../../library/usocket.rst:211
msgid "Connect to a remote socket at *address*."
msgstr ""

#: ../../../library/usocket.rst:215
msgid ""
"Send data to the socket. The socket must be connected to a remote socket."
" Returns number of bytes sent, which may be smaller than the length of "
"data (\"short write\")."
msgstr ""

#: ../../../library/usocket.rst:221
msgid ""
"Send all data to the socket. The socket must be connected to a remote "
"socket. Unlike `send()`, this method will try to send all of data, by "
"sending data chunk by chunk consecutively."
msgstr ""

#: ../../../library/usocket.rst:225
msgid ""
"The behavior of this method on non-blocking sockets is undefined. Due to "
"this, on MicroPython, it's recommended to use `write()` method instead, "
"which has the same \"no short writes\" policy for blocking sockets, and "
"will return number of bytes sent on non-blocking sockets."
msgstr ""

#: ../../../library/usocket.rst:232
msgid ""
"Receive data from the socket. The return value is a bytes object "
"representing the data received. The maximum amount of data to be received"
" at once is specified by bufsize."
msgstr ""

#: ../../../library/usocket.rst:237
msgid ""
"Send data to the socket. The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*."
msgstr ""

#: ../../../library/usocket.rst:242
msgid ""
"Receive data from the socket. The return value is a pair *(bytes, "
"address)* where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data."
msgstr ""

#: ../../../library/usocket.rst:248
msgid ""
"Set the value of the given socket option. The needed symbolic constants "
"are defined in the socket module (SO_* etc.). The *value* can be an "
"integer or a bytes-like object representing a buffer."
msgstr ""

#: ../../../library/usocket.rst:254
msgid "**Note**: Not every port supports this method, see below."
msgstr ""

#: ../../../library/usocket.rst:256
msgid ""
"Set a timeout on blocking socket operations. The value argument can be a "
"nonnegative floating point number expressing seconds, or None. If a non-"
"zero value is given, subsequent socket operations will raise an `OSError`"
" exception if the timeout period value has elapsed before the operation "
"has completed. If zero is given, the socket is put in non-blocking mode. "
"If None is given, the socket is put in blocking mode."
msgstr ""

#: ../../../library/usocket.rst:262
msgid ""
"Not every `MicroPython port` supports this method. A more portable and "
"generic solution is to use `uselect.poll` object. This allows to wait on "
"multiple objects at the same time (and not just on sockets, but on "
"generic `stream` objects which support polling). Example::"
msgstr ""

#: ../../../library/usocket.rst:267
msgid ""
"# Instead of:\n"
"s.settimeout(1.0)  # time in seconds\n"
"s.read(10)  # may timeout\n"
"\n"
"# Use:\n"
"poller = uselect.poll()\n"
"poller.register(s, uselect.POLLIN)\n"
"res = poller.poll(1000)  # time in milliseconds\n"
"if not res:\n"
"    # s is still not ready for input, i.e. operation timed out"
msgstr ""

#: ../../../library/usocket.rst:281
msgid ""
"CPython raises a ``socket.timeout`` exception in case of timeout, which "
"is an `OSError` subclass. MicroPython raises an OSError directly instead."
" If you use ``except OSError:`` to catch the exception, your code will "
"work both in MicroPython and CPython."
msgstr ""

#: ../../../library/usocket.rst:288
msgid ""
"Set blocking or non-blocking mode of the socket: if flag is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""

#: ../../../library/usocket.rst:291
msgid "This method is a shorthand for certain `settimeout()` calls:"
msgstr ""

#: ../../../library/usocket.rst:293
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr ""

#: ../../../library/usocket.rst:294
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0)``"
msgstr ""

#: ../../../library/usocket.rst:298
msgid ""
"Return a file object associated with the socket. The exact returned type "
"depends on the arguments given to makefile(). The support is limited to "
"binary modes only ('rb', 'wb', and 'rwb'). CPython's arguments: "
"*encoding*, *errors* and *newline* are not supported."
msgstr ""

#: ../../../library/usocket.rst:305
msgid ""
"As MicroPython doesn't support buffered streams, values of *buffering* "
"parameter is ignored and treated as if it was 0 (unbuffered)."
msgstr ""

#: ../../../library/usocket.rst:311
msgid ""
"Closing the file object returned by makefile() WILL close the original "
"socket as well."
msgstr ""

#: ../../../library/usocket.rst:316
msgid ""
"Read up to size bytes from the socket. Return a bytes object. If *size* "
"is not given, it reads all data available from the socket until EOF; as "
"such the method will not return until the socket is closed. This function"
" tries to read as much data as requested (no \"short reads\"). This may "
"be not possible with non-blocking socket though, and then less data will "
"be returned."
msgstr ""

#: ../../../library/usocket.rst:324
msgid ""
"Read bytes into the *buf*.  If *nbytes* is specified then read at most "
"that many bytes.  Otherwise, read at most *len(buf)* bytes. Just as "
"`read()`, this method follows \"no short reads\" policy."
msgstr ""

#: ../../../library/usocket.rst:328
msgid "Return value: number of bytes read and stored into *buf*."
msgstr ""

#: ../../../library/usocket.rst:334
msgid "Return value: the line read."
msgstr ""

#: ../../../library/usocket.rst:338
msgid ""
"Write the buffer of bytes to the socket. This function will try to write "
"all data to a socket (no \"short writes\"). This may be not possible with"
" a non-blocking socket though, and returned value will be less than the "
"length of *buf*."
msgstr ""

#: ../../../library/usocket.rst:343
msgid "Return value: number of bytes written."
msgstr ""

#: ../../../library/usocket.rst:347
msgid "MicroPython does NOT have this exception."
msgstr ""

#: ../../../library/usocket.rst:352
msgid ""
"CPython used to have a ``socket.error`` exception which is now "
"deprecated, and is an alias of `OSError`. In MicroPython, use `OSError` "
"directly."
msgstr ""

#: ../../../library/ussl.rst:2
msgid ":mod:`ussl` -- SSL/TLS module"
msgstr ""

#: ../../../library/ussl.rst:7
msgid "|see_cpython_module| :mod:`python:ssl`."
msgstr ""

#: ../../../library/ussl.rst:9
msgid ""
"This module provides access to Transport Layer Security (previously and "
"widely known as “Secure Sockets Layer”) encryption and peer "
"authentication facilities for network sockets, both client-side and "
"server-side."
msgstr ""

#: ../../../library/ussl.rst:18
msgid ""
"Takes a `stream` *sock* (usually usocket.socket instance of "
"``SOCK_STREAM`` type), and returns an instance of ssl.SSLSocket, which "
"wraps the underlying stream in an SSL context. Returned object has the "
"usual `stream` interface methods like ``read()``, ``write()``, etc. In "
"MicroPython, the returned object does not expose socket interface and "
"methods like ``recv()``, ``send()``. In particular, a server-side SSL "
"socket should be created from a normal socket returned from "
":meth:`~usocket.socket.accept()` on a non-SSL listening server socket."
msgstr ""

#: ../../../library/ussl.rst:26
msgid ""
"Depending on the underlying module implementation in a particular "
"`MicroPython port`, some or all keyword arguments above may be not "
"supported."
msgstr ""

#: ../../../library/ussl.rst:31
msgid ""
"Some implementations of ``ussl`` module do NOT validate server "
"certificates, which makes an SSL connection established prone to man-in-"
"the-middle attacks."
msgstr ""

#: ../../../library/ussl.rst:39
msgid "This exception does NOT exist. Instead its base class, OSError, is used."
msgstr ""

#: ../../../library/ussl.rst:48
msgid "Supported values for *cert_reqs* parameter."
msgstr ""

#: ../../../library/ustruct.rst:2
msgid ":mod:`ustruct` -- pack and unpack primitive data types"
msgstr ""

#: ../../../library/ustruct.rst:7
msgid "|see_cpython_module| :mod:`python:struct`."
msgstr ""

#: ../../../library/ustruct.rst:9
msgid "Supported size/byte order prefixes: ``@``, ``<``, ``>``, ``!``."
msgstr ""

#: ../../../library/ustruct.rst:11
msgid ""
"Supported format codes: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``, "
"``L``, ``q``, ``Q``, ``s``, ``P``, ``f``, ``d`` (the latter 2 depending "
"on the floating-point support)."
msgstr ""

#: ../../../library/ustruct.rst:20
msgid "Return the number of bytes needed to store the given *fmt*."
msgstr ""

#: ../../../library/ustruct.rst:24
msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *fmt*. The"
" return value is a bytes object encoding the values."
msgstr ""

#: ../../../library/ustruct.rst:29
msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *fmt* into"
" a *buffer* starting at *offset*. *offset* may be negative to count from "
"the end of *buffer*."
msgstr ""

#: ../../../library/ustruct.rst:35
msgid ""
"Unpack from the *data* according to the format string *fmt*. The return "
"value is a tuple of the unpacked values."
msgstr ""

#: ../../../library/ustruct.rst:40
msgid ""
"Unpack from the *data* starting at *offset* according to the format "
"string *fmt*. *offset* may be negative to count from the end of *buffer*."
" The return value is a tuple of the unpacked values."
msgstr ""

#: ../../../library/utime.rst:2
msgid ":mod:`utime` -- time related functions"
msgstr ""

#: ../../../library/utime.rst:7
msgid "|see_cpython_module| :mod:`python:time`."
msgstr ""

#: ../../../library/utime.rst:9
msgid ""
"The ``utime`` module provides functions for getting the current time and "
"date, measuring time intervals, and for delays."
msgstr ""

#: ../../../library/utime.rst:12
msgid ""
"**Time Epoch**: Unix port uses standard for POSIX systems epoch of "
"1970-01-01 00:00:00 UTC. However, embedded ports use epoch of 2000-01-01 "
"00:00:00 UTC."
msgstr ""

#: ../../../library/utime.rst:16
msgid ""
"**Maintaining actual calendar date/time**: This requires a Real Time "
"Clock (RTC). On systems with underlying OS (including some RTOS), an RTC "
"may be implicit. Setting and maintaining actual calendar time is "
"responsibility of OS/RTOS and is done outside of MicroPython, it just "
"uses OS API to query date/time. On baremetal ports however system time "
"depends on ``machine.RTC()`` object. The current calendar time may be set"
" using ``machine.RTC().datetime(tuple)`` function, and maintained by "
"following means:"
msgstr ""

#: ../../../library/utime.rst:25
msgid ""
"By a backup battery (which may be an additional, optional component for a"
" particular board)."
msgstr ""

#: ../../../library/utime.rst:27
msgid "Using networked time protocol (requires setup by a port/user)."
msgstr ""

#: ../../../library/utime.rst:28
msgid ""
"Set manually by a user on each power-up (many boards then maintain RTC "
"time across hard resets, though some may require setting it again in such"
" case)."
msgstr ""

#: ../../../library/utime.rst:32
msgid ""
"If actual calendar time is not maintained with a system/MicroPython RTC, "
"functions below which require reference to current absolute time may "
"behave not as expected."
msgstr ""

#: ../../../library/utime.rst:41
msgid ""
"Convert a time expressed in seconds since the Epoch (see above) into an "
"8-tuple which contains: (year, month, mday, hour, minute, second, "
"weekday, yearday) If secs is not provided or None, then the current time "
"from the RTC is used."
msgstr ""

#: ../../../library/utime.rst:45
msgid "year includes the century (for example 2014)."
msgstr ""

#: ../../../library/utime.rst:46
msgid "month   is 1-12"
msgstr ""

#: ../../../library/utime.rst:47
msgid "mday    is 1-31"
msgstr ""

#: ../../../library/utime.rst:48
msgid "hour    is 0-23"
msgstr ""

#: ../../../library/utime.rst:49
msgid "minute  is 0-59"
msgstr ""

#: ../../../library/utime.rst:50
msgid "second  is 0-59"
msgstr ""

#: ../../../library/utime.rst:51
msgid "weekday is 0-6 for Mon-Sun"
msgstr ""

#: ../../../library/utime.rst:52
msgid "yearday is 1-366"
msgstr ""

#: ../../../library/utime.rst:56
msgid ""
"This is inverse function of localtime. It's argument is a full 8-tuple "
"which expresses a time as per localtime. It returns an integer which is "
"the number of seconds since Jan 1, 2000."
msgstr ""

#: ../../../library/utime.rst:62
msgid ""
"Sleep for the given number of seconds. Some boards may accept *seconds* "
"as a floating-point number to sleep for a fractional number of seconds. "
"Note that other boards may not accept a floating-point argument, for "
"compatibility with them use `sleep_ms()` and `sleep_us()` functions."
msgstr ""

#: ../../../library/utime.rst:69
msgid "Delay for given number of milliseconds, should be positive or 0."
msgstr ""

#: ../../../library/utime.rst:73
msgid "Delay for given number of microseconds, should be positive or 0."
msgstr ""

#: ../../../library/utime.rst:77
msgid ""
"Returns an increasing millisecond counter with an arbitrary reference "
"point, that wraps around after some value."
msgstr ""

#: ../../../library/utime.rst:80
msgid ""
"The wrap-around value is not explicitly exposed, but we will refer to it "
"as *TICKS_MAX* to simplify discussion. Period of the values is "
"*TICKS_PERIOD = TICKS_MAX + 1*. *TICKS_PERIOD* is guaranteed to be a "
"power of two, but otherwise may differ from port to port. The same period"
" value is used for all of `ticks_ms()`, `ticks_us()`, `ticks_cpu()` "
"functions (for simplicity). Thus, these functions will return a value in "
"range [*0* .. *TICKS_MAX*], inclusive, total *TICKS_PERIOD* values. Note "
"that only non-negative values are used. For the most part, you should "
"treat values returned by these functions as opaque. The only operations "
"available for them are `ticks_diff()` and `ticks_add()` functions "
"described below."
msgstr ""

#: ../../../library/utime.rst:91
msgid ""
"Note: Performing standard mathematical operations (+, -) or relational "
"operators (<, <=, >, >=) directly on these value will lead to invalid "
"result. Performing mathematical operations and then passing their results"
" as arguments to `ticks_diff()` or `ticks_add()` will also lead to "
"invalid results from the latter functions."
msgstr ""

#: ../../../library/utime.rst:99
msgid "Just like `ticks_ms()` above, but in microseconds."
msgstr ""

#: ../../../library/utime.rst:103
msgid ""
"Similar to `ticks_ms()` and `ticks_us()`, but with the highest possible "
"resolution in the system. This is usually CPU clocks, and that's why the "
"function is named that way. But it doesn't have to be a CPU clock, some "
"other timing source available in a system (e.g. high-resolution timer) "
"can be used instead. The exact timing unit (resolution) of this function "
"is not specified on ``utime`` module level, but documentation for a "
"specific port may provide more specific information. This function is "
"intended for very fine benchmarking or very tight real-time loops. Avoid "
"using it in portable code."
msgstr ""

#: ../../../library/utime.rst:112
msgid "Availability: Not every port implements this function."
msgstr ""

#: ../../../library/utime.rst:117
msgid ""
"Offset ticks value by a given number, which can be either positive or "
"negative. Given a *ticks* value, this function allows to calculate ticks "
"value *delta* ticks before or after it, following modular-arithmetic "
"definition of tick values (see `ticks_ms()` above). *ticks* parameter "
"must be a direct result of call to `ticks_ms()`, `ticks_us()`, or "
"`ticks_cpu()` functions (or from previous call to `ticks_add()`). "
"However, *delta* can be an arbitrary integer number or numeric "
"expression. `ticks_add()` is useful for calculating deadlines for "
"events/tasks. (Note: you must use `ticks_diff()` function to work with "
"deadlines.)"
msgstr ""

#: ../../../library/utime.rst:127
msgid "Examples::"
msgstr ""

#: ../../../library/utime.rst:129
msgid ""
"# Find out what ticks value there was 100ms ago\n"
"print(ticks_add(time.ticks_ms(), -100))\n"
"\n"
"# Calculate deadline for operation and test for it\n"
"deadline = ticks_add(time.ticks_ms(), 200)\n"
"while ticks_diff(deadline, time.ticks_ms()) > 0:\n"
"    do_a_little_of_something()\n"
"\n"
"# Find out TICKS_MAX used by this port\n"
"print(ticks_add(0, -1))"
msgstr ""

#: ../../../library/utime.rst:143
msgid ""
"Measure ticks difference between values returned from `ticks_ms()`, "
"`ticks_us()`, or `ticks_cpu()` functions, as a signed value which may "
"wrap around."
msgstr ""

#: ../../../library/utime.rst:146
msgid ""
"The argument order is the same as for subtraction operator, "
"``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - "
"ticks2``. However, values returned by `ticks_ms()`, etc. functions may "
"wrap around, so directly using subtraction on them will produce incorrect"
" result. That is why `ticks_diff()` is needed, it implements modular (or "
"more specifically, ring) arithmetics to produce correct result even for "
"wrap-around values (as long as they not too distant inbetween, see "
"below). The function returns **signed** value in the range "
"[*-TICKS_PERIOD/2* .. *TICKS_PERIOD/2-1*] (that's a typical range "
"definition for two's-complement signed binary integers). If the result is"
" negative, it means that *ticks1* occurred earlier in time than *ticks2*."
" Otherwise, it means that *ticks1* occurred after *ticks2*. This holds "
"**only** if *ticks1* and *ticks2* are apart from each other for no more "
"than *TICKS_PERIOD/2-1* ticks. If that does not hold, incorrect result "
"will be returned. Specifically, if two tick values are apart for "
"*TICKS_PERIOD/2-1* ticks, that value will be returned by the function. "
"However, if *TICKS_PERIOD/2* of real-time ticks has passed between them, "
"the function will return *-TICKS_PERIOD/2* instead, i.e. result value "
"will wrap around to the negative range of possible values."
msgstr ""

#: ../../../library/utime.rst:164
msgid ""
"Informal rationale of the constraints above: Suppose you are locked in a "
"room with no means to monitor passing of time except a standard 12-notch "
"clock. Then if you look at dial-plate now, and don't look again for "
"another 13 hours (e.g., if you fall for a long sleep), then once you "
"finally look again, it may seem to you that only 1 hour has passed. To "
"avoid this mistake, just look at the clock regularly. Your application "
"should do the same. \"Too long sleep\" metaphor also maps directly to "
"application behavior: don't let your application run any single task for "
"too long. Run tasks in steps, and do time-keeping inbetween."
msgstr ""

#: ../../../library/utime.rst:173
msgid ""
"`ticks_diff()` is designed to accommodate various usage patterns, among "
"them:"
msgstr ""

#: ../../../library/utime.rst:175
msgid ""
"Polling with timeout. In this case, the order of events is known, and you"
" will deal only with positive results of `ticks_diff()`::"
msgstr ""

#: ../../../library/utime.rst:178
msgid ""
"# Wait for GPIO pin to be asserted, but at most 500us\n"
"start = time.ticks_us()\n"
"while pin.value() == 0:\n"
"    if time.ticks_diff(time.ticks_us(), start) > 500:\n"
"        raise TimeoutError"
msgstr ""

#: ../../../library/utime.rst:184
msgid ""
"Scheduling events. In this case, `ticks_diff()` result may be negative if"
" an event is overdue::"
msgstr ""

#: ../../../library/utime.rst:187
msgid ""
"# This code snippet is not optimized\n"
"now = time.ticks_ms()\n"
"scheduled_time = task.scheduled_time()\n"
"if ticks_diff(scheduled_time, now) > 0:\n"
"    print(\"Too early, let's nap\")\n"
"    sleep_ms(ticks_diff(scheduled_time, now))\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) == 0:\n"
"    print(\"Right at time!\")\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) < 0:\n"
"    print(\"Oops, running late, tell task to run faster!\")\n"
"    task.run(run_faster=true)"
msgstr ""

#: ../../../library/utime.rst:201
msgid ""
"Note: Do not pass `time()` values to `ticks_diff()`, you should use "
"normal mathematical operations on them. But note that `time()` may (and "
"will) also overflow. This is known as "
"https://en.wikipedia.org/wiki/Year_2038_problem ."
msgstr ""

#: ../../../library/utime.rst:208
msgid ""
"Returns the number of seconds, as an integer, since the Epoch, assuming "
"that underlying RTC is set and maintained as described above. If an RTC "
"is not set, this function returns number of seconds since a port-specific"
" reference point in time (for embedded boards without a battery-backed "
"RTC, usually since power up or reset). If you want to develop portable "
"MicroPython application, you should not rely on this function to provide "
"higher than second precision. If you need higher precision, use "
"`ticks_ms()` and `ticks_us()` functions, if you need calendar time, "
"`localtime()` without an argument is a better choice."
msgstr ""

#: ../../../library/utime.rst:220
msgid ""
"In CPython, this function returns number of seconds since Unix epoch, "
"1970-01-01 00:00 UTC, as a floating-point, usually having microsecond "
"precision. With MicroPython, only Unix port uses the same Epoch, and if "
"floating-point precision allows, returns sub-second precision. Embedded "
"hardware usually doesn't have floating-point precision to represent both "
"long time ranges and subsecond precision, so they use integer value with "
"second precision. Some embedded hardware also lacks battery-powered RTC, "
"so returns number of seconds since last power-up or from other relative, "
"hardware-specific point (e.g. reset)."
msgstr ""

#: ../../../library/uzlib.rst:2
msgid ":mod:`uzlib` -- zlib decompression"
msgstr ""

#: ../../../library/uzlib.rst:7
msgid "|see_cpython_module| :mod:`python:zlib`."
msgstr ""

#: ../../../library/uzlib.rst:9
msgid ""
"This module allows to decompress binary data compressed with `DEFLATE "
"algorithm <https://en.wikipedia.org/wiki/DEFLATE>`_ (commonly used in "
"zlib library and gzip archiver). Compression is not yet implemented."
msgstr ""

#: ../../../library/uzlib.rst:19
msgid ""
"Return decompressed *data* as bytes. *wbits* is DEFLATE dictionary window"
" size used during compression (8-15, the dictionary size is power of 2 of"
" that value). Additionally, if value is positive, *data* is assumed to be"
" zlib stream (with zlib header). Otherwise, if it's negative, it's "
"assumed to be raw DEFLATE stream. *bufsize* parameter is for "
"compatibility with CPython and is ignored."
msgstr ""

#: ../../../library/uzlib.rst:28
msgid ""
"Create a `stream` wrapper which allows transparent decompression of "
"compressed data in another *stream*. This allows to process compressed "
"streams with data larger than available heap size. In addition to values "
"described in :func:`decompress`, *wbits* may take values 24..31 (16 + "
"8..15), meaning that input stream has gzip header."
msgstr ""

#: ../../../library/uzlib.rst:37
msgid ""
"This class is MicroPython extension. It's included on provisional basis "
"and may be changed considerably or removed in later versions."
msgstr ""

#: ../../../library/wipy.rst:3
msgid ":mod:`wipy` -- WiPy specific features"
msgstr ""

#: ../../../library/wipy.rst:8
msgid ""
"The ``wipy`` module contains functions to control specific features of "
"the WiPy, such as the heartbeat LED."
msgstr ""

#: ../../../library/wipy.rst:16
msgid ""
"Get or set the state (enabled or disabled) of the heartbeat LED. Accepts "
"and returns boolean values (``True`` or ``False``)."
msgstr ""

