# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Damien P. George, Paul Sokolovsky, and
# contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-26 09:54+0900\n"
"PO-Revision-Date: 2020-02-24 12:50+0900\n"
"Last-Translator: Minoru Inachi\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../../library/_thread.rst:2
msgid ":mod:`_thread` -- multithreading support"
msgstr ":mod:`_thread` -- マルチスレッドサポート"

#: ../../../library/_thread.rst:7
msgid "|see_cpython_module| :mod:`python:_thread`."
msgstr ""

#: ../../../library/_thread.rst:9
msgid "This module implements multithreading support."
msgstr "このモジュールは、マルチスレッドのサポートを実装します。"

#: ../../../library/_thread.rst:11
msgid ""
"This module is highly experimental and its API is not yet fully settled "
"and not yet described in this documentation."
msgstr ""
"このモジュールは初期の実験段階にあり、API はまだ完全には決まっていないため、"
"このドキュメントではまだ説明しません。"

#: ../../../library/uarray.rst:2
msgid ":mod:`uarray` -- arrays of numeric data"
msgstr ":mod:`uarray` -- 数値データの配列"

#: ../../../library/uarray.rst:7
msgid "|see_cpython_module| :mod:`python:uarray`."
msgstr ""

#: ../../../library/uarray.rst:9
msgid ""
"Supported format codes: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``, "
"``L``, ``q``, ``Q``, ``f``, ``d`` (the latter 2 depending on the "
"floating-point support)."
msgstr ""
"サポートする書式コード: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``, "
"``L``, ``q``, ``Q``, ``f``, ``d`` (最後の２つは浮動小数点サポートに依存します)。"

#: ../../../library/uarray.rst:14 ../../../library/machine.rst:141
#: ../../../library/pyb.rst:291 ../../../library/ucollections.rst:13
#: ../../../library/ucryptolib.rst:8 ../../../library/uio.rst:87
msgid "Classes"
msgstr "クラス"

#: ../../../library/uarray.rst:18
msgid ""
"Create array with elements of given type. Initial contents of the array "
"are given by *iterable*. If it is not provided, an empty array is "
"created."
msgstr ""
"与えたデータ型の要素を持つ配列を作成します。配列の初期値は *iterable* に与えます。"
"これを与えない場合は空の配列が作成されます。"

#: ../../../library/uarray.rst:24
msgid "Append new element *val* to the end of array, growing it."
msgstr "配列の最後に新しい要素 *val* を追加します。"

#: ../../../library/uarray.rst:28
msgid ""
"Append new elements as contained in *iterable* to the end of array, "
"growing it."
msgstr ""
"配列の最後に *iterable* に含まれる新しい要素を追加します。"

#: ../../../library/btree.rst:2
msgid ":mod:`btree` -- simple BTree database"
msgstr ":mod:`btree` -- 単純な BTree データベース"

#: ../../../library/btree.rst:7
msgid ""
"The ``btree`` module implements a simple key-value database using "
"external storage (disk files, or in general case, a random-access "
"`stream`). Keys are stored sorted in the database, and besides efficient "
"retrieval by a key value, a database also supports efficient ordered "
"range scans (retrieval of values with the keys in a given range). On the "
"application interface side, BTree database work as close a possible to a "
"way standard `dict` type works, one notable difference is that both keys "
"and values must be `bytes` objects (so, if you want to store objects of "
"other types, you need to serialize them to `bytes` first)."
msgstr ""
"``btree`` モジュールは、外部記憶装置(ディスクファイル、または一般的な場合はランダム"
"アクセスストリーム)を使用して単純な キー/値 (Key-Value)データベースを実装します。"
"キーはデータベースにソートして格納され、キー値による効率的な検索に加えて、データベース"
"は効率的な順序付き範囲スキャン(特定の範囲内のキーを持つ値の検索)もサポートします。"
"アプリケーションインタフェース側では、BTreeデータベースは標準の辞書型(`dict`)と"
"同じように機能します。辞書型との大きな違いは、キーと値の両方がバイト列(`bytes`)"
"オブジェクトでなければならないことです(したがって、他の型のオブジェクトを格納する"
"場合はバイト列にシリアル化しておく必要があります)。"

#: ../../../library/btree.rst:17
msgid "The module is based on the well-known BerkelyDB library, version 1.xx."
msgstr "このモジュールは、有名な BerkelyDB ライブラリ、バージョン 1.xx をベースにしています。"

#: ../../../library/btree.rst:19 ../../../library/machine.Signal.rst:19
#: ../../../library/pyb.ADC.rst:164 ../../../library/pyb.I2C.rst:13
#: ../../../library/pyb.Switch.rst:18 ../../../library/pyb.rst:51
#: ../../../library/pyb.rst:64
msgid "Example::"
msgstr "サンプルコード:"

#: ../../../library/btree.rst:21
msgid ""
"import btree\n"
"\n"
"# First, we need to open a stream which holds a database\n"
"# This is usually a file, but can be in-memory database\n"
"# using uio.BytesIO, a raw flash partition, etc.\n"
"# Oftentimes, you want to create a database file if it doesn't\n"
"# exist and open if it exists. Idiom below takes care of this.\n"
"# DO NOT open database with \"a+b\" access mode.\n"
"try:\n"
"    f = open(\"mydb\", \"r+b\")\n"
"except OSError:\n"
"    f = open(\"mydb\", \"w+b\")\n"
"\n"
"# Now open a database itself\n"
"db = btree.open(f)\n"
"\n"
"# The keys you add will be sorted internally in the database\n"
"db[b\"3\"] = b\"three\"\n"
"db[b\"1\"] = b\"one\"\n"
"db[b\"2\"] = b\"two\"\n"
"\n"
"# Assume that any changes are cached in memory unless\n"
"# explicitly flushed (or database closed). Flush database\n"
"# at the end of each \"transaction\".\n"
"db.flush()\n"
"\n"
"# Prints b'two'\n"
"print(db[b\"2\"])\n"
"\n"
"# Iterate over sorted keys in the database, starting from b\"2\"\n"
"# until the end of the database, returning only values.\n"
"# Mind that arguments passed to values() method are *key* values.\n"
"# Prints:\n"
"#   b'two'\n"
"#   b'three'\n"
"for word in db.values(b\"2\"):\n"
"    print(word)\n"
"\n"
"del db[b\"2\"]\n"
"\n"
"# No longer true, prints False\n"
"print(b\"2\" in db)\n"
"\n"
"# Prints:\n"
"#  b\"1\"\n"
"#  b\"3\"\n"
"for key in db:\n"
"    print(key)\n"
"\n"
"db.close()\n"
"\n"
"# Don't forget to close the underlying stream!\n"
"f.close()"
msgstr ""
"import btree\n"
"\n"
"# まず、データベースを保持するストリームをオープンする必要があります。\n"
"# これは通常ファイルですが、uio.BytesIO、raw フラッシュパーティション\n"
"# などを使用してインメモリデータベースにすることもできます。多くの場合、\n"
"# データベースファイルが存在しない場合には作成し、存在する場合はその\n"
"# ファイルを開くようにしたいでしょう。以下の慣用句を使えばそのようにできます。\n"
"# \"a+b\" アクセスモードでデータベースをオープンしないでください。\n"
"try:\n"
"    f = open(\"mydb\", \"r+b\")\n"
"except OSError:\n"
"    f = open(\"mydb\", \"w+b\")\n"
"\n"
"# ここでデータベース自体をオープンします\n"
"db = btree.open(f)\n"
"\n"
"# 追加するキーは内部的にデータベースに格納されます\n"
"db[b\"3\"] = b\"three\"\n"
"db[b\"1\"] = b\"one\"\n"
"db[b\"2\"] = b\"two\"\n"
"\n"
"# 明示的にフラッシュした(またはデータベースを閉じた)場合を除き、変更は\n"
"# すべてメモリーにキャッシュされると想定します。各「トランザクション」の\n"
"# 終わりにデータベースをフラッシュするようにしてください。\n"
"db.flush()\n"
"\n"
"# b'two' を表示します\n"
"print(db[b\"2\"])\n"
"\n"
"# データベース内のソートされたキーを b"2" からデータベースの最後まで\n"
"# 繰り返し、値のみを返します。values() メソッドに渡す引数がキー値である\n"
"# ことに注意してください。\n"
"# 以下が表示されます:\n"
"#   b'two'\n"
"#   b'three'\n"
"for word in db.values(b\"2\"):\n"
"    print(word)\n"
"\n"
"del db[b\"2\"]\n"
"\n"
"# もう True ではないので、False が表示されます\n"
"print(b\"2\" in db)\n"
"\n"
"# 以下が表示されます:\n"
"#  b\"1\"\n"
"#  b\"3\"\n"
"for key in db:\n"
"    print(key)\n"
"\n"
"db.close()\n"
"\n"
"# 基になるストリームのクローズを忘れないでください！\n"
"f.close()"

#: ../../../library/btree.rst:77 ../../../library/cmath.rst:16
#: ../../../library/esp.rst:13 ../../../library/esp32.rst:12
#: ../../../library/gc.rst:10 ../../../library/math.rst:18
#: ../../../library/micropython.rst:8 ../../../library/sys.rst:10
#: ../../../library/ubinascii.rst:13 ../../../library/uheapq.rst:14
#: ../../../library/uio.rst:78 ../../../library/ujson.rst:13
#: ../../../library/ure.rst:56 ../../../library/uselect.rst:13
#: ../../../library/usocket.rst:67 ../../../library/ussl.rst:14
#: ../../../library/ustruct.rst:16 ../../../library/utime.rst:37
#: ../../../library/uzlib.rst:15 ../../../library/wipy.rst:12
msgid "Functions"
msgstr "関数"

#: ../../../library/btree.rst:81
msgid ""
"Open a database from a random-access `stream` (like an open file). All "
"other parameters are optional and keyword-only, and allow to tweak "
"advanced parameters of the database operation (most users will not need "
"them):"
msgstr ""
"ランダムアクセスストリームからデータベースをオープンします(ファイルのオープンに"
"似ています)。他のすべてのパラメータはオプション、キーワード指定のみであり、"
"データベース操作の高度なパラメータを調整できます(ほとんどのユーザには必要ないで"
"しょう):"

#: ../../../library/btree.rst:85
msgid "*flags* - Currently unused."
msgstr "*flags* - 現在未使用です。"

#: ../../../library/btree.rst:86
msgid ""
"*pagesize* - Page size used for the nodes in BTree. Acceptable range is "
"512-65536. If 0, a port-specific default will be used, optimized for "
"port's memory usage and/or performance."
msgstr ""
"*pagesize* - BTree のノードに使用されるページサイズ。許容範囲は 512 から 65536 です。"
"0 の場合はポート固有のデフォルト値が適用され、ポートのメモリ使用量やパフォーマンスに"
"合わせて最適化されます。"

#: ../../../library/btree.rst:89
msgid ""
"*cachesize* - Suggested memory cache size in bytes. For a board with "
"enough memory using larger values may improve performance. Cache policy "
"is as follows: entire cache is not allocated at once; instead, accessing "
"a new page in database will allocate a memory buffer for it, until value "
"specified by *cachesize* is reached. Then, these buffers will be managed "
"using LRU (least recently used) policy. More buffers may still be "
"allocated if needed (e.g., if a database contains big keys and/or "
"values). Allocated cache buffers aren't reclaimed."
msgstr ""
"*cachesize* - 推奨されるメモリキャッシュサイズ(バイト単位)。より大きな値を使うのに"
"十分なメモリを備えたボードでは、パフォーマンスが向上する可能性があります。キャッシュ"
"のポリシーは次のとおりです。キャッシュ全体は一度に割り当てられません。代わりに、"
"データベース内の新しいページにアクセスすると、 *cachesize* で指定された値に達するまで、"
"そのページ用のメモリバッファが割り当てられます。その後、これらのバッファーは LRU "
"(Least Recently Used)ポリシーを使用して管理されます。必要に応じて、さらに多くの"
"バッファを割り当てることができます(たとえば、データベースに大きなキーや値が含まれている"
"場合など)。割り当てられたキャッシュバッファは再利用されません。"

#: ../../../library/btree.rst:97
msgid ""
"*minkeypage* - Minimum number of keys to store per page. Default value of"
" 0 equivalent to 2."
msgstr ""
"*minkeypage* - 1 ページに格納するキーの最小数。デフォルト値は 0 ですが、2 を指定"
"したのと同等です。"

#: ../../../library/btree.rst:100
msgid ""
"Returns a BTree object, which implements a dictionary protocol (set of "
"methods), and some additional methods described below."
msgstr ""
"戻り値は BTree オブジェクトです。これは辞書のプロトコル(一連のメソッド)と、"
"以下で説明する追加のメソッドを実装しています。"

#: ../../../library/btree.rst:104 ../../../library/machine.ADC.rst:33
#: ../../../library/machine.Pin.rst:107 ../../../library/machine.RTC.rst:25
#: ../../../library/machine.SD.rst:38 ../../../library/machine.SPI.rst:30
#: ../../../library/machine.Signal.rst:97 ../../../library/machine.Timer.rst:36
#: ../../../library/machine.TimerWiPy.rst:40
#: ../../../library/machine.TimerWiPy.rst:114
#: ../../../library/machine.UART.rst:44 ../../../library/machine.WDT.rst:30
#: ../../../library/network.CC3K.rst:52
#: ../../../library/network.WIZNET5K.rst:52
#: ../../../library/network.WLAN.rst:27
#: ../../../library/network.WLANWiPy.rst:44 ../../../library/pyb.ADC.rst:32
#: ../../../library/pyb.Accel.rst:24 ../../../library/pyb.CAN.rst:50
#: ../../../library/pyb.DAC.rst:77 ../../../library/pyb.ExtInt.rst:81
#: ../../../library/pyb.I2C.rst:81 ../../../library/pyb.LCD.rst:51
#: ../../../library/pyb.LED.rst:21 ../../../library/pyb.Pin.rst:99
#: ../../../library/pyb.Pin.rst:250 ../../../library/pyb.RTC.rst:26
#: ../../../library/pyb.SPI.rst:48 ../../../library/pyb.Servo.rst:39
#: ../../../library/pyb.Switch.rst:32 ../../../library/pyb.Timer.rst:63
#: ../../../library/pyb.Timer.rst:229 ../../../library/pyb.UART.rst:70
#: ../../../library/pyb.USB_HID.rst:22 ../../../library/pyb.USB_VCP.rst:21
#: ../../../library/uhashlib.rst:43 ../../../library/uselect.rst:32
#: ../../../library/usocket.rst:180
msgid "Methods"
msgstr "メソッド"

#: ../../../library/btree.rst:108
msgid ""
"Close the database. It's mandatory to close the database at the end of "
"processing, as some unwritten data may be still in the cache. Note that "
"this does not close underlying stream with which the database was opened,"
" it should be closed separately (which is also mandatory to make sure "
"that data flushed from buffer to the underlying storage)."
msgstr ""
"データベースをクローズします。書き込まれていないデータがまだキャッシュに残っている"
"可能性があるため、処理の最後にデータベースをクローズすることが必須です。これは"
"データベースがオープンされた元のストリームを閉じないことに注意してください、それは"
"別々にクローズするべきです(それもまたデータがバッファから基となるストレージに"
"フラッシュされることを確実にするために必須です)。"

#: ../../../library/btree.rst:116
msgid "Flush any data in cache to the underlying stream."
msgstr "キャッシュ内のデータを基となるストリームにフラッシュします。"

#: ../../../library/btree.rst:124
msgid "Standard dictionary methods."
msgstr "標準の辞書メソッドです。"

#: ../../../library/btree.rst:128
msgid ""
"A BTree object can be iterated over directly (similar to a dictionary) to"
" get access to all keys in order."
msgstr ""
"BTree オブジェクトは、(辞書のように)直接繰り返し処理して、すべてのキーに"
"順番にアクセスできます。"

#: ../../../library/btree.rst:135
msgid ""
"These methods are similar to standard dictionary methods, but also can "
"take optional parameters to iterate over a key sub-range, instead of the "
"entire database. Note that for all 3 methods, *start_key* and *end_key* "
"arguments represent key values. For example, `values()` method will "
"iterate over values corresponding to they key range given. None values "
"for *start_key* means \"from the first key\", no *end_key* or its value "
"of None means \"until the end of database\". By default, range is "
"inclusive of *start_key* and exclusive of *end_key*, you can include "
"*end_key* in iteration by passing *flags* of `btree.INCL`. You can "
"iterate in descending key direction by passing *flags* of `btree.DESC`. "
"The flags values can be ORed together."
msgstr ""
"これらのメソッドは標準的な辞書のメソッドと似ていますが、データベース全体ではなく、"
"主要なサブ範囲にわたって反復するためのオプションのパラメータを取ることもできます。"
"3つのメソッドすべてについて、 *start_key* 引数と *end_key* 引数がキー値である"
"ことに注意してください。たとえば、 `values()` メソッドは与えられたキー範囲に"
"対応する値を反復します。 *start_key* に値がない場合は「最初のキーから」、 "
"*end_key* がない 場合、または値が None の場合は「データベースの終わりまで」を"
"意味します。デフォルトでの範囲は、 *start_key* を含みますが、 *end_key* は"
"外されます。 *flags* に `btree.INCL` を渡すことで繰り返しに *end_key* を"
"含められます。 *flags* に `btree.DESC` を渡すことで降順のキー方向に反復"
"できます。 flags の値はビットOR(|)演算を使って複数指定できます。"

#: ../../library/btree.rst:149 ../../library/cmath.rst:55
#: ../../library/esp32.rst:73 ../../library/esp32.rst:106
#: ../../library/framebuf.rst:118 ../../library/lcd160cr.rst:380
#: ../../library/machine.Pin.rst:223 ../../library/machine.RTC.rst:65
#: ../../library/machine.SPI.rst:89 ../../library/machine.Timer.rst:59
#: ../../library/machine.TimerWiPy.rst:154 ../../library/machine.UART.rst:146
#: ../../library/machine.rst:138 ../../library/math.rst:177
#: ../../library/network.CC3K.rst:83 ../../library/network.WLANWiPy.rst:145
#: ../../library/pyb.CAN.rst:278 ../../library/pyb.ExtInt.rst:102
#: ../../library/pyb.I2C.rst:157 ../../library/pyb.Pin.rst:181
#: ../../library/pyb.SPI.rst:112 ../../library/pyb.UART.rst:163
#: ../../library/pyb.USB_VCP.rst:114 ../../library/sys.rst:47
#: ../../library/ubluetooth.rst:333 ../../library/uerrno.rst:13
#: ../../library/usocket.rst:139 ../../library/ussl.rst:42
msgid "Constants"
msgstr "定数"

#: ../../../library/btree.rst:153
msgid ""
"A flag for `keys()`, `values()`, `items()` methods to specify that "
"scanning should be inclusive of the end key."
msgstr ""
"`keys()`, `values()`, `items()` メソッドに指定するフラグであり、"
"反復対象として終了キーを含めます。"

#: ../../../library/btree.rst:158
msgid ""
"A flag for `keys()`, `values()`, `items()` methods to specify that "
"scanning should be in descending direction of keys."
msgstr ""
"`keys()`, `values()`, `items()` メソッドに指定するフラグであり、"
"キーの反復方向を降順にします。"

#: ../../../library/builtins.rst:2
msgid "Builtin functions and exceptions"
msgstr "組込みの関数と例外"

#: ../../../library/builtins.rst:4
msgid ""
"All builtin functions and exceptions are described here. They are also "
"available via ``builtins`` module."
msgstr ""
"組込みの関数と例外のすべては、ここで説明します。これらは"
"``builtins`` モジュール経由でも利用できます。"

#: ../../../library/builtins.rst:8
msgid "Functions and types"
msgstr "関数とデータ型"

#: ../../../library/builtins.rst:24
msgid "|see_cpython| `python:bytes`."
msgstr ""

#: ../../../library/builtins.rst:38
msgid ""
"The argument *name* should be a string, and this function deletes the "
"named attribute from the object given by *obj*."
msgstr ""
"引数 *name* は文字列でなければならず、この関数は *obj* で与えたオブジェクトから、"
"指定された名前の属性を削除します。"

#: ../../../library/builtins.rst:77 ../../../library/builtins.rst:82
msgid ""
"In MicroPython, `byteorder` parameter must be positional (this is "
"compatible with CPython)."
msgstr ""
"MicroPython では `byteorder` は位置パラメータでなければなりません(位置"
"パラメータとすることは CPython でも可能です)。"

#: ../../../library/builtins.rst:135
msgid "The *slice* builtin is the type that slice objects have."
msgstr "*slice* 組込み型は、スライスオブジェクトが持つデータ型です。"

#: ../../../library/builtins.rst:155 ../../../library/ussl.rst:35
msgid "Exceptions"
msgstr "例外"

#: ../../../library/builtins.rst:179
msgid ""
"|see_cpython| `python:OSError`. MicroPython doesn't implement ``errno`` "
"attribute, instead use the standard way to access exception arguments: "
"``exc.args[0]``."
msgstr ""
"|see_cpython| `python:OSError` 。MicroPython は ``errno`` 属性を実装しておらず、"
"代わりに標準的な方法 ``exc.args[0]`` で例外引数にアクセスします。"

#: ../../../library/builtins.rst:191
msgid "|see_cpython| `python:SystemExit`."
msgstr ""

#: ../../../library/builtins.rst:195
msgid "|see_cpython| `python:TypeError`."
msgstr ""

#: ../../../library/cmath.rst:2
msgid ":mod:`cmath` -- mathematical functions for complex numbers"
msgstr ":mod:`cmath` -- 複素数のための数学関数"

#: ../../../library/cmath.rst:7
msgid "|see_cpython_module| :mod:`python:cmath`."
msgstr ""

#: ../../../library/cmath.rst:9
msgid ""
"The ``cmath`` module provides some basic mathematical functions for "
"working with complex numbers."
msgstr ""
"``cmath`` モジュールは、複素数を扱うための基本的な数学関数を提供します。"

#: ../../../library/cmath.rst:12
msgid ""
"Availability: not available on WiPy and ESP8266. Floating point support "
"required for this module."
msgstr ""
"可用性: WiPy および ESP8266 では利用できません。このモジュールには浮動小数点数の"
"サポートが必要です。"

#: ../../../library/cmath.rst:20
msgid "Return the cosine of ``z``."
msgstr "``z`` の余弦を返すます。"

#: ../../../library/cmath.rst:24
msgid "Return the exponential of ``z``."
msgstr "``z`` の指数を返します。"

#: ../../../library/cmath.rst:28
msgid ""
"Return the natural logarithm of ``z``.  The branch cut is along the "
"negative real axis."
msgstr ""
"``z`` の自然対数を返します。分岐截線は負の実軸を使います。"

#: ../../../library/cmath.rst:32
msgid ""
"Return the base-10 logarithm of ``z``.  The branch cut is along the "
"negative real axis."
msgstr ""
"``z`` の常用対数を返します。分岐截線は負の実軸を使います。"

#: ../../../library/cmath.rst:36
msgid "Returns the phase of the number ``z``, in the range (-pi, +pi]."
msgstr "``z`` の位相を (-pi, pi) の範囲内で返します。"

#: ../../../library/cmath.rst:40
msgid "Returns, as a tuple, the polar form of ``z``."
msgstr "``z`` の極座標をタプルで返します。"

#: ../../../library/cmath.rst:44
msgid "Returns the complex number with modulus ``r`` and phase ``phi``."
msgstr "モジュラス ``r`` と位相 ``phi`` を持つ複素数を返します。"

#: ../../../library/cmath.rst:48
msgid "Return the sine of ``z``."
msgstr "``z`` の正弦を返します。"

#: ../../../library/cmath.rst:52
msgid "Return the square-root of ``z``."
msgstr "``z`` の平方根を返します。"

#: ../../../library/cmath.rst:59 ../../../library/math.rst:181
msgid "base of the natural logarithm"
msgstr "自然対数の底"

#: ../../../library/cmath.rst:63 ../../../library/math.rst:185
msgid "the ratio of a circle's circumference to its diameter"
msgstr "円の円周と直径の比(円周率)"

#: ../../../library/esp.rst:2
msgid ":mod:`esp` --- functions related to the ESP8266 and ESP32"
msgstr ":mod:`esp` --- ESP8266 と ESP32 に関連する関数"

#: ../../../library/esp.rst:7
msgid ""
"The ``esp`` module contains specific functions related to both the ESP8266 "
"and ESP32 modules.  Some functions are only available on one or the other "
"of these ports."
msgstr ""
"``esp`` モジュールは、ESP8266 と ESP32 の両方のモジュールに関連する固有の機能を提供します。"
"一部の機能はこれらのポートのどちらか一方でしか使えません。"

#: ../../../library/esp.rst:17 ../../../library/esp.rst:47
#: ../../../library/esp.rst:67
msgid "**Note**: ESP8266 only"
msgstr "**注記**: ESP8266 のみ"

#: ../../../library/esp.rst:19
msgid "Get or set the sleep type."
msgstr "スリープのタイプを取得/設定します。"

#: ../../../library/esp.rst:21
msgid ""
"If the *sleep_type* parameter is provided, sets the sleep type to its "
"value. If the function is called without parameters, returns the current "
"sleep type."
msgstr ""
"**sleep_type** にパラメータが与えた場合、スリープのタイプをその値にを設定します。"
"この関数がパラメータなしで呼び出された場合は、現在のスリープのタイプを返します。"

#: ../../../library/esp.rst:25
msgid "The possible sleep types are defined as constants:"
msgstr "指定可能なスリープのタイプは定数として定義されています:"

#: ../../../library/esp.rst:27
msgid "``SLEEP_NONE`` -- all functions enabled,"
msgstr "``SLEEP_NONE`` -- すべての機能が有効"

#: ../../../library/esp.rst:28
msgid "``SLEEP_MODEM`` -- modem sleep, shuts down the WiFi Modem circuit."
msgstr "``SLEEP_MODEM`` -- モデムのスリープ、WiFi モデム回線をシャットダウン"

#: ../../../library/esp.rst:29
msgid ""
"``SLEEP_LIGHT`` -- light sleep, shuts down the WiFi Modem circuit and "
"suspends the processor periodically."
msgstr ""
"``SLEEP_LIGHT`` -- 軽量スリープ、WiFi モデム回路をシャットダウンし、プロセッサを定期的に停止"

#: ../../../library/esp.rst:32
msgid "The system enters the set sleep mode automatically when possible."
msgstr "可能であれば、システムは自動的に設定されたスリープモードに入ります。"

#: ../../../library/esp.rst:36
msgid "**Note**: ESP8266 only - use `machine.deepsleep()` on ESP32"
msgstr "**注記**: ESP8266 のみ - ESP32 では `machine.deepsleep()` を使用"

#: ../../../library/esp.rst:38
msgid "Enter deep sleep."
msgstr "ディープスリープに入ります。"

#: ../../../library/esp.rst:40
msgid ""
"The whole module powers down, except for the RTC clock circuit, which can"
" be used to restart the module after the specified time if the pin 16 is "
"connected to the reset pin. Otherwise the module will sleep until "
"manually reset."
msgstr ""
"RTC クロック回路を除いてモジュール全体がパワーダウンします。RTC クロック回路は、"
"ピン16がリセットピンに接続されている場合、指定時間後にモジュールを再起動するのに使えます。"
"それ以外の場合、モジュールは手動でリセットされるまでスリープします。"

#: ../../../library/esp.rst:49
msgid "Read the device ID of the flash memory."
msgstr "フラッシュメモリのデバイスIDを取得します。"

#: ../../../library/esp.rst:53
msgid "Read the total size of the flash memory."
msgstr "フラッシュメモリの合計サイズを取得します。"

#: ../../../library/esp.rst:57
msgid "Read the memory offset at which the user flash space begins."
msgstr "ユーザフラッシュスペースが始まるメモリオフセットを取得します。"

#: ../../../library/esp.rst:69
msgid ""
"Set the location that native code will be placed for execution after it "
"is compiled.  Native code is emitted when the ``@micropython.native``, "
"``@micropython.viper`` and ``@micropython.asm_xtensa`` decorators are "
"applied to a function.  The ESP8266 must execute code from either iRAM or"
" the lower 1MByte of flash (which is memory mapped), and this function "
"controls the location."
msgstr ""
"ネイティブコードがコンパイルされた後に実行のために配置される場所を設定します。"
"``@micropython.native``, ``@micropython.viper``, ``@micropython.asm_xtensa`` "
"デコレータが関数に適用されると、ネイティブコードが生成されます。ESP8266は iRAM または"
"(メモリマップされている)フラッシュの下位 1MB のいずれかからコードを実行する必要があり、"
"この関数はその位置を制御します。"

#: ../../../library/esp.rst:76
msgid ""
"If *start* and *length* are both ``None`` then the native code location "
"is set to the unused portion of memory at the end of the iRAM1 region.  "
"The size of this unused portion depends on the firmware and is typically "
"quite small (around 500 bytes), and is enough to store a few very small "
"functions.  The advantage of using this iRAM1 region is that it does not "
"get worn out by writing to it."
msgstr ""
"*start* と *length* がどちらも ``None`` であった場合、ネイティブコード位置は iRAM1 "
"領域の最後にあるメモリの未使用部分に設定されます。この未使用部分のサイズはファームウェア"
"によって異なり、通常は非常に小さく(約500バイト)、非常に小さな関数を格納するのに使います。"
"この iRAM1 領域を使用する利点は書き込んでもメモリの寿命が縮まないことです。"

#: ../../../library/esp.rst:83
msgid ""
"If neither *start* nor *length* are ``None`` then they should be "
"integers. *start* should specify the byte offset from the beginning of "
"the flash at which native code should be stored.  *length* specifies how "
"many bytes of flash from *start* can be used to store native code.  "
"*start* and *length* should be multiples of the sector size (being 4096 "
"bytes).  The flash will be automatically erased before writing to it so "
"be sure to use a region of flash that is not otherwise used, for example "
"by the firmware or the filesystem."
msgstr ""
"*start* と *length* のどちらも ``None`` でない場合はどｒちらも整数でなければならず、"
" *start* はネイティブコードを格納するフラッシュの先頭からのバイトオフセットを指定する"
"必要があります。 *length* はネイティブコードを格納するために最初から何バイトのフラッシュを"
"使用できるかを指定します。 *start* と *length* は、セクタサイズの倍数(4096バイト)に"
"してください。フラッシュする前にフラッシュは自動的に消去されるので、他(たとえば"
"ファームウェアやファイルシステム)では使用されないフラッシュの領域を使うようにしてください。"

#: ../../../library/esp.rst:92
msgid ""
"When using the flash to store native code *start+length* must be less "
"than or equal to 1MByte.  Note that the flash can be worn out if repeated"
" erasures (and writes) are made so use this feature sparingly. In "
"particular, native code needs to be recompiled and rewritten to flash on "
"each boot (including wake from deepsleep)."
msgstr ""
"フラッシュを使用してネイティブコードを格納する場合、 *start+length* は1MB以下で"
"なければなりません。繰り返し消去(および書き込み)を行うとフラッシュは寿命を縮めて"
"いくので、この機能は控えめに使ってください。特に、ネイティブコードは起動ごとに"
"再コンパイルしてフラッシュに書き換える必要があります(スリープ解除からの起動の場合も含みます)。"

#: ../../../library/esp.rst:98
msgid ""
"In both cases above, using iRAM1 or flash, if there is no more room left "
"in the specified region then the use of a native decorator on a function "
"will lead to `MemoryError` exception being raised during compilation of "
"that function."
msgstr ""
"上記のどちらの場合も、iRAM1 またはフラッシュを使って指定領域に空きがなくなった後、"
"関数にネイティブデコレータを使うとその関数のコンパイル中に `MemoryError` 例外が発生します。"

#: ../../../library/esp32.rst:4
msgid ":mod:`esp32` --- functionality specific to the ESP32"
msgstr ":mod:`esp32` --- EDS32 に固有の機能"

#: ../../../library/esp32.rst:9
msgid ""
"The ``esp32`` module contains functions and classes specifically aimed "
"at controlling ESP32 modules."
msgstr ""
"``esp32`` モジュールは、ESP32 モジュールに固有の制御を目的とした関数とクラスが含まれています。"

#: ../../../library/esp32.rst:18
msgid ""
"Configure whether or not a touch will wake the device from sleep. *wake* "
"should be a boolean value."
msgstr ""
"タッチでデバイスをスリープから復帰させるかどうかを設定します。 *wake* はブール型で"
"なければなりません。"

#: ../../../library/esp32.rst:23
msgid ""
"Configure how EXT0 wakes the device from sleep.  *pin* can be ``None`` or "
"a valid Pin object.  *level* should be ``esp32.WAKEUP_ALL_LOW`` or "
"``esp32.WAKEUP_ANY_HIGH``."
msgstr ""
"EXT0 がデバイスをスリープから復帰させる方法を設定します。 *pin* には ``None`` "
"あるいは有効な Pin オブジェクトを指定します。 *level* には ``esp32.WAKEUP_ALL_LOW`` "
"または ``esp32.WAKEUP_ANY_HIGH`` を指定する必要があります。"

#: ../../../library/esp32.rst:29
msgid ""
"Configure how EXT1 wakes the device from sleep.  *pins* can be ``None`` "
"or a tuple/list of valid Pin objects.  *level* should be "
"``esp32.WAKEUP_ALL_LOW`` or ``esp32.WAKEUP_ANY_HIGH``."
msgstr ""
"EXT1 がデバイスをスリープから復帰させる方法を設定します。  *pin* には ``None`` "
"あるいは有効な Pin オブジェクトのタプル/リストを指定します。 *level* には "
"``esp32.WAKEUP_ALL_LOW`` または ``esp32.WAKEUP_ANY_HIGH`` を指定する必要があります。"

#: ../../../library/esp32.rst:35
msgid ""
"Read the raw value of the internal temperature sensor, returning an "
"integer."
msgstr ""
"内部温度センサーの素の値を読み、整数を返します。"

#: ../../../library/esp32.rst:39
msgid ""
"Read the raw value of the internal Hall sensor, returning an integer."
msgstr ""
"内部ホールセンサーの素の値を読み、整数を返します。"

#: ../../library/esp32.rst:42
msgid "Flash partitions"
msgstr "フラッシュのパーティション"

#: ../../library/esp32.rst:44
msgid "This class gives access to the partitions in the device's flash memory."
msgstr "このクラスは、デバイスのフラッシュメモリ内のパーティションへのアクセスを提供します。"

#: ../../library/esp32.rst:48
msgid ""
"Create an object representing a partition.  *id* can be a string which is"
" the label of the partition to retrieve, or one of the constants: "
"``BOOT`` or ``RUNNING``."
msgstr ""
"パーティションを表すオブジェクトを作成します。 *id* は取得するパーティションのラベルである文字列、"
"または定数 BOOT または RUNNING のいずれかです。"

#: ../../library/esp32.rst:53
msgid ""
"Find a partition specified by *type*, *subtype* and *label*.  Returns a "
"(possibly empty) list of Partition objects."
msgstr ""
"*type*, *subtype*, *label* で指定したパーティションを見つけます。"
"Partition オブジェクトのリストを返します(空の場合もあります)。"

#: ../../library/esp32.rst:58
msgid "Returns a 6-tuple ``(type, subtype, addr, size, label, encrypted)``."
msgstr "``(type, subtype, addr, size, label, encrypted)`` の６項目のタプルを返します。"

#: ../../library/esp32.rst:66
msgid ""
"These methods implement the simple and :ref:`extended <block-device-"
"interface>` block protocol defined by :class:`uos.AbstractBlockDev`."
msgstr ""
"これらのメソッドは :class:`uos.AbstractBlockDev` によって定義されたシンプルで"
":ref:`extended <block-device-interface>` ブロックプロトコルを実装します。"

#: ../../library/esp32.rst:72
msgid "Sets the partition as the boot partition."
msgstr "パーティションをブートパーティションとして設定します。"

#: ../../library/esp32.rst:76
msgid ""
"Gets the next update partition after this one, and returns a new "
"Partition object."
msgstr ""
"このパーティションの次の更新パーティションを取得し、新しいパーティションオブジェクトを返します。"

#: ../../library/esp32.rst:84
msgid "Used in the `Partition` constructor to fetch various partitions."
msgstr "さまざまなパーティションを取得するために `Partition` コンストラクターで使います。"

#: ../../library/esp32.rst:89
msgid "Used in `Partition.find` to specify the partition type."
msgstr "`Partition.find` でパーティションタイプを指定するために使います。"

#: ../../library/esp32.rst:95
msgid "RMT"
msgstr ""

#: ../../library/esp32.rst:97
msgid ""
"The RMT (Remote Control) module, specific to the ESP32, was originally "
"designed to send and receive infrared remote control signals. However, "
"due to a flexible design and very accurate (as low as 12.5ns) pulse "
"generation, it can also be used to transmit or receive many other types "
"of digital signals::"
msgstr ""
"ESP32 に固有の RMT (リモートコントロール)モジュールは、もともと赤外線リモートコントロール"
"信号を送受信するために設計されました。ただし、柔軟な設計と非常に正確な(12.5ns程度の)パルス"
"生成により、他の多くのタイプのデジタル信号の送受信にも使用できます::"

#: ../../library/esp32.rst:102
msgid ""
"import esp32\n"
"from machine import Pin\n"
"\n"
"r = esp32.RMT(0, pin=Pin(18), clock_div=8)\n"
"r  # RMT(channel=0, pin=18, source_freq=80000000, clock_div=8)\n"
"# The channel resolution is 100ns (1/(source_freq/clock_div)).\n"
"r.write_pulses((1, 20, 2, 40), start=0)  # Send 0 for 100ns, 1 for "
"2000ns, 0 for 200ns, 1 for 4000ns"
msgstr ""
"import esp32\n"
"from machine import Pin\n"
"\n"
"r = esp32.RMT(0, pin=Pin(18), clock_div=8)\n"
"r  # RMT(channel=0, pin=18, source_freq=80000000, clock_div=8)\n"
"# チャンネルの分解能は 100ns (1/(source_freq/clock_div)).\n"
"r.write_pulses((1, 20, 2, 40), start=0) # 0 を 100ns, 1 を 2000ns,"
" 0 を 200ns, 1 を 4000ns 送信"

#: ../../library/esp32.rst:110
msgid ""
"The input to the RMT module is an 80MHz clock (in the future it may be "
"able to configure the input clock but, for now, it's fixed). "
"``clock_div`` *divides* the clock input which determines the resolution "
"of the RMT channel. The numbers specificed in ``write_pulses`` are "
"multiplied by the resolution to define the pulses."
msgstr ""
"RMT モジュールへの入力は 80MHz クロックです(将来的には入力クロックを設定できる可能性もありますが、"
"現時点では固定です)。RMT チャネルの分解能は、クロック入力を  ``clock_div`` で除算することにより決まります。"
"``write_pulses`` で指定した数値については、分解能を乗算してパルスが決まります。"

#: ../../library/esp32.rst:116
msgid ""
"``clock_div`` is an 8-bit divider (0-255) and each pulse can be defined "
"by multiplying the resolution by a 15-bit (0-32,768) number. There are "
"eight channels (0-7) and each can have a different clock divider."
msgstr ""
"``clock_div`` は8ビット(0-255)の分周器で、各パルスは、分解能に15ビット(0-32,768)の"
"数値を乗算することで定義できます。8つのチャネル(0-7)があり、それぞれ異なるクロック"
"分周器を使えます。"

#: ../../library/esp32.rst:120
msgid ""
"So, in the example above, the 80MHz clock is divided by 8. Thus the "
"resolution is (1/(80Mhz/8)) 100ns. Since the ``start`` level is 0 and "
"toggles with each number, the bitstream is ``0101`` with durations of "
"[100ns, 2000ns, 100ns, 4000ns]."
msgstr ""
"上記の例では80MHzクロックを8で除算しています。したがって分解能は (1/(80Mhz/8)) で 100ns になります。"
"開始レベルは 0 であり、各数値でレベルが切り替わるので、ビットストリームは ``0101`` で各ビットについて "
"[100ns, 2000ns, 100ns, 4000ns] の持続時間を有します。"

#: ../../library/esp32.rst:125
msgid ""
"For more details see Espressif's `ESP-IDF RMT documentation. "
"<https://docs.espressif.com/projects/esp-idf/en/latest/api-"
"reference/peripherals/rmt.html>`_."
msgstr ""
"詳細については `ESP-IDF RMT documentation. "
"<https://docs.espressif.com/projects/esp-idf/en/latest/api-"
"reference/peripherals/rmt.html>`_ を参照してください。"

#: ../../library/esp32.rst:129
msgid ""
"The current MicroPython RMT implementation lacks some features, most "
"notably receiving pulses and carrier transmit. RMT should be considered a"
" *beta feature* and the interface may change in the future."
msgstr ""
"現在の MicroPython RMT 実装にはいくつかの機能がありませんが、最も顕著なのは受信パルスと"
"キャリア送信です。RMT はベータ機能と見なすべきであり、インターフェースは将来変更する可能性が"
"あります。"

#: ../../library/esp32.rst:136
msgid ""
"This class provides access to one of the eight RMT channels. *channel* is"
" required and identifies which RMT channel (0-7) will be configured. "
"*pin*, also required, configures which Pin is bound to the RMT channel. "
"*clock_div* is an 8-bit clock divider that divides the source clock "
"(80MHz) to the RMT channel allowing the resolution to be specified."
msgstr ""
"このクラスは、8つのRMTチャネルの1つへのアクセスを提供します。 *channel* は必須であり、"
"どの RMT チャネル(0-7)を使うのかを識別します。 *pin* も必須であり、RMTチャネルに"
"バインドするピンを設定します。 *clock_div* はソースクロック(80MHz)を分割する"
"8ビットのクロック分周器であり、RMTチャネルの分解能を指定できます。"

#: ../../library/esp32.rst:144
msgid ""
"Returns the source clock frequency. Currently the source clock is not "
"configurable so this will always return 80MHz."
msgstr ""
"ソースクロック周波数を返します。現在のところソースクロックは設定できないため、"
"常に 80MHz が返されます。"

#: ../../library/esp32.rst:149
msgid ""
"Return the clock divider. Note that the channel resolution is ``1 / "
"(source_freq / clock_div)``."
msgstr ""
"クロック分周器を返します。チャネルの分解能は ``1 / (source_freq / clock_div)`` "
"であることに注意してください。"

#: ../../library/esp32.rst:154
msgid "Returns True if `RMT.write_pulses` has completed."
msgstr "`RMT.write_pulses` が完了している場合に True を返します。"

#: ../../library/esp32.rst:156
msgid ""
"If *timeout* (defined in ticks of ``source_freq / clock_div``) is "
"specified the method will wait for *timeout* or until `RMT.write_pulses` "
"is complete, returning ``False`` if the channel continues to transmit."
msgstr ""
"タイムアウト(``source_freq / clock_div`` のティックで定義)が指定されている場合、"
"このメソッドはタイムアウトか `RMT.write_pulses` の完了まで待ち、チャンネルがまだ"
"送信を継続していれば ``False`` を返します。"

#: ../../library/esp32.rst:161
msgid "Avoid using ``wait_done()`` if looping is enabled."
msgstr "ループが有効になっている場合は  ``wait_done()`` を使わないでください。"

#: ../../library/esp32.rst:165
msgid ""
"Configure looping on the channel, allowing a stream of pulses to be "
"indefinitely repeated. *enable_loop* is bool, set to True to enable "
"looping."
msgstr ""
"パルスのストリームを無期限に繰り返すチャネルのループを設定します。 "
"*enable_loop* は bool であり、True はループを有効に設定します。"

#: ../../library/esp32.rst:170
msgid ""
"Begin sending *pulses*, a list or tuple defining the stream of pulses. "
"The length of each pulse is defined by a number to be multiplied by the "
"channel resolution ``(1 / (source_freq / clock_div))``. *start* defines "
"whether the stream starts at 0 or 1."
msgstr ""
"パルスの送信を開始します。パルスのストリーム定義するリストまたはタプルを指定します。"
"各パルスの長さは、チャネルの分機能 ``(1 / (source_freq / clock_div))`` を乗算した値"
"によって定義されます。 *start* はストリームが 0 で始まるか 1 で始まるかを定義します。"

#: ../../../library/esp32.rst:177
msgid "Ultra-Low-Power co-processor"
msgstr "超低消費電力コプロセッサ"

#: ../../../library/esp32.rst:181
msgid "This class provides access to the Ultra-Low-Power co-processor."
msgstr "このクラスは超低消費電力コプロセッサへのアクセスを提供します。"

#: ../../../library/esp32.rst:185
msgid "Set the wake-up period."
msgstr "起床期間を設定します。"

#: ../../../library/esp32.rst:189
msgid "Load a *program_binary* into the ULP at the given *load_addr*."
msgstr "与えた *load_addr* で *program_binary* を ULP にロードします。"

#: ../../../library/esp32.rst:193
msgid "Start the ULP running at the given *entry_point*."
msgstr "与えた *entry_point* で ULP を起動します。"

#: ../../../library/esp32.rst:202
msgid "Selects the wake level for pins."
msgstr "ピンの起床レベル。"

#: ../../../library/framebuf.rst:2
msgid ":mod:`framebuf` --- frame buffer manipulation"
msgstr ":mod:`framebuf` --- フレームバッファの操作"

#: ../../../library/framebuf.rst:7
msgid ""
"This module provides a general frame buffer which can be used to create "
"bitmap images, which can then be sent to a display."
msgstr ""
"このモジュールは、一般的なフレームバッファを提供し、ビットマップイメージを作成して"
"ディスプレイに送ることができます。"

#: ../../../library/framebuf.rst:11
msgid "class FrameBuffer"
msgstr "クラス FrameBuffer"

#: ../../../library/framebuf.rst:13
msgid ""
"The FrameBuffer class provides a pixel buffer which can be drawn upon "
"with pixels, lines, rectangles, text and even other FrameBuffer's. It is "
"useful when generating output for displays."
msgstr ""
"FrameBuffer クラスは、ピクセル、ライン、矩形、テキスト、さらには他の FrameBuffer で"
"描画できるピクセルバッファを提供します。ディスプレイの出力を生成するときに便利です。"

#: ../../../library/framebuf.rst:17 ../../../library/lcd160cr.rst:25
#: ../../../library/network.rst:15
msgid "For example::"
msgstr "たとえば次のように使います::"

#: ../../../library/framebuf.rst:19
msgid ""
"import framebuf\n"
"\n"
"# FrameBuffer needs 2 bytes for every RGB565 pixel\n"
"fbuf = FrameBuffer(bytearray(10 * 100 * 2), 10, 100, framebuf.RGB565)\n"
"\n"
"fbuf.fill(0)\n"
"fbuf.text('MicroPython!', 0, 0, 0xffff)\n"
"fbuf.hline(0, 10, 96, 0xffff)"
msgstr ""
"import framebuf\n"
"\n"
"# FrameBuffer は RGB565 ピクセル毎に２バイトを必要とします\n"
"fbuf = FrameBuffer(bytearray(10 * 100 * 2), 10, 100, framebuf.RGB565)\n"
"\n"
"fbuf.fill(0)\n"
"fbuf.text('MicroPython!', 0, 0, 0xffff)\n"
"fbuf.hline(0, 10, 96, 0xffff)"

#: ../../../library/framebuf.rst:29 ../../../library/lcd160cr.rst:38
#: ../../../library/machine.ADC.rst:16 ../../../library/machine.I2C.rst:34
#: ../../../library/machine.Pin.rst:43 ../../../library/machine.RTC.rst:18
#: ../../../library/machine.SD.rst:31 ../../../library/machine.SPI.rst:15
#: ../../../library/machine.Signal.rst:75 ../../../library/machine.Timer.rst:28
#: ../../../library/machine.TimerWiPy.rst:32
#: ../../../library/machine.UART.rst:37 ../../../library/machine.WDT.rst:21
#: ../../../library/network.CC3K.rst:31
#: ../../../library/network.WIZNET5K.rst:32
#: ../../../library/network.WLAN.rst:17
#: ../../../library/network.WLANWiPy.rst:29 ../../../library/pyb.ADC.rst:24
#: ../../../library/pyb.Accel.rst:17 ../../../library/pyb.CAN.rst:23
#: ../../../library/pyb.DAC.rst:50 ../../../library/pyb.ExtInt.rst:52
#: ../../../library/pyb.I2C.rst:57 ../../../library/pyb.LCD.rst:42
#: ../../../library/pyb.LED.rst:11 ../../../library/pyb.Pin.rst:75
#: ../../../library/pyb.RTC.rst:18 ../../../library/pyb.SPI.rst:29
#: ../../../library/pyb.Servo.rst:31 ../../../library/pyb.Switch.rst:24
#: ../../../library/pyb.Timer.rst:54 ../../../library/pyb.UART.rst:47
#: ../../../library/pyb.USB_HID.rst:14 ../../../library/pyb.USB_VCP.rst:13
#: ../../../library/uhashlib.rst:28
msgid "Constructors"
msgstr "コンストラクタ"

#: ../../../library/framebuf.rst:33
msgid "Construct a FrameBuffer object.  The parameters are:"
msgstr "FrameBuffer オブジェクトを構築します。パラメータは次のとおりです:"

#: ../../../library/framebuf.rst:35
msgid ""
"*buffer* is an object with a buffer protocol which must be large enough "
"to contain every pixel defined by the width, height and format of the "
"FrameBuffer."
msgstr ""
"*buffer* はバッファプロトコルを持つオブジェクトで、FrameBuffer の幅、高さ、"
"フォーマットで定義されたすべてのピクセルを格納するのに十分な大きさでなければ"
"なりません。"

#: ../../../library/framebuf.rst:38
msgid "*width* is the width of the FrameBuffer in pixels"
msgstr "*width* は FrameBuffer の幅(ピクセル単位)です。"

#: ../../../library/framebuf.rst:39
msgid "*height* is the height of the FrameBuffer in pixels"
msgstr "*height* は FrameBuffer の高さ(ピクセル単位)です。"

#: ../../../library/framebuf.rst:40
msgid ""
"*format* specifies the type of pixel used in the FrameBuffer; permissible"
" values are listed under Constants below. These set the number of bits "
"used to encode a color value and the layout of these bits in *buffer*. "
"Where a color value c is passed to a method, c is a small integer with an"
" encoding that is dependent on the format of the FrameBuffer."
msgstr ""
"*format* は FrameBuffer で使用されるピクセルのタイプを指定します。指定できる値は"
"後述する定数にリストされているとおりです。これらは、カラー値をエンコードするために"
"使用されるビットの数と、これらのビットのバッファ内のレイアウトを設定します。カラー値 "
"c がメソッドに渡される場合、c は FrameBuffer のフォーマットに依存するエンコーディング"
"を持つ小さな整数です。"

#: ../../../library/framebuf.rst:46
msgid ""
"*stride* is the number of pixels between each horizontal line of pixels "
"in the FrameBuffer. This defaults to *width* but may need adjustments "
"when implementing a FrameBuffer within another larger FrameBuffer or "
"screen. The *buffer* size must accommodate an increased step size."
msgstr ""
"*stride* は FrameBuffer 内の水平ラインのピクセル数です。これはデフォルトでは "
"*width* ですが、別の大きな FrameBuffer や画面内に FrameBuffer を実装する際に"
"調整が必要な場合があります。 *buffer* のサイズは増えるステップサイズに対応しなければ"
"なりません。"

#: ../../../library/framebuf.rst:52
msgid ""
"One must specify valid *buffer*, *width*, *height*, *format* and "
"optionally *stride*.  Invalid *buffer* size or dimensions may lead to "
"unexpected errors."
msgstr ""
"コンストラクターでは有効な *buffer*, *width*, *height*, *format* と、オプションの "
"*stride* を指定する必要があります。 *buffer* のサイズや幅が無効な場合、予期しない"
"エラーが発生します。"

#: ../../../library/framebuf.rst:57 ../../../library/lcd160cr.rst:212
msgid "Drawing primitive shapes"
msgstr "基本図形の描画"

#: ../../../library/framebuf.rst:59
msgid "The following methods draw shapes onto the FrameBuffer."
msgstr "次のメソッドは FrameBuffer に図形を描画します。"

#: ../../../library/framebuf.rst:63
msgid "Fill the entire FrameBuffer with the specified color."
msgstr "FrameBuffer 全体を指定された色で塗りつぶします。"

#: ../../../library/framebuf.rst:67
msgid ""
"If *c* is not given, get the color value of the specified pixel. If *c* "
"is given, set the specified pixel to the given color."
msgstr ""
"*c* を指定しない場合は、指定されたピクセルのカラー値を取得します。"
"*c* を指定した場合は、指定したピクセルを指定した色に設定します。"

#: ../../../library/framebuf.rst:74
msgid ""
"Draw a line from a set of coordinates using the given color and a "
"thickness of 1 pixel. The `line` method draws the line up to a second set"
" of coordinates whereas the `hline` and `vline` methods draw horizontal "
"and vertical lines respectively up to a given length."
msgstr ""
"指定した色と1ピクセルの太さを使って、座標のセットから線を描画します。 `line` "
"メソッドはラインを第2の座標セットへ描画するのに対し、 `hline` と `vline` "
"メソッドはそれぞれ指定された長さまで水平ラインと垂直ラインを描画します。"

#: ../../../library/framebuf.rst:83
msgid ""
"Draw a rectangle at the given location, size and color. The `rect` method"
" draws only a 1 pixel outline whereas the `fill_rect` method draws both "
"the outline and interior."
msgstr ""
"指定された場所、サイズ、色で四角形を描画します。 `rect` メソッドはは１ピクセルの"
"アウトラインを描画するのに対して、 `fill_rect` メソッドは輪郭とその内側の両方を"
"描きます。"

#: ../../../library/framebuf.rst:88 ../../../library/lcd160cr.rst:172
msgid "Drawing text"
msgstr "テキストの描画"

#: ../../../library/framebuf.rst:92
msgid ""
"Write text to the FrameBuffer using the the coordinates as the upper-left"
" corner of the text. The color of the text can be defined by the optional"
" argument but is otherwise a default value of 1. All characters have "
"dimensions of 8x8 pixels and there is currently no way to change the "
"font."
msgstr ""
"座標をテキストの左上隅として、FrameBuffer にテキストを書き込みます。テキストの色は"
"オプションの引数で定義できますが、それ以外の場合はデフォルト値は 1 です。すべての"
"文字のサイズは8x8ピクセルですが、現在フォントを変更する方法はありません。"

#: ../../../library/framebuf.rst:99
msgid "Other methods"
msgstr "その他のメソッド"

#: ../../../library/framebuf.rst:103
msgid ""
"Shift the contents of the FrameBuffer by the given vector. This may leave"
" a footprint of the previous colors in the FrameBuffer."
msgstr ""
"指定された方向へ FrameBuffer の内容をシフトします。これにより、FrameBuffer に"
"前の色のフットプリントが残る場合があります。"

#: ../../../library/framebuf.rst:108
msgid ""
"Draw another FrameBuffer on top of the current one at the given "
"coordinates. If *key* is specified then it should be a color integer and "
"the corresponding color will be considered transparent: all pixels with "
"that color value will not be drawn."
msgstr ""
"現在のフレームバッファの上の指定された座標に、別の FrameBuffer を描画します。 "
"*key* が指定されている場合、それは色を表す整数でなければならず、対応する色は"
"透明であるとみなされます。その色の値を持つすべてのピクセルは描画されません。"

#: ../../../library/framebuf.rst:113
msgid ""
"This method works between FrameBuffer instances utilising different "
"formats, but the resulting colors may be unexpected due to the mismatch "
"in color formats."
msgstr ""
"このメソッドは、異なるフォーマットを使用する FrameBuffer インスタンス間で動作しますが、"
"カラーフォーマットが一致しない場合の結果の色は予期できません。"

#: ../../../library/framebuf.rst:122
msgid ""
"Monochrome (1-bit) color format This defines a mapping where the bits in "
"a byte are vertically mapped with bit 0 being nearest the top of the "
"screen. Consequently each byte occupies 8 vertical pixels. Subsequent "
"bytes appear at successive horizontal locations until the rightmost edge "
"is reached. Further bytes are rendered at locations starting at the "
"leftmost edge, 8 pixels lower."
msgstr ""
"モノクロ(1ビット)カラーフォーマットこれは、バイトのビットが垂直方向にマップされ、"
"ビット0が画面の最上部に最も近いマッピングを定義します。したがって、各バイトは"
"８垂直ピクセルを占有します。後続のバイトは、右端に達するまで連続した水平位置に"
"現れます。さらに後続のバイトは、最左端から8ピクセル下の位置でレンダリングされます。"

#: ../../../library/framebuf.rst:131
msgid ""
"Monochrome (1-bit) color format This defines a mapping where the bits in "
"a byte are horizontally mapped. Each byte occupies 8 horizontal pixels "
"with bit 7 being the leftmost. Subsequent bytes appear at successive "
"horizontal locations until the rightmost edge is reached. Further bytes "
"are rendered on the next row, one pixel lower."
msgstr ""
"モノクロ(1ビット)カラーフォーマット。これはバイト内のビットが水平方向にマッピング"
"されるよう定義します。各バイトは8ビットの水平ピクセルを占め、ビット7が最も左になります。"
"後続のバイトは右端に達するまで連続した水平位置に現れます。さらに後続のバイトは"
"1ピクセル下の次の行にレンダリングされます。"

#: ../../../library/framebuf.rst:140
msgid ""
"Monochrome (1-bit) color format This defines a mapping where the bits in "
"a byte are horizontally mapped. Each byte occupies 8 horizontal pixels "
"with bit 0 being the leftmost. Subsequent bytes appear at successive "
"horizontal locations until the rightmost edge is reached. Further bytes "
"are rendered on the next row, one pixel lower."
msgstr ""
"モノクロ(1ビット)カラーフォーマット。これはバイト内のビットが水平方向にマッピング"
"されるよう定義します。各バイトは8ビットの水平ピクセルを占め、ビット0が最も左になります。"
"後続のバイトは右端に達するまで連続した水平位置に現れます。さらに後続のバイトは"
"1ピクセル下の次の行にレンダリングされます。"

#: ../../../library/framebuf.rst:149
msgid "Red Green Blue (16-bit, 5+6+5) color format"
msgstr "レッドグリーンブルー(16ビット、5+6+5)カラーフォーマット"

#: ../../../library/framebuf.rst:153
msgid "Grayscale (2-bit) color format"
msgstr "グレースケール(2ビット)カラーフォーマット"

#: ../../../library/framebuf.rst:157
msgid "Grayscale (4-bit) color format"
msgstr "グレースケール(4ビット)カラーフォーマット"

#: ../../../library/framebuf.rst:161
msgid "Grayscale (8-bit) color format"
msgstr "グレースケール(8ビット)カラーフォーマット"

#: ../../../library/gc.rst:2
msgid ":mod:`gc` -- control the garbage collector"
msgstr ":mod:`gc` -- ガベージコレクションの制御"

#: ../../../library/gc.rst:7
msgid "|see_cpython_module| :mod:`python:gc`."
msgstr ""

#: ../../../library/gc.rst:14
msgid "Enable automatic garbage collection."
msgstr "自動ガベージコレクションを有効にします。"

#: ../../../library/gc.rst:18
msgid ""
"Disable automatic garbage collection.  Heap memory can still be "
"allocated, and garbage collection can still be initiated manually using "
":meth:`gc.collect`."
msgstr ""
"自動ガベージコレクションを無効にします。無効にしてもヒープメモリの割り当ては"
"可能であり、ガベージコレクションも :meth:`gc.collect` を使って手動で開始できます。"

#: ../../../library/gc.rst:23
msgid "Run a garbage collection."
msgstr "ガベージコレクションを実行します。"

#: ../../../library/gc.rst:27
msgid "Return the number of bytes of heap RAM that are allocated."
msgstr "割り当てられているヒープ RAM のバイト数を返します。"

#: ../../../library/gc.rst:29 ../../../library/gc.rst:39
#: ../../../library/gc.rst:61 ../../../library/sys.rst:23
#: ../../../library/sys.rst:56 ../../../library/ubinascii.rst:19
#: ../../../library/uio.rst:15 ../../../library/uio.rst:126
#: ../../../library/uselect.rst:79 ../../../library/uselect.rst:96
#: ../../../library/usocket.rst:12 ../../../library/usocket.rst:109
#: ../../../library/usocket.rst:278 ../../../library/usocket.rst:302
#: ../../../library/usocket.rst:308 ../../../library/usocket.rst:349
#: ../../../library/utime.rst:217 ../../../library/uzlib.rst:34
msgid "Difference to CPython"
msgstr "CPython との違い"

#: ../../../library/gc.rst:32 ../../../library/gc.rst:42
msgid "This function is MicroPython extension."
msgstr "この関数は、MicroPythonの拡張機能です。"

#: ../../../library/gc.rst:36
msgid ""
"Return the number of bytes of available heap RAM, or -1 if this amount is"
" not known."
msgstr ""
"使用可能なヒープ RAM のバイト数を返します。この量がわからない場合は -1 を返します。"

#: ../../../library/gc.rst:46
msgid ""
"Set or query the additional GC allocation threshold. Normally, a "
"collection is triggered only when a new allocation cannot be satisfied, "
"i.e. on an out-of-memory (OOM) condition. If this function is called, in "
"addition to OOM, a collection will be triggered each time after *amount* "
"bytes have been allocated (in total, since the previous time such an "
"amount of bytes have been allocated). *amount* is usually specified as "
"less than the full heap size, with the intention to trigger a collection "
"earlier than when the heap becomes exhausted, and in the hope that an "
"early collection will prevent excessive memory fragmentation. This is a "
"heuristic measure, the effect of which will vary from application to "
"application, as well as the optimal value of the *amount* parameter."
msgstr ""
"GC 割り当てしきい値を追加で設定または照会します。通常、ガベージコレクションは、"
"新しい割り当てを満たすことができない場合、つまりメモリー不足(OOM: Out-Of-Memory)"
"状態でのみトリガーされます。この関数が呼び出された場合は、OOMに加えて、 *amount* "
"バイトが(以前に割り当てられているものと合計で)割り当てられた後にガベージコレクション"
"がトリガーされます量は通常、ヒープが使い尽くされたときよりも早くガベージコレクション"
"をトリガーすることが目的であり、全ヒープサイズよりも小さく指定します。また、早めの"
"ガベージコレクションによって過剰なメモリー断片化が防止されることを期待しています。"
"これは、ヒューリスティックな尺度であり、その効果はアプリケーションごとに異なり、 "
"*amount* パラメータの最適値も異なります。"

#: ../../../library/gc.rst:58
msgid ""
"Calling the function without argument will return the current value of "
"the threshold. A value of -1 means a disabled allocation threshold."
msgstr ""
"引数なしで関数を呼び出すと、しきい値の現在の値が返されます。値が -1 の場合は"
"無効な割り当てしきい値であることを意味します。"

#: ../../../library/gc.rst:64
msgid ""
"This function is a MicroPython extension. CPython has a similar function "
"- ``set_threshold()``, but due to different GC implementations, its "
"signature and semantics are different."
msgstr ""
"この関数は、MicroPython の拡張機能です。CPython も同様の機能 ``set_threshold()`` "
"を持っていますが、GCの実装が異なるため、シグネチャとセマンティクスが異なります。"

#: ../../../library/index.rst:4
msgid "MicroPython libraries"
msgstr "MicroPython ライブラリ"

#: ../../../library/index.rst:8
msgid "Important summary of this section"
msgstr "この章の重要な要約"

#: ../../../library/index.rst:10
msgid "MicroPython implements a subset of Python functionality for each module."
msgstr "MicroPythonは各モジュールにPythonの機能のサブセットを実装しています。"

#: ../../../library/index.rst:11
msgid ""
"To ease extensibility, MicroPython versions of standard Python modules "
"usually have ``u`` (\"micro\") prefix."
msgstr ""
"拡張性を容易にするために、標準の Python モジュールの MicroPython 版には通常、 "
"``u`` (\"micro\")接頭辞が付いています。"

#: ../../../library/index.rst:13
msgid ""
"Any particular MicroPython variant or port may miss any feature/function "
"described in this general documentation (due to resource constraints or "
"other limitations)."
msgstr ""
"特定の MicroPython の亜種またはポートには、(リソースの制約またはその他の制限のために)"
"この一般的なドキュメンテーションに記載されている機能/関数がサポートされていないことが"
"あります。"

#: ../../../library/index.rst:18
msgid ""
"This chapter describes modules (function and class libraries) which are "
"built into MicroPython. There are a few categories of such modules:"
msgstr ""
"この章では、MicroPython に組み込まれているモジュール(関数とクラスのライブラリ)に"
"ついて説明します。このようなモジュールにはいくつかのカテゴリがあります。"

#: ../../../library/index.rst:21
msgid ""
"Modules which implement a subset of standard Python functionality and are"
" not intended to be extended by the user."
msgstr ""
"標準の Python 機能のサブセットを実装し、ユーザが拡張することを意図していないモジュール。"

#: ../../../library/index.rst:23
msgid ""
"Modules which implement a subset of Python functionality, with a "
"provision for extension by the user (via Python code)."
msgstr ""
"Python の機能のサブセットを実装するモジュールで、Python コードを介して"
"ユーザーが拡張を提供します。"

#: ../../../library/index.rst:25
msgid ""
"Modules which implement MicroPython extensions to the Python standard "
"libraries."
msgstr ""
"Python 標準ライブラリへの MicroPython 拡張を実装するモジュール。"

#: ../../../library/index.rst:26
msgid "Modules specific to a particular `MicroPython port` and thus not portable."
msgstr ""
"特定の `MicroPython ポート` に固有のモジュールで、移植性がありません。"

#: ../../../library/index.rst:28
msgid ""
"Note about the availability of the modules and their contents: This "
"documentation in general aspires to describe all modules and "
"functions/classes which are implemented in MicroPython project. However, "
"MicroPython is highly configurable, and each port to a particular "
"board/embedded system makes available only a subset of MicroPython "
"libraries. For officially supported ports, there is an effort to either "
"filter out non-applicable items, or mark individual descriptions with "
"\"Availability:\" clauses describing which ports provide a given feature."
msgstr ""
"モジュールとその内容の可能性に関する注意: このドキュメンテーションは、"
"MicroPython プロジェクトで実装されているすべてのモジュールと関数/クラスについて"
"記述することを目指しています。しかし、MicroPython は高度に構成可能であり、"
"特定のボード/組み込みシステムへの各ポートは、MicroPython ライブラリのサブセット"
"のみを使用可能にします。正式にサポートされているポートの場合、適用不可能な項目を"
"除外するか、ポートが提供する機能の個々の説明に「可用性:」節を付けるか"
"しています。"

#: ../../../library/index.rst:36
msgid ""
"With that in mind, please still be warned that some functions/classes in "
"a module (or even the entire module) described in this documentation "
"**may be unavailable** in a particular build of MicroPython on a "
"particular system. The best place to find general information of the "
"availability/non-availability of a particular feature is the \"General "
"Information\" section which contains information pertaining to a specific"
" `MicroPython port`."
msgstr ""
"これを念頭に置いて、特定のシステム上の MicroPython の特定のビルドでは、"
"このドキュメントで説明されているモジュールの一部の機能/クラス(またはモジュール全体)が"
"使えない可能性があります。特定の機能の可用性/非可用性に関する一般的な情報を"
"見つける最良の場所は、特定の `MicroPython ポート` に関連する情報を含む「一般情報」"
"の章です。"

#: ../../../library/index.rst:43
msgid ""
"On some ports you are able to discover the available, built-in libraries "
"that can be imported by entering the following at the REPL::"
msgstr ""
"いくつかのポートでは、REPL に次のように入力することで import できる、利用可能な"
"組込みライブラリを検出できます。"

#: ../../../library/index.rst:46
msgid "help('modules')"
msgstr ""

#: ../../../library/index.rst:48
msgid ""
"Beyond the built-in libraries described in this documentation, many more "
"modules from the Python standard library, as well as further MicroPython "
"extensions to it, can be found in `micropython-lib`."
msgstr ""
"このドキュメントで説明されている組込みライブラリ以外にも、Python 標準ライブラリからの"
"多くのモジュール、さらに MicroPython の拡張もあります。それらは `micropython-lib` "
"で見つけることができます。"

#: ../../../library/index.rst:53
msgid "Python standard libraries and micro-libraries"
msgstr "Python 標準ライブラリとマイクロライブラリ"

#: ../../../library/index.rst:55
msgid ""
"The following standard Python libraries have been \"micro-ified\" to fit "
"in with the philosophy of MicroPython.  They provide the core "
"functionality of that module and are intended to be a drop-in replacement"
" for the standard Python library.  Some modules below use a standard "
"Python name, but prefixed with \"u\", e.g. ``ujson`` instead of ``json``."
" This is to signify that such a module is micro-library, i.e. implements "
"only a subset of CPython module functionality. By naming them "
"differently, a user has a choice to write a Python-level module to extend"
" functionality for better compatibility with CPython (indeed, this is "
"what done by the `micropython-lib` project mentioned above)."
msgstr ""
"以下の標準的な Python ライブラリは、MicroPython の哲学に適合するように「マイクロ化」"
"されています。これらは、そのモジュールの中核となる機能を提供し、標準の Python ライブラリを"
"置き換えるものです。後述のモジュールいつくはか、標準的な Python の名前を使いますが、"
"接頭辞 \"u\" がついています。たとえば ``json`` の代わりに ``ujson`` となっています。"
"これは、そのようなモジュールがマイクロライブラリであることを示しています。すなわち、"
"CPython モジュールの機能のサブセットのみを実装しています。異なる名前を付けることによって、"
"ユーザーは Python レベルのモジュールを作成して、CPython との互換性を高める機能を拡張"
"できます(実際に、これは前述の `micropython-lib` プロジェクトによって行われます)。"

#: ../../../library/index.rst:65
msgid ""
"On some embedded platforms, where it may be cumbersome to add Python-"
"level wrapper modules to achieve naming compatibility with CPython, "
"micro-modules are available both by their u-name, and also by their "
"non-u-name.  The non-u-name can be overridden by a file of that name in "
"your library path (``sys.path``). For example, ``import json`` will first"
" search for a file ``json.py`` (or package directory ``json``) and load "
"that module if it is found.  If nothing is found, it will fallback to "
"loading the built-in ``ujson`` module."
msgstr ""
"CPython とのネーミングの互換性を実現するために Python レベルのラッパーモジュールを"
"追加するのは面倒な一部の組み込みプラットフォームでは、マイクロモジュールは u 付きの"
"と u なしの名前の両方を使えます。u なしの名前は、ライブラリパス(``sys.path``)内の"
"同名のファイルで上書きできます。たとえば ``import json`` はまず、ファイル "
"``json.py`` (あるいはパッケージディレクトリ ``json``)を検索し、見つかった場合は"
"そのモジュールをロードします。何も見つからなければ、組込みの ``ujson`` モジュール"
"をロードします。"

#: ../../../library/index.rst:101
msgid "MicroPython-specific libraries"
msgstr "MicroPython 固有のライブラリ"

#: ../../../library/index.rst:103
msgid ""
"Functionality specific to the MicroPython implementation is available in "
"the following libraries."
msgstr "MicroPython 処理系に固有の機能は、以下のライブラリで利用できます。"

#: ../../../library/index.rst:119
msgid "Port-specific libraries"
msgstr "ポート固有のライブラリ"

#: ../../../library/index.rst:122
msgid ""
"In some cases the following port/board-specific libraries have "
"functions or classes similar to those in the :mod:`machine` library.  "
"Where this occurs, the entry in the port specific library exposes "
"hardware functionality unique to that platform."
msgstr ""
"以降のポート/ボード固有のライブラリには、 :mod:`machine` ライブラリ内にあるものと"
"同様の関数やクラスが用意されていることがあります。そのような場合、ポート固有の"
"ライブラリの方では、そのプラットフォームに固有のハードウェア機能が使えるように"
"なっています。"

#: ../../../library/index.rst:122
msgid ""
"To write portable code use functions and classes from the :mod:`machine` "
"module. To access platform-specific hardware use the appropriate library, "
"e.g. :mod:`pyb` in the case of the Pyboard."
msgstr ""
"移植可能なコードを作成するには、 :mod:`machine` モジュールの関数やクラスを"
"使ってください。プラットフォーム固有のハードウェアにアクセスするには、適切な"
"ポート固有ライブラリを使ってください。たとえば Pyboard の場合は :mod:`pyb` "
"を使います。"

#: ../../../library/index.rst:132
msgid "Libraries specific to the pyboard"
msgstr "pyboard 固有のライブラリ"

#: ../../../library/index.rst:135
msgid "The following libraries are specific to the pyboard."
msgstr "以下のライブラリは pyboard に固有のものです。"

#: ../../../library/index.rst:144
msgid "Libraries specific to the WiPy"
msgstr "WiPy 固有のライブラリ"

#: ../../../library/index.rst:147
msgid "The following libraries and classes are specific to the WiPy."
msgstr "以下のライブラリとクラスは WiPy に固有のものです。"

#: ../../../library/index.rst:157
msgid "Libraries specific to the ESP8266 and ESP32"
msgstr "ESP8266 と ESP32 に固有のライブラリ"

#: ../../../library/index.rst:160
msgid "The following libraries are specific to the ESP8266 and ESP32."
msgstr "以下のライブラリは ESP8266 と ESP32 に固有のものです。"

#: ../../../library/lcd160cr.rst:2
msgid ":mod:`lcd160cr` --- control of LCD160CR display"
msgstr ""

#: ../../../library/lcd160cr.rst:7
msgid "This module provides control of the MicroPython LCD160CR display."
msgstr ""

msgid ""
".. image:: http://micropython.org/resources/LCD160CRv10-persp.jpg\n"
"   :alt: LCD160CRv1.0 picture"
msgstr ""

#: ../../../library/lcd160cr.rst:13
msgid "Further resources are available via the following links:"
msgstr ""

#: ../../../library/lcd160cr.rst:15
msgid ""
"`LCD160CRv1.0 reference manual "
"<http://micropython.org/resources/LCD160CRv10-refmanual.pdf>`_ (100KiB "
"PDF)"
msgstr ""

#: ../../../library/lcd160cr.rst:16
msgid ""
"`LCD160CRv1.0 schematics "
"<http://micropython.org/resources/LCD160CRv10-schematics.pdf>`_ (1.6MiB "
"PDF)"
msgstr ""

#: ../../../library/lcd160cr.rst:19
msgid "class LCD160CR"
msgstr ""

#: ../../../library/lcd160cr.rst:21
msgid ""
"The LCD160CR class provides an interface to the display.  Create an "
"instance of this class and use its methods to draw to the LCD and get the"
" status of the touch panel."
msgstr ""

#: ../../../library/lcd160cr.rst:27
msgid ""
"import lcd160cr\n"
"\n"
"lcd = lcd160cr.LCD160CR('X')\n"
"lcd.set_orient(lcd160cr.PORTRAIT)\n"
"lcd.set_pos(0, 0)\n"
"lcd.set_text_color(lcd.rgb(255, 0, 0), lcd.rgb(0, 0, 0))\n"
"lcd.set_font(1)\n"
"lcd.write('Hello MicroPython!')\n"
"print('touch:', lcd.get_touch())"
msgstr ""

#: ../../../library/lcd160cr.rst:42
msgid "Construct an LCD160CR object.  The parameters are:"
msgstr ""

#: ../../../library/lcd160cr.rst:44
msgid ""
"*connect* is a string specifying the physical connection of the LCD "
"display to the board; valid values are \"X\", \"Y\", \"XY\", \"YX\". Use "
"\"X\" when the display is connected to a pyboard in the X-skin position, "
"and \"Y\" when connected in the Y-skin position.  \"XY\" and \"YX\" are "
"used when the display is connected to the right or left side of the "
"pyboard, respectively."
msgstr ""

#: ../../../library/lcd160cr.rst:50
msgid "*pwr* is a Pin object connected to the LCD's power/enabled pin."
msgstr ""

#: ../../../library/lcd160cr.rst:51
msgid "*i2c* is an I2C object connected to the LCD's I2C interface."
msgstr ""

#: ../../../library/lcd160cr.rst:52
msgid "*spi* is an SPI object connected to the LCD's SPI interface."
msgstr ""

#: ../../../library/lcd160cr.rst:53
msgid "*i2c_addr* is the I2C address of the display."
msgstr ""

#: ../../../library/lcd160cr.rst:55
msgid ""
"One must specify either a valid *connect* or all of *pwr*, *i2c* and "
"*spi*. If a valid *connect* is given then any of *pwr*, *i2c* or *spi* "
"which are not passed as parameters (i.e. they are ``None``) will be "
"created based on the value of *connect*.  This allows to override the "
"default interface to the display if needed."
msgstr ""

#: ../../../library/lcd160cr.rst:61
msgid "The default values are:"
msgstr ""

#: ../../../library/lcd160cr.rst:63
msgid ""
"\"X\" is for the X-skin and uses: ``pwr=Pin(\"X4\")``, "
"``i2c=I2C(\"X\")``, ``spi=SPI(\"X\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:65
msgid ""
"\"Y\" is for the Y-skin and uses: ``pwr=Pin(\"Y4\")``, "
"``i2c=I2C(\"Y\")``, ``spi=SPI(\"Y\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:67
msgid ""
"\"XY\" is for the right-side and uses: ``pwr=Pin(\"X4\")``, "
"``i2c=I2C(\"Y\")``, ``spi=SPI(\"X\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:69
msgid ""
"\"YX\" is for the left-side and uses: ``pwr=Pin(\"Y4\")``, "
"``i2c=I2C(\"X\")``, ``spi=SPI(\"Y\")``"
msgstr ""

#: ../../../library/lcd160cr.rst:72
msgid ""
"See `this image "
"<http://micropython.org/resources/LCD160CRv10-positions.jpg>`_ for how "
"the display can be connected to the pyboard."
msgstr ""

#: ../../../library/lcd160cr.rst:76
msgid "Static methods"
msgstr ""

#: ../../../library/lcd160cr.rst:80
msgid ""
"Return a 16-bit integer representing the given rgb color values.  The "
"16-bit value can be used to set the font color (see "
":meth:`LCD160CR.set_text_color`) pen color (see :meth:`LCD160CR.set_pen`)"
" and draw individual pixels."
msgstr ""

#: ../../../library/lcd160cr.rst:87
msgid "Clip the given line data.  This is for internal use."
msgstr ""

#: ../../../library/lcd160cr.rst:90
msgid "Instance members"
msgstr ""

#: ../../../library/lcd160cr.rst:92
msgid "The following instance members are publicly accessible."
msgstr ""

#: ../../../library/lcd160cr.rst:97
msgid ""
"The width and height of the display, respectively, in pixels.  These "
"members are updated when calling :meth:`LCD160CR.set_orient` and should "
"be considered read-only."
msgstr ""

#: ../../../library/lcd160cr.rst:102
msgid "Setup commands"
msgstr ""

#: ../../../library/lcd160cr.rst:106
msgid ""
"Turn the display on or off, depending on the given value of *on*: 0 or "
"``False`` will turn the display off, and 1 or ``True`` will turn it on."
msgstr ""

#: ../../../library/lcd160cr.rst:111
msgid ""
"Set the orientation of the display.  The *orient* parameter can be one of"
" `PORTRAIT`, `LANDSCAPE`, `PORTRAIT_UPSIDEDOWN`, `LANDSCAPE_UPSIDEDOWN`."
msgstr ""

#: ../../../library/lcd160cr.rst:116
msgid "Set the brightness of the display, between 0 and 31."
msgstr ""

#: ../../../library/lcd160cr.rst:120
msgid ""
"Set the I2C address of the display.  The *addr* value must have the lower"
" 2 bits cleared."
msgstr ""

#: ../../../library/lcd160cr.rst:125
msgid "Set the baudrate of the UART interface."
msgstr ""

#: ../../../library/lcd160cr.rst:129
msgid ""
"Set the start-up decoration of the display.  The *value* parameter can be"
" a logical or of `STARTUP_DECO_NONE`, `STARTUP_DECO_MLOGO`, "
"`STARTUP_DECO_INFO`."
msgstr ""

#: ../../../library/lcd160cr.rst:134
msgid ""
"Save the following parameters to flash so they persist on restart and "
"power up: initial decoration, orientation, brightness, UART baud rate, "
"I2C address."
msgstr ""

#: ../../../library/lcd160cr.rst:138
msgid "Pixel access methods"
msgstr ""

#: ../../../library/lcd160cr.rst:140
msgid "The following methods manipulate individual pixels on the display."
msgstr ""

#: ../../../library/lcd160cr.rst:144
msgid ""
"Set the specified pixel to the given color.  The color should be a 16-bit"
" integer and can be created by :meth:`LCD160CR.rgb`."
msgstr ""

#: ../../../library/lcd160cr.rst:149
msgid "Get the 16-bit value of the specified pixel."
msgstr ""

#: ../../../library/lcd160cr.rst:153
msgid ""
"Low-level method to get a line of pixels into the given buffer. To read "
"*n* pixels *buf* should be *2*n+1* bytes in length.  The first byte is a "
"dummy byte and should be ignored, and subsequent bytes represent the "
"pixels in the line starting at coordinate *(x, y)*."
msgstr ""

#: ../../../library/lcd160cr.rst:160
msgid ""
"Dump the contents of the screen to the given buffer.  The parameters *x* "
"and *y* specify the starting coordinate, and *w* and *h* the size of the "
"region.  If *w* or *h* are ``None`` then they will take on their maximum "
"values, set by the size of the screen minus the given *x* and *y* values."
"  *buf* should be large enough to hold ``2*w*h`` bytes.  If it's smaller "
"then only the initial horizontal lines will be stored."
msgstr ""

#: ../../../library/lcd160cr.rst:169
msgid "Load the entire screen from the given buffer."
msgstr ""

#: ../../../library/lcd160cr.rst:174
msgid ""
"To draw text one sets the position, color and font, and then uses "
"`LCD160CR.write` to draw the text."
msgstr ""

#: ../../../library/lcd160cr.rst:179
msgid ""
"Set the position for text output using :meth:`LCD160CR.write`.  The "
"position is the upper-left corner of the text."
msgstr ""

#: ../../../library/lcd160cr.rst:184
msgid "Set the foreground and background color of the text."
msgstr ""

#: ../../../library/lcd160cr.rst:188
msgid ""
"Set the font for the text.  Subsequent calls to `write` will use the "
"newly configured font.  The parameters are:"
msgstr ""

#: ../../../library/lcd160cr.rst:191
msgid "*font* is the font family to use, valid values are 0, 1, 2, 3."
msgstr ""

#: ../../../library/lcd160cr.rst:192
msgid ""
"*scale* is a scaling value for each character pixel, where the pixels are"
" drawn as a square with side length equal to *scale + 1*.  The value can "
"be between 0 and 63."
msgstr ""

#: ../../../library/lcd160cr.rst:195
msgid ""
"*bold* controls the number of pixels to overdraw each character pixel, "
"making a bold effect.  The lower 2 bits of *bold* are the number of "
"pixels to overdraw in the horizontal direction, and the next 2 bits are "
"for the vertical direction.  For example, a *bold* value of 5 will "
"overdraw 1 pixel in both the horizontal and vertical directions."
msgstr ""

#: ../../../library/lcd160cr.rst:200
msgid ""
"*trans* can be either 0 or 1 and if set to 1 the characters will be drawn"
" with a transparent background."
msgstr ""

#: ../../../library/lcd160cr.rst:202
msgid ""
"*scroll* can be either 0 or 1 and if set to 1 the display will do a soft "
"scroll if the text moves to the next line."
msgstr ""

#: ../../../library/lcd160cr.rst:207
msgid ""
"Write text to the display, using the current position, color and font. As"
" text is written the position is automatically incremented.  The display "
"supports basic VT100 control codes such as newline and backspace."
msgstr ""

#: ../../../library/lcd160cr.rst:214
msgid ""
"Primitive drawing commands use a foreground and background color set by "
"the `set_pen` method."
msgstr ""

#: ../../../library/lcd160cr.rst:219
msgid "Set the line and fill color for primitive shapes."
msgstr ""

#: ../../../library/lcd160cr.rst:223
msgid "Erase the entire display to the pen fill color."
msgstr ""

#: ../../../library/lcd160cr.rst:227
msgid "Draw a single pixel at the given location using the pen line color."
msgstr ""

#: ../../../library/lcd160cr.rst:233
msgid ""
"Draw a rectangle at the given location and size using the pen line color "
"for the outline, and the pen fill color for the interior. The `rect` "
"method draws the outline and interior, while the other methods just draw "
"one or the other."
msgstr ""

#: ../../../library/lcd160cr.rst:240
msgid "Draw a line between the given coordinates using the pen line color."
msgstr ""

#: ../../../library/lcd160cr.rst:248
msgid ""
"These methods are as above but don't do any clipping on the input "
"coordinates.  They are faster than the clipping versions and can be used "
"when you know that the coordinates are within the display."
msgstr ""

#: ../../../library/lcd160cr.rst:254
msgid ""
"Draw a sequence of dots using the pen line color. The *data* should be a "
"buffer of bytes, with each successive pair of bytes corresponding to "
"coordinate pairs (x, y)."
msgstr ""

#: ../../../library/lcd160cr.rst:260
msgid "Similar to :meth:`LCD160CR.poly_dot` but draws lines between the dots."
msgstr ""

#: ../../../library/lcd160cr.rst:263
msgid "Touch screen methods"
msgstr ""

#: ../../../library/lcd160cr.rst:267
msgid "Configure the touch panel:"
msgstr ""

#: ../../../library/lcd160cr.rst:269
msgid ""
"If *calib* is ``True`` then the call will trigger a touch calibration of "
"the resistive touch sensor.  This requires the user to touch various "
"parts of the screen."
msgstr ""

#: ../../../library/lcd160cr.rst:272
msgid ""
"If *save* is ``True`` then the touch parameters will be saved to NVRAM to"
" persist across reset/power up."
msgstr ""

#: ../../../library/lcd160cr.rst:274
msgid ""
"If *irq* is ``True`` then the display will be configured to pull the IRQ "
"line low when a touch force is detected.  If *irq* is ``False`` then this"
" feature is disabled.  If *irq* is ``None`` (the default value) then no "
"change is made to this setting."
msgstr ""

#: ../../../library/lcd160cr.rst:281
msgid ""
"Returns a boolean: ``True`` if there is currently a touch force on the "
"screen, ``False`` otherwise."
msgstr ""

#: ../../../library/lcd160cr.rst:286
msgid ""
"Returns a 3-tuple of: *(active, x, y)*.  If there is currently a touch "
"force on the screen then *active* is 1, otherwise it is 0.  The *x* and "
"*y* values indicate the position of the current or most recent touch."
msgstr ""

#: ../../../library/lcd160cr.rst:291
msgid "Advanced commands"
msgstr ""

#: ../../../library/lcd160cr.rst:295
msgid "Set the window that SPI data is written to."
msgstr ""

#: ../../../library/lcd160cr.rst:299
msgid ""
"Ready the display to accept RGB pixel data on the SPI bus, resetting the "
"location of the first byte to go to the top-left corner of the window set"
" by :meth:`LCD160CR.set_spi_win`. The method returns an SPI object which "
"can be used to write the pixel data."
msgstr ""

#: ../../../library/lcd160cr.rst:304
msgid ""
"Pixels should be sent as 16-bit RGB values in the 5-6-5 format.  The "
"destination counter will increase as data is sent, and data can be sent "
"in arbitrary sized chunks.  Once the destination counter reaches the end "
"of the window specified by :meth:`LCD160CR.set_spi_win` it will wrap "
"around to the top-left corner of that window."
msgstr ""

#: ../../../library/lcd160cr.rst:311
msgid ""
"Show the given buffer on the display.  *buf* should be an array of bytes "
"containing the 16-bit RGB values for the pixels, and they will be written"
" to the area specified by :meth:`LCD160CR.set_spi_win`, starting from the"
" top-left corner."
msgstr ""

#: ../../../library/lcd160cr.rst:315
msgid ""
"The `framebuf <framebuf.html>`_ module can be used to construct frame "
"buffers and provides drawing primitives. Using a frame buffer will "
"improve performance of animations when compared to drawing directly to "
"the screen."
msgstr ""

#: ../../../library/lcd160cr.rst:321
msgid ""
"Turn scrolling on or off.  This controls globally whether any window "
"regions will scroll."
msgstr ""

#: ../../../library/lcd160cr.rst:326
msgid "Configure a window region for scrolling:"
msgstr ""

#: ../../../library/lcd160cr.rst:328
msgid ""
"*win* is the window id to configure.  There are 0..7 standard windows for"
" general purpose use.  Window 8 is the text scroll window (the ticker)."
msgstr ""

#: ../../../library/lcd160cr.rst:330
msgid "*x*, *y*, *w*, *h* specify the location of the window in the display."
msgstr ""

#: ../../../library/lcd160cr.rst:331
msgid ""
"*vec* specifies the direction and speed of scroll: it is a 16-bit value "
"of the form ``0bF.ddSSSSSSSSSSSS``.  *dd* is 0, 1, 2, 3 for +x, +y, -x, "
"-y scrolling. *F* sets the speed format, with 0 meaning that the window "
"is shifted *S % 256* pixel every frame, and 1 meaning that the window is "
"shifted 1 pixel every *S* frames."
msgstr ""

#: ../../../library/lcd160cr.rst:336
msgid "*pat* is a 16-bit pattern mask for the background."
msgstr ""

#: ../../../library/lcd160cr.rst:337
msgid "*fill* is the fill color."
msgstr ""

#: ../../../library/lcd160cr.rst:338
msgid "*color* is the extra color, either of the text or pattern foreground."
msgstr ""

#: ../../../library/lcd160cr.rst:342
msgid "Set a single parameter of a scrolling window region:"
msgstr ""

#: ../../../library/lcd160cr.rst:344
msgid "*win* is the window id, 0..8."
msgstr ""

#: ../../../library/lcd160cr.rst:345
msgid ""
"*param* is the parameter number to configure, 0..7, and corresponds to "
"the parameters in the `set_scroll_win` method."
msgstr ""

#: ../../../library/lcd160cr.rst:347
msgid "*value* is the value to set."
msgstr ""

#: ../../../library/lcd160cr.rst:351
msgid ""
"Set the string for scrolling in window 8.  The parameter *s* must be a "
"string with length 32 or less."
msgstr ""

#: ../../../library/lcd160cr.rst:356
msgid ""
"Display a JPEG.  *buf* should contain the entire JPEG data. JPEG data "
"should not include EXIF information. The following encodings are "
"supported: Baseline DCT, Huffman coding, 8 bits per sample, 3 color "
"components, YCbCr4:2:2. The origin of the JPEG is set by "
":meth:`LCD160CR.set_pos`."
msgstr ""

#: ../../../library/lcd160cr.rst:364
msgid ""
"Display a JPEG with the data split across multiple buffers.  There must "
"be a single call to `jpeg_start` to begin with, specifying the total "
"number of bytes in the JPEG.  Then this number of bytes must be "
"transferred to the display using one or more calls to the `jpeg_data` "
"command."
msgstr ""

#: ../../../library/lcd160cr.rst:371
msgid ""
"The first call to this method will start the display's internal watchdog "
"timer.  Subsequent calls will feed the watchdog.  The timeout is roughly "
"30 seconds."
msgstr ""

#: ../../../library/lcd160cr.rst:377
msgid "Reset the display."
msgstr ""

#: ../../../library/lcd160cr.rst:387
msgid "Orientations of the display, used by :meth:`LCD160CR.set_orient`."
msgstr ""

#: ../../../library/lcd160cr.rst:393
msgid ""
"Types of start-up decoration, can be OR'ed together, used by "
":meth:`LCD160CR.set_startup_deco`."
msgstr ""

#: ../../../library/machine.rst:2
msgid ":mod:`machine` --- functions related to the hardware"
msgstr ":mod:`machine` --- ハードウェア関連の関数"

#: ../../../library/machine.rst:7
msgid ""
"The ``machine`` module contains specific functions related to the "
"hardware on a particular board. Most functions in this module allow to "
"achieve direct and unrestricted access to and control of hardware blocks "
"on a system (like CPU, timers, buses, etc.). Used incorrectly, this can "
"lead to malfunction, lockups, crashes of your board, and in extreme "
"cases, hardware damage."
msgstr ""
"``machine`` モジュールは、特定のボード上のハードウェアに関連する固有の関数を含んで"
"います。このモジュールのほとんどの機能はシステム上のハードウェアブロック(CPU、"
"タイマー、バスなど)への直接的かつ無制限のアクセスと制御を実現します。誤って使用すると、"
"誤動作、ロックアップ、ボードのクラッシュ、および極端な場合にはハードウェアの損傷を"
"招く可能性があります。"

#: ../../../library/machine.rst:16
msgid ""
"A note of callbacks used by functions and class methods of :mod:`machine`"
" module: all these callbacks should be considered as executing in an "
"interrupt context. This is true for both physical devices with IDs >= 0 "
"and \"virtual\" devices with negative IDs like -1 (these \"virtual\" "
"devices are still thin shims on top of real hardware and real hardware "
"interrupts). See :ref:`isr_rules`."
msgstr ""
":mod:`machine` モジュールの関数とクラスが使うコールバックについての注記: "
"これらのコールバックはすべて、割り込みコンテキストでの実行とみなされるべきです。"
"これは ID >= 0 の物理デバイスと、-1 などの負のIDを持つ「仮想」デバイスの両方に"
"当てはまります(「仮想」デバイスであっても、実際のハードウェアと実際のハードウェア"
"割り込みのがある上に小さく用意されているものです)。 :ref:`isr_rules` を参照して"
"ください。"

#: ../../../library/machine.rst:23 ../../../library/pyb.rst:72
msgid "Reset related functions"
msgstr "リセット関連の関数"

#: ../../../library/machine.rst:27
msgid ""
"Resets the device in a manner similar to pushing the external RESET "
"button."
msgstr ""
"外部 RESET ボタンを押すのと同じようにデバイスをリセットします。"

#: ../../../library/machine.rst:32
msgid ""
"Performs a soft reset of the interpreter, deleting all Python objects and "
"resetting the Python heap.  It tries to retain the method by which the user "
"is connected to the MicroPython REPL (eg serial, USB, Wifi)."
msgstr ""
"インタープリタのソフトリセットを実行します。すべての Python オブジェクトを削除し、"
"Python のヒープをリセットします。MicroPython REPL への接続"
"(シリアル、USB、Wifi など)はそのまま維持が試みられます。"

#: ../../../library/machine.rst:38
msgid ""
"Get the reset cause. See :ref:`constants <machine_constants>` for the "
"possible return values."
msgstr ""
"リセット原因を取得します。戻り値については :ref:`定数 <machine_constants>` を"
"参照してください。"

#: ../../../library/machine.rst:40 ../../../library/pyb.rst:97
msgid "Interrupt related functions"
msgstr "割り込み関連の関数"

#: ../../../library/machine.rst:45
msgid ""
"Disable interrupt requests. Returns the previous IRQ state which should "
"be considered an opaque value. This return value should be passed to the "
"`enable_irq()` function to restore interrupts to their original state, "
"before `disable_irq()` was called."
msgstr ""
"割り込み要求を無効にします。無効にする前の IRQ 状態を返しますが、これは不明瞭な"
"値とみなす必要があります。この戻り値は `disable_irq()` を呼び出す前の"
"元の状態に割り込みを復元するために `enable_irq()` 関数に渡す必要があります。"

#: ../../../library/machine.rst:52
msgid ""
"Re-enable interrupt requests. The *state* parameter should be the value "
"that was returned from the most recent call to the `disable_irq()` "
"function."
msgstr ""
"割り込み要求を再度有効にします。 *state* パラメータは `disable_irq()` 関数の"
"最も最近の呼び出しから返された値である必要があります。"

#: ../../../library/machine.rst:56 ../../../library/pyb.rst:115
msgid "Power related functions"
msgstr "電力関連の関数"

#: ../../../library/machine.rst:61
msgid "Returns CPU frequency in hertz."
msgstr "CPU周波数をヘルツ単位で返します。"

#: ../../../library/machine.rst:65
msgid ""
"Gates the clock to the CPU, useful to reduce power consumption at any "
"time during short or long periods. Peripherals continue working and "
"execution resumes as soon as any interrupt is triggered (on many ports "
"this includes system timer interrupt occurring at regular intervals on "
"the order of millisecond)."
msgstr ""
"短時間または長期間のいずれでも消費電力を抑えるように CPU へのクロック供給を制御します。"
"ペリフェラルは動作を継続し、割り込みが発生すると直ちに実行を再開します(多くのポートでは、"
"システムタイマ割り込みがミリ秒単位で定期的に発生します)。"

#: ../../../library/machine.rst:72
msgid ""
"This function is deprecated, use `lightsleep()` instead with no arguments."
msgstr ""
"この関数は廃止予定です。代わりに `lightsleep()` を引数なしで使ってください。"

#: ../../../library/machine.rst:77
msgid "Stops execution in an attempt to enter a low power state."
msgstr "実行を停止して、低電力状態に入ります。"

#: ../../../library/machine.rst:79
msgid ""
"If *time_ms* is specified then this will be the maximum time in milliseconds that "
"the sleep will last for.  Otherwise the sleep can last indefinitely."
msgstr ""
"*time_ms* が指定されている場合、これはスリープが続く最大ミリ秒単位の時間になります。"
"指定しなければスリープが無期限に続くようになります。"

#: ../../../library/machine.rst:82
msgid ""
"With or without a timout, execution may resume at any time if there are events "
"that require processing.  Such events, or wake sources, should be configured before "
"sleeping, like `Pin` change or `RTC` timeout."
msgstr ""
"タイムアウトがあってもなくても、処理が必要なイベントがあれば実行はいつでも再開できます。"
"そのようなイベントまたは起床元となる `Pin` の変化や `RTC` タイムアウトなどは、"
"スリープ前に設定する必要があります。"

#: ../../../library/machine.rst:86
msgid ""
"The precise behaviour and power-saving capabilities of lightsleep and deepsleep is "
"highly dependent on the underlying hardware, but the general properties are:"
msgstr ""
"ライトスリープ(lightsleep)とディープスリープ(deepsleep)の正確な動作と省電力機能は、"
"基盤となるハードウェアに大きく依存しますが、一般的な特性は次のとおりです。"

#: ../../../library/machine.rst:89
msgid ""
"A lightsleep has full RAM and state retention.  Upon wake execution is resumed "
"from the point where the sleep was requested, with all subsystems operational."
msgstr ""
"ライトスリープには RAM と状態の完全な保持があります。スリープ解除が要求された時点から実行が"
"再開され、すべてのサブシステムが動作可能になります。"

#: ../../../library/machine.rst:92
msgid ""
"A deepsleep may not retain RAM or any other state of the system (for example "
"peripherals or network interfaces).  Upon wake execution is resumed from the main "
"script, similar to a hard or power-on reset. The `reset_cause()` function will "
"return `machine.DEEPSLEEP` and this can be used to distinguish a deepsleep wake "
"from other resets."
msgstr ""
"ディープスリープは RAM やシステムの他の状態(周辺機器やネットワークインタフェースなど)を"
"保持しません。ハードリセットやパワーオンリセットと同様に、ウェイクアップ時にメインスクリプト"
"から実行が再開されます。 `reset_cause()` 関数は `machine.DEEPSLEEP` を返します。"
"これは他のリセットとディープスリープからの起床を区別するのに使えます。"

#: ../../../library/machine.rst:100
msgid ""
"Get the wake reason. See :ref:`constants <machine_constants>` for the "
"possible return values."
msgstr ""
"起床の理由を取得します。戻り値については :ref:`定数 <machine_constants>` "
"を参照してください。"

#: ../../../library/machine.rst:102
msgid "Availability: ESP32, WiPy."
msgstr "可用性: ESP32、WiPy。"

#: ../../../library/machine.rst:104 ../../../library/pyb.rst:187
msgid "Miscellaneous functions"
msgstr "その他の関数"

#: ../../../library/machine.rst:109
msgid ""
"Returns a byte string with a unique identifier of a board/SoC. It will "
"vary from a board/SoC instance to another, if underlying hardware allows."
" Length varies by hardware (so use substring of a full value if you "
"expect a short ID). In some MicroPython ports, ID corresponds to the "
"network MAC address."
msgstr ""
"ボード/SoC の一意な識別子を持つバイト列を返します。基盤となるハードウェアが許せば、"
"この値はボード/SoC の個体ごとに異なります。長さはハードウェアによって異なります"
"(短い ID が必要な場合は、完全な値の部分文字列を使用してください)。一部の "
"MicroPython ポートにおいて、ID はネットワークの MAC アドレスに対応します。"

#: ../../../library/machine.rst:116
msgid ""
"Time a pulse on the given *pin*, and return the duration of the pulse in "
"microseconds.  The *pulse_level* argument should be 0 to time a low pulse"
" or 1 to time a high pulse."
msgstr ""
"指定の *pin* にパルスの持続時間をマイクロ秒単位で返します。 *pulse_level* 引数には、"
"低パルスの時間計測で 0、高パルスの時間計測で 1 を指定します。"

#: ../../../library/machine.rst:120
msgid ""
"If the current input value of the pin is different to *pulse_level*, the "
"function first (*) waits until the pin input becomes equal to "
"*pulse_level*, then (**) times the duration that the pin is equal to "
"*pulse_level*. If the pin is already equal to *pulse_level* then timing "
"starts straight away."
msgstr ""
"ピンの現在の入力値が *pulse_level* と異なる場合、関数は最初にピン入力が "
"*pulse_level* に等しくなるまで待機し(*)、次にそのピンが *pulse_level* に等しい"
"時間を測ります(**)。ピンが既に *pulse_level* に等しい場合、計測はすぐに開始"
"されます。"

#: ../../../library/machine.rst:125
msgid ""
"The function will return -2 if there was timeout waiting for condition "
"marked (*) above, and -1 if there was timeout during the main "
"measurement, marked (**) above. The timeout is the same for both cases "
"and given by *timeout_us* (which is in microseconds)."
msgstr ""
"タイムアウトが発生した場合、上記の(*)の状態を待っていた場合は -2 を返し、上記の"
"(**)の場合は -1 を返します。タイムアウト時間は両方のケースで同じで、 *timeout_us* "
"(マイクロ秒単位)で指定します。"

#: ../../../library/machine.rst:132
msgid "Return a 24-bit software generated random number."
msgstr "24ビットのソフトウェア生成乱数を返します。"

#: ../../../library/machine.I2C.rst:67 ../../../library/machine.Pin.rst:180
#: ../../../library/machine.UART.rst:149 ../../../library/machine.UART.rst:158
#: ../../../library/machine.rst:134
msgid "Availability: WiPy."
msgstr "可用性: WiPy"

#: ../../../library/machine.rst:145
msgid "IRQ wake values."
msgstr "IRQ 起床値。"

#: ../../../library/machine.rst:153
msgid "Reset causes."
msgstr "リセット原因。"

#: ../../../library/machine.rst:159
msgid "Wake-up reasons."
msgstr "起床理由。"

#: ../../../library/machine.ADC.rst:5 ../../../library/pyb.ADC.rst:5
msgid "class ADC -- analog to digital conversion"
msgstr "クラス ADC -- アナログ-デジタル変換"

#: ../../library/machine.ADC.rst:7
msgid ""
"The ADC class provides an interface to analog-to-digital convertors, and "
"represents a single endpoint that can sample a continuous voltage and "
"convert it to a discretised value."
msgstr ""
"ADC クラスはアナログ-デジタルコンバーターへのインターフェイスを提供します。"
"これは、電圧変動をサンプリングして離散値に変換する単一のエンドポイントを表します。"

#: ../../library/machine.ADC.rst:11 ../../library/machine.I2C.rst:15
#: ../../library/machine.RTC.rst:10 ../../library/machine.SD.rst:20
#: ../../library/machine.WDT.rst:12 ../../library/network.WIZNET5K.rst:12
#: ../../library/pyb.DAC.rst:12 ../../library/pyb.RTC.rst:10
#: ../../library/pyb.Servo.rst:12
msgid "Usage::"
msgstr "使用例:"

#: ../../../library/machine.ADC.rst:13
msgid ""
"import machine\n"
"\n"
"adc = machine.ADC(pin)   # create an ADC object acting on a pin\n"
"val = adc.read_u16()     # read a raw analog value in the range 0-65535"
msgstr ""
"import machine\n"
"\n"
"adc = machine.ADC(pin)   # 指定のピンの ADC オブジェクトを作成\n"
"val = adc.read_u16()     # 生のアナログ値を 0-65535 の範囲で読み込み"

#: ../../../library/machine.ADC.rst:20
msgid ""
"Access the ADC associated with a source identified by *id*.  This *id* "
"may be an integer (usually specifying a channel number), a :ref:`Pin "
"<machine.Pin>` object, or other value supported by the underlying "
"machine."
msgstr ""
"*id* が示すソースにソースに関連付けられた ADC にアクセスします。"
"この *id* は、整数(通常はチャネル番号を指定)、 :ref:`Pin <machine.Pin>` "
"オブジェクト、基盤の基礎のハードウェアがサポートする他の値です。"

#: ../../library/machine.ADC.rst:33
msgid ""
"Take an analog reading and return an integer in the range 0-65535. The "
"return value represents the raw reading taken by the ADC, scaled such "
"that the minimum value is 0 and the maximum value is 65535."
msgstr ""
"アナログ値の読込み行い、0-65535 の範囲の整数を返します。"
"戻り値は、ADC によって取得された生の読み取り値を表し、"
"最小値が 0、最大値が 65535 になるようにスケーリングされます。"

#: ../../../library/machine.ADC.rst:62
msgid "Fast method to read the channel value."
msgstr "チャネル値を読み取るための高速メソッド。"

#: ../../../library/machine.ADC.rst:66
msgid "Read the channel value."
msgstr "チャンネル値を読みます。"

#: ../../../library/machine.ADC.rst:70
msgid "Re-init (and effectively enable) the ADC channel."
msgstr "ADC チャネルを再初期化(そして効果的に有効化)します。"

#: ../../../library/machine.ADC.rst:74
msgid "Disable the ADC channel."
msgstr "ADC チャネルを無効化します。"

#: ../../../library/machine.I2C.rst:5 ../../../library/pyb.I2C.rst:5
msgid "class I2C -- a two-wire serial protocol"
msgstr "クラス I2C -- ２線式シリアルプロトコル"

#: ../../../library/machine.I2C.rst:7 ../../../library/pyb.I2C.rst:7
msgid ""
"I2C is a two-wire protocol for communicating between devices.  At the "
"physical level it consists of 2 wires: SCL and SDA, the clock and data "
"lines respectively."
msgstr ""
"I2C は、デバイス間通信のための２線式プロトコルです。物理レベルでは、クロックライン"
"である SCL とデータラインである SDA の2本のワイヤで構成されています。"

#: ../../../library/machine.I2C.rst:10 ../../../library/pyb.I2C.rst:10
msgid ""
"I2C objects are created attached to a specific bus.  They can be "
"initialised when created, or initialised later on."
msgstr ""
"I2C オブジェクトは特定のバスに接続して作成されます。作成時に初期化することも、"
"後で初期化することもできます。"

#: ../../../library/machine.I2C.rst:13
msgid "Printing the I2C object gives you information about its configuration."
msgstr "I2Cオブジェクトを print() で表示すると、その設定に関する情報が得られます。"

#: ../../../library/machine.I2C.rst:15 ../../../library/machine.RTC.rst:10
#: ../../../library/machine.SD.rst:20 ../../../library/machine.WDT.rst:12
#: ../../../library/network.WIZNET5K.rst:12 ../../../library/pyb.DAC.rst:12
#: ../../../library/pyb.RTC.rst:10 ../../../library/pyb.Servo.rst:12
msgid "Example usage::"
msgstr "使用例::"

#: ../../../library/machine.I2C.rst:17
msgid ""
"from machine import I2C\n"
"\n"
"i2c = I2C(freq=400000)          # create I2C peripheral at frequency of "
"400kHz\n"
"                                # depending on the port, extra parameters"
" may be required\n"
"                                # to select the peripheral and/or pins to"
" use\n"
"\n"
"i2c.scan()                      # scan for slaves, returning a list of "
"7-bit addresses\n"
"\n"
"i2c.writeto(42, b'123')         # write 3 bytes to slave with 7-bit "
"address 42\n"
"i2c.readfrom(42, 4)             # read 4 bytes from slave with 7-bit "
"address 42\n"
"\n"
"i2c.readfrom_mem(42, 8, 3)      # read 3 bytes from memory of slave 42,\n"
"                                #   starting at memory-address 8 in the "
"slave\n"
"i2c.writeto_mem(42, 2, b'\\x10') # write 1 byte to memory of slave 42\n"
"                                #   starting at address 2 in the slave"
msgstr ""
"from machine import I2C\n"
"\n"
"i2c = I2C(freq=400000)          # ポートに依存して 400kHz の周波数でI2Cペリフェラルを\n"
"                                # 作成します。使用するペリフェラルやピンを選択するために\n"
"                                # 追加のパラメータが必要になる場合があります\n"
"\n"
"i2c.scan()                      # スレーブをスキャンし、7ビットアドレスのリストを返します\n"
"\n"
"i2c.writeto(42, b'123')         # 7ビットアドレス 42 のスレーブに３バイトを書き込みます\n"
"i2c.readfrom(42, 4)             # 7ビットアドレス 42 のスレーブから４バイトを読み込みます\n"
"\n"
"i2c.readfrom_mem(42, 8, 3)      # スレーブ 42 のメモリから、スレーブのメモリアドレス 8 で\n"
"                                #   始まる３バイトを読み込みます\n"
"i2c.writeto_mem(42, 2, b'\\x10') # スレーブ 42 のメモリの、スレーブのメモリアドレス 2 で\n"
"                                #   始まるところに２バイトを書き込みます"

#: ../../../library/machine.I2C.rst:38
msgid "Construct and return a new I2C object using the following parameters:"
msgstr "以下のパラメータを使用して、新しい I2C オブジェクトを構築して返します。"

#: ../../../library/machine.I2C.rst:40
msgid ""
"*id* identifies a particular I2C peripheral.  The default value of -1 "
"selects a software implementation of I2C which can work (in most cases) "
"with arbitrary pins for SCL and SDA. If *id* is -1 then *scl* and *sda* "
"must be specified.  Other allowed values for *id* depend on the "
"particular port/board, and specifying *scl* and *sda* may or may not be "
"required or allowed in this case."
msgstr ""
"*id* は特定の I2C ペリフェラルを識別します。デフォルト値の -1 は I2C のソフトウェア"
"実装を選択し、(ほとんどの場合) SCL と SDA の任意のピンで動作できます。 "
"*id* が -1 の場合は *scl* と *sda* を指定する必要があります。 *id* に許可されている"
"その他の値は特定のポート/ボードによって異なります。この場合、 *scl* と *sda* の指定は"
"必須ではなく、許可もされていないこともあります。"

#: ../../../library/machine.I2C.rst:47
msgid "*scl* should be a pin object specifying the pin to use for SCL."
msgstr "*scl* は SCL に使用するピンを指定するピンオブジェクトでなければなりません。"

#: ../../../library/machine.I2C.rst:48
msgid "*sda* should be a pin object specifying the pin to use for SDA."
msgstr "*sda* は SDA に使用するピンを指定するピンオブジェクトです。"

#: ../../../library/machine.I2C.rst:49
msgid "*freq* should be an integer which sets the maximum frequency for SCL."
msgstr "*freq* は SCL の最大周波数を設定する整数です。"

#: ../../../library/machine.I2C.rst:53
msgid "General Methods"
msgstr "一般的なメソッド"

#: ../../../library/machine.I2C.rst:57
msgid "Initialise the I2C bus with the given arguments:"
msgstr "与えた引数で I2C バスを初期化します。"

#: ../../../library/machine.I2C.rst:59
msgid "*scl* is a pin object for the SCL line"
msgstr "*scl* は SCL ラインのピンオブジェクトです"

#: ../../../library/machine.I2C.rst:60
msgid "*sda* is a pin object for the SDA line"
msgstr "*sda* は SDA ラインのピンオブジェクトです"

#: ../../../library/machine.I2C.rst:61
msgid "*freq* is the SCL clock rate"
msgstr "*freq* は SCL のクロックレートです"

#: ../../../library/machine.I2C.rst:65 ../../../library/pyb.I2C.rst:85
msgid "Turn off the I2C bus."
msgstr "I2C バスをオフにします。"

#: ../../../library/machine.I2C.rst:71
msgid ""
"Scan all I2C addresses between 0x08 and 0x77 inclusive and return a list "
"of those that respond.  A device responds if it pulls the SDA line low "
"after its address (including a write bit) is sent on the bus."
msgstr ""
"0x08 から 0x77 までのすべてのI2Cアドレスをスキャンし、応答したもののリストを返します。"
"デバイスは、アドレス(書き込みビットを含む)がバスに送信された後に SDA ラインをローに"
"引き下げると応答します。"

#: ../../../library/machine.I2C.rst:76
msgid "Primitive I2C operations"
msgstr "プリミティブ I2C 操作"

#: ../../../library/machine.I2C.rst:78
msgid ""
"The following methods implement the primitive I2C master bus operations "
"and can be combined to make any I2C transaction.  They are provided if "
"you need more control over the bus, otherwise the standard methods (see "
"below) can be used."
msgstr ""
"以下のメソッドは、プリミティブな I2C マスターのバス操作を実装しており、任意の I2C "
"トランザクションを作成するために組み合わせることができます。標準的なメソッド(下記参照)"
"では足りない制御する必要があるなら、これらのメソッドを使います。"

#: ../../../library/machine.I2C.rst:82
msgid "These methods are available on software I2C only."
msgstr "これらのメソッドはソフトウェア I2C でのみ利用できます。"

#: ../../../library/machine.I2C.rst:86
msgid ""
"Generate a START condition on the bus (SDA transitions to low while SCL "
"is high)."
msgstr ""
"バス上で START 条件を生成します(SCL がハイの間に SDA がローに遷移します)。"

#: ../../../library/machine.I2C.rst:90
msgid ""
"Generate a STOP condition on the bus (SDA transitions to high while SCL "
"is high)."
msgstr ""
"バス上で STOP 条件を生成します(SCL がハイの間に SDA がハイに遷移します)。"

#: ../../../library/machine.I2C.rst:94
msgid ""
"Reads bytes from the bus and stores them into *buf*.  The number of bytes"
" read is the length of *buf*.  An ACK will be sent on the bus after "
"receiving all but the last byte.  After the last byte is received, if "
"*nack* is true then a NACK will be sent, otherwise an ACK will be sent "
"(and in this case the slave assumes more bytes are going to be read in a "
"later call)."
msgstr ""
"バスからバイト列を読み込んで *buf* に格納します。読み取るバイト数は *buf* の長さ分です。"
"ACK は最後のバイトを除くすべてを受信した後にバス上に送信されます。最後のバイトが受信"
"した後、 *nack* が true の場合は NACK が送信され、それ以外の場合は ACK が送信されます"
"(この場合、スレーブは後の呼び出しでさらにバイトが読み取られると想定します)。"

#: ../../../library/machine.I2C.rst:102
msgid ""
"Write the bytes from *buf* to the bus.  Checks that an ACK is received "
"after each byte and stops transmitting the remaining bytes if a NACK is "
"received.  The function returns the number of ACKs that were received."
msgstr ""
"*buf* からバスにバイト列を書き込みます。各バイトの後に ACK が受信されたことを確認し、"
"NACK が受信された場合は残りのバイト列の送信を停止します。この関数は受信した ACK "
"の数を返します。"

#: ../../../library/machine.I2C.rst:107
msgid "Standard bus operations"
msgstr "標準バスオペレーション"

#: ../../../library/machine.I2C.rst:109
msgid ""
"The following methods implement the standard I2C master read and write "
"operations that target a given slave device."
msgstr ""
"以下のメソッドは、特定のスレーブデバイスをターゲットとする標準の I2C マスター読取り/書込み"
"操作を実装しています。"

#: ../../../library/machine.I2C.rst:114
msgid ""
"Read *nbytes* from the slave specified by *addr*. If *stop* is true then "
"a STOP condition is generated at the end of the transfer. Returns a "
"`bytes` object with the data read."
msgstr ""
"*addr* で指定されたスレーブから *nbytes* 分を読み取ります。 *stop* が True の場合、"
"転送終了時に STOP 条件が生成されます。読み込んだデータを持つ `bytes` オブジェクトを"
"返します。"

#: ../../../library/machine.I2C.rst:120
msgid ""
"Read into *buf* from the slave specified by *addr*. The number of bytes "
"read will be the length of *buf*. If *stop* is true then a STOP condition"
" is generated at the end of the transfer."
msgstr ""
"*addr* で指定されたスレーブから *buf* に読み込みます。読み取られるバイト数は *buf* "
"の長さ分になります。 *stop* が True の場合、転送終了時にSTOP条件が生成されます。"

#: ../../../library/machine.I2C.rst:124 ../../../library/machine.I2C.rst:157
#: ../../../library/machine.I2C.rst:166
msgid "The method returns ``None``."
msgstr "このメソッドは ``None`` を返します。"

#: ../../../library/machine.I2C.rst:128
msgid ""
"Write the bytes from *buf* to the slave specified by *addr*.  If a NACK "
"is received following the write of a byte from *buf* then the remaining "
"bytes are not sent.  If *stop* is true then a STOP condition is generated"
" at the end of the transfer, even if a NACK is received. The function "
"returns the number of ACKs that were received."
msgstr ""
"*buf* から *addr* で指定されたスレーブにバイト列を書き込みます。 *buf* からの"
"バイト列の書き込みに続いて NACK を受信した場合、残りのバイトは送信されません。"
"もし *stop* が True であれば、たとえ NACK が受信されたとしても、転送の終わりに "
"STOP 条件が生成されます。この関数は受信した ACK の数を返します。"

#: ../../../library/machine.I2C.rst:136
msgid ""
"Write the bytes contained in *vector* to the slave specified by *addr*. "
"*vector* should be a tuple or list of objects with the buffer protocol. "
"The *addr* is sent once and then the bytes from each object in *vector* "
"are written out sequentially.  The objects in *vector* may be zero bytes "
"in length in which case they don't contribute to the output."
msgstr ""
"*vector* に指定したバイト列を *addr* に指定したスレーブに書き込みます。"
"*vector* はバッファプロトコルを持つオブジェクトのタプルかリストであるべきです。"
"*addr* が1回送信され、その後 *vector* 内の各オブジェクトからのバイトを順次書き込みます。"
"*vector* 内のオブジェクトは長さが0バイトであるかもしれませんが、その場合には出力しません。"

#: ../../../library/machine.I2C.rst:142
msgid ""
"If a NACK is received following the write of a byte from one of the "
"objects in *vector* then the remaining bytes, and any remaining objects, "
"are not sent.  If *stop* is true then a STOP condition is generated at "
"the end of the transfer, even if a NACK is received.  The function "
"returns the number of ACKs that were received."
msgstr ""
"*vector* 内のオブジェクトの１つから、あるバイトの書き込みの後に NACK が受信された場合、"
"残りのバイトおよび残りのオブジェクトは送信されません。 *stop* が真の場合、たとえ NACK "
"が受信されても、転送の終わりに STOP 条件が生成されます。この関数は受信した ACK の数を"
"返します。"

#: ../../../library/machine.I2C.rst:149
msgid "Memory operations"
msgstr "メモリ操作"

#: ../../../library/machine.I2C.rst:151
msgid ""
"Some I2C devices act as a memory device (or set of registers) that can be"
" read from and written to.  In this case there are two addresses "
"associated with an I2C transaction: the slave address and the memory "
"address.  The following methods are convenience functions to communicate "
"with such devices."
msgstr ""
"一部の I2C デバイスは、読み書き可能なメモリデバイス(またはレジスタセット)として機能します。"
"この場合、I2C トランザクションに関連付けられた２つのアドレスがあります。スレーブアドレスと"
"メモリアドレスです。以下のメソッドは、そのようなデバイスと通信するための便利な機能です。"

#: ../../../library/machine.I2C.rst:158
msgid ""
"Read *nbytes* from the slave specified by *addr* starting from the memory"
" address specified by *memaddr*. The argument *addrsize* specifies the "
"address size in bits. Returns a `bytes` object with the data read."
msgstr ""
"*addr* で指定したスレーブより、 *memaddr* で指定したメモリアドレスから *nbytes* 分を読み込みます。"
"引数 *addrsize* はアドレスサイズをビット数で指定します。この関数は読み込んだデータを持つバイト列"
"オブジェクトを返します。"

#: ../../../library/machine.I2C.rst:165
msgid ""
"Read into *buf* from the slave specified by *addr* starting from the "
"memory address specified by *memaddr*.  The number of bytes read is the "
"length of *buf*. The argument *addrsize* specifies the address size in "
"bits (on ESP8266 this argument is not recognised and the address size is "
"always 8 bits)."
msgstr ""
"*addr* で指定したスレーブより、 *memaddr* で指定したメモリアドレスから *buf* に読み込みます。"
"読み取られるバイト数は *buf* の長さです。引数 *addrsize* はアドレスサイズをビット数で指定します"
"(ESP8266ではこの引数は認識されず、アドレスサイズは常に8ビットです)。"

#: ../../../library/machine.I2C.rst:175
msgid ""
"Write *buf* to the slave specified by *addr* starting from the memory "
"address specified by *memaddr*. The argument *addrsize* specifies the "
"address size in bits (on ESP8266 this argument is not recognised and the "
"address size is always 8 bits)."
msgstr ""
"*addr* で指定したスレーブに、 *memaddr* で指定したメモリアドレスへ *buf* を書き込みます。"
"引数 *addrsize* はアドレスサイズをビット数で指定します"
"(ESP8266ではこの引数は認識されず、アドレスサイズは常に8ビットです)。"

#: ../../../library/machine.Pin.rst:5 ../../../library/pyb.Pin.rst:5
msgid "class Pin -- control I/O pins"
msgstr "クラス Pin -- I/O ピンの制御"

#: ../../../library/machine.Pin.rst:7
msgid ""
"A pin object is used to control I/O pins (also known as GPIO - general-"
"purpose input/output).  Pin objects are commonly associated with a "
"physical pin that can drive an output voltage and read input voltages.  "
"The pin class has methods to set the mode of the pin (IN, OUT, etc) and "
"methods to get and set the digital logic level. For analog control of a "
"pin, see the :class:`ADC` class."
msgstr ""
"ピンオブジェクトは、I/O ピン (GPIO - 汎用入出力)を制御するために使われます。"
"ピンオブジェクトは、一般に物理ピンに関連付けられていて、出力電圧を駆動したり、"
"入力電圧を読み取ることができます。ピンクラスには、ピンのモード(IN, OUT など)を"
"設定するメソッドと、デジタル論理レベルを取得および設定するメソッドがあります。"
"ピンのアナログ制御については :class:`ADC` クラスを参照してください。"

#: ../../../library/machine.Pin.rst:13
msgid ""
"A pin object is constructed by using an identifier which unambiguously "
"specifies a certain I/O pin.  The allowed forms of the identifier and the"
" physical pin that the identifier maps to are port-specific.  "
"Possibilities for the identifier are an integer, a string or a tuple with"
" port and pin number."
msgstr ""
"ピンオブジェクトは、特定の I/O ピンを明示する識別子を使って構築されます。識別子の形式と"
"その識別子が示す物理ピンはポートに固有です。識別子の形式としては、整数、文字列、ポートと"
"ピン番号のタプルなどがあります。"

#: ../../../library/machine.Pin.rst:19 ../../../library/pyb.Pin.rst:226
msgid "Usage Model::"
msgstr "よくある使用例::"

#: ../../../library/machine.Pin.rst:21
msgid ""
"from machine import Pin\n"
"\n"
"# create an output pin on pin #0\n"
"p0 = Pin(0, Pin.OUT)\n"
"\n"
"# set the value low then high\n"
"p0.value(0)\n"
"p0.value(1)\n"
"\n"
"# create an input pin on pin #2, with a pull up resistor\n"
"p2 = Pin(2, Pin.IN, Pin.PULL_UP)\n"
"\n"
"# read and print the pin value\n"
"print(p2.value())\n"
"\n"
"# reconfigure pin #0 in input mode\n"
"p0.mode(p0.IN)\n"
"\n"
"# configure an irq callback\n"
"p0.irq(lambda p:print(p))"
msgstr ""
"from machine import Pin\n"
"\n"
"# ピン #0 を出力ピンとして作成\n"
"p0 = Pin(0, Pin.OUT)\n"
"\n"
"# 値をロー、ハイと順に設定\n"
"p0.value(0)\n"
"p0.value(1)\n"
"\n"
"# ピン #2 をプルアップ抵抗付きの入力ピンとして作成\n"
"p2 = Pin(2, Pin.IN, Pin.PULL_UP)\n"
"\n"
"# ピンの値を読み込んで表示\n"
"print(p2.value())\n"
"\n"
"# ピン #0 を入力モードに再設定\n"
"p0.mode(p0.IN)\n"
"\n"
"# irq コールバックを設定\n"
"p0.irq(lambda p:print(p))"

#: ../../../library/machine.Pin.rst:47
msgid ""
"Access the pin peripheral (GPIO pin) associated with the given ``id``.  "
"If additional arguments are given in the constructor then they are used "
"to initialise the pin.  Any settings that are not specified will remain "
"in their previous state."
msgstr ""
"指定した ``id`` に関連づけられたピンペリフェラル(GPIO ピン)にアクセスします。"
"追加の引数がコンストラクタに指定された場合は、それらを使ってピンを初期化します。"
"指定していない場合の設定は、以前の状態のままとなります。"

#: ../../../library/machine.Pin.rst:51 ../../../library/machine.Pin.rst:191
#: ../../../library/machine.Signal.rst:88
msgid "The arguments are:"
msgstr "引数は次のとおりです:"

#: ../../../library/machine.Pin.rst:53
msgid ""
"``id`` is mandatory and can be an arbitrary object.  Among possible value"
" types are: int (an internal Pin identifier), str (a Pin name), and tuple"
" (pair of [port, pin])."
msgstr ""
"``id`` は必須であり、任意のオブジェクトを指定できます。可能な値の型には int (内部ピン"
"識別子)、str (ピン名)、およびタプル([ポート, ピン] のペア)があります。"

#: ../../../library/machine.Pin.rst:57
msgid "``mode`` specifies the pin mode, which can be one of:"
msgstr "``mode`` はピンモードを指定します。次のいずれかになります:"

#: ../../../library/machine.Pin.rst:59
msgid ""
"``Pin.IN`` - Pin is configured for input.  If viewed as an output the pin"
" is in high-impedance state."
msgstr ""
"``Pin.IN`` - ピンは入力用に設定されます。出力として参照すると、ピンはハイインピーダンス"
"状態です。"

#: ../../../library/machine.Pin.rst:62
msgid "``Pin.OUT`` - Pin is configured for (normal) output."
msgstr "``Pin.OUT`` - ピンは(通常の)出力用に構成されます。"

#: ../../../library/machine.Pin.rst:64
msgid ""
"``Pin.OPEN_DRAIN`` - Pin is configured for open-drain output. Open-drain "
"output works in the following way: if the output value is set to 0 the "
"pin is active at a low level; if the output value is 1 the pin is in a "
"high-impedance state.  Not all ports implement this mode, or some might "
"only on certain pins."
msgstr ""
"``Pin.OPEN_DRAIN`` - ピンはオープンドレイン出力用に設定されます。オープンドレイン"
"出力は次のように動作します: 出力値が 0 に設定される場合、ピンはローレベルでアクティブ"
"になります。出力値が 1 の場合、ピンはハイインピーダンス状態になります。すべてのポートが"
"このモードを実装しているわけではありません。"

#: ../../../library/machine.Pin.rst:69
msgid ""
"``Pin.ALT`` - Pin is configured to perform an alternative function, which"
" is port specific.  For a pin configured in such a way any other Pin "
"methods (except :meth:`Pin.init`) are not applicable (calling them will "
"lead to undefined, or a hardware-specific, result).  Not all ports "
"implement this mode."
msgstr ""
"``Pin.ALT`` - ピンは、ポート固有の代替機能を実行するように設定されています。このように"
"設定されたピンの場合、他のどの Pin メソッドは(:meth:`Pin.init` を除いて)適用され"
"ません(呼び出した結果は未定義またはハードウェア依存となります)。すべてのポートがこのモード"
"を実装しているわけではありません。"

#: ../../../library/machine.Pin.rst:74
msgid ""
"``Pin.ALT_OPEN_DRAIN`` - The Same as ``Pin.ALT``, but the pin is "
"configured as open-drain.  Not all ports implement this mode."
msgstr ""
"``Pin.ALT_OPEN_DRAIN`` - ``Pin.ALT`` と同じですが、ピンはオープンドレインとして"
"設定されます。すべてのポートがこのモードを実装しているわけではありません。"

#: ../../../library/machine.Pin.rst:77
msgid ""
"``pull`` specifies if the pin has a (weak) pull resistor attached, and "
"can be one of:"
msgstr ""
"``pull`` は、ピンに(弱い)プル抵抗を接続するかを指定します。次のいずれかに"
"なります:"

#: ../../../library/machine.Pin.rst:80
msgid "``None`` - No pull up or down resistor."
msgstr "``None`` - プルアップ抵抗もプルダウン抵抗もなし。"

#: ../../../library/machine.Pin.rst:81
msgid "``Pin.PULL_UP`` - Pull up resistor enabled."
msgstr "``Pin.PULL_UP`` - プルアップ抵抗を有効にします。"

#: ../../../library/machine.Pin.rst:82
msgid "``Pin.PULL_DOWN`` - Pull down resistor enabled."
msgstr "``Pin.PULL_DOWN`` - プルダウン抵抗を有効にします。"

#: ../../../library/machine.Pin.rst:84
msgid ""
"``value`` is valid only for Pin.OUT and Pin.OPEN_DRAIN modes and "
"specifies initial output pin value if given, otherwise the state of the "
"pin peripheral remains unchanged."
msgstr ""
"``value`` は Pin.OUT および Pin.OPEN_DRAIN モードでのみ有効で、指定されて"
"いる場合は初期出力ピン値になります。指定のない場合、ピンのペリフェラルの状態は"
"変更されません。"

#: ../../../library/machine.Pin.rst:88
msgid ""
"``drive`` specifies the output power of the pin and can be one of: "
"``Pin.LOW_POWER``, ``Pin.MED_POWER`` or ``Pin.HIGH_POWER``.  The actual "
"current driving capabilities are port dependent.  Not all ports implement"
" this argument."
msgstr ""
"``drive`` はピンの出力電力を指定します。この引数には ``Pin.LOW_POWER``, "
"``Pin.MED_POWER``, ``Pin.HIGH_POWER`` のいずれかを指定します。実際の電流駆動"
"能力はポートによって異なります。すべてのポートがこの引数を実装しているわけでは"
"ありません。"

#: ../../../library/machine.Pin.rst:92
msgid ""
"``alt`` specifies an alternate function for the pin and the values it can"
" take are port dependent.  This argument is valid only for ``Pin.ALT`` "
"and ``Pin.ALT_OPEN_DRAIN`` modes.  It may be used when a pin supports "
"more than one alternate function.  If only one pin alternate function is "
"supported the this argument is not required.  Not all ports implement "
"this argument."
msgstr ""
"``alt`` はピンの代替機能を指定し、ポートに依存する値を取ります。この引数は "
"``Pin.ALT`` と ``Pin.ALT_OPEN_DRAIN`` モードでのみ有効です。これは、ピンが"
"複数の代替機能をサポートしている場合に使われます。ピン代替機能が１つしかない場合、"
"この引数は必須ではありません。すべてのポートがこの引数を実装しているわけではありません。"

#: ../../../library/machine.Pin.rst:98
msgid ""
"As specified above, the Pin class allows to set an alternate function for"
" a particular pin, but it does not specify any further operations on such"
" a pin.  Pins configured in alternate-function mode are usually not used "
"as GPIO but are instead driven by other hardware peripherals.  The only "
"operation supported on such a pin is re-initialising, by calling the "
"constructor or :meth:`Pin.init` method.  If a pin that is configured in "
"alternate-function mode is re-initialised with ``Pin.IN``, ``Pin.OUT``, "
"or ``Pin.OPEN_DRAIN``, the alternate function will be removed from the "
"pin."
msgstr ""
"上記で指定されたように、Pin クラスは特定のピンに対して代替機能を設定することを可能に"
"していますが、そのようなピンに対するさらなる操作は指定しません。代替機能モードに設定"
"されたピンは、通常 GPIO として使われず、代わりに他のハードウェアペリフェラルによって"
"駆動されます。このようなピンでサポートされている唯一の操作は、コンストラクタまたは "
":meth:`Pin.init` メソッドを呼び出すことによる再初期化です。代替機能モードに設定"
"されたピンが ``Pin.IN``, ``Pin.OUT``, ``Pin.OPEN_DRAIN`` で再初期化されると、"
"代替機能がピンから外されます。"

#: ../../../library/machine.Pin.rst:111
msgid ""
"Re-initialise the pin using the given parameters.  Only those arguments "
"that are specified will be set.  The rest of the pin peripheral state "
"will remain unchanged.  See the constructor documentation for details of "
"the arguments."
msgstr ""
"指定したパラメータを使ってピンを再初期化します。指定された引数だけが設定されます。"
"残りのピンペリフェラルは変更されません。引数の詳細については、コンストラクタの"
"説明を参照してください。"

#: ../../../library/machine.Pin.rst:115
msgid "Returns ``None``."
msgstr "``None`` を返します。"

#: ../../../library/machine.Pin.rst:119
msgid ""
"This method allows to set and get the value of the pin, depending on "
"whether the argument ``x`` is supplied or not."
msgstr ""
"このメソッドは、引数 ``x`` を指定したかによって、ピンの値を設定したり取得する"
"のに使えます。"

#: ../../../library/machine.Pin.rst:122
msgid ""
"If the argument is omitted then this method gets the digital logic level "
"of the pin, returning 0 or 1 corresponding to low and high voltage "
"signals respectively.  The behaviour of this method depends on the mode "
"of the pin:"
msgstr ""
"引数を省略した場合、このメソッドはピンのデジタル論理レベルを取得し、低電圧信号と"
"高電圧信号に対応してそれぞれ 0 または 1 を返します。このメソッドの動作はピンの"
"モードによって異なります。"

#: ../../../library/machine.Pin.rst:126
msgid ""
"``Pin.IN`` - The method returns the actual input value currently present "
"on the pin."
msgstr ""
"``Pin.IN`` - メソッドはピンの現在の入力値を返します。"

#: ../../../library/machine.Pin.rst:128
msgid "``Pin.OUT`` - The behaviour and return value of the method is undefined."
msgstr "``Pin.OUT`` - メソッドの動作と戻り値は未定義です。"

#: ../../../library/machine.Pin.rst:129
msgid ""
"``Pin.OPEN_DRAIN`` - If the pin is in state '0' then the behaviour and "
"return value of the method is undefined.  Otherwise, if the pin is in "
"state '1', the method returns the actual input value currently present on"
" the pin."
msgstr ""
"``Pin.OPEN_DRAIN`` - ピンが状態 '0' の場合、メソッドの動作と戻り値は未定義です。"
"それ以外の場合、ピンが状態 '1' の場合、メソッドはピンに現在の入力値を返します。"

#: ../../../library/machine.Pin.rst:134
msgid ""
"If the argument is supplied then this method sets the digital logic level"
" of the pin.  The argument ``x`` can be anything that converts to a "
"boolean. If it converts to ``True``, the pin is set to state '1', "
"otherwise it is set to state '0'.  The behaviour of this method depends "
"on the mode of the pin:"
msgstr ""
"引数が指定されている場合、このメソッドはピンのデジタル論理レベルを設定します。引数 "
"``x`` はブール型に変換できるものであれば何でも構いません。変換後が True だと"
"ピンは状態 '1' に設定され、そうでない場合は状態 '0' に設定されます。このメソッドの"
"動作はピンのモードによって異なります。"

#: ../../../library/machine.Pin.rst:139
msgid ""
"``Pin.IN`` - The value is stored in the output buffer for the pin.  The "
"pin state does not change, it remains in the high-impedance state.  The "
"stored value will become active on the pin as soon as it is changed to "
"``Pin.OUT`` or ``Pin.OPEN_DRAIN`` mode."
msgstr ""
"``Pin.IN`` - 値はピンの出力バッファに格納されます。ピンの状態は変化せず、ハイ"
"インピーダンス状態のままです。格納された値は ``Pin.OUT`` または "
"``Pin.OPEN_DRAIN`` に変更されるとすぐにピンでアクティブになります。"

#: ../../../library/machine.Pin.rst:143
msgid "``Pin.OUT`` - The output buffer is set to the given value immediately."
msgstr "``Pin.OUT`` - 出力バッファは指定した値ですぐに設定されます。"

#: ../../../library/machine.Pin.rst:144
msgid ""
"``Pin.OPEN_DRAIN`` - If the value is '0' the pin is set to a low voltage "
"state.  Otherwise the pin is set to high-impedance state."
msgstr ""
"``Pin.OPEN_DRAIN`` - 値が '0' の場合ピンは低電圧状態に設定されます。それ以外の場合、"
"ピンはハイインピーダンス状態に設定されます。"

#: ../../../library/machine.Pin.rst:147
msgid "When setting the value this method returns ``None``."
msgstr "このメソッドは、値を設定する場合に ``None`` を返します。"

#: ../../../library/machine.Pin.rst:151
msgid ""
"Pin objects are callable.  The call method provides a (fast) shortcut to "
"set and get the value of the pin.  It is equivalent to Pin.value([x]). "
"See :meth:`Pin.value` for more details."
msgstr ""
"Pin オブジェクトは呼び出し可能です。呼び出しメソッドは、ピンの値の設定と取得のための"
"(速い)ショートカットを提供します。動作は Pin.value([x]) と等価です。詳細は "
":meth:`Pin.value` を参照してください。"

#: ../../../library/machine.Pin.rst:157
msgid "Set pin to \"1\" output level."
msgstr "ピンの出力レベルを \"1\" に設定します。"

#: ../../../library/machine.Pin.rst:161
msgid "Set pin to \"0\" output level."
msgstr "ピンの出力レベルを \"0\" に設定します。"

#: ../../../library/machine.Pin.rst:165
msgid ""
"Get or set the pin mode. See the constructor documentation for details of"
" the ``mode`` argument."
msgstr ""
"ピンのモードを取得または設定します。 ``mode`` 引数の詳細についてはコンストラクタ"
"の説明を参照してください。"

#: ../../../library/machine.Pin.rst:170
msgid ""
"Get or set the pin pull state. See the constructor documentation for "
"details of the ``pull`` argument."
msgstr ""
"ピンのプル状態を取得または設定します。 ``pull`` 引数の詳細についてはコンストラクタ"
"の説明を参照してください。"

#: ../../../library/machine.Pin.rst:175
msgid ""
"Get or set the pin drive strength. See the constructor documentation for "
"details of the ``drive`` argument."
msgstr ""
"ピンのドライブ強度を取得または設定します。 ``drive`` 引数の詳細についてはコンスト"
"ラクタの説明を参照してください。"

#: ../../../library/machine.Pin.rst:178
msgid "Not all ports implement this method."
msgstr "すべてのポートがこの方法を実装しているわけではありません。"

#: ../../../library/machine.Pin.rst:184
msgid ""
"Configure an interrupt handler to be called when the trigger source of "
"the pin is active.  If the pin mode is ``Pin.IN`` then the trigger source"
" is the external value on the pin.  If the pin mode is ``Pin.OUT`` then "
"the trigger source is the output buffer of the pin.  Otherwise, if the "
"pin mode is ``Pin.OPEN_DRAIN`` then the trigger source is the output "
"buffer for state '0' and the external pin value for state '1'."
msgstr ""
"ピンのトリガーとなるものがアクティブになったときに呼び出されるように割り込みハンドラを"
"設定します。ピンのモードが ``Pin.IN`` の場合、トリガーとなるのはピンの外部値です。"
"ピンのモードが ``Pin.OUT`` の場合、トリガーとなるのははピンの出力バッファです。"
"ピンのモードが ``Pin.OPEN_DRAIN`` の場合、トリガーとなるのは状態 '0' の出力バッファ"
"と状態 '1' の外部ピン値です。"

#: ../../../library/machine.Pin.rst:193
msgid ""
"``handler`` is an optional function to be called when the interrupt "
"triggers. The handler must take exactly one argument which is the ``Pin``"
" instance."
msgstr ""
"``handler`` は割り込みがトリガーされたときに呼び出されるオプションの関数です。"
"ハンドラは引数として ``Pin`` のインスタンス１つを必ず取る必要があります。"

#: ../../../library/machine.Pin.rst:197
msgid ""
"``trigger`` configures the event which can generate an interrupt. "
"Possible values are:"
msgstr ""
"``trigger`` は割り込みを生成できるイベントを設定します。"
"指定可能な値は次のとおりです:"

#: ../../../library/machine.Pin.rst:200
msgid "``Pin.IRQ_FALLING`` interrupt on falling edge."
msgstr "``Pin.IRQ_FALLING`` は立ち下がりエッジで割り込みを生成します。"

#: ../../../library/machine.Pin.rst:201
msgid "``Pin.IRQ_RISING`` interrupt on rising edge."
msgstr "``Pin.IRQ_RISING`` は立ち上がりエッジで割り込みを生成します。"

#: ../../../library/machine.Pin.rst:202
msgid "``Pin.IRQ_LOW_LEVEL`` interrupt on low level."
msgstr "``Pin.IRQ_LOW_LEVEL`` はローレベルで割り込みを生成します。"

#: ../../../library/machine.Pin.rst:203
msgid "``Pin.IRQ_HIGH_LEVEL`` interrupt on high level."
msgstr "``Pin.IRQ_HIGH_LEVEL`` はハイレベルで割り込みを生成します。"

#: ../../../library/machine.Pin.rst:205
msgid "These values can be OR'ed together to trigger on multiple events."
msgstr "これらの値を OR 演算して、複数のイベントをトリガーすることができます。"

#: ../../../library/machine.Pin.rst:207
msgid ""
"``priority`` sets the priority level of the interrupt.  The values it can"
" take are port-specific, but higher values always represent higher "
"priorities."
msgstr ""
"``priority`` は割り込みの優先度を設定します。必要な値はポート固有ですが、値が大きい"
"ほど常に優先順位が高くなります。"

#: ../../../library/machine.Pin.rst:211
msgid ""
"``wake`` selects the power mode in which this interrupt can wake up the "
"system.  It can be ``machine.IDLE``, ``machine.SLEEP`` or "
"``machine.DEEPSLEEP``. These values can also be OR'ed together to make a "
"pin generate interrupts in more than one power mode."
msgstr ""
"``wake`` はこの割り込みがシステムを起床させるパワーモードを選択します。指定できる値は "
"``machine.IDLE``, ``machine.SLEEP``, ``machine.DEEPSLEEP`` です。これらの値は、"
"複数の電源モードでピンが割り込みを生成するように OR 結合することもできます。"

#: ../../../library/machine.Pin.rst:216
msgid ""
"``hard`` if true a hardware interrupt is used. This reduces the delay "
"between the pin change and the handler being called. Hard interrupt "
"handlers may not allocate memory; see :ref:`isr_rules`."
msgstr ""
"``hard`` が True の場合、ハードウェア割り込みが使用されます。これにより、"
"ピンの変化と呼び出されるハンドラの間の遅延が小さくなります。ハード割り込みハンドラは"
"メモリを割り当てません。 :ref:`isr_rules` を参照してください。"

#: ../../../library/machine.Pin.rst:220
msgid "This method returns a callback object."
msgstr "このメソッドはコールバックオブジェクトを返します。"

#: ../../../library/machine.Pin.rst:225
msgid ""
"The following constants are used to configure the pin objects.  Note that"
" not all constants are available on all ports."
msgstr ""
"次の定数は、ピンオブジェクトを設定するために使われます。すべてのポートですべての定数を"
"使えるわけではないことに注意してください。"

#: ../../../library/machine.Pin.rst:234
msgid "Selects the pin mode."
msgstr "ピンのモードを選択します。"

#: ../../../library/machine.Pin.rst:239
msgid ""
"Selects whether there is a pull up/down resistor.  Use the value ``None``"
" for no pull."
msgstr ""
"プルアップ/ダウン抵抗があるかどうかを選択します。プルしないときには ``None`` "
"を使ってください。"

#: ../../../library/machine.Pin.rst:246
msgid "Selects the pin drive strength."
msgstr "ピンのドライブ強度を選択します。"

#: ../../../library/machine.Pin.rst:253
msgid "Selects the IRQ trigger type."
msgstr "IRQ トリガタイプを選択します。"

#: ../../../library/machine.RTC.rst:5 ../../../library/pyb.RTC.rst:5
msgid "class RTC -- real time clock"
msgstr "クラス RTC -- リアルタイムクロック"

#: ../../../library/machine.RTC.rst:7 ../../../library/pyb.RTC.rst:7
msgid "The RTC is and independent clock that keeps track of the date and time."
msgstr "RTCは、日時の経過を追う自律クロックです。"

#: ../../../library/machine.RTC.rst:12
msgid ""
"rtc = machine.RTC()\n"
"rtc.init((2014, 5, 1, 4, 13, 0, 0, 0))\n"
"print(rtc.now())"
msgstr ""

#: ../../../library/machine.RTC.rst:22
msgid "Create an RTC object. See init for parameters of initialization."
msgstr "RTC オブジェクトを作成します。初期化パラメータについてはinitを参照してください。"

#: ../../../library/machine.RTC.rst:29
msgid "Initialise the RTC. Datetime is a tuple of the form:"
msgstr "RTC を初期化します。datetime は次の形式のタプルです。"

#: ../../../library/machine.RTC.rst:31
msgid ""
"``(year, month, day[, hour[, minute[, second[, microsecond[, "
"tzinfo]]]]])``"
msgstr ""

#: ../../../library/machine.RTC.rst:35
msgid "Get get the current datetime tuple."
msgstr "現在の日時タプルを取得します。"

#: ../../../library/machine.RTC.rst:39
msgid "Resets the RTC to the time of January 1, 2015 and starts running it again."
msgstr "RTC を2015年1月1日の時刻にリセットして、実行を再開します。"

#: ../../../library/machine.RTC.rst:43
msgid ""
"Set the RTC alarm. Time might be either a millisecond value to program "
"the alarm to current time + time_in_ms in the future, or a datetimetuple."
" If the time passed is in milliseconds, repeat can be set to ``True`` to "
"make the alarm periodic."
msgstr ""
"RTC アラームを設定します。time にはアラームをプログラムする、現在時刻からの経過"
"ミリ秒数、あるいは日時タプルのどちらかを指定します。time の指定がミリ秒の場合、"
"repeat に True を設定すると、アラームを定期的に行うようになります。"

#: ../../../library/machine.RTC.rst:49
msgid "Get the number of milliseconds left before the alarm expires."
msgstr "アラームが期限切れになるまでの残りミリ秒数を取得します。"

#: ../../../library/machine.RTC.rst:53
msgid "Cancel a running alarm."
msgstr "作動中のアラームをキャンセルします。"

#: ../../../library/machine.RTC.rst:57
msgid "Create an irq object triggered by a real time clock alarm."
msgstr "リアルタイムクロックのアラームによってトリガーされる irq オブジェクトを作成します。"

#: ../../../library/machine.RTC.rst:59
msgid "``trigger`` must be ``RTC.ALARM0``"
msgstr "``trigger`` は ``RTC.ALARM0`` でなければなりません "

#: ../../../library/machine.RTC.rst:60
msgid "``handler`` is the function to be called when the callback is triggered."
msgstr "``handler`` はコールバックがトリガーされたときに呼び出される関数です。"

#: ../../../library/machine.RTC.rst:61
msgid ""
"``wake`` specifies the sleep mode from where this interrupt can wake up "
"the system."
msgstr ""
"``wake`` は、この割り込みがシステムを起床できるスリープモードを指定します。"

#: ../../../library/machine.RTC.rst:69
msgid "irq trigger source"
msgstr "irq トリガーソース"

#: ../../../library/machine.SD.rst:5
msgid "class SD -- secure digital memory card (cc3200 port only)"
msgstr "クラス SD -- セキュアデジタルメモリーカード(cc3200 ポートのみ)"

#: ../../../library/machine.SD.rst:9
msgid "This is a non-standard class and is only available on the cc3200 port."
msgstr "これは非標準クラスであり、cc3200 ポートでのみ利用可能です。"

#: ../../../library/machine.SD.rst:12
msgid ""
"The SD card class allows to configure and enable the memory card module "
"of the WiPy and automatically mount it as ``/sd`` as part of the file "
"system. There are several pin combinations that can be used to wire the "
"SD card socket to the WiPy and the pins used can be specified in the "
"constructor. Please check the `pinout and alternate functions table. "
"<https://raw.githubusercontent.com/wipy/wipy/master/docs/PinOUT.png>`_ "
"for more info regarding the pins which can be remapped to be used with a "
"SD card."
msgstr ""
"SD カードクラスを使用すると、WiPy のメモリカードモジュールを設定、有効化して、"
"ファイルシステムの一部として ``/sd`` に自動的にマウントできます。SD カードソケットを "
"WiPy に配線するために使うピンの組み合わせはいくつかあり、コンストラクタで指定できます。"
"SD カード用に再マッピングできるピンに関して詳しくは、ピン配置と代替機能の表を確認"
"してください。"

#: ../../../library/machine.SD.rst:22
msgid ""
"from machine import SD\n"
"import os\n"
"# clk cmd and dat0 pins must be passed along with\n"
"# their respective alternate functions\n"
"sd = machine.SD(pins=('GP10', 'GP11', 'GP15'))\n"
"os.mount(sd, '/sd')\n"
"# do normal file operations"
msgstr ""
"from machine import SD\n"
"import os\n"
"# clk cmd ピンと dat0 ピンはそれぞれの代替機能と\m"
"# 一緒に渡す必要があります\n"
"sd = machine.SD(pins=('GP10', 'GP11', 'GP15'))\n"
"os.mount(sd, '/sd')\n"
"# 通常のファイル操作を実行"

#: ../../../library/machine.SD.rst:35
msgid "Create a SD card object. See ``init()`` for parameters if initialization."
msgstr "SD カードオブジェクトを作成します。初期化の場合のパラメータは ``init()`` を参照してください。"

#: ../../../library/machine.SD.rst:42
msgid ""
"Enable the SD card. In order to initialize the card, give it a 3-tuple: "
"``(clk_pin, cmd_pin, dat0_pin)``."
msgstr ""
"SDカードを有効にします。カードを初期化するためには "
"``(clk_pin, cmd_pin, dat0_pin)`` の３項目のタプルを与えます。"

#: ../../../library/machine.SD.rst:47
msgid "Disable the SD card."
msgstr "SD カードを無効にします。"

#: ../../library/machine.SDCard.rst:5
msgid "class SDCard -- secure digital memory card"
msgstr "クラス SDCard -- SD メモリカード"

#: ../../library/machine.SDCard.rst:7
msgid ""
"SD cards are one of the most common small form factor removable storage "
"media. SD cards come in a variety of sizes and physical form factors. MMC"
" cards are similar removable storage devices while eMMC devices are "
"electrically similar storage devices designed to be embedded into other "
"systems. All three form share a common protocol for communication with "
"their host system and high-level support looks the same for them all. As "
"such in MicroPython they are implemented in a single class called "
":class:`machine.SDCard` ."
msgstr ""
"SD カードは、リムーバブルストレージメディアの最も一般的な小型フォームファクターの１つです。"
"SD カードにはさまざまなサイズと物理的なフォームファクターがあります。"
"MMC カードは SD カードと同様のリムバーブルストレージデバイスであり、eMMC デバイスは "
"電気的には MMC カードと同様のストレージデバイスですが、他のシステムに組み込むように"
"設計されています。３つの形式はすべて、ホストシステムとの通信に共通のプロトコルを使っていて、"
"高レベルのサポートはすべて同じです。このプロトコルの MicroPython でのサポートは、 "
":class:`machine.SDCard` という単一のクラスに実装しています。"

#: ../../library/machine.SDCard.rst:15
msgid ""
"Both SD and MMC interfaces support being accessed with a variety of bus "
"widths. When being accessed with a 1-bit wide interface they can be "
"accessed using the SPI protocol. Different MicroPython hardware platforms"
" support different widths and pin configurations but for most platforms "
"there is a standard configuration for any given hardware. In general "
"constructing an ``SDCard`` object with without passing any parameters will"
" initialise the interface to the default card slot for the current "
"hardware. The arguments listed below represent the common arguments that "
"might need to be set in order to use either a non-standard slot or a non-"
"standard pin assignment. The exact subset of arguments supported will vary"
" from platform to platform."
msgstr ""
"SD と MMC の双方のインターフェイスは、さまざまなバス幅でのアクセスをサポートしています。"
"1ビット幅のインターフェイスでアクセスする場合、SPI プロトコルを使用してアクセスできます。"
"MicroPython ハードウェアプラットフォームにより、さまざまな幅とピン構成を"
"サポートしていますが、ほとんどのプラットフォームでは、ハードウェアに適した標準構成が"
"あります。一般に、パラメータを渡さずに ``SDCard`` オブジェクトを構築すると、"
"使っているハードウェアのデフォルトのカードスロットのインターフェイスが初期化されます。"
"以下にリストされている引数は、非標準スロットまたは非標準のピン割り当てのいずれかを"
"使うのに設定が必要な共通の引数を表しています。サポートする引数の厳密なサブセットは、"
"プラットフォームごとに異なります。"

#: ../../library/machine.SDCard.rst:28
msgid ""
"This class provides access to SD or MMC storage cards using either a "
"dedicated SD/MMC interface hardware or through an SPI channel. The class "
"implements the block protocol defined by :class:`uos.AbstractBlockDev`. "
"This allows the mounting of an SD card to be as simple as::"
msgstr ""
"このクラスは、専用の SD/MMC インターフェイスハードウェアか、SPI チャネルを介しての、"
"SD または MMC ストレージカードへのアクセスを提供します。このクラスは "
":class:`uos.AbstractBlockDev` で定義されたブロックプロトコルを実装しています。"
"これにより、SD カードのマウントが次のように簡単になります。"

#: ../../library/machine.SDCard.rst:33
msgid "uos.mount(machine.SDCard(), \"/sd\")"
msgstr ""

#: ../../library/machine.SDCard.rst:35
msgid "The constructor takes the following parameters:"
msgstr "このコンストラクタは次のパラメーターを取ります。"

#: ../../library/machine.SDCard.rst:37
msgid ""
"*slot* selects which of the available interfaces to use. Leaving this "
"unset will select the default interface."
msgstr ""
"*slot* は、使用可能なインターフェースのどれを使用するかを選択します。"
"この指定を省略すると、デフォルトのインターフェースが選択されます。"

#: ../../library/machine.SDCard.rst:40
msgid "*width* selects the bus width for the SD/MMC interface."
msgstr "*width* は、SD/MMCインターフェイスのバス幅を選択します。"

#: ../../library/machine.SDCard.rst:42
msgid "*cd* can be used to specify a card-detect pin."
msgstr "*cd* でカード検出ピンを指定できます。"

#: ../../library/machine.SDCard.rst:44
msgid "*wp* can be used to specify a write-protect pin."
msgstr "*wp* で書き込み保護ピンを指定できます。"

#: ../../library/machine.SDCard.rst:46
msgid "*sck* can be used to specify an SPI clock pin."
msgstr "*sck* で SPI クロックピンを指定できます。"

#: ../../library/machine.SDCard.rst:48
msgid "*miso* can be used to specify an SPI miso pin."
msgstr "*miso* で SPI miso ピンを指定できます。"

#: ../../library/machine.SDCard.rst:50
msgid "*mosi* can be used to specify an SPI mosi pin."
msgstr "*miso* で SPI mosi ピンを指定できます。"

#: ../../library/machine.SDCard.rst:52
msgid "*cs* can be used to specify an SPI chip select pin."
msgstr "*cs* で SPI チップ選択ピンを指定できます。"

#: ../../library/machine.SDCard.rst:55
msgid "Implementation-specific details"
msgstr "ハードウェア固有の詳細"

#: ../../library/machine.SDCard.rst:57
msgid ""
"Different implementations of the ``SDCard`` class on different hardware "
"support varying subsets of the options above."
msgstr ""
"異なるハードウェア上の ``SDCard`` クラスの実装は、上記のオプションの"
"さまざまなサブセットをサポートします。"

#: ../../library/machine.SDCard.rst:61
msgid "PyBoard"
msgstr ""

#: ../../library/machine.SDCard.rst:63
msgid ""
"The standard PyBoard has just one slot. No arguments are necessary or "
"supported."
msgstr ""
"標準の PyBoard にはスロットが1つしかありません。引数は不要またはサポートされていません。"

#: ../../library/machine.SDCard.rst:66
msgid "ESP32"
msgstr ""

#: ../../library/machine.SDCard.rst:68
msgid ""
"The ESP32 provides two channels of SD/MMC hardware and also supports "
"access to SD Cards through either of the two SPI ports that are generally"
" available to the user. As a result the *slot* argument can take a value "
"between 0 and 3, inclusive. Slots 0 and 1 use the built-in SD/MMC "
"hardware while slots 2 and 3 use the SPI ports. Slot 0 supports 1, 4 or "
"8-bit wide access while slot 1 supports 1 or 4-bit access; the SPI slots "
"only support 1-bit access."
msgstr ""
"ESP32 は SD/MMC ハードウェアの2つのチャネルを提供し、ユーザーが通常利用できる2つの "
"SPI ポートのいずれかを介したSDカードへのアクセスもサポートします。結果として、 "
"*slot* 引数は 0 から 3 までの値を取ることができます。スロット 0 と 1 は組み込みの "
"SD/MMCハードウェアを使い、スロット 2 と 3 は SPI ポートを使います。スロット 0 は "
"1, 4, 8ビット幅のアクセスをサポートし、スロット1 は 1 または 4ビットアクセスを"
"サポートします。SPIスロットは1ビットアクセスのみをサポートします。"

#: ../../library/machine.SDCard.rst:76
msgid ""
"Slot 0 is used to communicate with on-board flash memory on most ESP32 "
"modules and so will be unavailable to the user."
msgstr ""
"スロット 0 は、ほとんどの ESP32 モジュールではオンボードのフラッシュメモリとの通信に"
"使っているため、ユーザーは使用できません。"

#: ../../library/machine.SDCard.rst:80
msgid ""
"Most ESP32 modules that provide an SD card slot using the dedicated "
"hardware only wire up 1 data pin, so the default value for *width* is 1."
msgstr ""
"専用ハードウェアを使って SD カードスロットを提供するほとんどの ESP32 モジュールは、"
"1データピンのみを配線しているため *width* のデフォルト値は1です。"

#: ../../library/machine.SDCard.rst:84
msgid ""
"The pins used by the dedicated SD/MMC hardware are fixed. The pins used "
"by the SPI hardware can be reassigned."
msgstr ""
"専用の SD/MMC ハードウェアで使われているピンは固定されています。SPI ハードウェアで"
"使うピンは再割り当てできます。"

#: ../../library/machine.SDCard.rst:87
msgid ""
"If any of the SPI signals are remapped then all of the SPI signals will "
"pass through a GPIO multiplexer unit which can limit the performance of "
"high frequency signals. Since the normal operating speed for SD cards is "
"40MHz this can cause problems on some cards."
msgstr ""
"SPI 信号のいずれかが再マッピングされると、すべての SPI 信号が GPIO マルチプレクサ"
"ユニットを通過するため、高周波信号のパフォーマンスが制限される可能性があります。"
"SDカードの通常の動作速度は 40MHz であるため、一部のカードで問題が発生する"
"場合があります。"

#: ../../library/machine.SDCard.rst:93
msgid "The default (and preferred) pin assignment are as follows:"
msgstr "デフォルト(および推奨)のピン割り当ては次のとおりです。"

#: ../../library/machine.SDCard.rst:96
msgid "Slot"
msgstr "スロット"

#: ../../library/machine.SDCard.rst:96 ../../library/pyb.CAN.rst:256
msgid "0"
msgstr ""

#: ../../library/machine.SDCard.rst:96 ../../library/pyb.CAN.rst:177
#: ../../library/pyb.CAN.rst:258
msgid "1"
msgstr ""

#: ../../library/machine.SDCard.rst:96 ../../library/machine.SDCard.rst:105
#: ../../library/pyb.CAN.rst:173 ../../library/pyb.CAN.rst:175
#: ../../library/pyb.CAN.rst:260
msgid "2"
msgstr ""

#: ../../library/machine.SDCard.rst:96
msgid "3"
msgstr ""

#: ../../library/machine.SDCard.rst:98
msgid "Signal"
msgstr ""

#: ../../library/machine.SDCard.rst:98
msgid "Pin"
msgstr "ピン"

#: ../../library/machine.SDCard.rst:100
msgid "sck"
msgstr ""

#: ../../library/machine.SDCard.rst:100
msgid "6"
msgstr ""

#: ../../library/machine.SDCard.rst:100
msgid "14"
msgstr ""

#: ../../library/machine.SDCard.rst:100 ../../library/machine.SDCard.rst:112
msgid "18"
msgstr ""

#: ../../library/machine.SDCard.rst:101
msgid "cmd"
msgstr ""

#: ../../library/machine.SDCard.rst:101
msgid "11"
msgstr ""

#: ../../library/machine.SDCard.rst:101 ../../library/machine.SDCard.rst:102
msgid "15"
msgstr ""

#: ../../library/machine.SDCard.rst:102
msgid "cs"
msgstr ""

#: ../../library/machine.SDCard.rst:102 ../../library/machine.SDCard.rst:111
msgid "5"
msgstr ""

#: ../../library/machine.SDCard.rst:103
msgid "miso"
msgstr ""

#: ../../library/machine.SDCard.rst:103
msgid "19"
msgstr ""

#: ../../library/machine.SDCard.rst:103 ../../library/machine.SDCard.rst:107
msgid "12"
msgstr ""

#: ../../library/machine.SDCard.rst:104
msgid "mosi"
msgstr ""

#: ../../library/machine.SDCard.rst:104
msgid "23"
msgstr ""

#: ../../library/machine.SDCard.rst:104 ../../library/machine.SDCard.rst:108
msgid "13"
msgstr ""

#: ../../library/machine.SDCard.rst:105
msgid "D0"
msgstr ""

#: ../../library/machine.SDCard.rst:105
msgid "7"
msgstr ""

#: ../../library/machine.SDCard.rst:106
msgid "D1"
msgstr ""

#: ../../library/machine.SDCard.rst:106
msgid "8"
msgstr ""

#: ../../library/machine.SDCard.rst:106 ../../library/pyb.CAN.rst:171
msgid "4"
msgstr ""

#: ../../library/machine.SDCard.rst:107
msgid "D2"
msgstr ""

#: ../../library/machine.SDCard.rst:107
msgid "9"
msgstr ""

#: ../../library/machine.SDCard.rst:108
msgid "D3"
msgstr ""

#: ../../library/machine.SDCard.rst:108
msgid "10"
msgstr ""

#: ../../library/machine.SDCard.rst:109
msgid "D4"
msgstr ""

#: ../../library/machine.SDCard.rst:109
msgid "16"
msgstr ""

#: ../../library/machine.SDCard.rst:110
msgid "D5"
msgstr ""

#: ../../library/machine.SDCard.rst:110
msgid "17"
msgstr ""

#: ../../library/machine.SDCard.rst:111
msgid "D6"
msgstr ""

#: ../../library/machine.SDCard.rst:112
msgid "D7"
msgstr ""

#: ../../library/machine.SDCard.rst:116
msgid "cc3200"
msgstr ""

#: ../../library/machine.SDCard.rst:118
msgid ""
"You can set the pins used for SPI access by passing a tuple as the *pins*"
" argument."
msgstr ""
"*pins* 引数にタプルを渡すことにより、SPI アクセスに使うピンを指定できます。"

#: ../../library/machine.SDCard.rst:121
msgid ""
"*Note:* The current cc3200 SD card implementation names the this class "
":class:`machine.SD` rather than :class:`machine.SDCard` ."
msgstr ""
"*注記:* 現在の cc3200 SDカードの実装では :class:`machine.SDCard` ではなく、"
":class:`machine.SD` のほうを使います。"

#: ../../../library/machine.SPI.rst:5
msgid "class SPI -- a Serial Peripheral Interface bus protocol (master side)"
msgstr "クラス SPI -- シリアルペリフェラルインタフェース バスプロトコル(マスタ側)"

#: ../../../library/machine.SPI.rst:7
msgid ""
"SPI is a synchronous serial protocol that is driven by a master. At the "
"physical level, a bus consists of 3 lines: SCK, MOSI, MISO. Multiple "
"devices can share the same bus. Each device should have a separate, 4th "
"signal, SS (Slave Select), to select a particular device on a bus with "
"which communication takes place. Management of an SS signal should happen"
" in user code (via machine.Pin class)."
msgstr ""
"SPI はマスタによって駆動される同期シリアルプロトコルです。物理レベルにおいて、バスは "
"SCK、MOSI、MISO 3本の線で構成されています。複数のデバイスが同じバスを共有できます。"
"各デバイスには、通信を行うバス上の特定のデバイスを選択するための個別の4番目の信号 SS "
"(Slave Select)が必要です。SSシグナルの管理はユーザーコードで(machine.Pin クラス"
"経由で)行う必要があります。"

#: ../../../library/machine.SPI.rst:19
msgid ""
"Construct an SPI object on the given bus, ``id``. Values of ``id`` depend"
" on a particular port and its hardware. Values 0, 1, etc. are commonly "
"used to select hardware SPI block #0, #1, etc. Value -1 can be used for "
"bitbanging (software) implementation of SPI (if supported by a port)."
msgstr ""
"与えたバス ``id`` で SPI オブジェクトを構築します。 ``id`` の値は特定のポートとその"
"ハードウェアに依存します。値 0, 1 などは一般的に、ハードウェア SPI ブロック #0, #1 "
"などを選択するために使われます。値 -1 は(ポートでサポートされている場合) SPI "
"のビットバンギング(ソフトウェア)実装を選択するのに使えます。"

#: ../../../library/machine.SPI.rst:24
msgid ""
"With no additional parameters, the SPI object is created but not "
"initialised (it has the settings from the last initialisation of the bus,"
" if any).  If extra arguments are given, the bus is initialised. See "
"``init`` for parameters of initialisation."
msgstr ""
"追加のパラメータを指定しないと、SPI オブジェクトは作成されますが初期化されません"
"(そのような場合、バスが過去に初期化されたことがあれば、その定が引き継がれます)。"
"追加のパラメータが与えられると、バスは初期化されます。追加のパラメータについては "
"``init`` を参照してください。"

#: ../../../library/machine.SPI.rst:34 ../../../library/pyb.SPI.rst:56
msgid "Initialise the SPI bus with the given parameters:"
msgstr "与えたパラメータで SPI バスを初期化します。"

#: ../../../library/machine.SPI.rst:36
msgid "``baudrate`` is the SCK clock rate."
msgstr "``baudrate`` は SCK のクロックレートです。"

#: ../../../library/machine.SPI.rst:37 ../../../library/pyb.SPI.rst:62
msgid "``polarity`` can be 0 or 1, and is the level the idle clock line sits at."
msgstr "``polarity`` は 0 か 1 であり、アイドリング状態のときのクロックのレベルを指定します。"

#: ../../../library/machine.SPI.rst:38 ../../../library/pyb.SPI.rst:63
msgid ""
"``phase`` can be 0 or 1 to sample data on the first or second clock edge "
"respectively."
msgstr ""
"``phase`` は 0 か 1 であり、それぞれ、１番目または２番目のクロックエッジでのデータ"
"読取りを指定します。"

#: ../../../library/machine.SPI.rst:40
msgid ""
"``bits`` is the width in bits of each transfer. Only 8 is guaranteed to "
"be supported by all hardware."
msgstr ""
"``bits`` は各転送のビット幅です。すべてのハードウェアでサポートされることが保証"
"されているのは 8 だけです。"

#: ../../../library/machine.SPI.rst:41 ../../../library/pyb.SPI.rst:66
msgid "``firstbit`` can be ``SPI.MSB`` or ``SPI.LSB``."
msgstr "``firstbit`` は SPI.MSB か SPI.LSB です。"

#: ../../../library/machine.SPI.rst:42
msgid ""
"``sck``, ``mosi``, ``miso`` are pins (machine.Pin) objects to use for bus"
" signals. For most hardware SPI blocks (as selected by ``id`` parameter "
"to the constructor), pins are fixed and cannot be changed. In some cases,"
" hardware blocks allow 2-3 alternative pin sets for a hardware SPI block."
" Arbitrary pin assignments are possible only for a bitbanging SPI driver "
"(``id`` = -1)."
msgstr ""
"``sck``, ``mosi``, ``miso`` はバス信号に使用するピン(machine.Pin)オブジェクトです。"
"ほとんどのハードウェア SPI ブロック(コンストラクタのパラメータ id で指定)では、"
"ピンが固定されていて変更できません。場合によっては、ハードウェアブロックが、"
"１つのハードウェアSPIブロックに対して２～３の代替ピンセットを許しています。"
"任意のピン割り当ては、ビットバンギング SPI ドライバ(``id`` = -1)に対してのみ可能です。"

#: ../../../library/machine.SPI.rst:47
msgid ""
"``pins`` - WiPy port doesn't ``sck``, ``mosi``, ``miso`` arguments, and "
"instead allows to specify them as a tuple of ``pins`` parameter."
msgstr ""
"``pins`` - WiPy ポートには ``sck``, ``mosi``, ``miso`` 引数がありません。"
"その代わり ``pins`` パラメータでタプルとしてそれらを指定できます。"

#: ../../../library/machine.SPI.rst:50
msgid ""
"In the case of hardware SPI the actual clock frequency may be lower than "
"the requested baudrate. This is dependant on the platform hardware. The "
"actual rate may be determined by printing the SPI object."
msgstr ""
"ハードウェア SPI の場合、実際のクロック周波数は要求されたボーレートより低いかも"
"しれません。これはプラットフォームのハードウェアに依存します。実際のレートは SPI "
"オブジェクトを ``print`` 関数で表示することにより判ります。"

#: ../../../library/machine.SPI.rst:56 ../../../library/pyb.SPI.rst:52
msgid "Turn off the SPI bus."
msgstr "SPI バスをオフにします。"

#: ../../../library/machine.SPI.rst:60
msgid ""
"Read a number of bytes specified by ``nbytes`` while continuously writing"
" the single byte given by ``write``. Returns a ``bytes`` object with the "
"data that was read."
msgstr ""
"``write`` で指定した１バイトを連続で書き込みながら、 ``nbytes`` で指定したバイト数"
"を読み込みます。読み込んだデータを持つ ``bytes`` オブジェクトを返します。"

#: ../../../library/machine.SPI.rst:66
msgid ""
"Read into the buffer specified by ``buf`` while continuously writing the "
"single byte given by ``write``. Returns ``None``."
msgstr ""
"``write`` で指定した１バイトを連続で書き込みながら、 ``buf`` に指定したバッファに"
"読み込みます。 ``None`` を返します。

#: ../../../library/machine.SPI.rst:70
msgid "Note: on WiPy this function returns the number of bytes read."
msgstr "注記: WiPy では読み込んだバイト数を返します。"

#: ../../../library/machine.SPI.rst:74
msgid "Write the bytes contained in ``buf``. Returns ``None``."
msgstr "``buf`` に含まれるバイト列を書き込みます。 ``None`` を返します。"

#: ../../../library/machine.SPI.rst:77 ../../../library/machine.SPI.rst:86
msgid "Note: on WiPy this function returns the number of bytes written."
msgstr "注記: WiPy では書き込んだバイト数を返します。"

#: ../../../library/machine.SPI.rst:81
msgid ""
"Write the bytes from ``write_buf`` while reading into ``read_buf``.  The "
"buffers can be the same or different, but both buffers must have the same"
" length. Returns ``None``."
msgstr ""
"``read_buf`` に読込みながら ``write_buf`` のバイト列を書き込みます。両バッファは"
"同じでも異なっていてもかまいませんが、同じ長さでなければなりません。 ``None`` "
"を返します。"

#: ../../../library/machine.SPI.rst:93
msgid "for initialising the SPI bus to master; this is only used for the WiPy"
msgstr "SPI バスをマスタに初期化するためのものです。これは WiPy のみで使います。"

#: ../../../library/machine.SPI.rst:97
msgid "set the first bit to be the most significant bit"
msgstr "最初のビットを最上位ビットに設定します"

#: ../../../library/machine.SPI.rst:101
msgid "set the first bit to be the least significant bit"
msgstr "最初のビットを最下位ビットに設定します"

#: ../../../library/machine.Signal.rst:5
msgid "class Signal -- control and sense external I/O devices"
msgstr "クラス Signal -- 外部 I/O デバイスの制御と検知"

#: ../../../library/machine.Signal.rst:7
msgid ""
"The Signal class is a simple extension of the `Pin` class. Unlike Pin, "
"which can be only in \"absolute\" 0 and 1 states, a Signal can be in "
"\"asserted\" (on) or \"deasserted\" (off) states, while being inverted "
"(active-low) or not. In other words, it adds logical inversion support to"
" Pin functionality. While this may seem a simple addition, it is exactly "
"what is needed to support wide array of simple digital devices in a way "
"portable across different boards, which is one of the major MicroPython "
"goals. Regardless of whether different users have an active-high or "
"active-low LED, a normally open or normally closed relay - you can "
"develop a single, nicely looking application which works with each of "
"them, and capture hardware configuration differences in few lines in the "
"config file of your app."
msgstr ""
"Signal クラスは `Pin` クラスを単純に拡張したものです。Pin の場合は 0 と 1 の"
"「絶対」の状態のみですが、Signal は反転(負論理: active-low)しているかどうかに"
"かかわらず、「アサート」(オン)または 「デアサート」(オフ)状態にできます。"
"つまり、Pin の機能に論理反転サポートを追加しています。これは単純な追加に思える"
"かもしれませんが、それはまさに MicroPython の主な目標の1つである、さまざまな"
"ボード間で移植性のある方法で幅広いシンプルなデジタルデバイスをサポートするために"
"必要なものです。正論理(active-high)または負論理(active-low)の LED のどちらか、"
"通常開( normally open)または通常閉(normally close)のリレーのどちらを使って"
"いるかに関係なく、それぞれに対応した単一の見栄えの良いアプリケーションを開発し、"
"ハードウェア構成の違いをアプリの設定ファイルのわずか数行で把握できます。"

#: ../../../library/machine.Signal.rst:21
msgid ""
"from machine import Pin, Signal\n"
"\n"
"# Suppose you have an active-high LED on pin 0\n"
"led1_pin = Pin(0, Pin.OUT)\n"
"# ... and active-low LED on pin 1\n"
"led2_pin = Pin(1, Pin.OUT)\n"
"\n"
"# Now to light up both of them using Pin class, you'll need to set\n"
"# them to different values\n"
"led1_pin.value(1)\n"
"led2_pin.value(0)\n"
"\n"
"# Signal class allows to abstract away active-high/active-low\n"
"# difference\n"
"led1 = Signal(led1_pin, invert=False)\n"
"led2 = Signal(led2_pin, invert=True)\n"
"\n"
"# Now lighting up them looks the same\n"
"led1.value(1)\n"
"led2.value(1)\n"
"\n"
"# Even better:\n"
"led1.on()\n"
"led2.on()"
msgstr ""
"from machine import Pin, Signal\n"
"\n"
"# # ピン0に正論理のLEDがあるものとする\n"
"led1_pin = Pin(0, Pin.OUT)\n"
"# ピン1に負論理のLEDがあるものとする\n"
"led2_pin = Pin(1, Pin.OUT)\n"
"\n"
"# Pin クラスを使って両方とも点灯するには、\n"
"# それらを異なる値に設定する必要がある。\n"
"led1_pin.value(1)\n"
"led2_pin.value(0)\n"
"\n"
"# Signal クラスは正論理/負論理の違いを抽象化できる\n"
"led1 = Signal(led1_pin, invert=False)\n"
"led2 = Signal(led2_pin, invert=True)\n"
"\n"
"# それらを点灯するのは同じようにできる\n"
"led1.value(1)\n"
"led2.value(1)\n"
"\n"
"# さらに見栄えを良くできる:\n"
"led1.on()\n"
"led2.on()"

#: ../../../library/machine.Signal.rst:46
msgid "Following is the guide when Signal vs Pin should be used:"
msgstr "Signal と Pin のどちらを使うかの指針は次のとおりです:"

#: ../../../library/machine.Signal.rst:48
msgid ""
"Use Signal: If you want to control a simple on/off (including software "
"PWM!) devices like LEDs, multi-segment indicators, relays, buzzers, or "
"read simple binary sensors, like normally open or normally closed "
"buttons, pulled high or low, Reed switches, moisture/flame detectors, "
"etc. etc. Summing up, if you have a real physical device/sensor requiring"
" GPIO access, you likely should use a Signal."
msgstr ""
"Signal の利用: LED、マルチセグメントディスプレイ、リレー、ブザーなどの"
"単純なオン/オフ(ソフトウェアPWMを含む)でデバイス、または通常開または通常閉のボタン、"
"リードスイッチ、湿気/火気検知器などなどの単純なバイナリセンサーを制御したい場合。"
"要約すると、GPIO アクセスを必要とする実際の物理デバイス/センサーがある場合は、"
"おそらく Signal を使うべきでしょう。"

#: ../../../library/machine.Signal.rst:55
msgid ""
"Use Pin: If you implement a higher-level protocol or bus to communicate "
"with more complex devices."
msgstr ""
"Pin の利用: より複雑な機器と通信するために、より高いレベルのプロトコルやバスを"
"実装する場合。"

#: ../../../library/machine.Signal.rst:58
msgid ""
"The split between Pin and Signal come from the usecases above and the "
"architecture of MicroPython: Pin offers the lowest overhead, which may be"
" important when bit-banging protocols. But Signal adds additional "
"flexibility on top of Pin, at the cost of minor overhead (much smaller "
"than if you implemented active-high vs active-low device differences in "
"Python manually!). Also, Pin is a low-level object which needs to be "
"implemented for each support board, while Signal is a high-level object "
"which comes for free once Pin is implemented."
msgstr ""
"Pin と Signal を分けたのは、上記のユースケースと MicroPython のアーキテクチャーが"
"理由となっています。Pin は、オーバーヘッドが最も低いため、ビットバンギングプロトコル"
"では重要になります。Signal は Pin の上に追加の柔軟性を追加しますが、わずかな"
"オーバーヘッドがあります(Python で正論理と負論理のデバイスの違いを手動で実装した場合"
"よりははるかに小さいですが)。また、Pin はサポートボードごとに実装する必要がある"
"低レベルのオブジェクトですが、Signal は Pin を実装してしまえば使える高レベルの"
"オブジェクトです。"

#: ../../../library/machine.Signal.rst:67
msgid ""
"If in doubt, give the Signal a try! Once again, it is offered to save "
"developers from the need to handle unexciting differences like active-low"
" vs active-high signals, and allow other users to share and enjoy your "
"application, instead of being frustrated by the fact that it doesn't work"
" for them simply because their LEDs or relays are wired in a slightly "
"different way."
msgstr ""
"疑問がある場合は Signal を試してみてください！　繰り返しになりますが、負論理や"
"正論理の信号のようなような望まない違いを処理する必要性から開発者を保護し、他の"
"ユーザーがアプリケーションを共有して楽しむことができるようにします。LED やリレーが"
"わずかに異なる方法で配線されていて動かなかったというようなイライラが起きなくなる"
"でしょう。"

#: ../../../library/machine.Signal.rst:80
msgid "Create a Signal object. There're two ways to create it:"
msgstr "Signalオブジェクトを作成します。作成する方法は2つあります。"

#: ../../../library/machine.Signal.rst:82
msgid ""
"By wrapping existing Pin object - universal method which works for any "
"board."
msgstr ""
"既存の Pin オブジェクトをラップして構築します - どのボードにも使えるユニバーサルな"
"方法です。"

#: ../../../library/machine.Signal.rst:84
msgid ""
"By passing required Pin parameters directly to Signal constructor, "
"skipping the need to create intermediate Pin object. Available on many, "
"but not all boards."
msgstr ""
"必要な Pin パラメータを Signal コンストラクタに直接渡して構築します。"
"中間の Pin オブジェクトを作成する必要がありません。多くのボードで使えますが、"
"すべてのボードで使えるわけではありません。"

#: ../../../library/machine.Signal.rst:90
msgid "``pin_obj`` is existing Pin object."
msgstr "``pin_obj`` は既存の Pin オブジェクトです。"

#: ../../../library/machine.Signal.rst:92
msgid ""
"``pin_arguments`` are the same arguments as can be passed to Pin "
"constructor."
msgstr ""
"``pin_arguments`` は Pin のコンストラクタに渡すものと同じ引数です。"

#: ../../../library/machine.Signal.rst:94
msgid "``invert`` - if True, the signal will be inverted (active low)."
msgstr "``invert`` - True の場合、信号が反転されます(負論理)。"

#: ../../../library/machine.Signal.rst:101
msgid ""
"This method allows to set and get the value of the signal, depending on "
"whether the argument ``x`` is supplied or not."
msgstr ""
"このメソッドは引数 ``x`` を与えているかどうかにより、シグナルの値を設定または取得"
"します。"

#: ../../../library/machine.Signal.rst:104
msgid ""
"If the argument is omitted then this method gets the signal level, 1 "
"meaning signal is asserted (active) and 0 - signal inactive."
msgstr ""
"引数を省略した場合、この信号レベルを取得します。1 は信号がアサート状態(アクティブ)"
"であり、0 は信号が非アクティブであることを意味します。"

#: ../../../library/machine.Signal.rst:107
msgid ""
"If the argument is supplied then this method sets the signal level. The "
"argument ``x`` can be anything that converts to a boolean. If it converts"
" to ``True``, the signal is active, otherwise it is inactive."
msgstr ""
"引数を与えた場合、このメソッドは信号レベルを設定します。引数 ``x`` はブール型に変換"
"できるものなら何でも構いません。変換後の値が ``True`` であれば、信号はアクティブとなり、"
" ``False`` であれば非アクティブとなります。"

#: ../../../library/machine.Signal.rst:111
msgid ""
"Correspondence between signal being active and actual logic level on the "
"underlying pin depends on whether signal is inverted (active-low) or not."
" For non-inverted signal, active status corresponds to logical 1, "
"inactive - to logical 0. For inverted/active-low signal, active status "
"corresponds to logical 0, while inactive - to logical 1."
msgstr ""
"信号がアクティブであることとその下にあるピンの実際のロジックレベルとの対応は、信号が"
"反転している(負論理)かどうかによって異なります。反転していない信号の場合、アクティブ"
"状態は論理 1、非アクティブ状態は論理 0 に対応します。反転/負論理の信号の場合、"
"アクティブ状態は論理 0、非アクティブ状態は論理 1 に対応します。"

#: ../../../library/machine.Signal.rst:119
msgid "Activate signal."
msgstr "信号を有効にします。"

#: ../../../library/machine.Signal.rst:123
msgid "Deactivate signal."
msgstr "信号を無効にします。"

#: ../../../library/machine.Timer.rst:5
msgid "class Timer -- control hardware timers"
msgstr "クラス Timer -- ハードウェアタイマーの制御"

#: ../../../library/machine.Timer.rst:7
#: ../../../library/machine.TimerWiPy.rst:14
msgid ""
"Hardware timers deal with timing of periods and events. Timers are "
"perhaps the most flexible and heterogeneous kind of hardware in MCUs and "
"SoCs, differently greatly from a model to a model. MicroPython's Timer "
"class defines a baseline operation of executing a callback with a given "
"period (or once after some delay), and allow specific boards to define "
"more non-standard behavior (which thus won't be portable to other "
"boards)."
msgstr ""
"ハードウェアタイマーは、一定周期とイベントのタイミングで処理します。タイマーは"
"おそらく MCU や SoC で最も柔軟で様々な種類のあるハードウェアであり、モデルごとに"
"大きく異なります。MicroPython の Timer クラスは、指定した周期で(または少し"
"経過後に1回だけ)コールバックを実行するベースライン操作を定義します。特定のボードが"
"より標準的でない動作を定義できます(したがって他のボードへの移植性はありません)。"

#: ../../../library/machine.Timer.rst:14
#: ../../../library/machine.TimerWiPy.rst:21
msgid ""
"See discussion of :ref:`important constraints <machine_callbacks>` on "
"Timer callbacks."
msgstr ""
"Timer のコールバックに関する :ref:`重要な制約 <machine_callbacks>` "
"の議論を見てください。"

#: ../../../library/machine.Timer.rst:19
#: ../../../library/machine.TimerWiPy.rst:26
msgid ""
"Memory can't be allocated inside irq handlers (an interrupt) and so "
"exceptions raised within a handler don't give much information.  See "
":func:`micropython.alloc_emergency_exception_buf` for how to get around "
"this limitation."
msgstr ""
"irq ハンドラ(割り込み)内でメモリを割り当てることはできず、そのためにハンドラ内で"
"発生した例外には多くの情報を持ちません。この制限を回避する方法については "
":func:`micropython.alloc_emergency_exception_buf` を参照してください。"

#: ../../../library/machine.Timer.rst:24
msgid ""
"If you are using a WiPy board please refer to :ref:`machine.TimerWiPy "
"<machine.TimerWiPy>` instead of this class."
msgstr ""
"WiPy ボードを使用している場合、このクラスの代わりに "
":ref:`machine.TimerWiPy <machine.TimerWiPy>` を参照してください。"

#: ../../../library/machine.Timer.rst:32
#: ../../../library/machine.TimerWiPy.rst:36
msgid ""
"Construct a new timer object of the given id. Id of -1 constructs a "
"virtual timer (if supported by a board)."
msgstr ""
"指定した id の新しいタイマーオブジェクトを構築します。id が -1 の場合は、"
"(ボードでサポートしていれば)仮想タイマーを構築します。"

#: ../../../library/machine.Timer.rst:40
#: ../../../library/machine.TimerWiPy.rst:44
msgid "Initialise the timer. Example::"
msgstr "タイマーを初期化します。たとえば次のように使います::"

#: ../../../library/machine.Timer.rst:42
msgid ""
"tim.init(period=100)                         # periodic with 100ms period"
"\n"
"tim.init(mode=Timer.ONE_SHOT, period=1000)   # one shot firing after "
"1000ms"
msgstr ""
"tim.init(period=100)                         # 100ms 周期で定期的に\n"
"tim.init(mode=Timer.ONE_SHOT, period=1000)   # 1000ms 後に一度だけ"

#: ../../../library/machine.Timer.rst:45
#: ../../../library/machine.TimerWiPy.rst:49 ../../../library/pyb.Timer.rst:73
#: ../../../library/pyb.Timer.rst:138
msgid "Keyword arguments:"
msgstr "キーワード引数:"

#: ../../../library/machine.Timer.rst:47
#: ../../../library/machine.TimerWiPy.rst:51 ../../../library/pyb.Pin.rst:105
#: ../../../library/pyb.Timer.rst:90 ../../../library/pyb.Timer.rst:140
msgid "``mode`` can be one of:"
msgstr "``mode`` は次のいずれかになります。"

#: ../../../library/machine.Timer.rst:49
msgid ""
"``Timer.ONE_SHOT`` - The timer runs once until the configured period of "
"the channel expires."
msgstr ""
"``Timer.ONE_SHOT`` - タイマーは、設定したチャネルの周期が経過した後に1回だけ"
"実行します。"

#: ../../../library/machine.Timer.rst:51
msgid ""
"``Timer.PERIODIC`` - The timer runs periodically at the configured "
"frequency of the channel."
msgstr ""
"``Timer.PERIODIC`` - タイマーは、チャネルの設定した周期で定期的に実行します。"

#: ../../../library/machine.Timer.rst:56
#: ../../../library/machine.TimerWiPy.rst:65
msgid ""
"Deinitialises the timer. Stops the timer, and disables the timer "
"peripheral."
msgstr ""
"タイマーを初期化解除します。タイマーを停止し、タイマーのペリフェラルを無効にします。"

#: ../../../library/machine.Timer.rst:64
#: ../../../library/machine.TimerWiPy.rst:159
msgid "Timer operating mode."
msgstr "タイマー操作モード。"

#: ../../../library/machine.TimerWiPy.rst:5
msgid "class TimerWiPy -- control hardware timers"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:9
msgid ""
"This class is a non-standard Timer implementation for the WiPy. It is "
"available simply as ``machine.Timer`` on the WiPy but is named in the "
"documentation below as ``machine.TimerWiPy`` to distinguish it from the "
"more general :ref:`machine.Timer <machine.Timer>` class."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:46
msgid ""
"tim.init(Timer.PERIODIC)             # periodic 16-bit timer\n"
"tim.init(Timer.ONE_SHOT, width=32)   # one shot 32-bit timer"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:53
msgid ""
"``TimerWiPy.ONE_SHOT`` - The timer runs once until the configured period "
"of the channel expires."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:55
msgid ""
"``TimerWiPy.PERIODIC`` - The timer runs periodically at the configured "
"frequency of the channel."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:57
msgid "``TimerWiPy.PWM``      - Output a PWM signal on a pin."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:59
msgid ""
"``width`` must be either 16 or 32 (bits). For really low frequencies < "
"5Hz (or large periods), 32-bit timers should be used. 32-bit mode is only"
" available for ``ONE_SHOT`` AND ``PERIODIC`` modes."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:69
msgid ""
"If only a channel identifier passed, then a previously initialized "
"channel object is returned (or ``None`` if there is no previous channel)."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:72 ../../../library/pyb.Timer.rst:132
msgid "Otherwise, a TimerChannel object is initialized and returned."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:74
msgid ""
"The operating mode is is the one configured to the Timer object that was "
"used to create the channel."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:77
msgid ""
"``channel`` if the width of the timer is 16-bit, then must be either "
"``TIMER.A``, ``TIMER.B``. If the width is 32-bit then it **must be** "
"``TIMER.A | TIMER.B``."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:80
msgid "Keyword only arguments:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:82
msgid "``freq`` sets the frequency in Hz."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:83
msgid "``period`` sets the period in microseconds."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:87
msgid "Either ``freq`` or ``period`` must be given, never both."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:89
msgid ""
"``polarity`` this is applicable for ``PWM``, and defines the polarity of "
"the duty cycle"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:90
msgid ""
"``duty_cycle`` only applicable to ``PWM``. It's a percentage "
"(0.00-100.00). Since the WiPy doesn't support floating point numbers the "
"duty cycle must be specified in the range 0-10000, where 10000 would "
"represent 100.00, 5050 represents 50.50, and so on."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:96
msgid ""
"When the channel is in PWM mode, the corresponding pin is assigned "
"automatically, therefore there's no need to assign the alternate function"
" of the pin via the ``Pin`` class. The pins which support PWM "
"functionality are the following:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:100
msgid "``GP24`` on Timer 0 channel A."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:101
msgid "``GP25`` on Timer 1 channel A."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:102
msgid "``GP9``  on Timer 2 channel B."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:103
msgid "``GP10`` on Timer 3 channel A."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:104
msgid "``GP11`` on Timer 3 channel B."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:107
#: ../../../library/pyb.Timer.rst:222
msgid "class TimerChannel --- setup a channel for a timer"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:109
#: ../../../library/pyb.Timer.rst:224
msgid "Timer channels are used to generate/capture a signal using a timer."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:111
#: ../../../library/pyb.Timer.rst:226
msgid "TimerChannel objects are created using the Timer.channel() method."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:118
msgid ""
"The behavior of this callback is heavily dependent on the operating mode "
"of the timer channel:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:121
msgid ""
"If mode is ``TimerWiPy.PERIODIC`` the callback is executed periodically "
"with the configured frequency or period."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:123
msgid ""
"If mode is ``TimerWiPy.ONE_SHOT`` the callback is executed once when the "
"configured timer expires."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:125
msgid ""
"If mode is ``TimerWiPy.PWM`` the callback is executed when reaching the "
"duty cycle value."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:128
msgid "The accepted params are:"
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:130
msgid ""
"``priority`` level of the interrupt. Can take values in the range 1-7. "
"Higher values represent higher priorities."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:132
msgid ""
"``handler`` is an optional function to be called when the interrupt is "
"triggered."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:133
msgid ""
"``trigger`` must be ``TimerWiPy.TIMEOUT`` when the operating mode is "
"either ``TimerWiPy.PERIODIC`` or ``TimerWiPy.ONE_SHOT``. In the case that"
" mode is ``TimerWiPy.PWM`` then trigger must be equal to "
"``TimerWiPy.MATCH``."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:137
msgid "Returns a callback object."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:141
msgid "Get or set the timer channel frequency (in Hz)."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:145
msgid "Get or set the timer channel period (in microseconds)."
msgstr ""

#: ../../../library/machine.TimerWiPy.rst:149
msgid ""
"Get or set the duty cycle of the PWM signal. It's a percentage "
"(0.00-100.00). Since the WiPy doesn't support floating point numbers the "
"duty cycle must be specified in the range 0-10000, where 10000 would "
"represent 100.00, 5050 represents 50.50, and so on."
msgstr ""

#: ../../../library/machine.UART.rst:5 ../../../library/pyb.UART.rst:5
msgid "class UART -- duplex serial communication bus"
msgstr "クラス UART -- 二重シリアル通信バス"

#: ../../../library/machine.UART.rst:7 ../../../library/pyb.UART.rst:7
msgid ""
"UART implements the standard UART/USART duplex serial communications "
"protocol.  At the physical level it consists of 2 lines: RX and TX.  The "
"unit of communication is a character (not to be confused with a string "
"character) which can be 8 or 9 bits wide."
msgstr ""
"UART は標準の UART/USART 二重シリアル通信プロトコルを実装しています。"
"物理レベルでは RX と TX の２線で構成されています。通信の単位は 8 または 9 ビット幅"
"の文字です(string 型の文字と混同しないでください)。"

#: ../../../library/machine.UART.rst:12 ../../../library/pyb.UART.rst:12
msgid "UART objects can be created and initialised using::"
msgstr "UART オブジェクトは以下をように作成、初期化できます::"

#: ../../../library/machine.UART.rst:14
msgid ""
"from machine import UART\n"
"\n"
"uart = UART(1, 9600)                         # init with given baudrate\n"
"uart.init(9600, bits=8, parity=None, stop=1) # init with given parameters"
msgstr ""
"from machine import UART\n"
"\n"
"uart = UART(1, 9600)                         # 与えたボーレートで初期化\n"
"uart.init(9600, bits=8, parity=None, stop=1) # 与えたパラメータで初期化"

#: ../../../library/machine.UART.rst:19
msgid "Supported parameters differ on a board:"
msgstr "サポートされているパラメータはボードによって異なります:"

#: ../../../library/machine.UART.rst:21
msgid ""
"Pyboard: Bits can be 7, 8 or 9. Stop can be 1 or 2. With *parity=None*, "
"only 8 and 9 bits are supported.  With parity enabled, only 7 and 8 bits "
"are supported."
msgstr ""
"pyboard: bits は 7, 8, 9 にすることができます。stop は 1 または 2 にすることが"
"できます。 *parity=None* の場合、bitsは 8 と 9 のみがサポートされます。parity "
"を有効にすると 7 と 8 のビット幅のみがサポートされます。"

#: ../../../library/machine.UART.rst:25
msgid "WiPy/CC3200: Bits can be 5, 6, 7, 8. Stop can be 1 or 2."
msgstr "WiPy/CC3200: ビット幅は 5, 6, 7, 8 です。stop は 1 または 2 です。"

#: ../../../library/machine.UART.rst:27 ../../../library/pyb.UART.rst:24
msgid ""
"A UART object acts like a `stream` object and reading and writing is done"
" using the standard stream methods::"
msgstr ""
"UART オブジェクトはストリームオブジェクトのように機能し、読み書きは標準のストリーム"
"メソッドを使って行われます。"

#: ../../../library/machine.UART.rst:30 ../../../library/pyb.UART.rst:27
msgid ""
"uart.read(10)       # read 10 characters, returns a bytes object\n"
"uart.read()         # read all available characters\n"
"uart.readline()     # read a line\n"
"uart.readinto(buf)  # read and store into the given buffer\n"
"uart.write('abc')   # write the 3 characters"
msgstr ""
"uart.read(10)       # 10文字を読み込んで、バイト列オブジェクトを返す\n"
"uart.read()         # 可能な限り文字を読み込む\n"
"uart.readline()     # 1行を読み込む\n"
"uart.readinto(buf)  # 読み込んで、与えたバッファに格納\n"
"uart.write('abc')   # 3文字を書き込む"

#: ../../../library/machine.UART.rst:41
msgid "Construct a UART object of the given id."
msgstr "指定した id の UART オブジェクトを構築します。"

#: ../../../library/machine.UART.rst:48 ../../../library/pyb.UART.rst:74
msgid "Initialise the UART bus with the given parameters:"
msgstr "与えたパラメータで UART バスを初期化します。"

#: ../../../library/machine.UART.rst:50
msgid "*baudrate* is the clock rate."
msgstr "*baudrate* はクロックレートです。"

#: ../../../library/machine.UART.rst:51
msgid "*bits* is the number of bits per character, 7, 8 or 9."
msgstr "*bits* は１文字あたりのビット数で、7, 8, 9 を指定できます。"

#: ../../../library/machine.UART.rst:52
msgid "*parity* is the parity, ``None``, 0 (even) or 1 (odd)."
msgstr "*parity* はパリティビットで、 ``None``, 0 (偶数)または 1 (奇数)を指定できます。"

#: ../../../library/machine.UART.rst:53
msgid "*stop* is the number of stop bits, 1 or 2."
msgstr "*stop* はストップビットの数で、1 または 2 を指定できます。"

#: ../../../library/machine.UART.rst:55
msgid "Additional keyword-only parameters that may be supported by a port are:"
msgstr "ポートでサポートされている可能性がある追加のキーワード指定のみのパラメータは次のとおりです:"

#: ../../../library/machine.UART.rst:57
msgid "*tx* specifies the TX pin to use."
msgstr "*tx* は TX に使うピンを指定します。"

#: ../../../library/machine.UART.rst:58
msgid "*rx* specifies the RX pin to use."
msgstr "*rx* は RX に使うピンを指定します。"

#: ../../../library/machine.UART.rst:59
msgid "*txbuf* specifies the length in characters of the TX buffer."
msgstr "*txbuf* は TX バッファの文字長を指定します。"

#: ../../../library/machine.UART.rst:60
msgid "*rxbuf* specifies the length in characters of the RX buffer."
msgstr "*rxbuf* は RX バッファの文字長を指定します。"

#: ../../../library/machine.UART.rst:61
msgid "*timeout* specifies the time to wait for the first character (in ms)."
msgstr "*timeout* は最初の文字を待つ時間を指定します(ミリ秒単位)。"

#: ../../../library/machine.UART.rst:62
msgid "*timeout_char* specifies the time to wait between characters (in ms)."
msgstr "*timeout_char* は文字間の待機時間を指定します(ミリ秒単位)。"

#: ../../../library/machine.UART.rst:63
msgid "*invert* specifies which lines to invert."
msgstr "*invert* は極性反転を指定します。"

#: ../../../library/machine.UART.rst:63
msgid "On the WiPy only the following keyword-only parameter is supported:"
msgstr "WiPy では、次のキーワード指定のみのパラメータがサポートされています。"

#: ../../../library/machine.UART.rst:67
msgid ""
"*pins* is a 4 or 2 item list indicating the TX, RX, RTS and CTS pins (in "
"that order). Any of the pins can be None if one wants the UART to operate"
" with limited functionality. If the RTS pin is given the the RX pin must "
"be given as well. The same applies to CTS. When no pins are given, then "
"the default set of TX and RX pins is taken, and hardware flow control "
"will be disabled. If *pins* is ``None``, no pin assignment will be made."
msgstr ""
"pins は TX, RX, RTS, CTS ピンを(この順序で)示す4または2項目のリストです。限られた"
"機能で UART を動作させたい場合は、どのピンも None にできます。RTS ピンが与えられて"
"いる場合は RX ピンも与えられなければなりません。同じことが CTS にも当てはまります。"
"ピンが指定されていない場合は、デフォルトの TX ピンと RX ピンが使われ、ハードウェア"
"フロー制御は無効になります。pins が None の場合、ピンの割り当ては行われません。"

#: ../../../library/machine.UART.rst:75 ../../../library/pyb.UART.rst:102
msgid "Turn off the UART bus."
msgstr "UART バスをオフにします。"

#: ../../../library/machine.UART.rst:79
msgid ""
"Returns an integer counting the number of characters that can be read "
"without blocking.  It will return 0 if there are no characters available "
"and a positive number if there are characters.  The method may return 1 "
"even if there is more than one character available for reading."
msgstr ""
"ブロックなしで読み込める文字数を整数で返します。読み込める文字がない場合は 0 を返し、"
"文字がある場合は正の数を返します。読み込める文字が複数ある場合でも、このメソッドは "
"1 を返すことがあります。"

#: ../../../library/machine.UART.rst:84
msgid "For more sophisticated querying of available characters use select.poll::"
msgstr "読み込める文字のより洗練された問い合わせには select.poll を使ってください::"

#: ../../../library/machine.UART.rst:86
msgid ""
"poll = select.poll()\n"
"poll.register(uart, select.POLLIN)\n"
"poll.poll(timeout)"
msgstr ""

#: ../../../library/machine.UART.rst:92
msgid ""
"Read characters.  If ``nbytes`` is specified then read at most that many "
"bytes, otherwise read as much data as possible. It may return sooner "
"if a timeout is reached. The timeout is configurable in the constructor."
msgstr ""
"文字を読み込みます。 ``nbytes`` を指定した場合は、最大でそのバイト数を読み込みます。 "
"``nbytes`` を指定しなかった場合は、できるだけ多くのデータを読み込みます。"
"タイムアウトにより、より早く戻ることがあります。"
"タイムアウトはコンストラクタで設定できます。"

#: ../../../library/machine.UART.rst:96 ../../../library/pyb.UART.rst:116
msgid ""
"Return value: a bytes object containing the bytes read in.  Returns "
"``None`` on timeout."
msgstr ""
"戻り値: 読み込んだバイト列を含む bytes オブジェクト。タイムアウト時は "
"``None`` を返します。"

#: ../../../library/machine.UART.rst:101
msgid ""
"Read bytes into the ``buf``.  If ``nbytes`` is specified then read at "
"most that many bytes.  Otherwise, read at most ``len(buf)`` bytes. "
"It may return sooner if a timeout is reached. The timeout is configurable "
"in the constructor."
msgstr ""
"``buf`` にバイトを読み込みます。 ``nbytes`` が指定されている場合は、最大でその"
"バイト数を読み取ります。nbytes を指定しなかった場合は、最大で ``len(buf)`` "
"バイト数を読み込みます。"
"タイムアウトにより、より早く戻ることがあります。"
"タイムアウトはコンストラクタで設定できます。"

#: ../../../library/machine.UART.rst:105 ../../../library/pyb.UART.rst:130
msgid ""
"Return value: number of bytes read and stored into ``buf`` or ``None`` on"
" timeout."
msgstr ""
"戻り値: 読み込んで ``buf`` に格納したバイト数。タイムアウト時は ``None`` を返します。"

#: ../../../library/machine.UART.rst:110
msgid ""
"Read a line, ending in a newline character. It may return sooner if a "
"timeout is reached. The timeout is configurable in the constructor."
msgstr ""
"改行文字で終わる行を読みます。"
"タイムアウトにより、より早く戻ることがあります。"
"タイムアウトはコンストラクタで設定できます。"

#: ../../../library/machine.UART.rst:113
msgid "Return value: the line read or ``None`` on timeout."
msgstr "戻り値: 読み込まれた行。タイムアウト時は ``None`` を返します。"

#: ../../../library/machine.UART.rst:117
msgid "Write the buffer of bytes to the bus."
msgstr "バッファのバイト列をバスに書き込みます。"

#: ../../../library/machine.UART.rst:119
msgid "Return value: number of bytes written or ``None`` on timeout."
msgstr "戻り値: 書き込まれたバイト数。タイムアウト時は ``None`` を返します。"

#: ../../../library/machine.UART.rst:123
msgid ""
"Send a break condition on the bus. This drives the bus low for a duration"
" longer than required for a normal transmission of a character."
msgstr ""
"バスにブレーク信号を送信します。これは通常の文字伝送に必要とされるよりも長い期間に"
"わたってバスをローで駆動します。"

#: ../../../library/machine.UART.rst:128
msgid "Create a callback to be triggered when data is received on the UART."
msgstr "データが UART で受信されたときにトリガーされるコールバックを作成します。"

#: ../../../library/machine.UART.rst:130
msgid "*trigger* can only be ``UART.RX_ANY``"
msgstr "*trigger* には ``UART.RX_ANY`` だけを指定できます。"

#: ../../../library/machine.UART.rst:131
msgid ""
"*priority* level of the interrupt. Can take values in the range 1-7. "
"Higher values represent higher priorities."
msgstr ""
"*priority* は割り込みの優先順位です。1-7 の範囲の値を取ることができます。"
"値が大きいほど優先順位が高くなります。"

#: ../../../library/machine.UART.rst:133
msgid "*handler* an optional function to be called when new characters arrive."
msgstr "*hanfler* は新しい文字が到着したときに呼び出されるオプションの関数です。"

#: ../../../library/machine.UART.rst:134
msgid "*wake* can only be ``machine.IDLE``."
msgstr "*wake* には ``machine.IDLE`` だけを指定できます。"

#: ../../../library/machine.UART.rst:138
msgid ""
"The handler will be called whenever any of the following two conditions "
"are met:"
msgstr ""
"このハンドラは、次の2つの条件のいずれかが満たされると必ず呼び出されます:"

#: ../../../library/machine.UART.rst:140
msgid "8 new characters have been received."
msgstr "新規に８文字を受信した。"

#: ../../../library/machine.UART.rst:141
msgid ""
"At least 1 new character is waiting in the Rx buffer and the Rx line has "
"been silent for the duration of 1 complete frame."
msgstr ""
"少なくとも新規の１文字が Rx バッファーで待機していて、Rx の線が1つの完全なフレームの間、"
"何も受信していない。"

#: ../../../library/machine.UART.rst:144
msgid ""
"This means that when the handler function is called there will be between"
" 1 to 8 characters waiting."
msgstr ""
"つまり、ハンドラ関数が呼び出されると、1 から 8 文字の間の待機があります。"

#: ../../../library/machine.UART.rst:147
msgid "Returns an irq object."
msgstr "irq オブジェクトを返します。"

#: ../../../library/machine.UART.rst:156
msgid "IRQ trigger sources"
msgstr "IRQ トリガーソース"

#: ../../../library/machine.WDT.rst:5
msgid "class WDT -- watchdog timer"
msgstr "クラス WDT -- ウォッチドッグタイマー"

#: ../../../library/machine.WDT.rst:7
msgid ""
"The WDT is used to restart the system when the application crashes and "
"ends up into a non recoverable state. Once started it cannot be stopped "
"or reconfigured in any way. After enabling, the application must \"feed\""
" the watchdog periodically to prevent it from expiring and resetting the "
"system."
msgstr ""
"アプリケーションがクラッシュして回復不可能な状態になった場合、WDT を使ってシステムを"
"再起動します。一度起動すると、停止したり再設定したりはできません。有効にした後、"
"アプリケーションはウォッチドッグが期限切れになりシステムがリセットされるのを防ぐために、"
"定期的にウォッチドッグに「フィード」する必要があります。"

#: ../../../library/machine.WDT.rst:14
msgid ""
"from machine import WDT\n"
"wdt = WDT(timeout=2000)  # enable it with a timeout of 2s\n"
"wdt.feed()"
msgstr ""
"from machine import WDT\n"
"wdt = WDT(timeout=2000)  # タイムアウト 2s で有効化\n"
"wdt.feed()"

#: ../../../library/machine.WDT.rst:18
msgid "Availability of this class: pyboard, WiPy."
msgstr "このクラスの可用性: pyboard, WiPy"

#: ../../../library/machine.WDT.rst:25
msgid ""
"Create a WDT object and start it. The timeout must be given in seconds "
"and the minimum value that is accepted is 1 second. Once it is running "
"the timeout cannot be changed and the WDT cannot be stopped either."
msgstr ""
"WDT オブジェクトを作成して起動します。タイムアウトは秒単位で指定する必要があり、"
"受け入れられる最小値は1秒です。一度実行するとタイムアウトを変更することはできず、"
"WDT の停止もできません。"

#: ../../../library/machine.WDT.rst:34
msgid ""
"Feed the WDT to prevent it from resetting the system. The application "
"should place this call in a sensible place ensuring that the WDT is only "
"fed after verifying that everything is functioning correctly."
msgstr ""
"システムがリセットされないようにWDTをフィードします。アプリケーションは、この"
"呼出しを適切な場所に配置して、すべてが正しく機能していることを確認した後に WDT "
"にのみフィードが供給されるようにする必要があります。"

#: ../../../library/math.rst:2
msgid ":mod:`math` -- mathematical functions"
msgstr ":mod:`math` -- 数学関数"

#: ../../../library/math.rst:7
msgid "|see_cpython_module| :mod:`python:math`."
msgstr ""

#: ../../../library/math.rst:9
msgid ""
"The ``math`` module provides some basic mathematical functions for "
"working with floating-point numbers."
msgstr ""
"``math`` モジュールは浮動小数点数を扱うための基本的な数学関数を提供します。"

#: ../../../library/math.rst:12
msgid "*Note:* On the pyboard, floating-point numbers have 32-bit precision."
msgstr "*注記:* pyboard では、浮動小数点は 32 ビット精度(単精度)です。"

#: ../../../library/math.rst:14
msgid ""
"Availability: not available on WiPy. Floating point support required for "
"this module."
msgstr ""
"可用性: WiPy では利用できません。このモジュールには浮動小数点数の"
"サポートが必要です。"

#: ../../../library/math.rst:22
msgid "Return the inverse cosine of ``x``."
msgstr "``x`` の逆余弦を返します。"

#: ../../../library/math.rst:26
msgid "Return the inverse hyperbolic cosine of ``x``."
msgstr "``x`` の双曲線逆余弦を返します。"

#: ../../../library/math.rst:30
msgid "Return the inverse sine of ``x``."
msgstr "``x`` の逆正弦を返します。"

#: ../../../library/math.rst:34
msgid "Return the inverse hyperbolic sine of ``x``."
msgstr "``x`` の双曲線逆正弦を返します。"

#: ../../../library/math.rst:38
msgid "Return the inverse tangent of ``x``."
msgstr "``x`` の逆正接を返します。"

#: ../../../library/math.rst:42
msgid "Return the principal value of the inverse tangent of ``y/x``."
msgstr "``y/x`` の逆正接の主値を返します。"

#: ../../../library/math.rst:46
msgid "Return the inverse hyperbolic tangent of ``x``."
msgstr "``x`` の双曲線逆正接を返します。"

#: ../../../library/math.rst:50
msgid "Return an integer, being ``x`` rounded towards positive infinity."
msgstr "``x`` の正の無限大方法に丸めた整数値を返します。"

#: ../../../library/math.rst:54
msgid "Return ``x`` with the sign of ``y``."
msgstr "``x`` を ``y`` の符号で返します。"

#: ../../../library/math.rst:58
msgid "Return the cosine of ``x``."
msgstr "``x`` の余弦を返します。"

#: ../../../library/math.rst:62
msgid "Return the hyperbolic cosine of ``x``."
msgstr "``x`` の双曲線余弦を返します。"

#: ../../../library/math.rst:66
msgid "Return radians ``x`` converted to degrees."
msgstr "ラジアン ``x`` を度に変換して返します。"

#: ../../../library/math.rst:70
msgid "Return the error function of ``x``."
msgstr "``x`` の誤差関数を返します。"

#: ../../../library/math.rst:74
msgid "Return the complementary error function of ``x``."
msgstr "``x`` の相補誤差関数を返します。"

#: ../../../library/math.rst:78
msgid "Return the exponential of ``x``."
msgstr "``x`` の指数を返します。"

#: ../../../library/math.rst:82
msgid "Return ``exp(x) - 1``."
msgstr "``exp(x) - 1`` を返します。"

#: ../../../library/math.rst:86
msgid "Return the absolute value of ``x``."
msgstr "``x`` の絶対値を返します。"

#: ../../../library/math.rst:90
msgid "Return an integer, being ``x`` rounded towards negative infinity."
msgstr "``x`` の負の無限大方向に丸めた整数を返します。"

#: ../../../library/math.rst:94
msgid "Return the remainder of ``x/y``."
msgstr "``x/y`` の剰余を返します。"

#: ../../../library/math.rst:98
msgid ""
"Decomposes a floating-point number into its mantissa and exponent. The "
"returned value is the tuple ``(m, e)`` such that ``x == m * 2**e`` "
"exactly.  If ``x == 0`` then the function returns ``(0.0, 0)``, otherwise"
" the relation ``0.5 <= abs(m) < 1`` holds."
msgstr ""
"浮動小数点数を仮数部と指数部に分解します。返される値は ``x == m * 2**e`` "
"となる ``(m, e)`` のタプルです。 ``x == 0`` の場合、関数は ``(0.0, 0)`` "
"を返します。さもなければ ``0.5 <= abs(m) < 1`` の関係が成り立ちます。"

#: ../../../library/math.rst:105
msgid "Return the gamma function of ``x``."
msgstr "``x`` のガンマ関数を返します。"

#: ../../../library/math.rst:109
msgid "Return ``True`` if ``x`` is finite."
msgstr "``x`` が有限数であれば ``True`` を返します。"

#: ../../../library/math.rst:113
msgid "Return ``True`` if ``x`` is infinite."
msgstr "``x`` が無限数であれば ``True`` を返します。"

#: ../../../library/math.rst:117
msgid "Return ``True`` if ``x`` is not-a-number"
msgstr "``x`` が非数(NaN: Not-a-Number)であれば ``True`` を返します。"

#: ../../../library/math.rst:121
msgid "Return ``x * (2**exp)``."
msgstr "``x * (2**exp)`` を返します。"

#: ../../../library/math.rst:125
msgid "Return the natural logarithm of the gamma function of ``x``."
msgstr "``x`` のガンマ関数の自然対数を返します。"

#: ../../../library/math.rst:129
msgid "Return the natural logarithm of ``x``."
msgstr "``x`` の自然対数を返します。"

#: ../../../library/math.rst:133
msgid "Return the base-10 logarithm of ``x``."
msgstr "``x`` の常用対数を返します。"

#: ../../../library/math.rst:137
msgid "Return the base-2 logarithm of ``x``."
msgstr "``x`` の２進対数を返します。"

#: ../../../library/math.rst:141
msgid ""
"Return a tuple of two floats, being the fractional and integral parts of "
"``x``.  Both return values have the same sign as ``x``."
msgstr ""
"``x`` の小数部分と整数部分の２つの浮動小数点数のタプルを返します。"
"両方の戻り値は ``x`` と同じ符号を持ちます。"

#: ../../../library/math.rst:146
msgid "Returns ``x`` to the power of ``y``."
msgstr "``x`` の ``y`` 乗を返します。"

#: ../../../library/math.rst:150
msgid "Return degrees ``x`` converted to radians."
msgstr "度 ``x`` をラジアンに変換して返します。"

#: ../../../library/math.rst:154
msgid "Return the sine of ``x``."
msgstr "``x`` の正弦を返します。"

#: ../../../library/math.rst:158
msgid "Return the hyperbolic sine of ``x``."
msgstr "``x`` の双曲線正弦を返します。"

#: ../../../library/math.rst:162
msgid "Return the square root of ``x``."
msgstr "``x`` の平方根を返します。"

#: ../../../library/math.rst:166
msgid "Return the tangent of ``x``."
msgstr "``x`` の正接を返します。"

#: ../../../library/math.rst:170
msgid "Return the hyperbolic tangent of ``x``."
msgstr "``x`` の双曲線正接を返します。"

#: ../../../library/math.rst:174
msgid "Return an integer, being ``x`` rounded towards 0."
msgstr "``x`` の 0 方向に丸めた整数を返します。"

#: ../../../library/micropython.rst:2
msgid ":mod:`micropython` -- access and control MicroPython internals"
msgstr ":mod:`micropython` -- MicroPython 内部のアクセスと制御"

#: ../../../library/micropython.rst:12
msgid ""
"Used to declare that the expression is a constant so that the compile can"
" optimise it.  The use of this function should be as follows::"
msgstr ""
"コンパイルが最適化できるように、式が定数であることを宣言するために使います。"
"この関数の使い方は次のとおりです::"

#: ../../../library/micropython.rst:15
msgid ""
"from micropython import const\n"
"\n"
"CONST_X = const(123)\n"
"CONST_Y = const(2 * CONST_X + 1)"
msgstr ""

#: ../../../library/micropython.rst:20
msgid ""
"Constants declared this way are still accessible as global variables from"
" outside the module they are declared in.  On the other hand, if a "
"constant begins with an underscore then it is hidden, it is not available"
" as a global variable, and does not take up any memory during execution."
msgstr ""
"このように宣言された定数でも、宣言されているモジュールの外部からグローバル変数として"
"アクセス可能です。一方、定数名がアンダースコアで始まっていれば不可視となり、グローバル"
"変数として利用でくなくなり、実行中のメモリを消費しません。"

#: ../../../library/micropython.rst:25
msgid ""
"This `const` function is recognised directly by the MicroPython parser "
"and is provided as part of the :mod:`micropython` module mainly so that "
"scripts can be written which run under both CPython and MicroPython, by "
"following the above pattern."
msgstr ""
"この `const` 関数は MicroPython パーサによって直接認識されます。上記のパターンに"
"したがって CPython と MicroPython の両方で動作するスクリプトを書けるよう、 "
":mod:`micropython` モジュールの一部として提供しています。"

#: ../../../library/micropython.rst:32
msgid ""
"If *level* is given then this function sets the optimisation level for "
"subsequent compilation of scripts, and returns ``None``.  Otherwise it "
"returns the current optimisation level."
msgstr ""
"*level* を指定した場合、この関数はスクリプトの後続のコンパイルの最適化レベルを設定"
"して、 ``None`` を返します。指定しない場合は、現在の最適化レベルを返します。"

#: ../../../library/micropython.rst:36
msgid "The optimisation level controls the following compilation features:"
msgstr "最適化レベルは、次のコンパイル特性を制御します。"

#: ../../../library/micropython.rst:38
msgid ""
"Assertions: at level 0 assertion statements are enabled and compiled into"
" the bytecode; at levels 1 and higher assertions are not compiled."
msgstr ""
"アサーション: レベル 0 では、アサーションステートメントが有効になり、バイトコードに"
"コンパイルされます。レベル 1 以上ではアサーションがコンパイルされません。"

#: ../../../library/micropython.rst:40
msgid ""
"Built-in ``__debug__`` variable: at level 0 this variable expands to "
"``True``; at levels 1 and higher it expands to ``False``."
msgstr ""
"ビルトイン ``__debug__`` 変数: レベル 0 でこの変数が ``True`` に展開されます。"
"レベル 1 以上では ``False`` で展開されます。"

#: ../../../library/micropython.rst:42
msgid ""
"Source-code line numbers: at levels 0, 1 and 2 source-code line number "
"are stored along with the bytecode so that exceptions can report the line"
" number they occurred at; at levels 3 and higher line numbers are not "
"stored."
msgstr ""
"ソースコード行番号: レベル 0, 1, 2 では、ソースコードの行番号がバイトコードとともに"
"格納され、例外が発生した行番号を例外として報告することができます。レベル 3 以上では"
"行番号が格納されません。"

#: ../../../library/micropython.rst:46
msgid "The default optimisation level is usually level 0."
msgstr "デフォルトの最適化レベルは通常レベル 0 です。"

#: ../../../library/micropython.rst:50
msgid ""
"Allocate *size* bytes of RAM for the emergency exception buffer (a good "
"size is around 100 bytes).  The buffer is used to create exceptions in "
"cases when normal RAM allocation would fail (eg within an interrupt "
"handler) and therefore give useful traceback information in these "
"situations."
msgstr ""
"緊急例外バッファ用に *size* バイトの RAM を割り当てます(適当なサイズは約 100 "
"バイトです)。このバッファは(たとえば、割り込みハンドラ内などで)通常の RAM の"
"割り当てが失敗した場合に例外を作成するために使用されます。したがって、そのような"
"状況でも有用なトレースバック情報を提供します。"

#: ../../../library/micropython.rst:55
msgid ""
"A good way to use this function is to put it at the start of your main "
"script (eg ``boot.py`` or ``main.py``) and then the emergency exception "
"buffer will be active for all the code following it."
msgstr ""
"この関数を使う良い方法は、メインスクリプト(たとえば ``boot.py`` や ``main.py``)"
"の先頭に置くことです。そのようにしておけば、それに続くすべてのコードに対して緊急例外"
"バッファが有効になります。"

#: ../../../library/micropython.rst:61
msgid ""
"Print information about currently used memory.  If the *verbose* argument"
" is given then extra information is printed."
msgstr ""
"現在使っているメモリに関する情報を表示します。 *verbose* を指定すると冗長モードとなり、"
"詳しい情報を表示します。"

#: ../../../library/micropython.rst:64
msgid ""
"The information that is printed is implementation dependent, but "
"currently includes the amount of stack and heap used.  In verbose mode it"
" prints out the entire heap indicating which blocks are used and which "
"are free."
msgstr ""
"表示する情報は実装に依存しますが、現在使っているスタックとヒープのサイズは含みます。"
"冗長モードではヒープ全体を出力し、どのブロックが使用され、どのブロックが空いて"
"いるかを示します。"

#: ../../../library/micropython.rst:70
msgid ""
"Print information about currently interned strings.  If the *verbose* "
"argument is given then extra information is printed."
msgstr ""
"現在のところのインターンド文字列(内部に蓄えられている文字列)に関する情報を表示します。 "
"*verbose* を指定すると冗長モードとなり、詳しい情報を表示します。"

#: ../../../library/micropython.rst:73
msgid ""
"The information that is printed is implementation dependent, but "
"currently includes the number of interned strings and the amount of RAM "
"they use.  In verbose mode it prints out the names of all RAM-interned "
"strings."
msgstr ""
"表示する情報は実装に依存しますが、現在のインターンド文字列の数とそれが使っている "
"RAM のサイズは含みます。冗長モードでは RAM 上のインターンド文字列すべての名前を"
"表示します。"

#: ../../../library/micropython.rst:79
msgid ""
"Return an integer representing the current amount of stack that is being "
"used.  The absolute value of this is not particularly useful, rather it "
"should be used to compute differences in stack usage at different points."
msgstr ""
"現在使われているスタックのサイズを表す整数を返します。この値そのものは特に有用では"
"なく、異なる時点でのスタック使用量の違いを計算するために使用されるべきです。"

#: ../../../library/micropython.rst:86
msgid ""
"Lock or unlock the heap.  When locked no memory allocation can occur and "
"a `MemoryError` will be raised if any heap allocation is attempted."
msgstr ""
"ヒープをロックまたはロック解除します。ロックされているとメモリ割り当ては発生せず、"
"ヒープを割り当てようとした場合は `MemoryError` が発生します。"

#: ../../../library/micropython.rst:89
msgid ""
"These functions can be nested, ie `heap_lock()` can be called multiple "
"times in a row and the lock-depth will increase, and then `heap_unlock()`"
" must be called the same number of times to make the heap available "
"again."
msgstr ""
"これらの関数はネストすることができます。つまり `heap_lock()` は連続して複数回呼び"
"出すことができ、ロックの深さが増します。その後、ヒープを再度使用可能にするためには "
"`heap_unlock()` を同じ回数呼び出す必要があります。"

#: ../../../library/micropython.rst:93
msgid ""
"If the REPL becomes active with the heap locked then it will be "
"forcefully unlocked."
msgstr ""
"ヒープがロックされた状態で REPL が有効になると、強制的にロックが解除されます。"

#: ../../../library/micropython.rst:98
msgid ""
"Set the character that will raise a `KeyboardInterrupt` exception.  By "
"default this is set to 3 during script execution, corresponding to "
"Ctrl-C. Passing -1 to this function will disable capture of Ctrl-C, and "
"passing 3 will restore it."
msgstr ""
"`KeyboardInterrupt` 例外を発生させる文字を設定します。デフォルトで、スクリプト"
"実行中は 3 に設定されていて、これは Ctrl-C に該当します。この関数に -1 を渡すと"
"Ctrl-C のキャプチャが無効になり、3 を渡すと元に戻ります。"

#: ../../../library/micropython.rst:103
msgid ""
"This function can be used to prevent the capturing of Ctrl-C on the "
"incoming stream of characters that is usually used for the REPL, in case "
"that stream is used for other purposes."
msgstr ""
"この関数は、通常は REPL で使っている文字の入力ストリームを他の目的で使う場合、"
"そのストリームで Ctrl-C がキャプチャーされるのを防ぐために使えます。"

#: ../../../library/micropython.rst:109
msgid ""
"Schedule the function *func* to be executed \"very soon\".  The function "
"is passed the value *arg* as its single argument.  \"Very soon\" means "
"that the MicroPython runtime will do its best to execute the function at "
"the earliest possible time, given that it is also trying to be efficient,"
" and that the following conditions hold:"
msgstr ""
"関数 *func* が「非常にすぐに」実行されるようにスケジュールします。この関数には、"
"単一の引数として値 *arg* が渡されます。「非常にすぐに」とは、MicroPython ランタイムが"
"できるだけ早くに関数を実行すること、効率的にもしようとしていること、および次の条件が"
"満たされるよう最善を尽くすことを意味します。"

#: ../../../library/micropython.rst:115
msgid "A scheduled function will never preempt another scheduled function."
msgstr "スケジュールされた関数が他のスケジュールされた機能を横取りすることはありません。"

#: ../../../library/micropython.rst:116
msgid ""
"Scheduled functions are always executed \"between opcodes\" which means "
"that all fundamental Python operations (such as appending to a list) are "
"guaranteed to be atomic."
msgstr ""
"スケジュールされた関数は常に「オペコード間」で実行されます。つまり、すべての基本的な "
"Python 操作(リストへの追加など)はアトミックであることが保証されています。"

#: ../../../library/micropython.rst:119
msgid ""
"A given port may define \"critical regions\" within which scheduled "
"functions will never be executed.  Functions may be scheduled within a "
"critical region but they will not be executed until that region is "
"exited.  An example of a critical region is a preempting interrupt "
"handler (an IRQ)."
msgstr ""
"使用するポートは、その中でスケジュールされた関数が決して実行されないであろう"
"「クリティカル範囲」を定義するかもしれません。関数はクリティカル範囲内で"
"スケジュールされますが、その範囲が終了するまで実行されません。クリティカル"
"範囲の例としては、割り込み割り込みハンドラ(IRQ)があります。"

#: ../../../library/micropython.rst:125
msgid ""
"A use for this function is to schedule a callback from a preempting IRQ. "
"Such an IRQ puts restrictions on the code that runs in the IRQ (for "
"example the heap may be locked) and scheduling a function to call later "
"will lift those restrictions."
msgstr ""
"この関数の用途は、プリエントしている IRQ からのコールバックをスケジュールすることです。"
"そのような IRQ は IRQ で実行されるコードに制限を課し(例えばヒープはロックされるかも"
"しれません)、後で呼び出すために関数をスケジュールすることはそれらの制限を取り除きます。"

#: ../../../library/micropython.rst:130
msgid ""
"Note: If `schedule()` is called from a preempting IRQ, when memory "
"allocation is not allowed and the callback to be passed to `schedule()` "
"is a bound method, passing this directly will fail. This is because "
"creating a reference to a bound method causes memory allocation. A "
"solution is to create a reference to the method in the class constructor "
"and to pass that reference to `schedule()`. This is discussed in detail "
"here :ref:`reference documentation <isr_rules>` under \"Creation of "
"Python objects\"."
msgstr ""
"注記: `schedule()` がプリエントしている IRQ から呼び出された場合、メモリ割り当てが"
"許可されておらず、 `schedule()` に渡されるコールバックがバウンドメソッドであるときに、"
"これを直接渡すことは失敗します。これは、バウンドメソッドへの参照を作成するとメモリが"
"割り当てられるためです。解決策は、クラスコンストラクターでメソッドへの参照を作成し、"
"その参照を `schedule()` に渡すことです。これについては "
"「Pythonオブジェクトの作成」の :ref:`参考資料 <isr_rules>` を参照してください 。"

#: ../../../library/micropython.rst:139
msgid ""
"There is a finite stack to hold the scheduled functions and `schedule()` "
"will raise a `RuntimeError` if the stack is full."
msgstr ""
"スケジュールされた関数を保持するための有限のスタックがあり、スタックがいっぱいになると "
"`schedule()` は `RuntimeError` を起こします。"

#: ../../../library/network.rst:3
msgid ":mod:`network` --- network configuration"
msgstr ":mod:`network` --- ネットワーク設定"

#: ../../../library/network.rst:8
msgid ""
"This module provides network drivers and routing configuration. To use "
"this module, a MicroPython variant/build with network capabilities must "
"be installed. Network drivers for specific hardware are available within "
"this module and are used to configure hardware network interface(s). "
"Network services provided by configured interfaces are then available for"
" use via the :mod:`usocket` module."
msgstr ""
"このモジュールはネットワークドライバとルーティングの設定を提供します。このモジュールを"
"使うには、ネットワーク機能を備えるようビルドした MicroPython をインストールする必要が"
"あります。特定のハードウェア用のネットワークドライバは、このモジュール内で利用可能であり、"
"ハードウェアネットワークインタフェースを設定するために使われます。設定したインタフェース"
"によって提供されたネットワークサービスは :mod:`usocket` モジュールを介して利用可能に"
"なります。"

#: ../../../library/network.rst:17
msgid ""
"# connect/ show IP config a specific network interface\n"
"# see below for examples of specific drivers\n"
"import network\n"
"import utime\n"
"nic = network.Driver(...)\n"
"if not nic.isconnected():\n"
"    nic.connect()\n"
"    print(\"Waiting for connection...\")\n"
"    while not nic.isconnected():\n"
"        utime.sleep(1)\n"
"print(nic.ifconfig())\n"
"\n"
"# now use usocket as usual\n"
"import usocket as socket\n"
"addr = socket.getaddrinfo('micropython.org', 80)[0][-1]\n"
"s = socket.socket()\n"
"s.connect(addr)\n"
"s.send(b'GET / HTTP/1.1\\r\\nHost: micropython.org\\r\\n\\r\\n')\n"
"data = s.recv(1000)\n"
"s.close()"
msgstr ""
"# 特定のネットワークインタフェースの接続と IP 設定の表示\n"
"# 特定のドライバの例は以降を参照\n"
"import network\n"
"import utime\n"
"nic = network.Driver(...)\n"
"if not nic.isconnected():\n"
"    nic.connect()\n"
"    print(\"Waiting for connection...\")\n"
"    while not nic.isconnected():\n"
"        utime.sleep(1)\n"
"print(nic.ifconfig())\n"
"\n"
"# これで通常どおり usocket を使えるようになる\n"
"import usocket as socket\n"
"addr = socket.getaddrinfo('micropython.org', 80)[0][-1]\n"
"s = socket.socket()\n"
"s.connect(addr)\n"
"s.send(b'GET / HTTP/1.1\\r\\nHost: micropython.org\\r\\n\\r\\n')\n"
"data = s.recv(1000)\n"
"s.close()"

#: ../../../library/network.rst:39
msgid "Common network adapter interface"
msgstr "共通のネットワークアダプターインタフェース"

#: ../../../library/network.rst:41
msgid ""
"This section describes an (implied) abstract base class for all network "
"interface classes implemented by `MicroPython ports <MicroPython port>` "
"for different hardware. This means that MicroPython does not actually "
"provide ``AbstractNIC`` class, but any actual NIC class, as described in "
"the following sections, implements methods as described here."
msgstr ""
"この章では、さまざまなハードウェアの `MicroPython ポート <MicroPython port>` "
"で実装されているすべてのネットワークインタフェースクラスの(暗黙の)抽象基底クラスに"
"ついて説明します。つまり、MicroPython は実際には ``AbstractNIC`` クラスを提供"
"しませんが、以降の章で説明するように、実際の NIC クラスはすべて、ここで説明する"
"メソッドを実装します。"

#: ../../../library/network.rst:49
msgid ""
"Instantiate a network interface object. Parameters are network interface "
"dependent. If there are more than one interface of the same type, the "
"first parameter should be `id`."
msgstr ""
"ネットワークインタフェースオブジェクトをインスタンス化します。パラメータはネットワーク"
"インタフェースに依存します。同じタイプのインタフェースが複数ある場合は、最初のパラメータを "
"id にします。"

#: ../../../library/network.rst:55
msgid ""
"Activate (\"up\") or deactivate (\"down\") the network interface, if a "
"boolean argument is passed. Otherwise, query current state if no argument"
" is provided. Most other methods require an active interface (behavior of"
" calling them on inactive interface is undefined)."
msgstr ""
"ブール型の引数が渡された場合、ネットワークインタフェースを有効化(\"up\")または"
"無効化(\"down\")します。引数が与えられていなければ現在の状態を問い合わせます。"
"他のほとんどのメソッドは有効化したインターフェースを必要とします(無効化した"
"インターフェースでそれらを呼び出す動作は未定義です)。"

#: ../../../library/network.rst:63
msgid ""
"Connect the interface to a network. This method is optional, and "
"available only for interfaces which are not \"always connected\". If no "
"parameters are given, connect to the default (or the only) service. If a "
"single parameter is given, it is the primary identifier of a service to "
"connect to. It may be accompanied by a key (password) required to access "
"said service. There can be further arbitrary keyword-only parameters, "
"depending on the networking medium type and/or particular device. "
"Parameters can be used to: a) specify alternative service identifier "
"types; b) provide additional connection parameters. For various medium "
"types, there are different sets of predefined/recommended parameters, "
"among them:"
msgstr ""
"インターフェイスをネットワークに接続します。このメソッドはオプションであり、"
"「常に接続されている」とは限らないインタフェースに対してのみ利用可能です。"
"パラメータが指定されていない場合は、デフォルトの(または唯一の)サービスに接続します。"
"単一のパラメータが与えられた場合、それは接続するサービスのプライマリ識別子です。"
"これはサービスにアクセスするために必要な鍵(パスワード)を伴うことがあります。"
"ネットワーク媒体の種類や特定の装置に応じて、さらに任意のキーワードのみのパラメータが"
"あり得ます。パラメータは、次の目的で使用できます: a) 代替サービス識別タイプを"
"指定; b) 追加の接続パラメータを提供。さまざまな媒体タイプのそれぞれに、定義済み/推奨"
"パラメータのセットがあります:"

#: ../../../library/network.rst:75
msgid "WiFi: *bssid* keyword to connect to a specific BSSID (MAC address)"
msgstr "WiFi: *bssid* - 特定の BSSID (MAC アドレス)に接続するためのキーワード"

#: ../../../library/network.rst:79
msgid "Disconnect from network."
msgstr "ネットワークから切断します。"

#: ../../../library/network.rst:83
msgid "Returns ``True`` if connected to network, otherwise returns ``False``."
msgstr "ネットワークに接続されていれば  ``True`` を返し、そうでなければ ``False`` を返します。"

#: ../../../library/network.rst:87
msgid ""
"Scan for the available network services/connections. Returns a list of "
"tuples with discovered service parameters. For various network media, "
"there are different variants of predefined/ recommended tuple formats, "
"among them:"
msgstr ""
"利用可能なネットワークサービス/接続をスキャンします。戻り値は、検出されたサービスパラメータを"
"持つタプルのリストです。さまざまなネットワーク媒体に対して、定義済み/推奨のタプル形式には"
"さまざまな種類があります:"

#: ../../../library/network.rst:92
msgid ""
"WiFi: (ssid, bssid, channel, RSSI, authmode, hidden). There may be "
"further fields, specific to a particular device."
msgstr ""
"WiFi: (ssid, bssid, channel, RSSI, authmode, hidden)。特定のデバイスに"
"固有のさらなる項目もあり得ます。"

#: ../../../library/network.rst:95
msgid ""
"The function may accept additional keyword arguments to filter scan "
"results (e.g. scan for a particular service, on a particular channel, for"
" services of a particular set, etc.), and to affect scan duration and "
"other parameters. Where possible, parameter names should match those in "
"connect()."
msgstr ""
"この関数は、追加のキーワード引数を受け取ることができ、スキャン結果をフィルタリングしたり"
"(たとえば、特定のサービスのスキャン、特定のチャンネルのスキャン、特定のセットのサービスの"
"スキャンなど)、スキャン期間やその他のパラメータに影響を与えたりできます。可能であれば、"
"パラメータ名は connect() のものと一致させるべきです。"

#: ../../../library/network.rst:103
msgid ""
"Query dynamic status information of the interface.  When called with no "
"argument the return value describes the network link status.  Otherwise "
"*param* should be a string naming the particular status parameter to "
"retrieve."
msgstr ""
"インターフェースの動的な状況情報を照会します。引数なしで呼び出された場合、戻り値は"
"ネットワークリンクステータスを表します。そうでなければ *param* は取得する特定の"
"ステータスパラメータを命名する文字列であるべきです。"

#: ../../../library/network.rst:108
msgid ""
"The return types and values are dependent on the network "
"medium/technology.  Some of the parameters that may be supported are:"
msgstr ""
"戻り値の型と値は、ネットワークの媒体/テクノロジによって異なります。サポートされている"
"可能性のあるパラメータは次のとおりです。"

#: ../../../library/network.rst:111
msgid "WiFi STA: use ``'rssi'`` to retrieve the RSSI of the AP signal"
msgstr "WiFi STA: AP 信号の RSSI を取得するには ``'rssi'`` 使います"

#: ../../../library/network.rst:112
msgid ""
"WiFi AP: use ``'stations'`` to retrieve a list of all the STAs connected "
"to the AP.  The list contains tuples of the form (MAC, RSSI)."
msgstr ""
"WiFi AP: AP に接続されているすべてのSTAのリストを取得するには ``'stations'`` "
"を使います。このリストには (MAC, RSSI) の形式のタプルが含まれています。"

#: ../../../library/network.WLAN.rst:96 ../../../library/network.rst:118
msgid ""
"Get/set IP-level network interface parameters: IP address, subnet mask, "
"gateway and DNS server. When called with no arguments, this method "
"returns a 4-tuple with the above information. To set the above values, "
"pass a 4-tuple with the required information.  For example::"
msgstr ""
"IP レベルのネットワークインターフェースパラメータ(IPアドレス、サブネットマスク、"
"ゲートウェイ、DNSサーバー)を取得/設定します。引数なしで呼び出されると、このメソッドは"
"上記の情報を含む4タプルを返します。上記の値を設定するには、必要な情報を含む4項目の"
"タプルを渡します。例えば次のように設定します:"

#: ../../../library/network.WIZNET5K.rst:67
#: ../../../library/network.WLAN.rst:101 ../../../library/network.rst:123
msgid "nic.ifconfig(('192.168.0.4', '255.255.255.0', '192.168.0.1', '8.8.8.8'))"
msgstr ""

#: ../../../library/network.rst:128
msgid ""
"Get or set general network interface parameters. These methods allow to "
"work with additional parameters beyond standard IP configuration (as "
"dealt with by `ifconfig()`). These include network-specific and hardware-"
"specific parameters. For setting parameters, the keyword argument syntax "
"should be used, and multiple parameters can be set at once. For querying,"
" a parameter name should be quoted as a string, and only one parameter "
"can be queried at a time::"
msgstr ""
"一般的なネットワークインターフェースパラメータを取得または設定します。これらのメソッドは、"
"(`ifconfig()` で扱われるように)標準の IP 設定以外の追加のパラメータを扱うことを"
"可能にします 。これらには、ネットワーク固有およびハードウェア固有のパラメータが含まれています。"
"パラメータを設定するには、キーワード引数の構文を使用する必要があり、複数のパラメータを"
"一度に設定できます。問合せを実行する場合、パラメータ名は文字列として引用符で囲みます。"
"一度に問合せできるパラメータは1つだけです。"

#: ../../../library/network.WLAN.rst:113 ../../../library/network.rst:136
msgid ""
"# Set WiFi access point name (formally known as ESSID) and WiFi channel\n"
"ap.config(essid='My AP', channel=11)\n"
"# Query params one by one\n"
"print(ap.config('essid'))\n"
"print(ap.config('channel'))"
msgstr ""
"# WiFi アクセスポイント名(正式には ESSID と呼ばれている)と WiFi チャンネルを設定\n"
"ap.config(essid='My AP', channel=11)\n"
"# 一つずつパラメータを問合せ\n"
"print(ap.config('essid'))\n"
"print(ap.config('channel'))"

#: ../../../library/network.rst:143
msgid "Specific network class implementations"
msgstr "特定のネットワーククラスの処理系"

#: ../../../library/network.rst:145
msgid ""
"The following concrete classes implement the AbstractNIC interface and "
"provide a way to control networking interfaces of various kinds."
msgstr ""
"以下の具象クラスは AbstractNIC インターフェースを実装し、さまざまな種類の"
"ネットワークインターフェースを制御する方法を提供します。"

#: ../../../library/network.rst:157
msgid "Network functions"
msgstr "ネットワーク関数"

#: ../../../library/network.rst:159
msgid "The following are functions available in the network module."
msgstr "以下はネットワークモジュールで利用可能な関数です。"

#: ../../../library/network.rst:163
msgid "Get or set the PHY mode."
msgstr "PHY モードを取得または設定します。"

#: ../../../library/network.rst:165
msgid ""
"If the *mode* parameter is provided, sets the mode to its value. If the "
"function is called without parameters, returns the current mode."
msgstr ""
"*mode* パラメータを与えた場合、その値にモードを設定します。関数がパラメータなしで"
"呼び出された場合は、現在のモードを返します。"

#: ../../../library/network.rst:171
msgid "The possible modes are defined as constants:"
msgstr "指定可能なモードは定数として定義されています:"

#: ../../../library/network.rst:169
msgid "``MODE_11B`` -- IEEE 802.11b,"
msgstr ""

#: ../../../library/network.rst:170
msgid "``MODE_11G`` -- IEEE 802.11g,"
msgstr ""

#: ../../../library/network.rst:171
msgid "``MODE_11N`` -- IEEE 802.11n."
msgstr ""

#: ../../../library/network.rst:173
msgid "Availability: ESP8266."
msgstr "可用性: ESP8266。"

#: ../../../library/network.CC3K.rst:5
msgid "class CC3K -- control CC3000 WiFi modules"
msgstr "クラス CC3K -- CC3000 WiFi モジュールの制御"

#: ../../../library/network.CC3K.rst:7
msgid "This class provides a driver for CC3000 WiFi modules.  Example usage::"
msgstr "このクラスは CC3000 WiFi モジュール用のドライバを提供します。たとえば次のように使います::"

#: ../../../library/network.CC3K.rst:9
msgid ""
"import network\n"
"nic = network.CC3K(pyb.SPI(2), pyb.Pin.board.Y5, pyb.Pin.board.Y4, "
"pyb.Pin.board.Y3)\n"
"nic.connect('your-ssid', 'your-password')\n"
"while not nic.isconnected():\n"
"    pyb.delay(50)\n"
"print(nic.ifconfig())\n"
"\n"
"# now use socket as usual\n"
"..."
msgstr ""
"import network\n"
"nic = network.CC3K(pyb.SPI(2), pyb.Pin.board.Y5, pyb.Pin.board.Y4, "
"pyb.Pin.board.Y3)\n"
"nic.connect('your-ssid', 'your-password')\n"
"while not nic.isconnected():\n"
"    pyb.delay(50)\n"
"print(nic.ifconfig())\n"
"\n"
"# これで通常どおりソケットを使えるようになる\n"
"..."

#: ../../../library/network.CC3K.rst:19
msgid ""
"For this example to work the CC3000 module must have the following "
"connections:"
msgstr ""
"この例が機能するためには CC3000 モジュールを次のように配線することが必要になります。"

#: ../../../library/network.CC3K.rst:21
msgid "MOSI connected to Y8"
msgstr "MOSI を Y8 に配線"

#: ../../../library/network.CC3K.rst:22
msgid "MISO connected to Y7"
msgstr "MISO を Y7 に配線"

#: ../../../library/network.CC3K.rst:23
msgid "CLK connected to Y6"
msgstr "CLK を Y6 に配線"

#: ../../../library/network.CC3K.rst:24
msgid "CS connected to Y5"
msgstr "CS を Y5 に配線"

#: ../../../library/network.CC3K.rst:25
msgid "VBEN connected to Y4"
msgstr "VBEN を Y4 に配線"

#: ../../../library/network.CC3K.rst:26
msgid "IRQ connected to Y3"
msgstr "IRQ を Y3 に配線"

#: ../../../library/network.CC3K.rst:28
msgid ""
"It is possible to use other SPI busses and other pins for CS, VBEN and "
"IRQ."
msgstr "他の SPI バスを使うことや、CS, VBEN, IRQ に他のピンを使うことも可能です。"

#: ../../../library/network.CC3K.rst:35
msgid ""
"Create a CC3K driver object, initialise the CC3000 module using the given"
" SPI bus and pins, and return the CC3K object."
msgstr ""
"CC3K ドライバオブジェクトを作成し、指定した SPI バスとピンを使って CC3000 モジュール"
"を初期化し、CC3K オブジェクトを返します。"

#: ../../../library/network.CC3K.rst:38
#: ../../../library/network.WIZNET5K.rst:39
#: ../../../library/network.WLANWiPy.rst:50
msgid "Arguments are:"
msgstr "引数は次のとおりです:"

#: ../../../library/network.CC3K.rst:40
msgid ""
"*spi* is an :ref:`SPI object <pyb.SPI>` which is the SPI bus that the "
"CC3000 is connected to (the MOSI, MISO and CLK pins)."
msgstr ""
"*spi* は CC3000 が接続されている SPI バス(MOSI, MISO, CLK ピン)の "
":ref:`SPI オブジェクト <pyb.SPI>` です。"

#: ../../../library/network.CC3K.rst:42
msgid ""
"*pin_cs* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"CC3000 CS pin."
msgstr ""
"*pin_cs* は CC3000 CS ピンが接続されている :ref:`Pin オブジェクト <pyb.Pin>` です。"

#: ../../../library/network.CC3K.rst:43
msgid ""
"*pin_en* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"CC3000 VBEN pin."
msgstr ""
"*pin_en* は CC3000 VBEN ピンが接続されている :ref:`Pin オブジェクト <pyb.Pin>` です。"

#: ../../../library/network.CC3K.rst:44
msgid ""
"*pin_irq* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"CC3000 IRQ pin."
msgstr ""
"*pin_irq* は CC3000 IRQ ピンが接続されている :ref:`Pin オブジェクト <pyb.Pin>` です。"

#: ../../../library/network.CC3K.rst:46
#: ../../../library/network.WIZNET5K.rst:46
msgid ""
"All of these objects will be initialised by the driver, so there is no "
"need to initialise them yourself.  For example, you can use::"
msgstr ""
"これらのオブジェクトはすべてドライバによって初期化されるので、自分で初期化する必要は"
"ありません。たとえば次のようにします。"

#: ../../../library/network.CC3K.rst:49
msgid ""
"nic = network.CC3K(pyb.SPI(2), pyb.Pin.board.Y5, pyb.Pin.board.Y4, "
"pyb.Pin.board.Y3)"
msgstr ""

#: ../../../library/network.CC3K.rst:56
#: ../../../library/network.WLANWiPy.rst:74
msgid ""
"Connect to a WiFi access point using the given SSID, and other security "
"parameters."
msgstr ""
"指定した SSID と他のセキュリティパラメータを使用して WiFi アクセスポイントに接続します。"

#: ../../../library/network.CC3K.rst:61
#: ../../../library/network.WLANWiPy.rst:92
msgid "Disconnect from the WiFi access point."
msgstr "WiFi アクセスポイントから切断します。"

#: ../../../library/network.CC3K.rst:65
msgid ""
"Returns True if connected to a WiFi access point and has a valid IP "
"address, False otherwise."
msgstr ""
"WiFi アクセスポイントに接続されていて有効なIPアドレスを持っていれば True を、"
"そうでなければ False を返します。"

#: ../../../library/network.CC3K.rst:70
msgid ""
"Returns a 7-tuple with (ip, subnet mask, gateway, DNS server, DHCP "
"server, MAC address, SSID)."
msgstr ""
"７項目のタプル (ip, subnet mask, gateway, DNS server, DHCP "
"server, MAC address, SSID) を返します。

#: ../../../library/network.CC3K.rst:75
msgid "Return the version of the patch program (firmware) on the CC3000."
msgstr "CC3000 のパッチプログラム(ファームウェア)のバージョンを返します。"

#: ../../../library/network.CC3K.rst:79
msgid ""
"Upload the current firmware to the CC3000.  You must pass 'pgm' as the "
"first argument in order for the upload to proceed."
msgstr ""
"現在のファームウェアを CC3000 にアップロードします。アップロードを続行するには、"
"最初の引数として 'pgm' を渡す必要があります。"

#: ../../../library/network.CC3K.rst:89
msgid "security type to use"
msgstr "使用するセキュリティの種類"

#: ../../../library/network.WIZNET5K.rst:5
msgid "class WIZNET5K -- control WIZnet5x00 Ethernet modules"
msgstr "クラス WIZNET5K -- WIZnet5x00 イーサネットモジュールの制御"

#: ../../../library/network.WIZNET5K.rst:7
msgid ""
"This class allows you to control WIZnet5x00 Ethernet adaptors based on "
"the W5200 and W5500 chipsets.  The particular chipset that is supported "
"by the firmware is selected at compile-time via the MICROPY_PY_WIZNET5K "
"option."
msgstr ""
"このクラスを使用すると、W5200 および W5500 チップセットに基づいた WIZnet5x00 "
"イーサネットアダプタを制御できます。ファームウェアでサポートされている特定の"
"チップセットは、コンパイル時の MICROPY_PY_WIZNET5K オプションで選択されます。"

#: ../../../library/network.WIZNET5K.rst:14
msgid ""
"import network\n"
"nic = network.WIZNET5K(pyb.SPI(1), pyb.Pin.board.X5, pyb.Pin.board.X4)\n"
"print(nic.ifconfig())\n"
"\n"
"# now use socket as usual\n"
"..."
msgstr ""
"import network\n"
"nic = network.WIZNET5K(pyb.SPI(1), pyb.Pin.board.X5, pyb.Pin.board.X4)\n"
"print(nic.ifconfig())\n"
"\n"
"# これで通常どおりソケットを使えるようになる\n"
"..."

#: ../../../library/network.WIZNET5K.rst:21
msgid ""
"For this example to work the WIZnet5x00 module must have the following "
"connections:"
msgstr ""
"この例が機能するためには WIZnet5x00 モジュールを次のように配線することが必要になります。"

#: ../../../library/network.WIZNET5K.rst:23
msgid "MOSI connected to X8"
msgstr "MOSI を X8 に配線"

#: ../../../library/network.WIZNET5K.rst:24
msgid "MISO connected to X7"
msgstr "MISO を X7 に配線"

#: ../../../library/network.WIZNET5K.rst:25
msgid "SCLK connected to X6"
msgstr "SCLK を X7 に配線"

#: ../../../library/network.WIZNET5K.rst:26
msgid "nSS connected to X5"
msgstr "nSS を X5 に配線"

#: ../../../library/network.WIZNET5K.rst:27
msgid "nRESET connected to X4"
msgstr "nRESET を X4 に配線"

#: ../../../library/network.WIZNET5K.rst:29
msgid "It is possible to use other SPI busses and other pins for nSS and nRESET."
msgstr "他の SPI バスを使うことや、nSS, nRESET に他のピンを使うことも可能です。"

#: ../../../library/network.WIZNET5K.rst:36
msgid ""
"Create a WIZNET5K driver object, initialise the WIZnet5x00 module using "
"the given SPI bus and pins, and return the WIZNET5K object."
msgstr ""
"WIZNET5K ドライバオブジェクトを作成し、指定した SPI バスとピンを使って WIZnet5x00 "
"モジュールを初期化し、WIZNET5K オブジェクトを返します。"

#: ../../../library/network.WIZNET5K.rst:41
msgid ""
"*spi* is an :ref:`SPI object <pyb.SPI>` which is the SPI bus that the "
"WIZnet5x00 is connected to (the MOSI, MISO and SCLK pins)."
msgstr ""
"*spi* は WIZnet5x00 が接続されている SPI バス(MOSI, MISO, CLK ピン)の "
":ref:`SPI オブジェクト <pyb.SPI>` です。"

#: ../../../library/network.WIZNET5K.rst:43
msgid ""
"*pin_cs* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"WIZnet5x00 nSS pin."
msgstr ""
"*pin_cs* は WIZnet5x00 nSS ピンが接続されている :ref:`Pin オブジェクト <pyb.Pin>` です。"

#: ../../../library/network.WIZNET5K.rst:44
msgid ""
"*pin_rst* is a :ref:`Pin object <pyb.Pin>` which is connected to the "
"WIZnet5x00 nRESET pin."
msgstr ""
"*pin_rst* は WIZnet5x00 nRESET ピンが接続されている :ref:`Pin オブジェクト <pyb.Pin>` です。"

#: ../../../library/network.WIZNET5K.rst:49
msgid "nic = network.WIZNET5K(pyb.SPI(1), pyb.Pin.board.X5, pyb.Pin.board.X4)"
msgstr ""

#: ../../../library/network.WIZNET5K.rst:56
msgid ""
"Returns ``True`` if the physical Ethernet link is connected and up. "
"Returns ``False`` otherwise."
msgstr ""
"物理イーサネットリンクが接続されて有効化していれば ``True`` を、"
"そうでなければ ``False`` を返します。"

#: ../../../library/network.WIZNET5K.rst:61
msgid "Get/set IP address, subnet mask, gateway and DNS."
msgstr "IP アドレス、サブネットマスク、ゲートウェイ、DNS を取得/設定します。"

#: ../../../library/network.WIZNET5K.rst:63
msgid ""
"When called with no arguments, this method returns a 4-tuple with the "
"above information."
msgstr ""
"引数なしで呼び出されると、このメソッドは上記の情報を含む４項目のタプルを返します。"

#: ../../../library/network.WIZNET5K.rst:65
msgid ""
"To set the above values, pass a 4-tuple with the required information.  "
"For example::"
msgstr ""
"上記の値を設定するには、必要な情報を含む４項目のタプルを渡します。たとえば"
"次のようにします::"

#: ../../../library/network.WIZNET5K.rst:71
msgid "Dump the WIZnet5x00 registers.  Useful for debugging."
msgstr "WIZnet5x00 のレジスタをダンプします。デバッグ用です。"

#: ../../../library/network.WLAN.rst:5
msgid "class WLAN -- control built-in WiFi interfaces"
msgstr "クラス WLAN -- 組込み WiFi インタフェースの制御"

#: ../../../library/network.WLAN.rst:7
msgid "This class provides a driver for WiFi network processors.  Example usage::"
msgstr "このクラスは WiFi ネットワークプロセッサー用のドライバを提供します。たとえば次のように使います::"

#: ../../../library/network.WLAN.rst:9
msgid ""
"import network\n"
"# enable station interface and connect to WiFi access point\n"
"nic = network.WLAN(network.STA_IF)\n"
"nic.active(True)\n"
"nic.connect('your-ssid', 'your-password')\n"
"# now use sockets as usual"
msgstr ""
"import network\n"
"# ステーションインタフェースを有効にし、WiFi アクセスポイントに接続\n"
"nic = network.WLAN(network.STA_IF)\n"
"nic.active(True)\n"
"nic.connect('your-ssid', 'your-password')\n"
"# これで通常どおりソケットを使えるようになる"

#: ../../../library/network.WLAN.rst:20
msgid ""
"Create a WLAN network interface object. Supported interfaces are "
"``network.STA_IF`` (station aka client, connects to upstream WiFi access "
"points) and ``network.AP_IF`` (access point, allows other WiFi clients to"
" connect). Availability of the methods below depends on interface type. "
"For example, only STA interface may `WLAN.connect()` to an access point."
msgstr ""
"WLAN ネットワークインタフェースオブジェクトを作成します。サポートされているインタフェース"
"は ``network.STA_IF`` (ステーション、別名クライアント、上流のWiFiアクセスポイントに"
"接続します)と ``network.AP_IF`` (アクセスポイント、他の WiFi クライアントが接続できる"
"ようにする)です。以下のメソッドを利用できるかどうかは、インターフェイスの種類によって"
"異なります。たとえば、STA インタフェースのみが `WLAN.connect()` でアクセスポイントに"
"接続できます。"

#: ../../../library/network.WLAN.rst:31
msgid ""
"Activate (\"up\") or deactivate (\"down\") network interface, if boolean "
"argument is passed. Otherwise, query current state if no argument is "
"provided. Most other methods require active interface."
msgstr ""
"ブール型の引数が渡された場合、ネットワークインタフェースを有効化(\"up\")または"
"無効化(\"down\")します。引数が与えられていなければ現在の状態を問い合わせます。"
"他のほとんどのメソッドは有効化したインターフェースを必要とします。"

#: ../../../library/network.WLAN.rst:37
msgid ""
"Connect to the specified wireless network, using the specified password. "
"If *bssid* is given then the connection will be restricted to the access-"
"point with that MAC address (the *ssid* must also be specified in this "
"case)."
msgstr ""
"指定されたパスワードを使用して、指定されたワイヤレスネットワークに接続します。 "
"*bssid* が与えられると、接続はそのMACアドレスのアクセスポイントに制限されます"
"(この場合でも *ssid* は指定する必要があります)。"

#: ../../../library/network.WLAN.rst:44
msgid "Disconnect from the currently connected wireless network."
msgstr "現在接続している無線ネットワークから切断します。"

#: ../../../library/network.WLAN.rst:48
msgid "Scan for the available wireless networks."
msgstr "利用可能な無線ネットワークをスキャンします。"

#: ../../../library/network.WLAN.rst:50
msgid ""
"Scanning is only possible on STA interface. Returns list of tuples with "
"the information about WiFi access points:"
msgstr ""
"スキャンは STA インターフェイスでのみ可能です。戻り値は WiFi アクセスポイントに"
"関する情報を含むタプルのリストです。"

#: ../../../library/network.WLAN.rst:53
msgid "(ssid, bssid, channel, RSSI, authmode, hidden)"
msgstr ""

#: ../../../library/network.WLAN.rst:55
msgid ""
"*bssid* is hardware address of an access point, in binary form, returned "
"as bytes object. You can use `ubinascii.hexlify()` to convert it to ASCII"
" form."
msgstr ""
"*bssid* はアクセスポイントのハードウェアアドレスで、バイナリ形式です。これはバイト列"
"オブジェクトとして返されます。 `ubinascii.hexlify()` を使えば ASCII 形式に変換"
"できます。"

#: ../../../library/network.WLAN.rst:58
msgid "There are five values for authmode:"
msgstr "authmode には5つの値があります:"

#: ../../../library/network.WLAN.rst:60
msgid "0 -- open"
msgstr ""

#: ../../../library/network.WLAN.rst:61
msgid "1 -- WEP"
msgstr ""

#: ../../../library/network.WLAN.rst:62
msgid "2 -- WPA-PSK"
msgstr ""

#: ../../../library/network.WLAN.rst:63
msgid "3 -- WPA2-PSK"
msgstr ""

#: ../../../library/network.WLAN.rst:64
msgid "4 -- WPA/WPA2-PSK"
msgstr ""

#: ../../../library/network.WLAN.rst:66
msgid "and two for hidden:"
msgstr "hidden には２つの値があります:"

#: ../../../library/network.WLAN.rst:68
msgid "0 -- visible"
msgstr "0 -- 可視""

#: ../../../library/network.WLAN.rst:69
msgid "1 -- hidden"
msgstr "1 -- 不可視"

#: ../../../library/network.WLAN.rst:73
msgid "Return the current status of the wireless connection."
msgstr "無線接続の現在のステータスを返します。"

#: ../../../library/network.WLAN.rst:75
msgid ""
"When called with no argument the return value describes the network link "
"status. The possible statuses are defined as constants:"
msgstr ""
"引数なしで呼び出された場合、戻り値はネットワークリンクステータスを表します。"
"戻されるステータスは定数として定義されています:"

#: ../../../library/network.WLAN.rst:78
msgid "``STAT_IDLE`` -- no connection and no activity,"
msgstr "``STAT_IDLE`` -- 無接続、無アクティビティ"

#: ../../../library/network.WLAN.rst:79
msgid "``STAT_CONNECTING`` -- connecting in progress,"
msgstr "``STAT_CONNECTING`` -- 接続中"

#: ../../../library/network.WLAN.rst:80
msgid "``STAT_WRONG_PASSWORD`` -- failed due to incorrect password,"
msgstr "``STAT_WRONG_PASSWORD`` -- パスワード不正により失敗"

#: ../../../library/network.WLAN.rst:81
msgid "``STAT_NO_AP_FOUND`` -- failed because no access point replied,"
msgstr "``STAT_NO_AP_FOUND`` -- アクセスポイントが応答しないため失敗"

#: ../../../library/network.WLAN.rst:82
msgid "``STAT_CONNECT_FAIL`` -- failed due to other problems,"
msgstr "``STAT_CONNECT_FAIL`` -- その他の問題により失敗"

#: ../../../library/network.WLAN.rst:83
msgid "``STAT_GOT_IP`` -- connection successful."
msgstr "``STAT_GOT_IP`` -- 接続成功"

#: ../../../library/network.WLAN.rst:85
msgid ""
"When called with one argument *param* should be a string naming the "
"status parameter to retrieve.  Supported parameters in WiFI STA mode are:"
" ``'rssi'``."
msgstr ""
"１つの引数 *param* を指定して呼び出された場合、 *param* は取得するステータス"
"パラメータの名前を表す文字列にする必要があります。WiFi STA モードでサポートされている"
"パラメータは ``'rssi'`` です。"

#: ../../../library/network.WLAN.rst:90
msgid ""
"In case of STA mode, returns ``True`` if connected to a WiFi access point"
" and has a valid IP address.  In AP mode returns ``True`` when a station "
"is connected. Returns ``False`` otherwise."
msgstr ""
"STA モードの場合、WiFi アクセスポイントに接続されていて有効なIPアドレスを持っていれば "
"``True`` を返します。AP モードの場合、ステーションが接続されていれば ``True`` を"
"返します。これら以外では ``False`` を返します。"

#: ../../../library/network.WLAN.rst:106
msgid ""
"Get or set general network interface parameters. These methods allow to "
"work with additional parameters beyond standard IP configuration (as "
"dealt with by `WLAN.ifconfig()`). These include network-specific and "
"hardware-specific parameters. For setting parameters, keyword argument "
"syntax should be used, multiple parameters can be set at once. For "
"querying, parameters name should be quoted as a string, and only one "
"parameter can be queries at time::"
msgstr ""
"一般的なネットワークインターフェースパラメータを取得または設定します。これらのメソッドは、"
"(`WLAN.ifconfig()` で扱われるように)標準の IP 設定以外の追加のパラメータを扱うことを"
"可能にします 。これらには、ネットワーク固有およびハードウェア固有のパラメータが含まれています。"
"パラメータを設定するには、キーワード引数の構文を使用する必要があり、複数のパラメータを"
"一度に設定できます。問合せを実行する場合、パラメータ名は文字列として引用符で囲みます。"
"一度に問合せできるパラメータは1つだけです。"

#: ../../../library/network.WLAN.rst:119
msgid ""
"Following are commonly supported parameters (availability of a specific "
"parameter depends on network technology type, driver, and `MicroPython "
"port`)."
msgstr ""
"以下は一般的にサポートされているパラメータです(特定のパラメータが使用可能かどうかは、"
"ネットワーク技術の種類、ドライバ、 `MicroPython ポート <MicroPython port>` "
"によって異なります)。"

#: ../../../library/network.WLAN.rst:123
msgid "Parameter"
msgstr "パラメータ"

#: ../../../library/network.WLAN.rst:123
msgid "Description"
msgstr "説明"

#: ../../../library/network.WLAN.rst:125
msgid "mac"
msgstr ""

#: ../../../library/network.WLAN.rst:125
msgid "MAC address (bytes)"
msgstr "MAC アドレス(バイト列)"

#: ../../../library/network.WLAN.rst:126
msgid "essid"
msgstr ""

#: ../../../library/network.WLAN.rst:126
msgid "WiFi access point name (string)"
msgstr "WiFi アクセスポイント名(文字列)"

#: ../../../library/network.WLAN.rst:127
msgid "channel"
msgstr ""

#: ../../../library/network.WLAN.rst:127
msgid "WiFi channel (integer)"
msgstr "WiFi チャンネル(整数)"

#: ../../../library/network.WLAN.rst:128
msgid "hidden"
msgstr ""

#: ../../../library/network.WLAN.rst:128
msgid "Whether ESSID is hidden (boolean)"
msgstr "ESSID が非表示かどうか(ブール型)"

#: ../../../library/network.WLAN.rst:129
msgid "authmode"
msgstr ""

#: ../../../library/network.WLAN.rst:129
msgid "Authentication mode supported (enumeration, see module constants)"
msgstr "サポートされている認証モード(列挙値、モジュール定数を参照)"

#: ../../../library/network.WLAN.rst:130
msgid "password"
msgstr ""

#: ../../../library/network.WLAN.rst:130
msgid "Access password (string)"
msgstr "アクセスパスワード(文字列)"

#: ../../../library/network.WLAN.rst:131
msgid "dhcp_hostname"
msgstr ""

#: ../../../library/network.WLAN.rst:131
msgid "The DHCP hostname to use"
msgstr "使用する DHCP ホスト名"

#: ../../../library/network.WLANWiPy.rst:5
msgid "class WLANWiPy -- WiPy specific WiFi control"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:9
msgid ""
"This class is a non-standard WLAN implementation for the WiPy. It is "
"available simply as ``network.WLAN`` on the WiPy but is named in the "
"documentation below as ``network.WLANWiPy`` to distinguish it from the "
"more general :ref:`network.WLAN <network.WLAN>` class."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:14
msgid ""
"This class provides a driver for the WiFi network processor in the WiPy. "
"Example usage::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:16
msgid ""
"import network\n"
"import time\n"
"# setup as a station\n"
"wlan = network.WLAN(mode=WLAN.STA)\n"
"wlan.connect('your-ssid', auth=(WLAN.WPA2, 'your-key'))\n"
"while not wlan.isconnected():\n"
"    time.sleep_ms(50)\n"
"print(wlan.ifconfig())\n"
"\n"
"# now use socket as usual\n"
"..."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:33
msgid ""
"Create a WLAN object, and optionally configure it. See `init()` for "
"params of configuration."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:37
msgid ""
"The ``WLAN`` constructor is special in the sense that if no arguments "
"besides the id are given, it will return the already existing ``WLAN`` "
"instance without re-configuring it. This is because ``WLAN`` is a system "
"feature of the WiPy. If the already existing instance is not initialized "
"it will do the same as the other constructors an will initialize it with "
"default values."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:48
msgid "Set or get the WiFi network processor configuration."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:52
msgid "*mode* can be either ``WLAN.STA`` or ``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:53
msgid ""
"*ssid* is a string with the ssid name. Only needed when mode is "
"``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:54
msgid ""
"*auth* is a tuple with (sec, key). Security can be ``None``, "
"``WLAN.WEP``, ``WLAN.WPA`` or ``WLAN.WPA2``. The key is a string with the"
" network password. If ``sec`` is ``WLAN.WEP`` the key must be a string "
"representing hexadecimal values (e.g. 'ABC1DE45BF'). Only needed when "
"mode is ``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:58
msgid ""
"*channel* a number in the range 1-11. Only needed when mode is "
"``WLAN.AP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:59
msgid ""
"*antenna* selects between the internal and the external antenna. Can be "
"either ``WLAN.INT_ANT`` or ``WLAN.EXT_ANT``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:62
msgid "For example, you can do::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:64
msgid ""
"# create and configure as an access point\n"
"wlan.init(mode=WLAN.AP, ssid='wipy-wlan', auth=(WLAN.WPA2,'www.wipy.io'),"
" channel=7, antenna=WLAN.INT_ANT)"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:67 ../../../library/pyb.Pin.rst:245
msgid "or::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:69
msgid ""
"# configure as an station\n"
"wlan.init(mode=WLAN.STA)"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:77
msgid ""
"*auth* is a tuple with (sec, key). Security can be ``None``, "
"``WLAN.WEP``, ``WLAN.WPA`` or ``WLAN.WPA2``. The key is a string with the"
" network password. If ``sec`` is ``WLAN.WEP`` the key must be a string "
"representing hexadecimal values (e.g. 'ABC1DE45BF')."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:81
msgid ""
"*bssid* is the MAC address of the AP to connect to. Useful when there are"
" several APs with the same ssid."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:83
msgid ""
"*timeout* is the maximum time in milliseconds to wait for the connection "
"to succeed."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:87
msgid ""
"Performs a network scan and returns a list of named tuples with (ssid, "
"bssid, sec, channel, rssi). Note that channel is always ``None`` since "
"this info is not provided by the WiPy."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:96
msgid ""
"In case of STA mode, returns ``True`` if connected to a WiFi access point"
" and has a valid IP address. In AP mode returns ``True`` when a station "
"is connected, ``False`` otherwise."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:101
msgid ""
"With no parameters given returns a 4-tuple of *(ip, subnet_mask, gateway,"
" DNS_server)*."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:103
msgid ""
"if ``'dhcp'`` is passed as a parameter then the DHCP client is enabled "
"and the IP params are negotiated with the AP."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:106
msgid ""
"If the 4-tuple config is given then a static IP is configured. For "
"instance::"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:108
msgid ""
"wlan.ifconfig(config=('192.168.0.4', '255.255.255.0', '192.168.0.1', "
"'8.8.8.8'))"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:112
msgid "Get or set the WLAN mode."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:116
msgid "Get or set the SSID when in AP mode."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:120
msgid "Get or set the authentication type when in AP mode."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:124
msgid "Get or set the channel (only applicable in AP mode)."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:128
msgid "Get or set the antenna type (external or internal)."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:132
msgid "Get or set a 6-byte long bytes object with the MAC address."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:136
msgid ""
"Create a callback to be triggered when a WLAN event occurs during "
"``machine.SLEEP`` mode. Events are triggered by socket activity or by "
"WLAN connection/disconnection."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:139
msgid "*handler* is the function that gets called when the IRQ is triggered."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:140
msgid "*wake* must be ``machine.SLEEP``."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:142
msgid "Returns an IRQ object."
msgstr ""

#: ../../../library/network.WLANWiPy.rst:150
msgid "selects the WLAN mode"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:156
msgid "selects the network security"
msgstr ""

#: ../../../library/network.WLANWiPy.rst:161
msgid "selects the antenna type"
msgstr ""

#: ../../../library/pyb.rst:2
msgid ":mod:`pyb` --- functions related to the board"
msgstr ":mod:`pyb` --- pyboard 関連の関数"

#: ../../../library/pyb.rst:7
msgid "The ``pyb`` module contains specific functions related to the board."
msgstr ""
"``pyb`` は puboard に固有の関数を提供します(訳注: 元々は pyboard 用ですが、"
"似たアーキテクチャ、特に STM32 系の MCU を載せたボードではサポートされて"
"いることが多いです)。"

#: ../../../library/pyb.rst:10
msgid "Time related functions"
msgstr "時間関連の関数"

#: ../../../library/pyb.rst:14
msgid "Delay for the given number of milliseconds."
msgstr "与えたミリ秒数だけ遅延します。"

#: ../../../library/pyb.rst:18
msgid "Delay for the given number of microseconds."
msgstr "与えたマイクロ秒数だけ遅延します。"

#: ../../../library/pyb.rst:22
msgid "Returns the number of milliseconds since the board was last reset."
msgstr "ボードが最後にリセットされてからのミリ秒数を返します。"

#: ../../../library/pyb.rst:24
msgid ""
"The result is always a MicroPython smallint (31-bit signed number), so "
"after 2^30 milliseconds (about 12.4 days) this will start to return "
"negative numbers."
msgstr ""
"結果は常に MicroPython の smallint (31ビットの符号付き数値)なので、"
"2^30 ミリ秒(約12.4日)が経過すると、負の数が返され始めます。"

#: ../../../library/pyb.rst:28
msgid ""
"Note that if :meth:`pyb.stop()` is issued the hardware counter supporting"
" this function will pause for the duration of the \"sleeping\" state. "
"This will affect the outcome of :meth:`pyb.elapsed_millis()`."
msgstr ""
"`pyb.stop()` が発行された場合、この機能をサポートするハードウェアカウンタが"
"「睡眠」状態の継続のために一時停止します。これは `pyb.elapsed_millis()` の"
"結果に影響します。"

#: ../../../library/pyb.rst:34
msgid "Returns the number of microseconds since the board was last reset."
msgstr "ボードが最後にリセットされてからのマイクロ秒数を返します。"

#: ../../../library/pyb.rst:36
msgid ""
"The result is always a MicroPython smallint (31-bit signed number), so "
"after 2^30 microseconds (about 17.8 minutes) this will start to return "
"negative numbers."
msgstr ""
"結果は常に MicroPython の smallint (31ビットの符号付き数値)なので、"
"2^30マイクロ秒(約17.8分)後に負の数が返され始めます。"

#: ../../../library/pyb.rst:40
msgid ""
"Note that if :meth:`pyb.stop()` is issued the hardware counter supporting"
" this function will pause for the duration of the \"sleeping\" state. "
"This will affect the outcome of :meth:`pyb.elapsed_micros()`."
msgstr ""
"`pyb.stop()` が発行された場合、この機能をサポートするハードウェアカウンタが"
"「睡眠」状態の継続のために一時停止します。これは `pyb.elapsed_millis()` の"
"結果に影響します。"

#: ../../../library/pyb.rst:46
msgid "Returns the number of milliseconds which have elapsed since ``start``."
msgstr "``start`` から経過したミリ秒数を返します。"

#: ../../../library/pyb.rst:48
msgid ""
"This function takes care of counter wrap, and always returns a positive "
"number. This means it can be used to measure periods up to about 12.4 "
"days."
msgstr ""
"この関数はカウンタラップを処理し、常に正の数を返します。これは、"
"最大約12.4日の期間を測定するために使用できることを意味します。"

#: ../../../library/pyb.rst:53
msgid ""
"start = pyb.millis()\n"
"while pyb.elapsed_millis(start) < 1000:\n"
"    # Perform some operation"
msgstr ""
"start = pyb.millis()\n"
"while pyb.elapsed_millis(start) < 1000:\n"
"    # 何等かの操作の実行"

#: ../../../library/pyb.rst:59
msgid "Returns the number of microseconds which have elapsed since ``start``."
msgstr "``start`` から経過したマイクロ秒数を返します。"

#: ../../../library/pyb.rst:61
msgid ""
"This function takes care of counter wrap, and always returns a positive "
"number. This means it can be used to measure periods up to about 17.8 "
"minutes."
msgstr ""
"この関数はカウンタラップを処理し、常に正の数を返します。これは、"
"最大約17.8分の期間を測定するために使用できることを意味します。"

#: ../../../library/pyb.rst:66
msgid ""
"start = pyb.micros()\n"
"while pyb.elapsed_micros(start) < 1000:\n"
"    # Perform some operation\n"
"    pass"
msgstr ""
"start = pyb.micros()\n"
"while pyb.elapsed_micros(start) < 1000:\n"
"    # 何等かの操作の実行\n"
"    pass"

#: ../../../library/pyb.rst:76
msgid ""
"Resets the pyboard in a manner similar to pushing the external RESET "
"button."
msgstr ""
"外部 RESET ボタンを押すのと同じように、pyboard をリセットします。"

#: ../../../library/pyb.rst:81
msgid "Activate the bootloader without BOOT\\* pins."
msgstr "BOOT\\* ピンなしでブートローダを起動します。"

#: ../../../library/pyb.rst:85
msgid ""
"Enable or disable hard-fault debugging.  A hard-fault is when there is a "
"fatal error in the underlying system, like an invalid memory access."
msgstr ""
"ハードフォルト(hard-fault)デバッグを有効または無効にします。ハードフォルトとは、"
"無効なメモリアクセスのように、基盤となるシステムに致命的なエラーがある場合のことです。"

#: ../../../library/pyb.rst:88
msgid ""
"If the *value* argument is ``False`` then the board will automatically "
"reset if there is a hard fault."
msgstr ""
"*value* 引数が ``False`` の場合、ハードフォルトがあると、ボードは自動的にリセット"
"されます。"

#: ../../../library/pyb.rst:91
msgid ""
"If *value* is ``True`` then, when the board has a hard fault, it will "
"print the registers and the stack trace, and then cycle the LEDs "
"indefinitely."
msgstr ""
"*value* 引数が ``True`` の場合、ボードにハードフォルトがあると、レジスタと"
"スタックトレースを表示してから、LED を無期限に点滅させます。"

#: ../../../library/pyb.rst:94
msgid "The default value is disabled, i.e. to automatically reset."
msgstr "デフォルト値は無効、つまり自動的にリセットされます。"

#: ../../../library/pyb.rst:101
msgid ""
"Disable interrupt requests. Returns the previous IRQ state: "
"``False``/``True`` for disabled/enabled IRQs respectively.  This return "
"value can be passed to enable_irq to restore the IRQ to its original "
"state."
msgstr ""
"割り込み要求を禁止します。前のIRQの状態の無効/有効に対応してそれぞれ "
"``False``/``True`` を返します。この戻り値をenable_irqに渡して IRQ を元の状態に"
"戻せます。"

#: ../../../library/pyb.rst:108
msgid ""
"Enable interrupt requests. If ``state`` is ``True`` (the default value) "
"then IRQs are enabled. If ``state`` is ``False`` then IRQs are disabled."
"  The most common use of this function is to pass it the value returned "
"by ``disable_irq`` to exit a critical section."
msgstr ""
"割り込み要求を有効にします。 ``state`` が ``True`` の場合(デフォルト値)、"
"その後の IRQ が有効になります。 ``state`` が ``False`` の場合、その後の IRQ が"
"無効になります。この関数の最も一般的な使い方は、クリティカルセクションを終了するために "
"``disable_irq`` が返した値を渡すことです。"

#: ../../../library/pyb.rst:119
msgid ""
"If given no arguments, returns a tuple of clock frequencies: (sysclk, "
"hclk, pclk1, pclk2). These correspond to:"
msgstr ""
"引数を与えなかった場合、クロック周波数のタプル (sysclk, hclk, pclk1, pclk2) を返しま。"
"これらは以下に対応します。"

#: ../../../library/pyb.rst:123
msgid "sysclk: frequency of the CPU"
msgstr "sysclk：CPUの周波数"

#: ../../../library/pyb.rst:124
msgid "hclk: frequency of the AHB bus, core memory and DMA"
msgstr "hclk: AHB バス、コアメモリ、DMA の周波数"

#: ../../../library/pyb.rst:125
msgid "pclk1: frequency of the APB1 bus"
msgstr "pclk1: APB1バスの周波数"

#: ../../../library/pyb.rst:126
msgid "pclk2: frequency of the APB2 bus"
msgstr "pclk2: APB2バスの周波数"

#: ../../../library/pyb.rst:128
msgid ""
"If given any arguments then the function sets the frequency of the CPU, "
"and the busses if additional arguments are given.  Frequencies are given "
"in Hz.  Eg freq(120000000) sets sysclk (the CPU frequency) to 120MHz.  "
"Note that not all values are supported and the largest supported "
"frequency not greater than the given value will be selected."
msgstr ""
"引数を与えと、関数は CPU の周波数を設定し、追加の引数が与えられるとバスを設定します。"
"周波数は Hz で与えます。たとえば freq(120000000) は sysclk (CPU 周波数) を 120 MHz "
"に設定します。すべての値がサポートされているわけではなく、指定された値以下の最大の"
"サポート周波数が選択されます。"

#: ../../../library/pyb.rst:134
msgid ""
"Supported sysclk frequencies are (in MHz): 8, 16, 24, 30, 32, 36, 40, 42,"
" 48, 54, 56, 60, 64, 72, 84, 96, 108, 120, 144, 168."
msgstr ""
"サポートしている sysclk 周波数(MHz) は 8, 16, 24, 30, 32, 36, 40, 42,"
" 48, 54, 56, 60, 64, 72, 84, 96, 108, 120, 144, 168 です。"

#: ../../../library/pyb.rst:137
msgid ""
"The maximum frequency of hclk is 168MHz, of pclk1 is 42MHz, and of pclk2 "
"is 84MHz.  Be sure not to set frequencies above these values."
msgstr ""
"hclk の最大周波数は 168MHz、pclk1 の最大周波数は 42MHz、pclk2 のは最大周波数は "
"84MHzです。周波数をこれらの値より上に設定しないでください。"

#: ../../../library/pyb.rst:140
msgid ""
"The hclk, pclk1 and pclk2 frequencies are derived from the sysclk "
"frequency using a prescaler (divider).  Supported prescalers for hclk "
"are: 1, 2, 4, 8, 16, 64, 128, 256, 512.  Supported prescalers for pclk1 "
"and pclk2 are: 1, 2, 4, 8.  A prescaler will be chosen to best match the "
"requested frequency."
msgstr ""
"hclk, pclk1, pclk2 の周波数は、プリスケーラ(分周器)を使用して sysclk の周波数から"
"導き出されます。hclk でサポートされている プリスケーラは 1, 2, 4, 8, 16, 64, "
"128, 256, 512 です。pclk1 と pclk2 でサポートされているプリスケーラは 1, 2, 4, 8 "
"です。プリスケーラは要求された周波数に最もよく合うように選択されます。"

#: ../../../library/pyb.rst:145
msgid ""
"A sysclk frequency of 8MHz uses the HSE (external crystal) directly and "
"16MHz uses the HSI (internal oscillator) directly.  The higher "
"frequencies use the HSE to drive the PLL (phase locked loop), and then "
"use the output of the PLL."
msgstr ""
"8MHz の sysclk 周波数は HSE (外部水晶)を直接使用し、16MHz は HSI (内部発振器)を"
"直接使用します。より高い周波数では、HSE を使って PLL (位相同期ループ)を駆動して、"
"PLL の出力を使います。"

#: ../../../library/pyb.rst:150
msgid ""
"Note that if you change the frequency while the USB is enabled then the "
"USB may become unreliable.  It is best to change the frequency in "
"boot.py, before the USB peripheral is started.  Also note that sysclk "
"frequencies below 36MHz do not allow the USB to function correctly."
msgstr ""
"USB が有効になっている間に周波数を変更すると、USB の信頼性が低下する可能性があります。"
"USB 周辺機器を起動する前に、boot.py で周波数を変更するのが最善です。また、sysclk の"
"周波数が 36MHz より低いと、USB は正しく機能しません。"

#: ../../../library/pyb.rst:157
msgid "Wait for an internal or external interrupt."
msgstr "内部または外部割り込みを待ちます。"

#: ../../../library/pyb.rst:159
msgid ""
"This executes a ``wfi`` instruction which reduces power consumption of "
"the MCU until any interrupt occurs (be it internal or external), at which"
" point execution continues.  Note that the system-tick interrupt occurs "
"once every millisecond (1000Hz) so this function will block for at most "
"1ms."
msgstr ""
"これは、(MCU の内部または外部にかかわらず)割り込みが発生するまで MCU の消費電力を"
"削減する ``wfi`` 命令を実行し、その時点で実行は継続します。システムティックの"
"割り込みは1ミリ秒(1000Hz)に１回発生するため、この関数は最大 1ms ブロックします。"

#: ../../../library/pyb.rst:167
msgid "Put the pyboard in a \"sleeping\" state."
msgstr "pyboard を「スリープ」状態にします。"

#: ../../../library/pyb.rst:169
msgid ""
"This reduces power consumption to less than 500 uA.  To wake from this "
"sleep state requires an external interrupt or a real-time-clock event. "
"Upon waking execution continues where it left off."
msgstr ""
"これにより、消費電力が 500 µA 未満になります。このスリープ状態から復帰するには、"
"外部割り込みまたはリアルタイムクロックイベントが必要です。目が覚めると実行は中断した"
"所から再開されます。"

#: ../../../library/pyb.rst:173 ../../../library/pyb.rst:184
msgid "See :meth:`rtc.wakeup` to configure a real-time-clock wakeup event."
msgstr "リアルタイムクロックのウェイクアップイベントを設定する方法については :meth:`rtc.wakeup` を参照してください。"

#: ../../../library/pyb.rst:177
msgid "Put the pyboard into a \"deep sleep\" state."
msgstr "pyboard を「ディープスリープ」状態にします。"

#: ../../../library/pyb.rst:179
msgid ""
"This reduces power consumption to less than 50 uA.  To wake from this "
"sleep state requires a real-time-clock event, or an external interrupt on"
" X1 (PA0=WKUP) or X18 (PC13=TAMP1). Upon waking the system undergoes a "
"hard reset."
msgstr ""
"これにより、消費電力が 50 µA 未満になります。このスリープ状態から復帰するには、"
"リアルタイムクロックイベント、または X1 (PA0=WKUP)か X18 (PC13=TAMP1) での"
"外部割り込みが必要です。起動するとシステムはハードリセットされます。"

#: ../../../library/pyb.rst:191
msgid "Return True if USB is connected as a serial device, False otherwise."
msgstr "USB がシリアルデバイスとして接続されていれば True を、そうでなければ False を返します。"

#: ../../../library/pyb.rst:193
msgid "This function is deprecated.  Use pyb.USB_VCP().isconnected() instead."
msgstr "この関数は非推奨です。代わりに pyb.USB_VCP().isconnected() を使ってください。"

#: ../../../library/pyb.rst:197
msgid ""
"Takes a 4-tuple (or list) and sends it to the USB host (the PC) to signal"
" a HID mouse-motion event."
msgstr ""
"4項目のタプル(またはリスト)を取り、それを USB ホスト(PC)に送信して HID "
"マウスモーションイベントを通知します。"

#: ../../../library/pyb.rst:200
msgid "This function is deprecated.  Use :meth:`pyb.USB_HID.send()` instead."
msgstr "この関数は非推奨です。代わりに :meth:`pyb.USB_HID.send()` を使ってください。"

#: ../../../library/pyb.rst:204
msgid "Print out lots of information about the board."
msgstr "ボードについてのたくさんの情報を表示します。"

#: ../../../library/pyb.rst:208
msgid ""
"Set the filename of the main script to run after boot.py is finished.  If"
" this function is not called then the default file main.py will be "
"executed."
msgstr ""
"boot.py が完了した後に実行するメインスクリプトのファイル名を設定します。"
"この関数が呼び出されないと、デフォルトのファイル main.py が実行されます。"

#: ../../../library/pyb.rst:211
msgid "It only makes sense to call this function from within boot.py."
msgstr "boot.py の中からこの関数を呼び出すことだけが理にかなっています。"

#: ../../../library/pyb.rst:215
msgid ""
"This function is deprecated. Mounting and unmounting devices should be "
"performed by :meth:`uos.mount` and :meth:`uos.umount` instead."
msgstr ""
"この関数は非推奨です。デバイスのマウントとマウント解除には、代わりに "
":meth:`uos.mount` と :meth:`uos.umount` を使ってください。"

#: ../../../library/pyb.rst:218
msgid ""
"Mount a block device and make it available as part of the filesystem. "
"``device`` must be an object that provides the block protocol. (The "
"following is also deprecated. See :class:`uos.AbstractBlockDev` for the "
"correct way to create a block device.)"
msgstr ""
"ブロックデバイスをマウントしてファイルシステムの一部として利用できるようにします。 "
"``device`` はブロックプロトコルを提供するオブジェクトでなければなりません。"
"(以下も非推奨です。ブロックデバイスを作成する正しい方法については "
":class:`uos.AbstractBlockDev` を参照してください。）"

#: ../../../library/pyb.rst:223
msgid "``readblocks(self, blocknum, buf)``"
msgstr ""

#: ../../../library/pyb.rst:224
msgid "``writeblocks(self, blocknum, buf)`` (optional)"
msgstr "``writeblocks(self, blocknum, buf)`` (オプション)"

#: ../../../library/pyb.rst:225
msgid "``count(self)``"
msgstr ""

#: ../../../library/pyb.rst:226
msgid "``sync(self)`` (optional)"
msgstr "``sync(self)`` (オプション)"

#: ../../../library/pyb.rst:228
msgid ""
"``readblocks`` and ``writeblocks`` should copy data between ``buf`` and "
"the block device, starting from block number ``blocknum`` on the device. "
"``buf`` will be a bytearray with length a multiple of 512.  If "
"``writeblocks`` is not defined then the device is mounted read-only. The "
"return value of these two functions is ignored."
msgstr ""
"``readblocks`` と ``writeblocks`` は ``buf`` とブロックデバイスの間でデータを"
"コピーするもので、デバイスのブロック番号 ``blocknum`` から始まります。 ``buf`` は"
" 512 の倍数の長さを持つ bytearray です。 ``writeblocks`` が定義されていなければ、"
"デバイスは読み取り専用でマウントされます。これら2つの関数の戻り値は無視されます。"

#: ../../../library/pyb.rst:234
msgid ""
"``count`` should return the number of blocks available on the device. "
"``sync``, if implemented, should sync the data on the device."
msgstr ""
"``count`` はデバイスで利用可能なブロック数を返します。"
"``sync``  が実装されている場合、この関数はデバイス上のデータを同期します。"

#: ../../../library/pyb.rst:237
msgid ""
"The parameter ``mountpoint`` is the location in the root of the "
"filesystem to mount the device.  It must begin with a forward-slash."
msgstr ""
"パラメータ ``mountpoint`` は、デバイスをマウントするためのファイルシステムの"
"ルート内の場所です。それはスラッシュ記号で始まらなければなりません。"

#: ../../../library/pyb.rst:240
msgid ""
"If ``readonly`` is ``True``, then the device is mounted read-only, "
"otherwise it is mounted read-write."
msgstr ""
"``readonly`` が ``True`` であれば、デバイスは読み取り専用でマウントされ、"
"それ以外の場合は、読み書きができるようマウントされます。"

#: ../../../library/pyb.rst:243
msgid ""
"If ``mkfs`` is ``True``, then a new filesystem is created if one does not"
" already exist."
msgstr ""
"``mkfs`` が ``True`` である場合、ファイルシステムが存在しない場合は、新しい"
"ファイルシステムが作成されます。"

#: ../../../library/pyb.rst:248
msgid "Get or set the UART object where the REPL is repeated on."
msgstr "REPL が繰り返される UART オブジェクトを取得または設定します。"

#: ../../../library/pyb.rst:252
msgid "Return a 30-bit hardware generated random number."
msgstr "30ビットのハードウェア生成乱数を返します。"

#: ../../../library/pyb.rst:256
msgid "Sync all file systems."
msgstr "すべてのファイルシステムを同期します。"

#: ../../../library/pyb.rst:260
msgid "Returns a string of 12 bytes (96 bits), which is the unique ID of the MCU."
msgstr "MCU の一意な ID である12バイト(96ビット)の文字列を返します。"

#: ../../../library/pyb.rst:264
msgid "If called with no arguments, return the current USB mode as a string."
msgstr "引数なしで呼び出された場合は、現在の USB モードを文字列として返します。"

#: ../../../library/pyb.rst:266
msgid ""
"If called with *modestr* provided, attempts to configure the USB mode. "
"The following values of *modestr* are understood:"
msgstr ""
"*modestr* を指定して呼び出した場合、USB モードの設定を試みます。 "
"*modestr* の値には次のものがあります:"

#: ../../../library/pyb.rst:271
msgid "``None``: disables USB"
msgstr "``None``: USB を無効化"

#: ../../../library/pyb.rst:272
msgid "``'VCP'``: enable with VCP (Virtual COM Port) interface"
msgstr "``'VCP'``: VCP (仮想 COM ポート)インタフェースを有効化"

#: ../../../library/pyb.rst:273
msgid "``'MSC'``: enable with MSC (mass storage device class) interface"
msgstr "``'MSC'``: MSC (マスストレージデバイスクラス)インタフェースを有効化"

#: ../../../library/pyb.rst:274
msgid "``'VCP+MSC'``: enable with VCP and MSC"
msgstr "``'VCP+MSC'``: VCP と MSC を有効化"

#: ../../../library/pyb.rst:275
msgid "``'VCP+HID'``: enable with VCP and HID (human interface device)"
msgstr "``'VCP+HID'``: VCP と HID (ヒューマンインタフェースデバイス)を有効化"

#: ../../../library/pyb.rst:276
msgid ""
"For backwards compatibility, ``'CDC'`` is understood to mean ``'VCP'`` "
"(and similarly for ``'CDC+MSC'`` and ``'CDC+HID'``)."
msgstr ""
"後方互換性のために、 ``'CDC'`` は ``'VCP'`` を意味すると解釈されます"
"(``'CDC+MSC'`` と ``'CDC+HID'`` も同様です)。"

#: ../../library/pyb.rst:279
msgid ""
"The *port* parameter should be an integer (0, 1, ...) and selects which "
"USB port to use if the board supports multiple ports.  A value of -1 uses"
" the default or automatically selected port."
msgstr ""
"*port* パラメータには整数(0, 1, ...)を指定し、ボードが複数の USB ポートをサポート"
している場合に使う USB ポートを選択します。値が -1 である場合は、デフォルトまたは"
"自動的に選択された USB ポートを使います。"

#: ../../library/pyb.rst:283
msgid ""
"The *vid* and *pid* parameters allow you to specify the VID (vendor id) "
"and PID (product id).  A *pid* value of -1 will select a PID based on the"
" value of *modestr*."
msgstr ""
"*vid* と *pid* パラメータは、VID (ベンダID)と PID (プロダクトID)を指定します。 "
"*pid* の値が -1 である場合は *modestr* の値に基づいて PID を選択します。"

#: ../../library/pyb.rst:287
msgid ""
"If enabling MSC mode, the *msc* parameter can be used to specify a list "
"of SCSI LUNs to expose on the mass storage interface.  For example "
"``msc=(pyb.Flash(), pyb.SDCard())``."
msgstr ""
"MSC モードを有効にする場合、 *msc* パラメーターを使ってマスストレージインターフェイスで"
"公開する SCSI LUN のリストを指定できます。たとえば "
"``msc=(pyb.Flash(), pyb.SDCard())`` と指定します。"

#: ../../library/pyb.rst:291
msgid ""
"If enabling HID mode, you may also specify the HID details by passing the"
" *hid* keyword parameter.  It takes a tuple of (subclass, protocol, max "
"packet length, polling interval, report descriptor).  By default it will "
"set appropriate values for a USB mouse.  There is also a "
"``pyb.hid_keyboard`` constant, which is an appropriate tuple for a USB "
"keyboard."
msgstr ""
"HID モードを有効にする場合、 *hid* キーワードパラメータを渡して HID の詳細を指定"
"することもできます。それは (subclass, protocol, max packet length, polling "
"interval, report descriptor) のタプルを引数に取ります。デフォルトでは USB "
"マウスに適切な値を設定します。USB キーボードに適したタプルである "
"``pyb.hid_keyboard`` 定数もあります。"

#: ../../library/pyb.rst:298
msgid ""
"The *high_speed* parameter, when set to ``True``, enables USB HS mode if "
"it is supported by the hardware."
msgstr ""
"*high_speed* パラメータを ``True`` に設定すると、ハードウェアでサポートされていれば "
"USB HS モードが有効になります。"

#: ../../../library/pyb.ADC.rst:9
msgid ""
"import pyb\n"
"\n"
"adc = pyb.ADC(pin)                  # create an analog object from a pin\n"
"val = adc.read()                    # read an analog value\n"
"\n"
"adc = pyb.ADCAll(resolution)        # create an ADCAll object\n"
"adc = pyb.ADCAll(resolution, mask)  # create an ADCAll object for "
"selected analog channels\n"
"val = adc.read_channel(channel)     # read the given channel\n"
"val = adc.read_core_temp()          # read MCU temperature\n"
"val = adc.read_core_vbat()          # read MCU VBAT\n"
"val = adc.read_core_vref()          # read MCU VREF\n"
"val = adc.read_vref()               # read MCU supply voltage"
msgstr ""
"import pyb\n"
"\n"
"adc = pyb.ADC(pin)                  # ピンからアナログオブジェクトを作成\n"
"val = adc.read()                    # アナログ値の読み取り\n"
"\n"
"adc = pyb.ADCAll(resolution)        # ADCAll オブジェクトを作成\n"
"adc = pyb.ADCAll(resolution, mask)  # 指定のアナログチャンネルの ADCAll オブジェクトを作成\n"
"val = adc.read_channel(channel)     # 指定のチャンネルの読み取り\n"
"val = adc.read_core_temp()          # MCU 温度の読み取り\n"
"val = adc.read_core_vbat()          # MCU VBAT の読み取り\n"
"val = adc.read_core_vref()          # MCU VREF の読み取り\n"
"val = adc.read_vref()               # MCU 供給電圧の読み取り"

#: ../../../library/pyb.ADC.rst:28
msgid ""
"Create an ADC object associated with the given pin. This allows you to "
"then read analog values on that pin."
msgstr ""
"指定したピンに関連付けた ADC オブジェクトを作成します。これにより、指定のピンの"
"アナログ値を読み取れます。"

#: ../../../library/pyb.ADC.rst:36
msgid ""
"Read the value on the analog pin and return it.  The returned value will "
"be between 0 and 4095."
msgstr ""
"アナログピンの値を読み取って返します。返される値は 0-4095 の間です。"

#: ../../../library/pyb.ADC.rst:41
msgid "Read analog values into ``buf`` at a rate set by the ``timer`` object."
msgstr ""
"``timer`` オブジェクトで指定のレートで ``buf`` にアナログ値を読み込みます。"

#: ../../../library/pyb.ADC.rst:43
msgid ""
"``buf`` can be bytearray or array.array for example.  The ADC values have"
" 12-bit resolution and are stored directly into ``buf`` if its element "
"size is 16 bits or greater.  If ``buf`` has only 8-bit elements (eg a "
"bytearray) then the sample resolution will be reduced to 8 bits."
msgstr ""
"``buf`` には、たとえば ``bytearray`` や ``array.array`` にできます。 "
"``buf`` の項目のサイズが 16 ビット以上であれば、ADC 値は 12 ビットの分解能を持ち、"
"値を ``buf`` に直接格納されます。 ``buf`` の項目の幅が 8 ビットしかない場合
"(バイト配列など)、サンプリングの解像度は 8 ビットに減少します。"

#: ../../../library/pyb.ADC.rst:48
msgid ""
"``timer`` should be a Timer object, and a sample is read each time the "
"timer triggers.  The timer must already be initialised and running at the"
" desired sampling frequency."
msgstr ""
"``timer`` は Timer オブジェクトである必要があります。タイマーがトリガーされるたびに"
"サンプルが読み込まれます。タイマーは予め初期化しておき、目的のサンプリング周波数で"
"実行されている必要があります。"

#: ../../../library/pyb.ADC.rst:52
msgid ""
"To support previous behaviour of this function, ``timer`` can also be an "
"integer which specifies the frequency (in Hz) to sample at.  In this case"
" Timer(6) will be automatically configured to run at the given frequency."
msgstr ""
"この関数の以前の動作をサポートするため、 ``timer`` にはサンプリング周波数(Hz)を整数値で"
"指定することもできます。この場合、指定の周波数で動作するよう ``Timer(6)`` が自動的に"
"構成されます。"

#: ../../../library/pyb.ADC.rst:56
msgid "Example using a Timer object (preferred way)::"
msgstr ""
"Timer オブジェクトを使った例(推奨する方法):"

#: ../../../library/pyb.ADC.rst:58
msgid ""
"adc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\n"
"tim = pyb.Timer(6, freq=10)         # create a timer running at 10Hz\n"
"buf = bytearray(100)                # creat a buffer to store the samples"
"\n"
"adc.read_timed(buf, tim)            # sample 100 values, taking 10s"
msgstr ""
"adc = pyb.ADC(pyb.Pin.board.X19)    # ピン X19 の ADC を作成\n"
"tim = pyb.Timer(6, freq=10)         # 10Hz で動作するタイマーを作成\n"
"buf = bytearray(100)                # 採取データを格納するバッファを作成\n"
"adc.read_timed(buf, tim)            # 10秒かけて 100 の値を採取"

#: ../../../library/pyb.ADC.rst:63
msgid "Example using an integer for the frequency::"
msgstr ""
"周波数に整数値を使った例:"

#: ../../../library/pyb.ADC.rst:65
msgid ""
"adc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\n"
"buf = bytearray(100)                # create a buffer of 100 bytes\n"
"adc.read_timed(buf, 10)             # read analog values into buf at 10Hz"
"\n"
"                                    #   this will take 10 seconds to "
"finish\n"
"for val in buf:                     # loop over all values\n"
"    print(val)                      # print the value out"
msgstr ""
"adc = pyb.ADC(pyb.Pin.board.X19)    # ピン X19 の ADC を作成\n"
"buf = bytearray(100)                # 100バイトのバッファを作成\n"
"adc.read_timed(buf, 10)             # 10Hz でアナログ値を buf に読込み\n"
"                                    #   これは完了するまでに10秒かかります\n"
"for val in buf:                     # すべての値を巡回し\n"
"    print(val)                      # 値を印字"

#: ../../../library/pyb.ADC.rst:72
msgid ""
"This function does not allocate any heap memory. It has blocking "
"behaviour: it does not return to the calling program until the buffer is "
"full."
msgstr ""
"この関数はヒープメモリを割り当てません。"
"ブロッキングがあり、バッファがいっぱいになるまで、呼び出し元プログラムに戻りません。"

#: ../../../library/pyb.ADC.rst:77
msgid ""
"This is a static method. It can be used to extract relative timing or "
"phase data from multiple ADC's."
msgstr ""
"これは静的メソッドです。複数の ADC から相対的なタイミングで抽出したり、"
"位相データを抽出するために使われます。"

#: ../../../library/pyb.ADC.rst:80
msgid ""
"It reads analog values from multiple ADC's into buffers at a rate set by "
"the *timer* object. Each time the timer triggers a sample is rapidly read"
" from each ADC in turn."
msgstr ""
"*timer* オブジェクトで指定したレートで、複数の ADC からアナログ値をバッファに読み込みます。"
"タイマーがトリガーするたびに、順番に各 ADC からサンプルが迅速に読み取ります。"

#: ../../../library/pyb.ADC.rst:84
msgid ""
"ADC and buffer instances are passed in tuples with each ADC having an "
"associated buffer. All buffers must be of the same type and length and "
"the number of buffers must equal the number of ADC's."
msgstr ""
"ADC および バッファのインスタンスはタプルで渡し、各 ADC には関連するバッファーがあります。"
"すべてのバッファは同じタイプと長さでなければならず、バッファの数は ADC の数と等しく"
"なければなりません。"

#: ../../../library/pyb.ADC.rst:88
msgid ""
"Buffers can be ``bytearray`` or ``array.array`` for example. The ADC "
"values have 12-bit resolution and are stored directly into the buffer if "
"its element size is 16 bits or greater.  If buffers have only 8-bit "
"elements (eg a ``bytearray``) then the sample resolution will be reduced "
"to 8 bits."
msgstr ""
"バッファは、たとえば ``bytearray`` や ``array.array`` にできます。 "
"``buf`` の項目のサイズが 16 ビット以上であれば、ADC 値は 12 ビットの分解能を持ち、"
"値を ``buf`` に直接格納されます。 ``buf`` の項目の幅が 8 ビットしかない場合
"(バイト配列など)、サンプリングの解像度は 8 ビットに減少します。"

#: ../../../library/pyb.ADC.rst:93
msgid ""
"*timer* must be a Timer object. The timer must already be initialised and"
" running at the desired sampling frequency."
msgstr ""
"``timer`` は Timer オブジェクトである必要があります。"
"タイマーは予め初期化しておき、目的のサンプリング周波数で実行されている必要があります。"

#: ../../../library/pyb.ADC.rst:96
msgid "Example reading 3 ADC's::"
msgstr "3つの ADC を読み取る例::"

#: ../../../library/pyb.ADC.rst:98
msgid ""
"adc0 = pyb.ADC(pyb.Pin.board.X1)    # Create ADC's\n"
"adc1 = pyb.ADC(pyb.Pin.board.X2)\n"
"adc2 = pyb.ADC(pyb.Pin.board.X3)\n"
"tim = pyb.Timer(8, freq=100)        # Create timer\n"
"rx0 = array.array('H', (0 for i in range(100))) # ADC buffers of\n"
"rx1 = array.array('H', (0 for i in range(100))) # 100 16-bit words\n"
"rx2 = array.array('H', (0 for i in range(100)))\n"
"# read analog values into buffers at 100Hz (takes one second)\n"
"pyb.ADC.read_timed_multi((adc0, adc1, adc2), (rx0, rx1, rx2), tim)\n"
"for n in range(len(rx0)):\n"
"    print(rx0[n], rx1[n], rx2[n])"
msgstr ""
"adc0 = pyb.ADC(pyb.Pin.board.X1)    # ADC の作成\n"
"adc1 = pyb.ADC(pyb.Pin.board.X2)\n"
"adc2 = pyb.ADC(pyb.Pin.board.X3)\n"
"tim = pyb.Timer(8, freq=100)        # タイマーの作成\n"
"rx0 = array.array('H', (0 for i in range(100))) # 16ビット幅の\n"
"rx1 = array.array('H', (0 for i in range(100))) # 100 項目のバッファを作成\n"
"rx2 = array.array('H', (0 for i in range(100)))\n"
"# アナログ値を 100Hz でバッファに読込み(1秒かかる)\n"
"pyb.ADC.read_timed_multi((adc0, adc1, adc2), (rx0, rx1, rx2), tim)\n"
"for n in range(len(rx0)):\n"
"    print(rx0[n], rx1[n], rx2[n])"

#: ../../../library/pyb.ADC.rst:110
msgid ""
"This function does not allocate any heap memory. It has blocking "
"behaviour: it does not return to the calling program until the buffers "
"are full."
msgstr ""
"この関数はヒープメモリを割り当てません。"
"ブロッキングがあり、バッファがいっぱいになるまで、呼び出し元プログラムに戻りません。"

#: ../../../library/pyb.ADC.rst:113
msgid ""
"The function returns ``True`` if all samples were acquired with correct "
"timing. At high sample rates the time taken to acquire a set of samples "
"can exceed the timer period. In this case the function returns ``False``,"
" indicating a loss of precision in the sample interval. In extreme cases "
"samples may be missed."
msgstr ""
"すべての採取が正しいタイミングで取得された場合、関数は ``True`` を返します。"
"サンプリングレートが高い場合、データセットの取得にかかる時間がタイマー期間を"
"超える可能性があります。この場合、関数は ``False`` を返し、サンプリングの"
"精度が失われたことを示します。極端な場合、データ採取が欠落することもあります。"

#: ../../../library/pyb.ADC.rst:119
msgid ""
"The maximum rate depends on factors including the data width and the "
"number of ADC's being read. In testing two ADC's were sampled at a timer "
"rate of 210kHz without overrun. Samples were missed at 215kHz.  For three"
" ADC's the limit is around 140kHz, and for four it is around 110kHz. At "
"high sample rates disabling interrupts for the duration can reduce the "
"risk of sporadic data loss."
msgstr ""
"最大レートはデータ幅や読み取られる ADC の数などの要因によって異なります。"
"テストでは、2つの ADC がオーバーランなしで 210kHz のタイマーレートで"
"サンプリングされました。採取データは 215kHz で欠落しました。"
"3つの ADC の制限は約 140kHz で、4つのADCの場合は約 110kHz です。"
"高いサンプルレートでは、その期間中の割り込みを無効にすると、散発的なデータ損失の"
"リスクを減らすことができます。"

#: ../../../library/pyb.ADC.rst:127
msgid "The ADCAll Object"
msgstr "ADCALL オブジェクト"

#: ../../../library/pyb.ADC.rst:129
msgid ""
"Instantiating this changes all masked ADC pins to analog inputs. The "
"preprocessed MCU temperature, VREF and VBAT data can be accessed on ADC "
"channels 16, 17 and 18 respectively. Appropriate scaling is handled "
"according to reference voltage used (usually 3.3V). The temperature "
"sensor on the chip is factory calibrated and allows to read the die "
"temperature to +/- 1 degree centigrade. Although this sounds pretty "
"accurate, don't forget that the MCU's internal temperature is measured. "
"Depending on processing loads and I/O subsystems active the die "
"temperature may easily be tens of degrees above ambient temperature. On "
"the other hand a pyboard woken up after a long standby period will show "
"correct ambient temperature within limits mentioned above."
msgstr ""
"これをインスタンス化すると、マスクされたすべての ADC ピンがアナログ入力に変更されます。"
"前処理された MCU 温度、VREF、VBAT データは、それぞれ ADC チャネル 16, 17, 18 で"
"アクセスできます。適切なスケーリングは、使用される基準電圧（通常3.3V）に従って処理されます。"
"チップ上の温度センサーは工場で較正されており、ダイ温度を摂氏 +/- 1度の精度で読み取る"
"ことができます。これはかなり正確に聞こえますが、MCU の内部温度が測定されることを忘れないで"
"ください。処理負荷とアクティブな I/O サブシステムによっては、ダイ温度が周囲温度よりも"
"数十度高くなることがあります。その一方で、長い待機期間から起床した直後の pyboard は、"
"上記の制限内で正しい周囲温度を示します。"

#: ../../../library/pyb.ADC.rst:138
msgid ""
"The ``ADCAll`` ``read_core_vbat()``, ``read_vref()`` and "
"``read_core_vref()`` methods read the backup battery voltage, reference "
"voltage and the (1.21V nominal) reference voltage using the actual supply"
" as a reference. All results are floating point numbers giving direct "
"voltage values."
msgstr ""
"``ADCAll`` の ``read_core_vbat()``, ``read_vref()``, ``read_core_vref()`` "
"メソッドは、それぞれバックアップバッテリー電圧、基準電圧、実際の供給電圧を用いた基準電圧"
"(公称 1.21V)を読み出します。戻り値はどのメソッドも電圧値を示す浮動小数点数です。"

#: ../../../library/pyb.ADC.rst:142
msgid ""
"``read_core_vbat()`` returns the voltage of the backup battery. This "
"voltage is also adjusted according to the actual supply voltage. To avoid"
" analog input overload the battery voltage is measured via a voltage "
"divider and scaled according to the divider value. To prevent excessive "
"loads to the backup battery, the voltage divider is only active during "
"ADC conversion."
msgstr ""
"``read_core_vbat()`` はバックアップバッテリーの電圧を返します。"
"この電圧も実際の供給電圧に応じて調整されます。アナログ入力の過負荷を避けるため、"
"バッテリー電圧は分圧器を介して計測し、分圧器の値に応じてスケーリングします。"
"バックアップバッテリーへの過度の負荷を防ぐため、分圧器は ADC 変換中のみアクティブに"
"なります。"

#: ../../../library/pyb.ADC.rst:147
msgid ""
"``read_vref()`` is evaluated by measuring the internal voltage reference "
"and backscale it using factory calibration value of the internal voltage "
"reference. In most cases the reading would be close to 3.3V. If the "
"pyboard is operated from a battery, the supply voltage may drop to values"
" below 3.3V. The pyboard will still operate fine as long as the operating"
" conditions are met. With proper settings of MCU clock, flash access "
"speed and programming mode it is possible to run the pyboard down to 2 V "
"and still get useful ADC conversion."
msgstr ""
"``read_vref()`` は内部基準電圧を計測し、内部基準電圧の工場校正値を使ってバックスケール"
"することにより求めます。ほとんどの場合、読み取り値は 3.3V に近くなります。pyboard が"
"バッテリーで動作している場合、供給電圧が 3.3V 未満の値に低下する場合があります。"
"動作条件が満たされている限り、pyboard は引き続き正常に動作します。MCU クロック、"
"フラッシュアクセス速度、プログラミングモードを適切に設定することにより、pyboard を 2V "
"まで落として実行しても、有用なADC変換を得ることができます。"

#: ../../../library/pyb.ADC.rst:154
msgid ""
"It is very important to make sure analog input voltages never exceed "
"actual supply voltage."
msgstr ""
"アナログ入力電圧が実際の供給電圧を超えないようにすることは非常に重要です。"

#: ../../../library/pyb.ADC.rst:156
msgid ""
"Other analog input channels (0..15) will return unscaled integer values "
"according to the selected precision."
msgstr ""
"他のアナログ入力チャンネル (0..15) は、指定の精度で、スケーリングしない整数値を返します。"

#: ../../../library/pyb.ADC.rst:159
msgid ""
"To avoid unwanted activation of analog inputs (channel 0..15) a second "
"parameter can be specified. This parameter is a binary pattern where each"
" requested analog input has the corresponding bit set. The default value "
"is 0xffffffff which means all analog inputs are active. If just the "
"internal channels (16..18) are required, the mask value should be "
"0x70000."
msgstr ""
"アナログ入力(チャンネル 0..15)の不要な有効化を回避するために、第２パラメーターを指定できます。"
"このパラメーターは、アナログ入力を望むチャンネルに対応するビットセットを持つバイナリパターンです。"
"デフォルト値は 0xffffffff で、これはすべてのアナログ入力が有効であることを意味します。"
"内部チャネル (16..18) のみが必要な場合、マスク値は 0x70000 でなければなりません。"

#: ../../../<rst_epilog>:166
msgid ""
"adcall = pyb.ADCAll(12, 0x70000) # 12 bit resolution, internal channels\n"
"temp = adcall.read_core_temp()"
msgstr ""
"adcall = pyb.ADCAll(12, 0x70000) # 12 ビットの分解能で、内部チャンネルのみ"
"temp = adcall.read_core_temp()"

#: ../../../library/pyb.Accel.rst:5
msgid "class Accel -- accelerometer control"
msgstr "クラス Accel - 加速度センサー制御"

#: ../../../library/pyb.Accel.rst:7
msgid "Accel is an object that controls the accelerometer.  Example usage::"
msgstr "Accelは加速度センサーを制御するオブジェクトです。たとえば次のように使います::"

#: ../../../library/pyb.Accel.rst:9
msgid ""
"accel = pyb.Accel()\n"
"for i in range(10):\n"
"    print(accel.x(), accel.y(), accel.z())"
msgstr ""

#: ../../../library/pyb.Accel.rst:13
msgid "Raw values are between -32 and 31."
msgstr "生の値は -32 と 31 の間になります。"

#: ../../../library/pyb.Accel.rst:21
msgid "Create and return an accelerometer object."
msgstr "加速度センサーオブジェクトを作成して返します。"

#: ../../../library/pyb.Accel.rst:28
msgid "Get a 3-tuple of filtered x, y and z values."
msgstr "フィルター処理された x、y、z 軸の値を3項目のタプルで返します。"

#: ../../../library/pyb.Accel.rst:30
msgid ""
"Implementation note: this method is currently implemented as taking the "
"sum of 4 samples, sampled from the 3 previous calls to this function "
"along with the sample from the current call.  Returned values are "
"therefore 4 times the size of what they would be from the raw x(), y() "
"and z() calls."
msgstr ""
"実装に関する注記: このメソッドは現在のところ、呼び出し時のサンプルと一緒に、"
"この関数の前3回の呼び出しからサンプリングされた4つのサンプルの合計を取るように"
"実装されています。したがって、戻り値は、生の x(), y(), z() 呼出しの4倍程度の"
"値となります。"

#: ../../../library/pyb.Accel.rst:37
msgid "Get the tilt register."
msgstr "傾斜レジスタを取得します。"

#: ../../../library/pyb.Accel.rst:41
msgid "Get the x-axis value."
msgstr "x 軸の値を取得します。"

#: ../../../library/pyb.Accel.rst:45
msgid "Get the y-axis value."
msgstr "y 軸の値を取得します。"

#: ../../../library/pyb.Accel.rst:49
msgid "Get the z-axis value."
msgstr "z 軸の値を取得します。"

#: ../../../library/pyb.Accel.rst:52
msgid "Hardware Note"
msgstr "ハードウェアに関する注記"

#: ../../../library/pyb.Accel.rst:54
msgid ""
"The accelerometer uses I2C bus 1 to communicate with the processor. "
"Consequently when readings are being taken pins X9 and X10 should be "
"unused (other than for I2C). Other devices using those pins, and which "
"therefore cannot be used concurrently, are UART 1 and Timer 4 channels 1 "
"and 2."
msgstr ""
"加速度センサーはプロセッサと通信するためにI2Cバス1を使用します。"
"その結果、読み取りが行われているとき、ピン X9 と X10 は(I2C 以外で)使わないように"
"すべきです。これらのピンを使うデバイス(つまり加速度センサーと同時に使えないデバイス)は、"
"UART 1 とタイマ 4 のチャネル 1 と 2 です。"

#: ../../../library/pyb.CAN.rst:5
msgid "class CAN -- controller area network communication bus"
msgstr ""

#: ../../../library/pyb.CAN.rst:7
msgid ""
"CAN implements the standard CAN communications protocol.  At the physical"
" level it consists of 2 lines: RX and TX.  Note that to connect the "
"pyboard to a CAN bus you must use a CAN transceiver to convert the CAN "
"logic signals from the pyboard to the correct voltage levels on the bus."
msgstr ""

#: ../../../library/pyb.CAN.rst:13
msgid "Example usage (works without anything connected)::"
msgstr ""

#: ../../../library/pyb.CAN.rst:15
msgid ""
"from pyb import CAN\n"
"can = CAN(1, CAN.LOOPBACK)\n"
"can.setfilter(0, CAN.LIST16, 0, (123, 124, 125, 126))  # set a filter to "
"receive messages with id=123, 124, 125 and 126\n"
"can.send('message!', 123)   # send a message with id 123\n"
"can.recv(0)                 # receive message on FIFO 0"
msgstr ""

#: ../../../library/pyb.CAN.rst:27
msgid ""
"Construct a CAN object on the given bus.  *bus* can be 1-2, or ``'YA'`` "
"or ``'YB'``. With no additional parameters, the CAN object is created but"
" not initialised (it has the settings from the last initialisation of the"
" bus, if any).  If extra arguments are given, the bus is initialised. See"
" :meth:`CAN.init` for parameters of initialisation."
msgstr ""

#: ../../../library/pyb.CAN.rst:33
msgid "The physical pins of the CAN busses are:"
msgstr ""

#: ../../../library/pyb.CAN.rst:35
msgid "``CAN(1)`` is on ``YA``: ``(RX, TX) = (Y3, Y4) = (PB8, PB9)``"
msgstr ""

#: ../../../library/pyb.CAN.rst:36
msgid "``CAN(2)`` is on ``YB``: ``(RX, TX) = (Y5, Y6) = (PB12, PB13)``"
msgstr ""

#: ../../../library/pyb.CAN.rst:39
msgid "Class Methods"
msgstr ""

#: ../../../library/pyb.CAN.rst:42
msgid ""
"Reset and disable all filter banks and assign how many banks should be "
"available for CAN(1)."
msgstr ""

#: ../../../library/pyb.CAN.rst:44
msgid ""
"STM32F405 has 28 filter banks that are shared between the two available "
"CAN bus controllers. This function configures how many filter banks "
"should be assigned to each. *nr* is the number of banks that will be "
"assigned to CAN(1), the rest of the 28 are assigned to CAN(2). At boot, "
"14 banks are assigned to each controller."
msgstr ""

#: ../../../library/pyb.CAN.rst:54
msgid "Initialise the CAN bus with the given parameters:"
msgstr ""

#: ../../../library/pyb.CAN.rst:56
msgid "*mode* is one of:  NORMAL, LOOPBACK, SILENT, SILENT_LOOPBACK"
msgstr ""

#: ../../../library/pyb.CAN.rst:57
msgid ""
"if *extframe* is True then the bus uses extended identifiers in the "
"frames (29 bits); otherwise it uses standard 11 bit identifiers"
msgstr ""

#: ../../../library/pyb.CAN.rst:59
msgid ""
"*prescaler* is used to set the duration of 1 time quanta; the time quanta"
" will be the input clock (PCLK1, see :meth:`pyb.freq()`) divided by the "
"prescaler"
msgstr ""

#: ../../../library/pyb.CAN.rst:61
msgid ""
"*sjw* is the resynchronisation jump width in units of the time quanta; it"
" can be 1, 2, 3, 4"
msgstr ""

#: ../../../library/pyb.CAN.rst:63
msgid ""
"*bs1* defines the location of the sample point in units of the time "
"quanta; it can be between 1 and 1024 inclusive"
msgstr ""

#: ../../../library/pyb.CAN.rst:65
msgid ""
"*bs2* defines the location of the transmit point in units of the time "
"quanta; it can be between 1 and 16 inclusive"
msgstr ""

#: ../../../library/pyb.CAN.rst:67
msgid ""
"*auto_restart* sets whether the controller will automatically try and "
"restart communications after entering the bus-off state; if this is "
"disabled then :meth:`~CAN.restart()` can be used to leave the bus-off "
"state"
msgstr ""

#: ../../../library/pyb.CAN.rst:71
msgid ""
"The time quanta tq is the basic unit of time for the CAN bus.  tq is the "
"CAN prescaler value divided by PCLK1 (the frequency of internal "
"peripheral bus 1); see :meth:`pyb.freq()` to determine PCLK1."
msgstr ""

#: ../../../library/pyb.CAN.rst:75
msgid ""
"A single bit is made up of the synchronisation segment, which is always 1"
" tq. Then follows bit segment 1, then bit segment 2.  The sample point is"
" after bit segment 1 finishes.  The transmit point is after bit segment 2"
" finishes. The baud rate will be 1/bittime, where the bittime is 1 + BS1 "
"+ BS2 multiplied by the time quanta tq."
msgstr ""

#: ../../../library/pyb.CAN.rst:81
msgid ""
"For example, with PCLK1=42MHz, prescaler=100, sjw=1, bs1=6, bs2=8, the "
"value of tq is 2.38 microseconds.  The bittime is 35.7 microseconds, and "
"the baudrate is 28kHz."
msgstr ""

#: ../../../library/pyb.CAN.rst:85
msgid "See page 680 of the STM32F405 datasheet for more details."
msgstr ""

#: ../../../library/pyb.CAN.rst:89
msgid "Turn off the CAN bus."
msgstr ""

#: ../../../library/pyb.CAN.rst:93
msgid ""
"Force a software restart of the CAN controller without resetting its "
"configuration."
msgstr ""

#: ../../../library/pyb.CAN.rst:96
msgid ""
"If the controller enters the bus-off state then it will no longer "
"participate in bus activity.  If the controller is not configured to "
"automatically restart (see :meth:`~CAN.init()`) then this method can be "
"used to trigger a restart, and the controller will follow the CAN "
"protocol to leave the bus-off state and go into the error active state."
msgstr ""

#: ../../../library/pyb.CAN.rst:104
msgid "Return the state of the controller.  The return value can be one of:"
msgstr ""

#: ../../../library/pyb.CAN.rst:106
msgid "``CAN.STOPPED`` -- the controller is completely off and reset;"
msgstr ""

#: ../../../library/pyb.CAN.rst:107
msgid ""
"``CAN.ERROR_ACTIVE`` -- the controller is on and in the Error Active "
"state (both TEC and REC are less than 96);"
msgstr ""

#: ../../../library/pyb.CAN.rst:109
msgid ""
"``CAN.ERROR_WARNING`` -- the controller is on and in the Error Warning "
"state (at least one of TEC or REC is 96 or greater);"
msgstr ""

#: ../../../library/pyb.CAN.rst:111
msgid ""
"``CAN.ERROR_PASSIVE`` -- the controller is on and in the Error Passive "
"state (at least one of TEC or REC is 128 or greater);"
msgstr ""

#: ../../../library/pyb.CAN.rst:113
msgid ""
"``CAN.BUS_OFF`` -- the controller is on but not participating in bus "
"activity (TEC overflowed beyond 255)."
msgstr ""

#: ../../../library/pyb.CAN.rst:118
msgid ""
"Get information about the controller's error states and TX and RX "
"buffers. If *list* is provided then it should be a list object with at "
"least 8 entries, which will be filled in with the information.  Otherwise"
" a new list will be created and filled in.  In both cases the return "
"value of the method is the populated list."
msgstr ""

#: ../../../library/pyb.CAN.rst:124
msgid "The values in the list are:"
msgstr ""

#: ../../../library/pyb.CAN.rst:126
msgid "TEC value"
msgstr ""

#: ../../../library/pyb.CAN.rst:127
msgid "REC value"
msgstr ""

#: ../../../library/pyb.CAN.rst:128
msgid ""
"number of times the controller enterted the Error Warning state (wrapped "
"around to 0 after 65535)"
msgstr ""

#: ../../../library/pyb.CAN.rst:130
msgid ""
"number of times the controller enterted the Error Passive state (wrapped "
"around to 0 after 65535)"
msgstr ""

#: ../../../library/pyb.CAN.rst:132
msgid ""
"number of times the controller enterted the Bus Off state (wrapped around"
" to 0 after 65535)"
msgstr ""

#: ../../../library/pyb.CAN.rst:134
msgid "number of pending TX messages"
msgstr ""

#: ../../../library/pyb.CAN.rst:135
msgid "number of pending RX messages on fifo 0"
msgstr ""

#: ../../../library/pyb.CAN.rst:136
msgid "number of pending RX messages on fifo 1"
msgstr ""

#: ../../../library/pyb.CAN.rst:140
msgid "Configure a filter bank:"
msgstr ""

#: ../../../library/pyb.CAN.rst:142
msgid "*bank* is the filter bank that is to be configured."
msgstr ""

#: ../../../library/pyb.CAN.rst:143
msgid "*mode* is the mode the filter should operate in."
msgstr ""

#: ../../../library/pyb.CAN.rst:144
msgid ""
"*fifo* is which fifo (0 or 1) a message should be stored in, if it is "
"accepted by this filter."
msgstr ""

#: ../../../library/pyb.CAN.rst:145
msgid ""
"*params* is an array of values the defines the filter. The contents of "
"the array depends on the *mode* argument."
msgstr ""

#: ../../../library/pyb.CAN.rst:148 ../../../library/pyb.CAN.rst:169
msgid "*mode*"
msgstr ""

#: ../../../library/pyb.CAN.rst:148
msgid "contents of *params* array"
msgstr ""

#: ../../../library/pyb.CAN.rst:150 ../../../library/pyb.CAN.rst:171
msgid "CAN.LIST16"
msgstr ""

#: ../../../library/pyb.CAN.rst:150
msgid "Four 16 bit ids that will be accepted"
msgstr ""

#: ../../../library/pyb.CAN.rst:152 ../../../library/pyb.CAN.rst:173
msgid "CAN.LIST32"
msgstr ""

#: ../../../library/pyb.CAN.rst:152
msgid "Two 32 bit ids that will be accepted"
msgstr ""

#: ../../../library/pyb.CAN.rst:154 ../../../library/pyb.CAN.rst:175
msgid "CAN.MASK16"
msgstr ""

#: ../../../library/pyb.CAN.rst:157
msgid "Two 16 bit id/mask pairs. E.g. (1, 3, 4, 4)"
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "The first pair, 1 and 3 will accept all ids"
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "that have bit 0 = 1 and bit 1 = 0."
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "The second pair, 4 and 4, will accept all ids"
msgstr ""

#: ../../../library/pyb.CAN.rst
msgid "that have bit 2 = 1."
msgstr ""

#: ../../../library/pyb.CAN.rst:160 ../../../library/pyb.CAN.rst:177
msgid "CAN.MASK32"
msgstr ""

#: ../../../library/pyb.CAN.rst:160
msgid "As with CAN.MASK16 but with only one 32 bit id/mask pair."
msgstr ""

#: ../../../library/pyb.CAN.rst:163
msgid ""
"*rtr* is an array of booleans that states if a filter should accept a "
"remote transmission request message.  If this argument is not given then "
"it defaults to ``False`` for all entries.  The length of the array "
"depends on the *mode* argument."
msgstr ""

#: ../../../library/pyb.CAN.rst:169
msgid "length of *rtr* array"
msgstr ""

#: ../../../library/pyb.CAN.rst:171
msgid "4"
msgstr ""

#: ../../../library/pyb.CAN.rst:173 ../../../library/pyb.CAN.rst:175
#: ../../../library/pyb.CAN.rst:260
msgid "2"
msgstr ""

#: ../../../library/pyb.CAN.rst:177 ../../../library/pyb.CAN.rst:258
msgid "1"
msgstr ""

#: ../../../library/pyb.CAN.rst:182
msgid "Clear and disables a filter bank:"
msgstr ""

#: ../../../library/pyb.CAN.rst:184
msgid "*bank* is the filter bank that is to be cleared."
msgstr ""

#: ../../../library/pyb.CAN.rst:188
msgid "Return ``True`` if any message waiting on the FIFO, else ``False``."
msgstr ""

#: ../../../library/pyb.CAN.rst:192 ../../../library/pyb.I2C.rst:131
#: ../../../library/pyb.SPI.rst:81 ../../../library/pyb.USB_HID.rst:26
#: ../../../library/pyb.USB_VCP.rst:87
msgid "Receive data on the bus:"
msgstr ""

#: ../../../library/pyb.CAN.rst:194
msgid "*fifo* is an integer, which is the FIFO to receive on"
msgstr ""

#: ../../../library/pyb.CAN.rst:195
msgid "*list* is an optional list object to be used as the return value"
msgstr ""

#: ../../../library/pyb.CAN.rst:196
msgid "*timeout* is the timeout in milliseconds to wait for the receive."
msgstr ""

#: ../../../library/pyb.CAN.rst:198
msgid "Return value: A tuple containing four values."
msgstr ""

#: ../../../library/pyb.CAN.rst:200
msgid "The id of the message."
msgstr ""

#: ../../../library/pyb.CAN.rst:201
msgid "A boolean that indicates if the message is an RTR message."
msgstr ""

#: ../../../library/pyb.CAN.rst:202
msgid "The FMI (Filter Match Index) value."
msgstr ""

#: ../../../library/pyb.CAN.rst:203
msgid "An array containing the data."
msgstr ""

#: ../../../library/pyb.CAN.rst:205
msgid ""
"If *list* is ``None`` then a new tuple will be allocated, as well as a "
"new bytes object to contain the data (as the fourth element in the "
"tuple)."
msgstr ""

#: ../../../library/pyb.CAN.rst:208
msgid ""
"If *list* is not ``None`` then it should be a list object with a least "
"four elements.  The fourth element should be a memoryview object which is"
" created from either a bytearray or an array of type 'B' or 'b', and this"
" array must have enough room for at least 8 bytes.  The list object will "
"then be populated with the first three return values above, and the "
"memoryview object will be resized inplace to the size of the data and "
"filled in with that data. The same list and memoryview objects can be "
"reused in subsequent calls to this method, providing a way of receiving "
"data without using the heap. For example::"
msgstr ""

#: ../../../library/pyb.CAN.rst:218
msgid ""
"buf = bytearray(8)\n"
"lst = [0, 0, 0, memoryview(buf)]\n"
"# No heap memory is allocated in the following call\n"
"can.recv(0, lst)"
msgstr ""

#: ../../../library/pyb.CAN.rst:225
msgid "Send a message on the bus:"
msgstr ""

#: ../../../library/pyb.CAN.rst:227
msgid "*data* is the data to send (an integer to send, or a buffer object)."
msgstr ""

#: ../../../library/pyb.CAN.rst:228
msgid "*id* is the id of the message to be sent."
msgstr ""

#: ../../../library/pyb.CAN.rst:229
msgid "*timeout* is the timeout in milliseconds to wait for the send."
msgstr ""

#: ../../../library/pyb.CAN.rst:230
msgid ""
"*rtr* is a boolean that specifies if the message shall be sent as a "
"remote transmission request.  If *rtr* is True then only the length of "
"*data* is used to fill in the DLC slot of the frame; the actual bytes in "
"*data* are unused."
msgstr ""

#: ../../../library/pyb.CAN.rst:235
msgid ""
"If timeout is 0 the message is placed in a buffer in one of three "
"hardware buffers and the method returns immediately. If all three buffers"
" are in use an exception is thrown. If timeout is not 0, the method waits"
" until the message is transmitted. If the message can't be transmitted "
"within the specified time an exception is thrown."
msgstr ""

#: ../../../library/pyb.CAN.rst:241 ../../../library/pyb.I2C.rst:149
#: ../../../library/pyb.SPI.rst:97
msgid "Return value: ``None``."
msgstr "戻り値: ``None`` 。"

#: ../../../library/pyb.CAN.rst:245
msgid ""
"Register a function to be called when a message is accepted into a empty "
"fifo:"
msgstr ""

#: ../../../library/pyb.CAN.rst:247
msgid "*fifo* is the receiving fifo."
msgstr ""

#: ../../../library/pyb.CAN.rst:248
msgid "*fun* is the function to be called when the fifo becomes non empty."
msgstr ""

#: ../../../library/pyb.CAN.rst:250
msgid ""
"The callback function takes two arguments the first is the can object it "
"self the second is a integer that indicates the reason for the callback."
msgstr ""

#: ../../../library/pyb.CAN.rst:254
msgid "Reason"
msgstr ""

#: ../../../library/pyb.CAN.rst:256
msgid "0"
msgstr ""

#: ../../../library/pyb.CAN.rst:256
msgid "A message has been accepted into a empty FIFO."
msgstr ""

#: ../../../library/pyb.CAN.rst:258
msgid "The FIFO is full"
msgstr ""

#: ../../../library/pyb.CAN.rst:260
msgid "A message has been lost due to a full FIFO"
msgstr ""

#: ../../../library/pyb.CAN.rst:263
msgid "Example use of rxcallback::"
msgstr ""

#: ../../../library/pyb.CAN.rst:265
msgid ""
"def cb0(bus, reason):\n"
"  print('cb0')\n"
"  if reason == 0:\n"
"      print('pending')\n"
"  if reason == 1:\n"
"      print('full')\n"
"  if reason == 2:\n"
"      print('overflow')\n"
"\n"
"can = CAN(1, CAN.LOOPBACK)\n"
"can.rxcallback(0, cb0)"
msgstr ""

#: ../../../library/pyb.CAN.rst:285
msgid "The mode of the CAN bus used in :meth:`~CAN.init()`."
msgstr ""

#: ../../../library/pyb.CAN.rst:293
msgid "Possible states of the CAN controller returned from :meth:`~CAN.state()`."
msgstr ""

#: ../../../library/pyb.CAN.rst:300
msgid "The operation mode of a filter used in :meth:`~CAN.setfilter()`."
msgstr ""

#: ../../../library/pyb.DAC.rst:5
msgid "class DAC -- digital to analog conversion"
msgstr ""

#: ../../../library/pyb.DAC.rst:7
msgid ""
"The DAC is used to output analog values (a specific voltage) on pin X5 or"
" pin X6. The voltage will be between 0 and 3.3V."
msgstr ""

#: ../../../library/pyb.DAC.rst:10
msgid "*This module will undergo changes to the API.*"
msgstr ""

#: ../../../library/pyb.DAC.rst:14
msgid ""
"from pyb import DAC\n"
"\n"
"dac = DAC(1)            # create DAC 1 on pin X5\n"
"dac.write(128)          # write a value to the DAC (makes X5 1.65V)\n"
"\n"
"dac = DAC(1, bits=12)   # use 12 bit resolution\n"
"dac.write(4095)         # output maximum value, 3.3V"
msgstr ""

#: ../../../library/pyb.DAC.rst:22
msgid "To output a continuous sine-wave::"
msgstr ""

#: ../../../library/pyb.DAC.rst:24
msgid ""
"import math\n"
"from pyb import DAC\n"
"\n"
"# create a buffer containing a sine-wave\n"
"buf = bytearray(100)\n"
"for i in range(len(buf)):\n"
"    buf[i] = 128 + int(127 * math.sin(2 * math.pi * i / len(buf)))\n"
"\n"
"# output the sine-wave at 400Hz\n"
"dac = DAC(1)\n"
"dac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)"
msgstr ""

#: ../../../library/pyb.DAC.rst:36
msgid "To output a continuous sine-wave at 12-bit resolution::"
msgstr ""

#: ../../../library/pyb.DAC.rst:38
msgid ""
"import math\n"
"from array import array\n"
"from pyb import DAC\n"
"\n"
"# create a buffer containing a sine-wave, using half-word samples\n"
"buf = array('H', 2048 + int(2047 * math.sin(2 * math.pi * i / 128)) for i"
" in range(128))\n"
"\n"
"# output the sine-wave at 400Hz\n"
"dac = DAC(1, bits=12)\n"
"dac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)"
msgstr ""

#: ../../../library/pyb.DAC.rst:54
msgid "Construct a new DAC object."
msgstr ""

#: ../../../library/pyb.DAC.rst:56
msgid ""
"``port`` can be a pin object, or an integer (1 or 2). DAC(1) is on pin X5"
" and DAC(2) is on pin X6."
msgstr ""

#: ../../../library/pyb.DAC.rst:59
msgid ""
"``bits`` is an integer specifying the resolution, and can be 8 or 12. The"
" maximum value for the write and write_timed methods will be "
"2\\*\\*``bits``-1."
msgstr ""

#: ../../../library/pyb.DAC.rst:63
msgid ""
"The *buffering* parameter selects the behaviour of the DAC op-amp output "
"buffer, whose purpose is to reduce the output impedance.  It can be "
"``None`` to select the default (buffering enabled for :meth:`DAC.noise`, "
":meth:`DAC.triangle` and :meth:`DAC.write_timed`, and disabled for "
":meth:`DAC.write`), ``False`` to disable buffering completely, or "
"``True`` to enable output buffering."
msgstr ""

#: ../../../library/pyb.DAC.rst:70
msgid ""
"When buffering is enabled the DAC pin can drive loads down to 5KΩ. "
"Otherwise it has an output impedance of 15KΩ maximum: consequently to "
"achieve a 1% accuracy without buffering requires the applied load to be "
"less than 1.5MΩ.  Using the buffer incurs a penalty in accuracy, "
"especially near the extremes of range."
msgstr ""

#: ../../../library/pyb.DAC.rst:81
msgid ""
"Reinitialise the DAC.  *bits* can be 8 or 12.  *buffering* can be "
"``None``, ``False`` or ``True``; see above constructor for the meaning of"
" this parameter."
msgstr ""

#: ../../../library/pyb.DAC.rst:87
msgid "De-initialise the DAC making its pin available for other uses."
msgstr ""

#: ../../../library/pyb.DAC.rst:91
msgid ""
"Generate a pseudo-random noise signal.  A new random sample is written to"
" the DAC output at the given frequency."
msgstr ""

#: ../../../library/pyb.DAC.rst:96
msgid ""
"Generate a triangle wave.  The value on the DAC output changes at the "
"given frequency, and the frequency of the repeating triangle wave itself "
"is 2048 times smaller."
msgstr ""

#: ../../../library/pyb.DAC.rst:102
msgid ""
"Direct access to the DAC output.  The minimum value is 0.  The maximum "
"value is 2\\*\\*``bits``-1, where ``bits`` is set when creating the DAC "
"object or by using the ``init`` method."
msgstr ""

#: ../../../library/pyb.DAC.rst:108
msgid ""
"Initiates a burst of RAM to DAC using a DMA transfer. The input data is "
"treated as an array of bytes in 8-bit mode, and an array of unsigned "
"half-words (array typecode 'H') in 12-bit mode."
msgstr ""

#: ../../../library/pyb.DAC.rst:112
msgid ""
"``freq`` can be an integer specifying the frequency to write the DAC "
"samples at, using Timer(6).  Or it can be an already-initialised Timer "
"object which is used to trigger the DAC sample.  Valid timers are 2, 4, "
"5, 6, 7 and 8."
msgstr ""

#: ../../../library/pyb.DAC.rst:117
msgid "``mode`` can be ``DAC.NORMAL`` or ``DAC.CIRCULAR``."
msgstr ""

#: ../../../library/pyb.DAC.rst:119
msgid "Example using both DACs at the same time::"
msgstr ""

#: ../../../library/pyb.DAC.rst:121
msgid ""
"dac1 = DAC(1)\n"
"dac2 = DAC(2)\n"
"dac1.write_timed(buf1, pyb.Timer(6, freq=100), mode=DAC.CIRCULAR)\n"
"dac2.write_timed(buf2, pyb.Timer(7, freq=200), mode=DAC.CIRCULAR)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:5
msgid "class ExtInt -- configure I/O pins to interrupt on external events"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:7
msgid ""
"There are a total of 22 interrupt lines. 16 of these can come from GPIO "
"pins and the remaining 6 are from internal sources."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:10
msgid ""
"For lines 0 through 15, a given line can map to the corresponding line "
"from an arbitrary port. So line 0 can map to Px0 where x is A, B, C, ... "
"and line 1 can map to Px1 where x is A, B, C, ... ::"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:14
msgid ""
"def callback(line):\n"
"    print(\"line =\", line)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:17
msgid "Note: ExtInt will automatically configure the gpio line as an input. ::"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:19
msgid ""
"extint = pyb.ExtInt(pin, pyb.ExtInt.IRQ_FALLING, pyb.Pin.PULL_UP, "
"callback)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:21
msgid ""
"Now every time a falling edge is seen on the X1 pin, the callback will be"
" called. Caution: mechanical pushbuttons have \"bounce\" and pushing or "
"releasing a switch will often generate multiple edges. See: "
"http://www.eng.utah.edu/~cs5780/debouncing.pdf for a detailed "
"explanation, along with various techniques for debouncing."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:27
msgid "Trying to register 2 callbacks onto the same pin will throw an exception."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:29
msgid ""
"If pin is passed as an integer, then it is assumed to map to one of the "
"internal interrupt sources, and must be in the range 16 through 22."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:32
msgid ""
"All other pin objects go through the pin mapper to come up with one of "
"the gpio pins. ::"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:35
msgid "extint = pyb.ExtInt(pin, mode, pull, callback)"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:37
msgid ""
"Valid modes are pyb.ExtInt.IRQ_RISING, pyb.ExtInt.IRQ_FALLING, "
"pyb.ExtInt.IRQ_RISING_FALLING, pyb.ExtInt.EVT_RISING, "
"pyb.ExtInt.EVT_FALLING, and pyb.ExtInt.EVT_RISING_FALLING."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:41
msgid ""
"Only the IRQ_xxx modes have been tested. The EVT_xxx modes have something"
" to do with sleep mode and the WFE instruction."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:44
msgid ""
"Valid pull values are pyb.Pin.PULL_UP, pyb.Pin.PULL_DOWN, "
"pyb.Pin.PULL_NONE."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:46
msgid ""
"There is also a C API, so that drivers which require EXTI interrupt lines"
" can also use this code. See extint.h for the available functions and "
"usrsw.h for an example of using this."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:56
msgid "Create an ExtInt object:"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:58
msgid ""
"``pin`` is the pin on which to enable the interrupt (can be a pin object "
"or any valid pin name)."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:59
msgid ""
"``mode`` can be one of: - ``ExtInt.IRQ_RISING`` - trigger on a rising "
"edge; - ``ExtInt.IRQ_FALLING`` - trigger on a falling edge; - "
"``ExtInt.IRQ_RISING_FALLING`` - trigger on a rising or falling edge."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:63
msgid ""
"``pull`` can be one of: - ``pyb.Pin.PULL_NONE`` - no pull up or down "
"resistors; - ``pyb.Pin.PULL_UP`` - enable the pull-up resistor; - "
"``pyb.Pin.PULL_DOWN`` - enable the pull-down resistor."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:67
msgid ""
"``callback`` is the function to call when the interrupt triggers.  The "
"callback function must accept exactly 1 argument, which is the line that "
"triggered the interrupt."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:73 ../../../library/pyb.Pin.rst:83
msgid "Class methods"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:77
msgid "Dump the values of the EXTI registers."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:85
msgid ""
"Disable the interrupt associated with the ExtInt object. This could be "
"useful for debouncing."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:90
msgid "Enable a disabled interrupt."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:94
msgid "Return the line number that the pin is mapped to."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:98
msgid "Trigger the callback from software."
msgstr ""

#: ../../../library/pyb.ExtInt.rst:106
msgid "interrupt on a falling edge"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:110
msgid "interrupt on a rising edge"
msgstr ""

#: ../../../library/pyb.ExtInt.rst:114
msgid "interrupt on a rising or falling edge"
msgstr ""

#: ../../../library/pyb.I2C.rst:15
msgid ""
"from pyb import I2C\n"
"\n"
"i2c = I2C(1)                         # create on bus 1\n"
"i2c = I2C(1, I2C.MASTER)             # create and init as a master\n"
"i2c.init(I2C.MASTER, baudrate=20000) # init as a master\n"
"i2c.init(I2C.SLAVE, addr=0x42)       # init as a slave with given address"
"\n"
"i2c.deinit()                         # turn off the peripheral"
msgstr ""
"from pyb import I2C\n"
"\n"
"i2c = I2C(1)                         # バス 1 に作成\n"
"i2c = I2C(1, I2C.MASTER)             # マスターとして作成・初期化\n"
"i2c.init(I2C.MASTER, baudrate=20000) # マスターとして初期化\n"
"i2c.init(I2C.SLAVE, addr=0x42)       # 指定したアドレスでスレーブとして初期化"
"\n"
"i2c.deinit()                         # ペリフェラルをオフ"

#: ../../../library/pyb.I2C.rst:23
msgid "Printing the i2c object gives you information about its configuration."
msgstr "i2c オブジェクトを印字すると、その構成に関する情報が得られます。"

#: ../../../library/pyb.I2C.rst:25
msgid "The basic methods are send and recv::"
msgstr "基本的なメソッドは send と recv です::"

#: ../../../library/pyb.I2C.rst:27
msgid ""
"i2c.send('abc')      # send 3 bytes\n"
"i2c.send(0x42)       # send a single byte, given by the number\n"
"data = i2c.recv(3)   # receive 3 bytes"
msgstr ""
"i2c.send('abc')      # 3 バイト送信\n"
"i2c.send(0x42)       # 数値で指定の 1 バイトを送信\n"
"data = i2c.recv(3)   # 3 バイト受信"

#: ../../../library/pyb.I2C.rst:31
msgid "To receive inplace, first create a bytearray::"
msgstr "指定場所に受信するには、まず bytearray を作成します::""

#: ../../../library/pyb.I2C.rst:33
msgid ""
"data = bytearray(3)  # create a buffer\n"
"i2c.recv(data)       # receive 3 bytes, writing them into data"
msgstr ""
"data = bytearray(3)  # バッファを作成\n"
"i2c.recv(data)       # 3 バイト受信し、それを data に書き込む"

#: ../../../library/pyb.I2C.rst:36
msgid "You can specify a timeout (in ms)::"
msgstr "タイムアウト時間を指定できます(ms 単位)::"

#: ../../../library/pyb.I2C.rst:38
msgid "i2c.send(b'123', timeout=2000)   # timeout after 2 seconds"
msgstr "i2c.send(b'123', timeout=2000)   # 2秒後にタイムアウト"

#: ../../../library/pyb.I2C.rst:40
msgid "A master must specify the recipient's address::"
msgstr "マスターは受信側のアドレスを指定する必要があります::"

#: ../../../library/pyb.I2C.rst:42
msgid ""
"i2c.init(I2C.MASTER)\n"
"i2c.send('123', 0x42)        # send 3 bytes to slave with address 0x42\n"
"i2c.send(b'456', addr=0x42)  # keyword for address"
msgstr ""
"i2c.init(I2C.MASTER)\n"
"i2c.send('123', 0x42)        # スレーブアドレス 0x42 に 3 バイト送信\n"
"i2c.send(b'456', addr=0x42)  # アドレスをキーワード引数で指定"

#: ../../../library/pyb.I2C.rst:46
msgid "Master also has other methods::"
msgstr "マスターには他にもメソッドがあります::"

#: ../../../library/pyb.I2C.rst:48
msgid ""
"i2c.is_ready(0x42)           # check if slave 0x42 is ready\n"
"i2c.scan()                   # scan for slaves on the bus, returning\n"
"                             #   a list of valid addresses\n"
"i2c.mem_read(3, 0x42, 2)     # read 3 bytes from memory of slave 0x42,\n"
"                             #   starting at address 2 in the slave\n"
"i2c.mem_write('abc', 0x42, 2, timeout=1000) # write 'abc' (3 bytes) to "
"memory of slave 0x42\n"
"                                            # starting at address 2 in "
"the slave, timeout after 1 second"
msgstr ""
"i2c.is_ready(0x42)           # スレーブ 0x42 の準備ができているか確認\n"
"i2c.scan()                   # バスのスレーブをスキャンし、\n"
"                             #   有効なアドレスのリストを戻す\n"
"i2c.mem_read(3, 0x42, 2)     # スレーブ 0x42 のメモリから、スレーブ上の\n"
"                             #   アドレス 2 で始まる 3 バイトを読み込む\n"
"i2c.mem_write('abc', 0x42, 2, timeout=1000) # 'abc' (3 バイト)をスレーブ 0x42 のメモリの、\n"
"                             #   スレーブ上のアドレス 2 から書き込む。1 秒後にタイムアウト"

#: ../../../library/pyb.I2C.rst:61
msgid ""
"Construct an I2C object on the given bus.  ``bus`` can be 1 or 2, 'X' or "
"'Y'. With no additional parameters, the I2C object is created but not "
"initialised (it has the settings from the last initialisation of the bus,"
" if any).  If extra arguments are given, the bus is initialised. See "
"``init`` for parameters of initialisation."
msgstr ""
"指定したバスで I2C オブジェクトを作成します。 ``bus`` は 1 または 2、 "
"'X' または 'Y' を指定できます。追加のパラメーター無しだと、I2C オブジェクトは"
"作成されますが、初期化されません(以前にバスが初期化さえていれば、その設定を引継ぎます)。"
"追加の引数を指定すると、バスが初期化されます。初期化のパラメータは ``init`` "
"を参照してください。"

#: ../../../library/pyb.I2C.rst:67
msgid "The physical pins of the I2C busses on Pyboards V1.0 and V1.1 are:"
msgstr "Pyboards V1.0 および V1.1 の I2C バスの物理ピンは次のとおりです。"

#: ../../../library/pyb.I2C.rst:69 ../../../library/pyb.I2C.rst:74
msgid "``I2C(1)`` is on the X position: ``(SCL, SDA) = (X9, X10) = (PB6, PB7)``"
msgstr "``I2C(1)`` は X 位置にあります: ``(SCL, SDA) = (X9, X10) = (PB6, PB7)``"

#: ../../../library/pyb.I2C.rst:70
msgid "``I2C(2)`` is on the Y position: ``(SCL, SDA) = (Y9, Y10) = (PB10, PB11)``"
msgstr "``I2C(2)`` は Y 位置にあります: ``(SCL, SDA) = (Y9, Y10) = (PB10, PB11)``"

#: ../../../library/pyb.I2C.rst:72
msgid "On the Pyboard Lite:"
msgstr "Pyboard Lite の場合:"

#: ../../../library/pyb.I2C.rst:75
msgid "``I2C(3)`` is on the Y position: ``(SCL, SDA) = (Y9, Y10) = (PA8, PB8)``"
msgstr "``I2C(3)`` は Y 位置にあります: ``(SCL, SDA) = (Y9, Y10) = (PA8, PB8)``"

#: ../../../library/pyb.I2C.rst:77
msgid ""
"Calling the constructor with 'X' or 'Y' enables portability between "
"Pyboard types."
msgstr ""
"'X' または 'Y' でコンストラクターを呼び出すと、Pyboard タイプ間の移植性が"
"高まります。

#: ../../../library/pyb.I2C.rst:89
msgid "Initialise the I2C bus with the given parameters:"
msgstr "指定のパラメータで I2C バスを初期化します:"

#: ../../../library/pyb.I2C.rst:91
msgid "``mode`` must be either ``I2C.MASTER`` or ``I2C.SLAVE``"
msgstr "``mode`` は ``I2C.MASTER`` か ``I2C.SLAVE`` のいずれかでなければなりません"

#: ../../../library/pyb.I2C.rst:92
msgid "``addr`` is the 7-bit address (only sensible for a slave)"
msgstr "``addr`` は 7 ビットアドレスです(スレーブ時のみ有効)"

#: ../../../library/pyb.I2C.rst:93
msgid "``baudrate`` is the SCL clock rate (only sensible for a master)"
msgstr "``baudrate`` は SCL クロックレートです(マスター時のみ有効)"

#: ../../../library/pyb.I2C.rst:94
msgid "``gencall`` is whether to support general call mode"
msgstr "``gencall`` は汎用呼出しモードをサポートするかどうかを指定します"

#: ../../../library/pyb.I2C.rst:95
msgid ""
"``dma`` is whether to allow the use of DMA for the I2C transfers (note "
"that DMA transfers have more precise timing but currently do not handle "
"bus errors properly)"
msgstr ""
"``dma`` は I2C 転送に DMA の使用を許可するかどうかを指定します(DMA 転送のタイミングは"
"より正確ですが、現在のところバスエラーを適切に処理しないことに注意してください)"

#: ../../../library/pyb.I2C.rst:101
msgid ""
"Check if an I2C device responds to the given address.  Only valid when in"
" master mode."
msgstr ""
"I2C デバイスが指定のアドレスに応答するかどうかを確認します。"
"マスターモードの場合のみ有効です。"

#: ../../../library/pyb.I2C.rst:105
msgid "Read from the memory of an I2C device:"
msgstr "I2C デバイスのメモリから読み取ります:"

#: ../../../library/pyb.I2C.rst:107
msgid ""
"``data`` can be an integer (number of bytes to read) or a buffer to read "
"into"
msgstr "``data`` には整数(読み取るバイト数)または読み込むバッファを指定します"

#: ../../../library/pyb.I2C.rst:108 ../../../library/pyb.I2C.rst:121
msgid "``addr`` is the I2C device address"
msgstr "``addr`` は I2C デバイスアドレスです"

#: ../../../library/pyb.I2C.rst:109 ../../../library/pyb.I2C.rst:122
msgid "``memaddr`` is the memory location within the I2C device"
msgstr "``memaddr`` は I2C デバイス中のメモリ位置です"

#: ../../../library/pyb.I2C.rst:110
msgid "``timeout`` is the timeout in milliseconds to wait for the read"
msgstr "``timeout`` は読み取りを待つタイムアウト時間をミリ秒単位で指定します"

#: ../../../library/pyb.I2C.rst:111 ../../../library/pyb.I2C.rst:124
msgid "``addr_size`` selects width of memaddr: 8 or 16 bits"
msgstr "``addr_size`` は memaddr の幅であり、8 または 16 を指定します"

#: ../../../library/pyb.I2C.rst:113
msgid "Returns the read data. This is only valid in master mode."
msgstr "読み取ったデータを返します。これはマスターモードでのみ有効です。"

#: ../../../library/pyb.I2C.rst:118
msgid "Write to the memory of an I2C device:"
msgstr "I2C デバイスのメモリに書き込みます:"

#: ../../../library/pyb.I2C.rst:120
msgid "``data`` can be an integer or a buffer to write from"
msgstr "``data`` には整数または書き込み元のバッファを指定します"

#: ../../../library/pyb.I2C.rst:123
msgid "``timeout`` is the timeout in milliseconds to wait for the write"
msgstr "``timeout`` は書き込み待つタイムアウト時間をミリ秒単位で指定します"

#: ../../../library/pyb.I2C.rst:126
msgid "Returns ``None``. This is only valid in master mode."
msgstr "``None`` を返します。これはマスターモードでのみ有効です。"

#: ../../../library/pyb.I2C.rst:133
msgid ""
"``recv`` can be an integer, which is the number of bytes to receive, or a"
" mutable buffer, which will be filled with received bytes"
msgstr ""
"``recv`` には受信するバイト数を示す整数、または受信したバイト列を格納する書き込み可能"
"バッファを指定できます"

#: ../../../library/pyb.I2C.rst:135
msgid "``addr`` is the address to receive from (only required in master mode)"
msgstr "``addr`` は受信元のアドレスです(マスターモードでのみ必要)"

#: ../../../library/pyb.I2C.rst:136
msgid "``timeout`` is the timeout in milliseconds to wait for the receive"
msgstr "``timeout`` は受信を待つタイムアウト時間をミリ秒単位で指定します"

#: ../../../library/pyb.I2C.rst:138 ../../../library/pyb.SPI.rst:87
msgid ""
"Return value: if ``recv`` is an integer then a new buffer of the bytes "
"received, otherwise the same buffer that was passed in to ``recv``."
msgstr ""
"戻り値: パラメータ ``recv`` が整数であれば、受信したバイト数を格納した新しい"
"バッファを返します。さもなければ ``recv`` に渡したのと同じバッファを返します。"

#: ../../../library/pyb.I2C.rst:143 ../../../library/pyb.SPI.rst:92
msgid "Send data on the bus:"
msgstr "バスにデータを送信します:"

#: ../../../library/pyb.I2C.rst:145
msgid "``send`` is the data to send (an integer to send, or a buffer object)"
msgstr "``send`` は送信するデータです(送信する整数値、またはバッファオブジェクト)"

#: ../../../library/pyb.I2C.rst:146
msgid "``addr`` is the address to send to (only required in master mode)"
msgstr "``addr`` は送信先のアドレスです(マスターモードでのみ必要)"

#: ../../../library/pyb.I2C.rst:147
msgid "``timeout`` is the timeout in milliseconds to wait for the send"
msgstr "``timeout`` は送信を待つタイムアウト時間をミリ秒単位で指定します"

#: ../../../library/pyb.I2C.rst:153
msgid ""
"Scan all I2C addresses from 0x01 to 0x7f and return a list of those that "
"respond. Only valid when in master mode."
msgstr ""
"0x01 から 0x7f までのすべてのI2Cアドレスをスキャンし、応答するアドレスのリストを"
"返します。マスターモードの場合のみ有効です。"

#: ../../../library/pyb.I2C.rst:161
msgid "for initialising the bus to master mode"
msgstr "バスをマスターモードに初期化するためのもの"

#: ../../../library/pyb.I2C.rst:165
msgid "for initialising the bus to slave mode"
msgstr "バスをスレーブーモードに初期化するためのもの"

#: ../../../library/pyb.LCD.rst:5
msgid "class LCD -- LCD control for the LCD touch-sensor pyskin"
msgstr ""

#: ../../../library/pyb.LCD.rst:7
msgid ""
"The LCD class is used to control the LCD on the LCD touch-sensor pyskin, "
"LCD32MKv1.0.  The LCD is a 128x32 pixel monochrome screen, part NHD-"
"C12832A1Z."
msgstr ""

#: ../../../library/pyb.LCD.rst:10
msgid ""
"The pyskin must be connected in either the X or Y positions, and then an "
"LCD object is made using::"
msgstr ""

#: ../../../library/pyb.LCD.rst:13
msgid ""
"lcd = pyb.LCD('X')      # if pyskin is in the X position\n"
"lcd = pyb.LCD('Y')      # if pyskin is in the Y position"
msgstr ""

#: ../../../library/pyb.LCD.rst:16
msgid "Then you can use::"
msgstr ""

#: ../../../library/pyb.LCD.rst:18
msgid ""
"lcd.light(True)                 # turn the backlight on\n"
"lcd.write('Hello world!\\n')     # print text to the screen"
msgstr ""

#: ../../../library/pyb.LCD.rst:21
msgid ""
"This driver implements a double buffer for setting/getting pixels. For "
"example, to make a bouncing dot, try::"
msgstr ""

#: ../../../library/pyb.LCD.rst:24
msgid ""
"x = y = 0\n"
"dx = dy = 1\n"
"while True:\n"
"    # update the dot's position\n"
"    x += dx\n"
"    y += dy\n"
"\n"
"    # make the dot bounce of the edges of the screen\n"
"    if x <= 0 or x >= 127: dx = -dx\n"
"    if y <= 0 or y >= 31: dy = -dy\n"
"\n"
"    lcd.fill(0)                 # clear the buffer\n"
"    lcd.pixel(x, y, 1)          # draw the dot\n"
"    lcd.show()                  # show the buffer\n"
"    pyb.delay(50)               # pause for 50ms"
msgstr ""

#: ../../../library/pyb.LCD.rst:46
msgid ""
"Construct an LCD object in the given skin position.  ``skin_position`` "
"can be 'X' or 'Y', and should match the position where the LCD pyskin is "
"plugged in."
msgstr ""

#: ../../../library/pyb.LCD.rst:55
msgid ""
"Send an arbitrary command to the LCD.  Pass 0 for ``instr_data`` to send "
"an instruction, otherwise pass 1 to send data.  ``buf`` is a buffer with "
"the instructions/data to send."
msgstr ""

#: ../../../library/pyb.LCD.rst:61
msgid "Set the contrast of the LCD.  Valid values are between 0 and 47."
msgstr ""

#: ../../../library/pyb.LCD.rst:65
msgid "Fill the screen with the given colour (0 or 1 for white or black)."
msgstr ""

#: ../../../library/pyb.LCD.rst:67 ../../../library/pyb.LCD.rst:83
#: ../../../library/pyb.LCD.rst:93
msgid ""
"This method writes to the hidden buffer.  Use ``show()`` to show the "
"buffer."
msgstr ""

#: ../../../library/pyb.LCD.rst:71
msgid "Get the pixel at the position ``(x, y)``.  Returns 0 or 1."
msgstr ""

#: ../../../library/pyb.LCD.rst:73
msgid "This method reads from the visible buffer."
msgstr ""

#: ../../../library/pyb.LCD.rst:77
msgid ""
"Turn the backlight on/off.  True or 1 turns it on, False or 0 turns it "
"off."
msgstr ""

#: ../../../library/pyb.LCD.rst:81
msgid "Set the pixel at ``(x, y)`` to the given colour (0 or 1)."
msgstr ""

#: ../../../library/pyb.LCD.rst:87
msgid "Show the hidden buffer on the screen."
msgstr ""

#: ../../../library/pyb.LCD.rst:91
msgid ""
"Draw the given text to the position ``(x, y)`` using the given colour (0 "
"or 1)."
msgstr ""

#: ../../../library/pyb.LCD.rst:97
msgid "Write the string ``str`` to the screen.  It will appear immediately."
msgstr ""

#: ../../../library/pyb.LED.rst:5
msgid "class LED -- LED object"
msgstr "クラス LED -- LED オブジェクト"

#: ../../../library/pyb.LED.rst:7
msgid "The LED object controls an individual LED (Light Emitting Diode)."
msgstr "LED オブジェクトはオンボードの各 LED (発光ダイオード)を制御します。"

#: ../../../library/pyb.LED.rst:15
msgid "Create an LED object associated with the given LED:"
msgstr "指定の LED に対応した LED オブジェクトを作成します:"

#: ../../../library/pyb.LED.rst:17
msgid "``id`` is the LED number, 1-4."
msgstr "``id`` は LED の番号で、1-4 のいずれかの値を指定します。"

#: ../../../library/pyb.LED.rst:25
msgid ""
"Get or set the LED intensity.  Intensity ranges between 0 (off) and 255 "
"(full on). If no argument is given, return the LED intensity. If an "
"argument is given, set the LED intensity and return ``None``."
msgstr ""
"LED の輝度を取得または設定します。輝度の範囲は 0 (オフ)〜255 (最大オン)です。"
"引数が指定されていない場合、LEDの輝度を返します。引数が指定されている場合は "
"LED の輝度を設定して ``None`` を返します。"

#: ../../../library/pyb.LED.rst:29
msgid ""
"*Note:* Only LED(3) and LED(4) can have a smoothly varying intensity, and"
" they use timer PWM to implement it.  LED(3) uses Timer(2) and LED(4) "
"uses Timer(3).  These timers are only configured for PWM if the intensity"
" of the relevant LED is set to a value between 1 and 254.  Otherwise the "
"timers are free for general purpose use."
msgstr ""
"*注記:* LED(3) と LED(4) のみが滑らかに変化する輝度を持つことができ、タイマー PWM "
"を使って実装します。LED (3) は Timer(2) を使い、LED(4) は Timer(3) を使います。"
"これらのタイマーは、関連する LED の輝度が 1-254 の値に設定されている場合にのみ、PWM "
"用に構成されます。それ以外の場合、タイマーは汎用目的で使用できます。"

#: ../../../library/pyb.LED.rst:37
msgid "Turn the LED off."
msgstr "LED をオフにします。"

#: ../../../library/pyb.LED.rst:41
msgid "Turn the LED on, to maximum intensity."
msgstr "LED をオンにし、最大輝度にします。"

#: ../../../library/pyb.LED.rst:45
msgid ""
"Toggle the LED between on (maximum intensity) and off.  If the LED is at "
"non-zero intensity then it is considered \"on\" and toggle will turn it "
"off."
msgstr ""
"LEDのオン(最大輝度)とオフを切り替えます。LED の輝度がゼロ以外の場合は「オン」と"
"見なされ、このメソッドの呼び出しによりオフに切り替わります。"

#: ../../../library/pyb.Pin.rst:7
msgid ""
"A pin is the basic object to control I/O pins.  It has methods to set the"
" mode of the pin (input, output, etc) and methods to get and set the "
"digital logic level. For analog control of a pin, see the ADC class."
msgstr ""

#: ../../../library/pyb.Pin.rst:11
msgid "Usage Model:"
msgstr ""

#: ../../../library/pyb.Pin.rst:13
msgid "All Board Pins are predefined as pyb.Pin.board.Name::"
msgstr ""

#: ../../../library/pyb.Pin.rst:15
msgid ""
"x1_pin = pyb.Pin.board.X1\n"
"\n"
"g = pyb.Pin(pyb.Pin.board.X1, pyb.Pin.IN)"
msgstr ""

#: ../../../library/pyb.Pin.rst:19
msgid ""
"CPU pins which correspond to the board pins are available as "
"``pyb.Pin.cpu.Name``. For the CPU pins, the names are the port letter "
"followed by the pin number. On the PYBv1.0, ``pyb.Pin.board.X1`` and "
"``pyb.Pin.cpu.A0`` are the same pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:24
msgid "You can also use strings::"
msgstr ""

#: ../../../library/pyb.Pin.rst:26
msgid "g = pyb.Pin('X1', pyb.Pin.OUT_PP)"
msgstr ""

#: ../../../library/pyb.Pin.rst:28
msgid "Users can add their own names::"
msgstr ""

#: ../../../library/pyb.Pin.rst:30
msgid ""
"MyMapperDict = { 'LeftMotorDir' : pyb.Pin.cpu.C12 }\n"
"pyb.Pin.dict(MyMapperDict)\n"
"g = pyb.Pin(\"LeftMotorDir\", pyb.Pin.OUT_OD)"
msgstr ""

#: ../../../library/pyb.Pin.rst:34
msgid "and can query mappings::"
msgstr ""

#: ../../../library/pyb.Pin.rst:36
msgid "pin = pyb.Pin(\"LeftMotorDir\")"
msgstr ""

#: ../../../library/pyb.Pin.rst:38
msgid "Users can also add their own mapping function::"
msgstr ""

#: ../../../library/pyb.Pin.rst:40
msgid ""
"def MyMapper(pin_name):\n"
"   if pin_name == \"LeftMotorDir\":\n"
"       return pyb.Pin.cpu.A0\n"
"\n"
"pyb.Pin.mapper(MyMapper)"
msgstr ""

#: ../../../library/pyb.Pin.rst:46
msgid ""
"So, if you were to call: ``pyb.Pin(\"LeftMotorDir\", pyb.Pin.OUT_PP)`` "
"then ``\"LeftMotorDir\"`` is passed directly to the mapper function."
msgstr ""

#: ../../../library/pyb.Pin.rst:49
msgid ""
"To summarise, the following order determines how things get mapped into "
"an ordinal pin number:"
msgstr ""

#: ../../../library/pyb.Pin.rst:52
msgid "Directly specify a pin object"
msgstr ""

#: ../../../library/pyb.Pin.rst:53
msgid "User supplied mapping function"
msgstr ""

#: ../../../library/pyb.Pin.rst:54
msgid "User supplied mapping (object must be usable as a dictionary key)"
msgstr ""

#: ../../../library/pyb.Pin.rst:55
msgid "Supply a string which matches a board pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:56
msgid "Supply a string which matches a CPU port/pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:58
msgid ""
"You can set ``pyb.Pin.debug(True)`` to get some debug information about "
"how a particular object gets mapped to a pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:61
msgid ""
"When a pin has the ``Pin.PULL_UP`` or ``Pin.PULL_DOWN`` pull-mode "
"enabled, that pin has an effective 40k Ohm resistor pulling it to 3V3 or "
"GND respectively (except pin Y5 which has 11k Ohm resistors)."
msgstr ""

#: ../../../library/pyb.Pin.rst:65
msgid ""
"Now every time a falling edge is seen on the gpio pin, the callback will "
"be executed. Caution: mechanical push buttons have \"bounce\" and pushing"
" or releasing a switch will often generate multiple edges. See: "
"http://www.eng.utah.edu/~cs5780/debouncing.pdf for a detailed "
"explanation, along with various techniques for debouncing."
msgstr ""

#: ../../../library/pyb.Pin.rst:71
msgid ""
"All pin objects go through the pin mapper to come up with one of the gpio"
" pins."
msgstr ""

#: ../../../library/pyb.Pin.rst:79
msgid ""
"Create a new Pin object associated with the id.  If additional arguments "
"are given, they are used to initialise the pin.  See :meth:`pin.init`."
msgstr ""

#: ../../../library/pyb.Pin.rst:87
msgid "Get or set the debugging state (``True`` or ``False`` for on or off)."
msgstr ""

#: ../../../library/pyb.Pin.rst:91
msgid "Get or set the pin mapper dictionary."
msgstr ""

#: ../../../library/pyb.Pin.rst:95
msgid "Get or set the pin mapper function."
msgstr ""

#: ../../../library/pyb.Pin.rst:103
msgid "Initialise the pin:"
msgstr ""

#: ../../../library/pyb.Pin.rst:107
msgid "``Pin.IN`` - configure the pin for input;"
msgstr ""

#: ../../../library/pyb.Pin.rst:108
msgid "``Pin.OUT_PP`` - configure the pin for output, with push-pull control;"
msgstr ""

#: ../../../library/pyb.Pin.rst:109
msgid "``Pin.OUT_OD`` - configure the pin for output, with open-drain control;"
msgstr ""

#: ../../../library/pyb.Pin.rst:110
msgid "``Pin.AF_PP`` - configure the pin for alternate function, pull-pull;"
msgstr ""

#: ../../../library/pyb.Pin.rst:111
msgid "``Pin.AF_OD`` - configure the pin for alternate function, open-drain;"
msgstr ""

#: ../../../library/pyb.Pin.rst:112
msgid "``Pin.ANALOG`` - configure the pin for analog."
msgstr ""

#: ../../../library/pyb.Pin.rst:114
msgid "``pull`` can be one of:"
msgstr ""

#: ../../../library/pyb.Pin.rst:116
msgid "``Pin.PULL_NONE`` - no pull up or down resistors;"
msgstr ""

#: ../../../library/pyb.Pin.rst:117
msgid "``Pin.PULL_UP`` - enable the pull-up resistor;"
msgstr ""

#: ../../../library/pyb.Pin.rst:118
msgid "``Pin.PULL_DOWN`` - enable the pull-down resistor."
msgstr ""

#: ../../../library/pyb.Pin.rst:120
msgid ""
"when mode is ``Pin.AF_PP`` or ``Pin.AF_OD``, then af can be the index or "
"name of one of the alternate functions associated with a pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:123
msgid "Returns: ``None``."
msgstr ""

#: ../../../library/pyb.Pin.rst:127
msgid "Get or set the digital logic level of the pin:"
msgstr ""

#: ../../../library/pyb.Pin.rst:129
msgid "With no argument, return 0 or 1 depending on the logic level of the pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:130
msgid ""
"With ``value`` given, set the logic level of the pin.  ``value`` can be "
"anything that converts to a boolean.  If it converts to ``True``, the pin"
" is set high, otherwise it is set low."
msgstr ""

#: ../../../library/pyb.Pin.rst:136
msgid "Return a string describing the pin object."
msgstr ""

#: ../../../library/pyb.Pin.rst:140
msgid ""
"Returns the currently configured alternate-function of the pin. The "
"integer returned will match one of the allowed constants for the af "
"argument to the init function."
msgstr ""

#: ../../../library/pyb.Pin.rst:146
msgid "Returns an array of alternate functions available for this pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:150
msgid "Returns the base address of the GPIO block associated with this pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:154
msgid ""
"Returns the currently configured mode of the pin. The integer returned "
"will match one of the allowed constants for the mode argument to the init"
" function."
msgstr ""

#: ../../../library/pyb.Pin.rst:160
msgid "Get the pin name."
msgstr ""

#: ../../../library/pyb.Pin.rst:164
msgid "Returns the cpu and board names for this pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:168
msgid "Get the pin number."
msgstr ""

#: ../../../library/pyb.Pin.rst:172
msgid "Get the pin port."
msgstr ""

#: ../../../library/pyb.Pin.rst:176
msgid ""
"Returns the currently configured pull of the pin. The integer returned "
"will match one of the allowed constants for the pull argument to the init"
" function."
msgstr ""

#: ../../../library/pyb.Pin.rst:185
msgid "initialise the pin to alternate-function mode with an open-drain drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:189
msgid "initialise the pin to alternate-function mode with a push-pull drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:193
msgid "initialise the pin to analog mode"
msgstr ""

#: ../../../library/pyb.Pin.rst:197
msgid "initialise the pin to input mode"
msgstr ""

#: ../../../library/pyb.Pin.rst:201
msgid "initialise the pin to output mode with an open-drain drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:205
msgid "initialise the pin to output mode with a push-pull drive"
msgstr ""

#: ../../../library/pyb.Pin.rst:209
msgid "enable the pull-down resistor on the pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:213
msgid "don't enable any pull up or down resistors on the pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:217
msgid "enable the pull-up resistor on the pin"
msgstr ""

#: ../../../library/pyb.Pin.rst:220
msgid "class PinAF -- Pin Alternate Functions"
msgstr ""

#: ../../../library/pyb.Pin.rst:222
msgid ""
"A Pin represents a physical pin on the microprocessor. Each pin can have "
"a variety of functions (GPIO, I2C SDA, etc). Each PinAF object represents"
" a particular function for a pin."
msgstr ""

#: ../../../library/pyb.Pin.rst:228
msgid ""
"x3 = pyb.Pin.board.X3\n"
"x3_af = x3.af_list()"
msgstr ""

#: ../../../library/pyb.Pin.rst:231
msgid ""
"x3_af will now contain an array of PinAF objects which are available on "
"pin X3."
msgstr ""

#: ../../../library/pyb.Pin.rst:235
msgid "For the pyboard, x3_af would contain:"
msgstr ""

#: ../../../library/pyb.Pin.rst:235
msgid "[Pin.AF1_TIM2, Pin.AF2_TIM5, Pin.AF3_TIM9, Pin.AF7_USART2]"
msgstr ""

#: ../../../library/pyb.Pin.rst:237
msgid ""
"Normally, each peripheral would configure the af automatically, but "
"sometimes the same function is available on multiple pins, and having "
"more control is desired."
msgstr ""

#: ../../../library/pyb.Pin.rst:241
msgid "To configure X3 to expose TIM2_CH3, you could use::"
msgstr ""

#: ../../../library/pyb.Pin.rst:243
msgid "pin = pyb.Pin(pyb.Pin.board.X3, mode=pyb.Pin.AF_PP, af=pyb.Pin.AF1_TIM2)"
msgstr ""

#: ../../../library/pyb.Pin.rst:247
msgid "pin = pyb.Pin(pyb.Pin.board.X3, mode=pyb.Pin.AF_PP, af=1)"
msgstr ""

#: ../../../library/pyb.Pin.rst:254
msgid "Return a string describing the alternate function."
msgstr ""

#: ../../../library/pyb.Pin.rst:258
msgid "Return the alternate function index."
msgstr ""

#: ../../../library/pyb.Pin.rst:262
msgid "Return the name of the alternate function."
msgstr ""

#: ../../../library/pyb.Pin.rst:266
msgid ""
"Return the base register associated with the peripheral assigned to this "
"alternate function. For example, if the alternate function were TIM2_CH3 "
"this would return stm.TIM2"
msgstr ""

#: ../../../library/pyb.RTC.rst:12
msgid ""
"rtc = pyb.RTC()\n"
"rtc.datetime((2014, 5, 1, 4, 13, 0, 0, 0))\n"
"print(rtc.datetime())"
msgstr ""

#: ../../../library/pyb.RTC.rst:22
msgid "Create an RTC object."
msgstr ""

#: ../../../library/pyb.RTC.rst:30
msgid "Get or set the date and time of the RTC."
msgstr ""

#: ../../../library/pyb.RTC.rst:32
msgid ""
"With no arguments, this method returns an 8-tuple with the current date "
"and time.  With 1 argument (being an 8-tuple) it sets the date and time "
"(and ``subseconds`` is reset to 255)."
msgstr ""

#: ../../../library/pyb.RTC.rst:36
msgid "The 8-tuple has the following format:"
msgstr ""

#: ../../../library/pyb.RTC.rst:38
msgid "(year, month, day, weekday, hours, minutes, seconds, subseconds)"
msgstr ""

#: ../../../library/pyb.RTC.rst:40
msgid "``weekday`` is 1-7 for Monday through Sunday."
msgstr ""

#: ../../../library/pyb.RTC.rst:42
msgid "``subseconds`` counts down from 255 to 0"
msgstr ""

#: ../../../library/pyb.RTC.rst:46
msgid ""
"Set the RTC wakeup timer to trigger repeatedly at every ``timeout`` "
"milliseconds.  This trigger can wake the pyboard from both the sleep "
"states: :meth:`pyb.stop` and :meth:`pyb.standby`."
msgstr ""

#: ../../../library/pyb.RTC.rst:50
msgid "If ``timeout`` is ``None`` then the wakeup timer is disabled."
msgstr ""

#: ../../../library/pyb.RTC.rst:52
msgid ""
"If ``callback`` is given then it is executed at every trigger of the "
"wakeup timer.  ``callback`` must take exactly one argument."
msgstr ""

#: ../../../library/pyb.RTC.rst:57
msgid "Get information about the startup time and reset source."
msgstr ""

#: ../../../library/pyb.RTC.rst:59
msgid "The lower 0xffff are the number of milliseconds the RTC took to start up."
msgstr ""

#: ../../../library/pyb.RTC.rst:61
msgid "Bit 0x10000 is set if a power-on reset occurred."
msgstr ""

#: ../../../library/pyb.RTC.rst:62
msgid "Bit 0x20000 is set if an external reset occurred"
msgstr ""

#: ../../../library/pyb.RTC.rst:66
msgid "Get or set RTC calibration."
msgstr ""

#: ../../../library/pyb.RTC.rst:68
msgid ""
"With no arguments, ``calibration()`` returns the current calibration "
"value, which is an integer in the range [-511 : 512].  With one argument "
"it sets the RTC calibration."
msgstr ""

#: ../../../library/pyb.RTC.rst:72
msgid ""
"The RTC Smooth Calibration mechanism adjusts the RTC clock rate by adding"
" or subtracting the given number of ticks from the 32768 Hz clock over a "
"32 second period (corresponding to 2^20 clock ticks.) Each tick added "
"will speed up the clock by 1 part in 2^20, or 0.954 ppm; likewise the RTC"
" clock it slowed by negative values. The usable calibration range is: "
"(-511 * 0.954) ~= -487.5 ppm up to (512 * 0.954) ~= 488.5 ppm"
msgstr ""

#: ../../../library/pyb.SPI.rst:5
msgid "class SPI -- a master-driven serial protocol"
msgstr ""

#: ../../../library/pyb.SPI.rst:7
msgid ""
"SPI is a serial protocol that is driven by a master.  At the physical "
"level there are 3 lines: SCK, MOSI, MISO."
msgstr ""

#: ../../../library/pyb.SPI.rst:10
msgid ""
"See usage model of I2C; SPI is very similar.  Main difference is "
"parameters to init the SPI bus::"
msgstr ""

#: ../../../library/pyb.SPI.rst:13
msgid ""
"from pyb import SPI\n"
"spi = SPI(1, SPI.MASTER, baudrate=600000, polarity=1, phase=0, crc=0x7)"
msgstr ""

#: ../../../library/pyb.SPI.rst:16
msgid ""
"Only required parameter is mode, SPI.MASTER or SPI.SLAVE.  Polarity can "
"be 0 or 1, and is the level the idle clock line sits at.  Phase can be 0 "
"or 1 to sample data on the first or second clock edge respectively.  Crc "
"can be None for no CRC, or a polynomial specifier."
msgstr ""

#: ../../../library/pyb.SPI.rst:21
msgid "Additional methods for SPI::"
msgstr ""

#: ../../../library/pyb.SPI.rst:23
msgid ""
"data = spi.send_recv(b'1234')        # send 4 bytes and receive 4 bytes\n"
"buf = bytearray(4)\n"
"spi.send_recv(b'1234', buf)          # send 4 bytes and receive 4 into "
"buf\n"
"spi.send_recv(buf, buf)              # send/recv 4 bytes from/to buf"
msgstr ""

#: ../../../library/pyb.SPI.rst:33
msgid ""
"Construct an SPI object on the given bus.  ``bus`` can be 1 or 2, or 'X' "
"or 'Y'. With no additional parameters, the SPI object is created but not "
"initialised (it has the settings from the last initialisation of the bus,"
" if any).  If extra arguments are given, the bus is initialised. See "
"``init`` for parameters of initialisation."
msgstr ""

#: ../../../library/pyb.SPI.rst:39
msgid "The physical pins of the SPI busses are:"
msgstr ""

#: ../../../library/pyb.SPI.rst:41
msgid ""
"``SPI(1)`` is on the X position: ``(NSS, SCK, MISO, MOSI) = (X5, X6, X7, "
"X8) = (PA4, PA5, PA6, PA7)``"
msgstr ""

#: ../../../library/pyb.SPI.rst:42
msgid ""
"``SPI(2)`` is on the Y position: ``(NSS, SCK, MISO, MOSI) = (Y5, Y6, Y7, "
"Y8) = (PB12, PB13, PB14, PB15)``"
msgstr ""

#: ../../../library/pyb.SPI.rst:44
msgid ""
"At the moment, the NSS pin is not used by the SPI driver and is free for "
"other use."
msgstr ""

#: ../../../library/pyb.SPI.rst:58
msgid "``mode`` must be either ``SPI.MASTER`` or ``SPI.SLAVE``."
msgstr ""

#: ../../../library/pyb.SPI.rst:59
msgid "``baudrate`` is the SCK clock rate (only sensible for a master)."
msgstr ""

#: ../../../library/pyb.SPI.rst:60
msgid ""
"``prescaler`` is the prescaler to use to derive SCK from the APB bus "
"frequency; use of ``prescaler`` overrides ``baudrate``."
msgstr ""

#: ../../../library/pyb.SPI.rst:65
msgid ""
"``bits`` can be 8 or 16, and is the number of bits in each transferred "
"word."
msgstr ""

#: ../../../library/pyb.SPI.rst:67
msgid "``crc`` can be None for no CRC, or a polynomial specifier."
msgstr ""

#: ../../../library/pyb.SPI.rst:69
msgid ""
"Note that the SPI clock frequency will not always be the requested "
"baudrate. The hardware only supports baudrates that are the APB bus "
"frequency (see :meth:`pyb.freq`) divided by a prescaler, which can be 2, "
"4, 8, 16, 32, 64, 128 or 256.  SPI(1) is on AHB2, and SPI(2) is on AHB1."
"  For precise control over the SPI clock frequency, specify ``prescaler``"
" instead of ``baudrate``."
msgstr ""

#: ../../../library/pyb.SPI.rst:76
msgid ""
"Printing the SPI object will show you the computed baudrate and the "
"chosen prescaler."
msgstr ""

#: ../../../library/pyb.SPI.rst:83
msgid ""
"``recv`` can be an integer, which is the number of bytes to receive, or a"
" mutable buffer, which will be filled with received bytes."
msgstr ""

#: ../../../library/pyb.SPI.rst:85 ../../../library/pyb.SPI.rst:107
#: ../../../library/pyb.USB_HID.rst:30 ../../../library/pyb.USB_VCP.rst:91
msgid "``timeout`` is the timeout in milliseconds to wait for the receive."
msgstr ""

#: ../../../library/pyb.SPI.rst:94 ../../../library/pyb.SPI.rst:103
msgid "``send`` is the data to send (an integer to send, or a buffer object)."
msgstr ""

#: ../../../library/pyb.SPI.rst:95 ../../../library/pyb.USB_VCP.rst:101
msgid "``timeout`` is the timeout in milliseconds to wait for the send."
msgstr ""

#: ../../../library/pyb.SPI.rst:101
msgid "Send and receive data on the bus at the same time:"
msgstr ""

#: ../../../library/pyb.SPI.rst:104
msgid ""
"``recv`` is a mutable buffer which will be filled with received bytes. It"
" can be the same as ``send``, or omitted.  If omitted, a new buffer will "
"be created."
msgstr ""

#: ../../../library/pyb.SPI.rst:109
msgid "Return value: the buffer with the received bytes."
msgstr ""

#: ../../../library/pyb.SPI.rst:117
msgid "for initialising the SPI bus to master or slave mode"
msgstr ""

#: ../../../library/pyb.SPI.rst:122
msgid "set the first bit to be the least or most significant bit"
msgstr ""

#: ../../../library/pyb.Servo.rst:5
msgid "class Servo -- 3-wire hobby servo driver"
msgstr ""

#: ../../../library/pyb.Servo.rst:7
msgid ""
"Servo objects control standard hobby servo motors with 3-wires (ground, "
"power, signal).  There are 4 positions on the pyboard where these motors "
"can be plugged in: pins X1 through X4 are the signal pins, and next to "
"them are 4 sets of power and ground pins."
msgstr ""

#: ../../../library/pyb.Servo.rst:14
msgid ""
"import pyb\n"
"\n"
"s1 = pyb.Servo(1)   # create a servo object on position X1\n"
"s2 = pyb.Servo(2)   # create a servo object on position X2\n"
"\n"
"s1.angle(45)        # move servo 1 to 45 degrees\n"
"s2.angle(0)         # move servo 2 to 0 degrees\n"
"\n"
"# move servo1 and servo2 synchronously, taking 1500ms\n"
"s1.angle(-60, 1500)\n"
"s2.angle(30, 1500)"
msgstr ""

#: ../../../library/pyb.Servo.rst:26
msgid ""
"The Servo objects use Timer(5) to produce the PWM output.  You can use "
"Timer(5) for Servo control, or your own purposes, but not both at the "
"same time."
msgstr ""

#: ../../../library/pyb.Servo.rst:35
msgid ""
"Create a servo object.  ``id`` is 1-4, and corresponds to pins X1 through"
" X4."
msgstr ""

#: ../../../library/pyb.Servo.rst:43
msgid "If no arguments are given, this function returns the current angle."
msgstr ""

#: ../../../library/pyb.Servo.rst:45
msgid "If arguments are given, this function sets the angle of the servo:"
msgstr ""

#: ../../../library/pyb.Servo.rst:47
msgid "``angle`` is the angle to move to in degrees."
msgstr ""

#: ../../../library/pyb.Servo.rst:48
msgid ""
"``time`` is the number of milliseconds to take to get to the specified "
"angle.  If omitted, then the servo moves as quickly as possible to its "
"new position."
msgstr ""

#: ../../../library/pyb.Servo.rst:54
msgid "If no arguments are given, this function returns the current speed."
msgstr ""

#: ../../../library/pyb.Servo.rst:56
msgid "If arguments are given, this function sets the speed of the servo:"
msgstr ""

#: ../../../library/pyb.Servo.rst:58
msgid "``speed`` is the speed to change to, between -100 and 100."
msgstr ""

#: ../../../library/pyb.Servo.rst:59
msgid ""
"``time`` is the number of milliseconds to take to get to the specified "
"speed.  If omitted, then the servo accelerates as quickly as possible."
msgstr ""

#: ../../../library/pyb.Servo.rst:64
msgid ""
"If no arguments are given, this function returns the current raw pulse-"
"width value."
msgstr ""

#: ../../../library/pyb.Servo.rst:67
msgid "If an argument is given, this function sets the raw pulse-width value."
msgstr ""

#: ../../../library/pyb.Servo.rst:71
msgid ""
"If no arguments are given, this function returns the current calibration "
"data, as a 5-tuple."
msgstr ""

#: ../../../library/pyb.Servo.rst:74
msgid "If arguments are given, this function sets the timing calibration:"
msgstr ""

#: ../../../library/pyb.Servo.rst:76
msgid "``pulse_min`` is the minimum allowed pulse width."
msgstr ""

#: ../../../library/pyb.Servo.rst:77
msgid "``pulse_max`` is the maximum allowed pulse width."
msgstr ""

#: ../../../library/pyb.Servo.rst:78
msgid ""
"``pulse_centre`` is the pulse width corresponding to the centre/zero "
"position."
msgstr ""

#: ../../../library/pyb.Servo.rst:79
msgid "``pulse_angle_90`` is the pulse width corresponding to 90 degrees."
msgstr ""

#: ../../../library/pyb.Servo.rst:80
msgid "``pulse_speed_100`` is the pulse width corresponding to a speed of 100."
msgstr ""

#: ../../../library/pyb.Switch.rst:5
msgid "class Switch -- switch object"
msgstr ""

#: ../../../library/pyb.Switch.rst:7
msgid "A Switch object is used to control a push-button switch."
msgstr ""

#: ../../../library/pyb.Switch.rst:11
msgid ""
"sw = pyb.Switch()       # create a switch object\n"
"sw.value()              # get state (True if pressed, False otherwise)\n"
"sw()                    # shorthand notation to get the switch state\n"
"sw.callback(f)          # register a callback to be called when the\n"
"                        #   switch is pressed down\n"
"sw.callback(None)       # remove the callback"
msgstr ""

#: ../../../library/pyb.Switch.rst:20
msgid "pyb.Switch().callback(lambda: pyb.LED(1).toggle())"
msgstr ""

#: ../../../library/pyb.Switch.rst:28
msgid "Create and return a switch object."
msgstr ""

#: ../../../library/pyb.Switch.rst:36
msgid ""
"Call switch object directly to get its state: ``True`` if pressed down, "
"``False`` otherwise."
msgstr ""

#: ../../../library/pyb.Switch.rst:41
msgid ""
"Get the switch state.  Returns ``True`` if pressed down, otherwise "
"``False``."
msgstr ""

#: ../../../library/pyb.Switch.rst:45
msgid ""
"Register the given function to be called when the switch is pressed down."
" If ``fun`` is ``None``, then it disables the callback."
msgstr ""

#: ../../../library/pyb.Timer.rst:5
msgid "class Timer -- control internal timers"
msgstr ""

#: ../../../library/pyb.Timer.rst:7
msgid ""
"Timers can be used for a great variety of tasks.  At the moment, only the"
" simplest case is implemented: that of calling a function periodically."
msgstr ""

#: ../../../library/pyb.Timer.rst:10
msgid ""
"Each timer consists of a counter that counts up at a certain rate.  The "
"rate at which it counts is the peripheral clock frequency (in Hz) divided"
" by the timer prescaler.  When the counter reaches the timer period it "
"triggers an event, and the counter resets back to zero.  By using the "
"callback method, the timer event can call a Python function."
msgstr ""

#: ../../../library/pyb.Timer.rst:16
msgid "Example usage to toggle an LED at a fixed frequency::"
msgstr ""

#: ../../../library/pyb.Timer.rst:18
msgid ""
"tim = pyb.Timer(4)              # create a timer object using timer 4\n"
"tim.init(freq=2)                # trigger at 2Hz\n"
"tim.callback(lambda t:pyb.LED(1).toggle())"
msgstr ""

#: ../../../library/pyb.Timer.rst:22
msgid "Example using named function for the callback::"
msgstr ""

#: ../../../library/pyb.Timer.rst:24
msgid ""
"def tick(timer):                # we will receive the timer object when "
"being called\n"
"    print(timer.counter())      # show current timer's counter value\n"
"tim = pyb.Timer(4, freq=1)      # create a timer object using timer 4 - "
"trigger at 1Hz\n"
"tim.callback(tick)              # set the callback to our tick function"
msgstr ""

#: ../../../library/pyb.Timer.rst:29
msgid "Further examples::"
msgstr ""

#: ../../../library/pyb.Timer.rst:31
msgid ""
"tim = pyb.Timer(4, freq=100)    # freq in Hz\n"
"tim = pyb.Timer(4, prescaler=0, period=99)\n"
"tim.counter()                   # get counter (can also set)\n"
"tim.prescaler(2)                # set prescaler (can also get)\n"
"tim.period(199)                 # set period (can also get)\n"
"tim.callback(lambda t: ...)     # set callback for update interrupt "
"(t=tim instance)\n"
"tim.callback(None)              # clear callback"
msgstr ""

#: ../../../library/pyb.Timer.rst:39
msgid ""
"*Note:* Timer(2) and Timer(3) are used for PWM to set the intensity of "
"LED(3) and LED(4) respectively.  But these timers are only configured for"
" PWM if the intensity of the relevant LED is set to a value between 1 and"
" 254.  If the intensity feature of the LEDs is not used then these timers"
" are free for general purpose use.  Similarly, Timer(5) controls the "
"servo driver, and Timer(6) is used for timed ADC/DAC reading/writing.  It"
" is recommended to use the other timers in your programs."
msgstr ""

#: ../../../library/pyb.Timer.rst:47
msgid ""
"*Note:* Memory can't be allocated during a callback (an interrupt) and so"
" exceptions raised within a callback don't give much information.  See "
":func:`micropython.alloc_emergency_exception_buf` for how to get around "
"this limitation."
msgstr ""

#: ../../../library/pyb.Timer.rst:58
msgid ""
"Construct a new timer object of the given id.  If additional arguments "
"are given, then the timer is initialised by ``init(...)``. ``id`` can be "
"1 to 14."
msgstr ""

#: ../../../library/pyb.Timer.rst:67
msgid ""
"Initialise the timer.  Initialisation must be either by frequency (in Hz)"
" or by prescaler and period::"
msgstr ""

#: ../../../library/pyb.Timer.rst:70
msgid ""
"tim.init(freq=100)                  # set the timer to trigger at 100Hz\n"
"tim.init(prescaler=83, period=999)  # set the prescaler and period "
"directly"
msgstr ""

#: ../../../library/pyb.Timer.rst:75
msgid ""
"``freq`` --- specifies the periodic frequency of the timer. You might "
"also view this as the frequency with which the timer goes through one "
"complete cycle."
msgstr ""

#: ../../../library/pyb.Timer.rst:78
msgid ""
"``prescaler`` [0-0xffff] - specifies the value to be loaded into the "
"timer's Prescaler Register (PSC). The timer clock source is divided by "
"(``prescaler + 1``) to arrive at the timer clock. Timers 2-7 and 12-14 "
"have a clock source of 84 MHz (pyb.freq()[2] \\* 2), and Timers 1, and "
"8-11 have a clock source of 168 MHz (pyb.freq()[3] \\* 2)."
msgstr ""

#: ../../../library/pyb.Timer.rst:84
msgid ""
"``period`` [0-0xffff] for timers 1, 3, 4, and 6-15. [0-0x3fffffff] for "
"timers 2 & 5. Specifies the value to be loaded into the timer's "
"AutoReload Register (ARR). This determines the period of the timer (i.e. "
"when the counter cycles). The timer counter will roll-over after ``period"
" + 1`` timer clock cycles."
msgstr ""

#: ../../../library/pyb.Timer.rst:92
msgid "``Timer.UP`` - configures the timer to count from 0 to ARR (default)"
msgstr ""

#: ../../../library/pyb.Timer.rst:93
msgid "``Timer.DOWN`` - configures the timer to count from ARR down to 0."
msgstr ""

#: ../../../library/pyb.Timer.rst:94
msgid ""
"``Timer.CENTER`` - configures the timer to count from 0 to ARR and then "
"back down to 0."
msgstr ""

#: ../../../library/pyb.Timer.rst:97
msgid ""
"``div`` can be one of 1, 2, or 4. Divides the timer clock to determine "
"the sampling clock used by the digital filters."
msgstr ""

#: ../../../library/pyb.Timer.rst:100
msgid "``callback`` - as per Timer.callback()"
msgstr ""

#: ../../../library/pyb.Timer.rst:102
msgid ""
"``deadtime`` - specifies the amount of \"dead\" or inactive time between "
"transitions on complimentary channels (both channels will be inactive) "
"for this time). ``deadtime`` may be an integer between 0 and 1008, with "
"the following restrictions: 0-128 in steps of 1. 128-256 in steps of 2, "
"256-512 in steps of 8, and 512-1008 in steps of 16. ``deadtime`` measures"
" ticks of ``source_freq`` divided by ``div`` clock ticks. ``deadtime`` is"
" only available on timers 1 and 8."
msgstr ""

#: ../../../library/pyb.Timer.rst:110
msgid "You must either specify freq or both of period and prescaler."
msgstr ""

#: ../../../library/pyb.Timer.rst:114
msgid "Deinitialises the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:116
msgid "Disables the callback (and the associated irq)."
msgstr ""

#: ../../../library/pyb.Timer.rst:118
msgid ""
"Disables any channel callbacks (and the associated irq). Stops the timer,"
" and disables the timer peripheral."
msgstr ""

#: ../../../library/pyb.Timer.rst:123
msgid ""
"Set the function to be called when the timer triggers. ``fun`` is passed "
"1 argument, the timer object. If ``fun`` is ``None`` then the callback "
"will be disabled."
msgstr ""

#: ../../../library/pyb.Timer.rst:129
msgid ""
"If only a channel number is passed, then a previously initialized channel"
" object is returned (or ``None`` if there is no previous channel)."
msgstr ""

#: ../../../library/pyb.Timer.rst:134
msgid ""
"Each channel can be configured to perform pwm, output compare, or input "
"capture. All channels share the same underlying timer, which means that "
"they share the same timer clock."
msgstr ""

#: ../../../library/pyb.Timer.rst:142
msgid "``Timer.PWM`` --- configure the timer in PWM mode (active high)."
msgstr ""

#: ../../../library/pyb.Timer.rst:143
msgid "``Timer.PWM_INVERTED`` --- configure the timer in PWM mode (active low)."
msgstr ""

#: ../../../library/pyb.Timer.rst:144
msgid "``Timer.OC_TIMING`` --- indicates that no pin is driven."
msgstr ""

#: ../../../library/pyb.Timer.rst:145
msgid ""
"``Timer.OC_ACTIVE`` --- the pin will be made active when a compare match "
"occurs (active is determined by polarity)"
msgstr ""

#: ../../../library/pyb.Timer.rst:146
msgid ""
"``Timer.OC_INACTIVE`` --- the pin will be made inactive when a compare "
"match occurs."
msgstr ""

#: ../../../library/pyb.Timer.rst:147
msgid ""
"``Timer.OC_TOGGLE`` --- the pin will be toggled when an compare match "
"occurs."
msgstr ""

#: ../../../library/pyb.Timer.rst:148
msgid ""
"``Timer.OC_FORCED_ACTIVE`` --- the pin is forced active (compare match is"
" ignored)."
msgstr ""

#: ../../../library/pyb.Timer.rst:149
msgid ""
"``Timer.OC_FORCED_INACTIVE`` --- the pin is forced inactive (compare "
"match is ignored)."
msgstr ""

#: ../../../library/pyb.Timer.rst:150
msgid "``Timer.IC`` --- configure the timer in Input Capture mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:151
msgid ""
"``Timer.ENC_A`` --- configure the timer in Encoder mode. The counter only"
" changes when CH1 changes."
msgstr ""

#: ../../../library/pyb.Timer.rst:152
msgid ""
"``Timer.ENC_B`` --- configure the timer in Encoder mode. The counter only"
" changes when CH2 changes."
msgstr ""

#: ../../../library/pyb.Timer.rst:153
msgid ""
"``Timer.ENC_AB`` --- configure the timer in Encoder mode. The counter "
"changes when CH1 or CH2 changes."
msgstr ""

#: ../../../library/pyb.Timer.rst:155
msgid "``callback`` - as per TimerChannel.callback()"
msgstr ""

#: ../../../library/pyb.Timer.rst:157
msgid ""
"``pin`` None (the default) or a Pin object. If specified (and not None) "
"this will cause the alternate function of the the indicated pin to be "
"configured for this timer channel. An error will be raised if the pin "
"doesn't support any alternate functions for this timer channel."
msgstr ""

#: ../../../library/pyb.Timer.rst:162
msgid "Keyword arguments for Timer.PWM modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:164
msgid "``pulse_width`` - determines the initial pulse width value to use."
msgstr ""

#: ../../../library/pyb.Timer.rst:165
msgid ""
"``pulse_width_percent`` - determines the initial pulse width percentage "
"to use."
msgstr ""

#: ../../../library/pyb.Timer.rst:167
msgid "Keyword arguments for Timer.OC modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:169
msgid "``compare`` - determines the initial value of the compare register."
msgstr ""

#: ../../../library/pyb.Timer.rst:171 ../../../library/pyb.Timer.rst:178
msgid "``polarity`` can be one of:"
msgstr ""

#: ../../../library/pyb.Timer.rst:173
msgid "``Timer.HIGH`` - output is active high"
msgstr ""

#: ../../../library/pyb.Timer.rst:174
msgid "``Timer.LOW`` - output is active low"
msgstr ""

#: ../../../library/pyb.Timer.rst:176
msgid "Optional keyword arguments for Timer.IC modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:180
msgid "``Timer.RISING`` - captures on rising edge."
msgstr ""

#: ../../../library/pyb.Timer.rst:181
msgid "``Timer.FALLING`` - captures on falling edge."
msgstr ""

#: ../../../library/pyb.Timer.rst:182
msgid "``Timer.BOTH`` - captures on both edges."
msgstr ""

#: ../../../library/pyb.Timer.rst:184
msgid ""
"Note that capture only works on the primary channel, and not on the "
"complimentary channels."
msgstr ""

#: ../../../library/pyb.Timer.rst:187
msgid "Notes for Timer.ENC modes:"
msgstr ""

#: ../../../library/pyb.Timer.rst:189
msgid ""
"Requires 2 pins, so one or both pins will need to be configured to use "
"the appropriate timer AF using the Pin API."
msgstr ""

#: ../../../library/pyb.Timer.rst:191
msgid "Read the encoder value using the timer.counter() method."
msgstr ""

#: ../../../library/pyb.Timer.rst:192
msgid "Only works on CH1 and CH2 (and not on CH1N or CH2N)"
msgstr ""

#: ../../../library/pyb.Timer.rst:193
msgid "The channel number is ignored when setting the encoder mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:195
msgid "PWM Example::"
msgstr ""

#: ../../../library/pyb.Timer.rst:197
msgid ""
"timer = pyb.Timer(2, freq=1000)\n"
"ch2 = timer.channel(2, pyb.Timer.PWM, pin=pyb.Pin.board.X2, "
"pulse_width=8000)\n"
"ch3 = timer.channel(3, pyb.Timer.PWM, pin=pyb.Pin.board.X3, "
"pulse_width=16000)"
msgstr ""

#: ../../../library/pyb.Timer.rst:203
msgid "Get or set the timer counter."
msgstr ""

#: ../../../library/pyb.Timer.rst:207
msgid ""
"Get or set the frequency for the timer (changes prescaler and period if "
"set)."
msgstr ""

#: ../../../library/pyb.Timer.rst:211
msgid "Get or set the period of the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:215
msgid "Get or set the prescaler for the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:219
msgid "Get the frequency of the source of the timer."
msgstr ""

#: ../../../library/pyb.Timer.rst:233
msgid ""
"Set the function to be called when the timer channel triggers. ``fun`` is"
" passed 1 argument, the timer object. If ``fun`` is ``None`` then the "
"callback will be disabled."
msgstr ""

#: ../../../library/pyb.Timer.rst:239
msgid ""
"Get or set the capture value associated with a channel. capture, compare,"
" and pulse_width are all aliases for the same function. capture is the "
"logical name to use when the channel is in input capture mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:245
msgid ""
"Get or set the compare value associated with a channel. capture, compare,"
" and pulse_width are all aliases for the same function. compare is the "
"logical name to use when the channel is in output compare mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:251
msgid ""
"Get or set the pulse width value associated with a channel. capture, "
"compare, and pulse_width are all aliases for the same function. "
"pulse_width is the logical name to use when the channel is in PWM mode."
msgstr ""

#: ../../../library/pyb.Timer.rst:255
msgid ""
"In edge aligned mode, a pulse_width of ``period + 1`` corresponds to a "
"duty cycle of 100% In center aligned mode, a pulse width of ``period`` "
"corresponds to a duty cycle of 100%"
msgstr ""

#: ../../../library/pyb.Timer.rst:260
msgid ""
"Get or set the pulse width percentage associated with a channel.  The "
"value is a number between 0 and 100 and sets the percentage of the timer "
"period for which the pulse is active.  The value can be an integer or "
"floating-point number for more accuracy.  For example, a value of 25 "
"gives a duty cycle of 25%."
msgstr ""

#: ../../../library/pyb.UART.rst:14
msgid ""
"from pyb import UART\n"
"\n"
"uart = UART(1, 9600)                         # init with given baudrate\n"
"uart.init(9600, bits=8, parity=None, stop=1) # init with given parameters"
msgstr ""

#: ../../../library/pyb.UART.rst:19
msgid ""
"Bits can be 7, 8 or 9.  Parity can be None, 0 (even) or 1 (odd).  Stop "
"can be 1 or 2."
msgstr ""

#: ../../../library/pyb.UART.rst:21 ../../../library/pyb.UART.rst:93
msgid ""
"*Note:* with parity=None, only 8 and 9 bits are supported.  With parity "
"enabled, only 7 and 8 bits are supported."
msgstr ""

#: ../../../library/pyb.UART.rst:33
msgid "Individual characters can be read/written using::"
msgstr ""

#: ../../../library/pyb.UART.rst:35
msgid ""
"uart.readchar()     # read 1 character and returns it as an integer\n"
"uart.writechar(42)  # write 1 character"
msgstr ""

#: ../../../library/pyb.UART.rst:38
msgid "To check if there is anything to be read, use::"
msgstr ""

#: ../../../library/pyb.UART.rst:40
msgid "uart.any()          # returns the number of characters waiting"
msgstr ""

#: ../../../library/pyb.UART.rst:43
msgid ""
"*Note:* The stream functions ``read``, ``write``, etc. are new in "
"MicroPython v1.3.4. Earlier versions use ``uart.send`` and ``uart.recv``."
msgstr ""

#: ../../../library/pyb.UART.rst:51
msgid ""
"Construct a UART object on the given bus.  ``bus`` can be 1-6, or 'XA', "
"'XB', 'YA', or 'YB'. With no additional parameters, the UART object is "
"created but not initialised (it has the settings from the last "
"initialisation of the bus, if any).  If extra arguments are given, the "
"bus is initialised. See ``init`` for parameters of initialisation."
msgstr ""

#: ../../../library/pyb.UART.rst:57
msgid "The physical pins of the UART busses are:"
msgstr ""

#: ../../../library/pyb.UART.rst:59
msgid "``UART(4)`` is on ``XA``: ``(TX, RX) = (X1, X2) = (PA0, PA1)``"
msgstr ""

#: ../../../library/pyb.UART.rst:60
msgid "``UART(1)`` is on ``XB``: ``(TX, RX) = (X9, X10) = (PB6, PB7)``"
msgstr ""

#: ../../../library/pyb.UART.rst:61
msgid "``UART(6)`` is on ``YA``: ``(TX, RX) = (Y1, Y2) = (PC6, PC7)``"
msgstr ""

#: ../../../library/pyb.UART.rst:62
msgid "``UART(3)`` is on ``YB``: ``(TX, RX) = (Y9, Y10) = (PB10, PB11)``"
msgstr ""

#: ../../../library/pyb.UART.rst:63
msgid "``UART(2)`` is on: ``(TX, RX) = (X3, X4) = (PA2, PA3)``"
msgstr ""

#: ../../../library/pyb.UART.rst:65
msgid ""
"The Pyboard Lite supports UART(1), UART(2) and UART(6) only. Pins are as "
"above except:"
msgstr ""

#: ../../../library/pyb.UART.rst:67
msgid "``UART(2)`` is on: ``(TX, RX) = (X1, X2) = (PA2, PA3)``"
msgstr ""

#: ../../../library/pyb.UART.rst:76
msgid "``baudrate`` is the clock rate."
msgstr ""

#: ../../../library/pyb.UART.rst:77
msgid "``bits`` is the number of bits per character, 7, 8 or 9."
msgstr ""

#: ../../../library/pyb.UART.rst:78
msgid "``parity`` is the parity, ``None``, 0 (even) or 1 (odd)."
msgstr ""

#: ../../../library/pyb.UART.rst:79
msgid "``stop`` is the number of stop bits, 1 or 2."
msgstr ""

#: ../../../library/pyb.UART.rst:80
msgid ""
"``flow`` sets the flow control type. Can be 0, ``UART.RTS``, ``UART.CTS``"
" or ``UART.RTS | UART.CTS``."
msgstr ""

#: ../../../library/pyb.UART.rst:82
msgid ""
"``timeout`` is the timeout in milliseconds to wait for writing/reading "
"the first character."
msgstr ""

#: ../../../library/pyb.UART.rst:83
msgid ""
"``timeout_char`` is the timeout in milliseconds to wait between "
"characters while writing or reading."
msgstr ""

#: ../../../library/pyb.UART.rst:84
msgid ""
"``read_buf_len`` is the character length of the read buffer (0 to "
"disable)."
msgstr ""

#: ../../../library/pyb.UART.rst:86
#, python-format
msgid ""
"This method will raise an exception if the baudrate could not be set "
"within 5% of the desired value.  The minimum baudrate is dictated by the "
"frequency of the bus that the UART is on; UART(1) and UART(6) are APB2, "
"the rest are on APB1.  The default bus frequencies give a minimum "
"baudrate of 1300 for UART(1) and UART(6) and 650 for the others.  Use "
":func:`pyb.freq <pyb.freq>` to reduce the bus frequencies to get lower "
"baudrates."
msgstr ""

#: ../../../library/pyb.UART.rst:102
msgid "Returns the number of bytes waiting (may be 0)."
msgstr ""

#: ../../../library/pyb.UART.rst:106
msgid ""
"Read characters.  If ``nbytes`` is specified then read at most that many "
"bytes. If ``nbytes`` are available in the buffer, returns immediately, "
"otherwise returns when sufficient characters arrive or the timeout "
"elapses."
msgstr ""

#: ../../../library/pyb.UART.rst:110
msgid ""
"If ``nbytes`` is not given then the method reads as much data as "
"possible.  It returns after the timeout has elapsed."
msgstr ""

#: ../../../library/pyb.UART.rst:113
msgid ""
"*Note:* for 9 bit characters each character takes two bytes, ``nbytes`` "
"must be even, and the number of characters is ``nbytes/2``."
msgstr ""

#: ../../../library/pyb.UART.rst:121
msgid "Receive a single character on the bus."
msgstr ""

#: ../../../library/pyb.UART.rst:123
msgid "Return value: The character read, as an integer.  Returns -1 on timeout."
msgstr ""

#: ../../../library/pyb.UART.rst:127
msgid ""
"Read bytes into the ``buf``.  If ``nbytes`` is specified then read at "
"most that many bytes.  Otherwise, read at most ``len(buf)`` bytes."
msgstr ""
"``buf`` にバイトを読み込みます。 ``nbytes`` が指定されている場合は、最大でその"
"バイト数を読み取ります。nbytes を指定しなかった場合は、最大で ``len(buf)`` "
"バイト数を読み込みます。"

#: ../../../library/pyb.UART.rst:135
msgid ""
"Read a line, ending in a newline character. If such a line exists, return"
" is immediate. If the timeout elapses, all available data is returned "
"regardless of whether a newline exists."
msgstr ""

#: ../../../library/pyb.UART.rst:139
msgid ""
"Return value: the line read or ``None`` on timeout if no data is "
"available."
msgstr ""

#: ../../../library/pyb.UART.rst:143
msgid ""
"Write the buffer of bytes to the bus.  If characters are 7 or 8 bits wide"
" then each byte is one character.  If characters are 9 bits wide then two"
" bytes are used for each character (little endian), and ``buf`` must "
"contain an even number of bytes."
msgstr ""

#: ../../../library/pyb.UART.rst:148
msgid ""
"Return value: number of bytes written. If a timeout occurs and no bytes "
"were written returns ``None``."
msgstr ""

#: ../../../library/pyb.UART.rst:153
msgid ""
"Write a single character on the bus.  ``char`` is an integer to write. "
"Return value: ``None``. See note below if CTS flow control is used."
msgstr ""

#: ../../../library/pyb.UART.rst:158
msgid ""
"Send a break condition on the bus.  This drives the bus low for a "
"duration of 13 bits. Return value: ``None``."
msgstr ""

#: ../../../library/pyb.UART.rst:168
msgid "to select the flow control type."
msgstr ""

#: ../../../library/pyb.UART.rst:171
msgid "Flow Control"
msgstr ""

#: ../../../library/pyb.UART.rst:173
msgid ""
"On Pyboards V1 and V1.1 ``UART(2)`` and ``UART(3)`` support RTS/CTS "
"hardware flow control using the following pins:"
msgstr ""

#: ../../../library/pyb.UART.rst:176
msgid ""
"``UART(2)`` is on: ``(TX, RX, nRTS, nCTS) = (X3, X4, X2, X1) = (PA2, PA3,"
" PA1, PA0)``"
msgstr ""

#: ../../../library/pyb.UART.rst:177
msgid ""
"``UART(3)`` is on :``(TX, RX, nRTS, nCTS) = (Y9, Y10, Y7, Y6) = (PB10, "
"PB11, PB14, PB13)``"
msgstr ""

#: ../../../library/pyb.UART.rst:179
msgid "On the Pyboard Lite only ``UART(2)`` supports flow control on these pins:"
msgstr ""

#: ../../../library/pyb.UART.rst:181
msgid "``(TX, RX, nRTS, nCTS) = (X1, X2, X4, X3) = (PA2, PA3, PA1, PA0)``"
msgstr ""

#: ../../../library/pyb.UART.rst:183
msgid ""
"In the following paragraphs the term \"target\" refers to the device "
"connected to the UART."
msgstr ""

#: ../../../library/pyb.UART.rst:186
msgid ""
"When the UART's ``init()`` method is called with ``flow`` set to one or "
"both of ``UART.RTS`` and ``UART.CTS`` the relevant flow control pins are "
"configured. ``nRTS`` is an active low output, ``nCTS`` is an active low "
"input with pullup enabled. To achieve flow control the Pyboard's ``nCTS``"
" signal should be connected to the target's ``nRTS`` and the Pyboard's "
"``nRTS`` to the target's ``nCTS``."
msgstr ""

#: ../../../library/pyb.UART.rst:193
msgid "CTS: target controls Pyboard transmitter"
msgstr ""

#: ../../../library/pyb.UART.rst:195
msgid "If CTS flow control is enabled the write behaviour is as follows:"
msgstr ""

#: ../../../library/pyb.UART.rst:197
msgid ""
"If the Pyboard's ``UART.write(buf)`` method is called, transmission will "
"stall for any periods when ``nCTS`` is ``False``. This will result in a "
"timeout if the entire buffer was not transmitted in the timeout period. "
"The method returns the number of bytes written, enabling the user to "
"write the remainder of the data if required. In the event of a timeout, a"
" character will remain in the UART pending ``nCTS``. The number of bytes "
"composing this character will be included in the return value."
msgstr ""

#: ../../../library/pyb.UART.rst:204
msgid ""
"If ``UART.writechar()`` is called when ``nCTS`` is ``False`` the method "
"will time out unless the target asserts ``nCTS`` in time. If it times out"
" ``OSError 116`` will be raised. The character will be transmitted as "
"soon as the target asserts ``nCTS``."
msgstr ""

#: ../../../library/pyb.UART.rst:209
msgid "RTS: Pyboard controls target's transmitter"
msgstr ""

#: ../../../library/pyb.UART.rst:211
msgid "If RTS flow control is enabled, behaviour is as follows:"
msgstr ""

#: ../../../library/pyb.UART.rst:213
msgid ""
"If buffered input is used (``read_buf_len`` > 0), incoming characters are"
" buffered. If the buffer becomes full, the next character to arrive will "
"cause ``nRTS`` to go ``False``: the target should cease transmission. "
"``nRTS`` will go ``True`` when characters are read from the buffer."
msgstr ""

#: ../../../library/pyb.UART.rst:218
msgid ""
"Note that the ``any()`` method returns the number of bytes in the buffer."
" Assume a buffer length of ``N`` bytes. If the buffer becomes full, and "
"another character arrives, ``nRTS`` will be set False, and ``any()`` will"
" return the count ``N``. When characters are read the additional "
"character will be placed in the buffer and will be included in the result"
" of a subsequent ``any()`` call."
msgstr ""

#: ../../../library/pyb.UART.rst:224
msgid ""
"If buffered input is not used (``read_buf_len`` == 0) the arrival of a "
"character will cause ``nRTS`` to go ``False`` until the character is "
"read."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:5
msgid "class USB_HID -- USB Human Interface Device (HID)"
msgstr ""

#: ../../../library/pyb.USB_HID.rst:7
msgid ""
"The USB_HID class allows creation of an object representing the USB Human"
" Interface Device (HID) interface.  It can be used to emulate a "
"peripheral such as a mouse or keyboard."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:11
msgid ""
"Before you can use this class, you need to use :meth:`pyb.usb_mode()` to "
"set the USB mode to include the HID interface."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:18
msgid "Create a new USB_HID object."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:28 ../../../library/pyb.USB_VCP.rst:89
msgid ""
"``data`` can be an integer, which is the number of bytes to receive, or a"
" mutable buffer, which will be filled with received bytes."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:32 ../../../library/pyb.USB_VCP.rst:93
msgid ""
"Return value: if ``data`` is an integer then a new buffer of the bytes "
"received, otherwise the number of bytes read into ``data`` is returned."
msgstr ""

#: ../../../library/pyb.USB_HID.rst:37
msgid "Send data over the USB HID interface:"
msgstr ""

#: ../../../library/pyb.USB_HID.rst:39
msgid "``data`` is the data to send (a tuple/list of integers, or a bytearray)."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:5
msgid "class USB_VCP -- USB virtual comm port"
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:7
msgid ""
"The USB_VCP class allows creation of a `stream`-like object representing "
"the USB virtual comm port.  It can be used to read and write data over "
"USB to the connected host."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:17
msgid "Create a new USB_VCP object."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:25
msgid ""
"Set the character which interrupts running Python code.  This is set to 3"
" (CTRL-C) by default, and when a CTRL-C character is received over the "
"USB VCP port, a KeyboardInterrupt exception is raised."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:29
msgid ""
"Set to -1 to disable this interrupt feature.  This is useful when you "
"want to send raw bytes over the USB VCP port."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:34
msgid "Return ``True`` if USB is connected as a serial device, else ``False``."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:38
msgid "Return ``True`` if any characters waiting, else ``False``."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:42
msgid ""
"This method does nothing.  It exists so the USB_VCP object can act as a "
"file."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:47
msgid ""
"Read at most ``nbytes`` from the serial device and return them as a bytes"
" object.  If ``nbytes`` is not specified then the method reads all "
"available bytes from the serial device. USB_VCP `stream` implicitly works"
" in non-blocking mode, so if no pending data available, this method will "
"return immediately with ``None`` value."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:56
msgid ""
"Read bytes from the serial device and store them into ``buf``, which "
"should be a buffer-like object.  At most ``len(buf)`` bytes are read. If "
"``maxlen`` is given and then at most ``min(maxlen, len(buf))`` bytes are "
"read."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:61
msgid ""
"Returns the number of bytes read and stored into ``buf`` or ``None`` if "
"no pending data available."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:66
msgid "Read a whole line from the serial device."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:68
msgid ""
"Returns a bytes object containing the data, including the trailing "
"newline character or ``None`` if no pending data available."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:73
msgid ""
"Read as much data as possible from the serial device, breaking it into "
"lines."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:76
msgid ""
"Returns a list of bytes objects, each object being one of the lines. Each"
" line will include the newline character."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:81
msgid "Write the bytes from ``buf`` to the serial device."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:83
msgid "Returns the number of bytes written."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:98
msgid "Send data over the USB VCP:"
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:100
msgid "``data`` is the data to send (an integer to send, or a buffer object)."
msgstr ""

#: ../../../library/pyb.USB_VCP.rst:103
msgid "Return value: number of bytes sent."
msgstr ""

#: ../../../library/sys.rst:2
msgid ":mod:`sys` -- system specific functions"
msgstr ":mod:`sys` -- システム固有関数"

#: ../../../library/sys.rst:7
msgid "|see_cpython_module| :mod:`python:sys`."
msgstr ""

#: ../../../library/sys.rst:14
msgid ""
"Terminate current program with a given exit code. Underlyingly, this "
"function raise as `SystemExit` exception. If an argument is given, its "
"value given as an argument to `SystemExit`."
msgstr ""
"与えた終了コードで現在のプログラムを終了します。基本的に、この関数は "
"`SystemExit` 例外を起こします。引数を与えた場合、その値は `SystemExit` "
"に引数として与えられます。"

#: ../../../library/sys.rst:20
msgid ""
"Print exception with a traceback to a file-like object *file* (or "
"`sys.stdout` by default)."
msgstr ""
"トレースバックを使用して例外をファイルライクなオブジェクト *file* (または"
"デフォルトの `sys.stdout`)に出力します。"

#: ../../../library/sys.rst:26
msgid ""
"This is simplified version of a function which appears in the "
"``traceback`` module in CPython. Unlike ``traceback.print_exception()``, "
"this function takes just exception value instead of exception type, "
"exception value, and traceback object; *file* argument should be "
"positional; further arguments are not supported. CPython-compatible "
"``traceback`` module can be found in `micropython-lib`."
msgstr ""
"これは CPython の ``traceback`` モジュールにある関数の簡略版です。"
"``traceback.print_exception()`` とは異なり、この関数は例外型、例外値、"
"トレースバックオブジェクトの代わりに例外値だけをとります。 *file* 引数は位置"
"パラメータでなければなりません。この他の引数はサポートされていません。"
"CPython 互換の ``traceback`` モジュールは `micropython-lib` にあります。"

#: ../../../library/sys.rst:38
msgid "A mutable list of arguments the current program was started with."
msgstr "現在のプログラム開始時の引数の変更可能なリスト。"

#: ../../../library/sys.rst:42
msgid "The byte order of the system (``\"little\"`` or ``\"big\"``)."
msgstr "システムのバイト順(``\"little\"`` または ``\"big\"``)。"

#: ../../../library/sys.rst:46
msgid ""
"Object with information about the current Python implementation. For "
"MicroPython, it has following attributes:"
msgstr ""
"現在の Python 実装に関する情報を持つオブジェクト。MicroPython では次の属性を持ちます:"

#: ../../../library/sys.rst:49
msgid "*name* - string \"micropython\""
msgstr "*name* - 文字列 \"micropython\""

#: ../../../library/sys.rst:50
msgid "*version* - tuple (major, minor, micro), e.g. (1, 7, 0)"
msgstr "*version* - タプル (major, minor, micro)。例: (1, 7, 0)"

#: ../../../library/sys.rst:52
msgid ""
"This object is the recommended way to distinguish MicroPython from other "
"Python implementations (note that it still may not exist in the very "
"minimal ports)."
msgstr ""
"このオブジェクトは、MicroPython を他の Python 実装と区別する推奨手段です(しかし、"
"最小限のポートには存在しないことに注意してください)。"

#: ../../../library/sys.rst:59
msgid ""
"CPython mandates more attributes for this object, but the actual useful "
"bare minimum is implemented in MicroPython."
msgstr ""
"CPython ではこのオブジェクトにもっと多くの属性がありますが、MicroPython では実際に"
"有用となる最低限のものだけを実装しています。"

#: ../../../library/sys.rst:64
msgid ""
"Maximum value which a native integer type can hold on the current "
"platform, or maximum value representable by MicroPython integer type, if "
"it's smaller than platform max value (that is the case for MicroPython "
"ports without long int support)."
msgstr ""
"現在のプラットフォームでネイティブ整数型が保持できる最大値、またはプラットフォームの"
"最大値より小さい場合は MicroPython 整数型で表現可能な最大値(MicroPython ポートで "
"long int をサポートしないとした場合)。"

#: ../../../library/sys.rst:69
msgid ""
"This attribute is useful for detecting \"bitness\" of a platform (32-bit "
"vs 64-bit, etc.). It's recommended to not compare this attribute to some "
"value directly, but instead count number of bits in it::"
msgstr ""
"この属性は、プラットフォームの「ビット数」(32ビットか64ビットかなど)を検出するのに"
"便利です。この属性をある値と直接比較するのよりも、その属性のビット数をカウントする"
"ことをお勧めします。"

#: ../../../library/sys.rst:73
msgid ""
"bits = 0\n"
"v = sys.maxsize\n"
"while v:\n"
"    bits += 1\n"
"    v >>= 1\n"
"if bits > 32:\n"
"    # 64-bit (or more) platform\n"
"    ...\n"
"else:\n"
"    # 32-bit (or less) platform\n"
"    # Note that on 32-bit platform, value of bits may be less than 32\n"
"    # (e.g. 31) due to peculiarities described above, so use \"> 16\",\n"
"    # \"> 32\", \"> 64\" style of comparisons."
msgstr ""
"bits = 0\n"
"v = sys.maxsize\n"
"while v:\n"
"    bits += 1\n"
"    v >>= 1\n"
"if bits > 32:\n"
"    # 64ビット(以上)のプラットフォーム\n"
"    ...\n"
"else:\n"
"    # 32ビット(以下)のプラットフォーム\n"
"    # 32ビットプラットフォームでは、上記の特性によってビットの値が32未満\n"
"    # (たとえば31)になる可能性があるので、 \"> 16\", \"> 32\", \"> 64\" の\n"
"    # の比較スタイルを使用してください。"

#: ../../../library/sys.rst:89
msgid ""
"Dictionary of loaded modules. On some ports, it may not include builtin "
"modules."
msgstr ""
"読み込まれたモジュールの辞書。一部のポートでは、組込みモジュールが含まれていない"
"可能性があります。"

#: ../../../library/sys.rst:94
msgid "A mutable list of directories to search for imported modules."
msgstr "import するモジュールを検索するディレクトリの変更可能なリスト。"

#: ../../../library/sys.rst:98
msgid ""
"The platform that MicroPython is running on. For OS/RTOS ports, this is "
"usually an identifier of the OS, e.g. ``\"linux\"``. For baremetal ports "
"it is an identifier of a board, e.g. ``\"pyboard\"`` for the original "
"MicroPython reference board. It thus can be used to distinguish one board"
" from another. If you need to check whether your program runs on "
"MicroPython (vs other Python implementation), use `sys.implementation` "
"instead."
msgstr ""
"MicroPython が実行されているプラ​​ットフォーム。OS/RTOS ポートの場合、これは通常 "
"``\"linux\"`` など OS の識別子となります。ベアメタルポートの場合はボードの識別子"
"となります。オリジナルの MicroPython リファレンスボードでは ``\"pyboard\"`` "
"となります。したがって、これはあるボードを別のボードと区別するために使用できます。"
"あなたのプログラムが MicroPython 上で実行されているのか(それとも他の Python "
"実装で動いているのか)を確認する必要がある場合は代わりに `sys.implementation` "
"を使ってください。"

#: ../../../library/sys.rst:107
msgid "Standard error `stream`."
msgstr "標準エラーの `stream` 。"

#: ../../../library/sys.rst:111
msgid "Standard input `stream`."
msgstr "標準入力の `stream` 。"

#: ../../../library/sys.rst:115
msgid "Standard output `stream`."
msgstr "標準出力の `stream` 。"

#: ../../../library/sys.rst:119
msgid "Python language version that this implementation conforms to, as a string."
msgstr "この実装が準拠する Python 言語バージョン。"

#: ../../../library/sys.rst:123
msgid ""
"Python language version that this implementation conforms to, as a tuple "
"of ints."
msgstr ""
"この実装が準拠している Python 言語バージョンを表す int の タプル。"

#: ../../../library/ubinascii.rst:2
msgid ":mod:`ubinascii` -- binary/ASCII conversions"
msgstr ":mod:`ubinascii` -- バイナリ/ASCII 変換"

#: ../../../library/ubinascii.rst:7
msgid "|see_cpython_module| :mod:`python:binascii`."
msgstr ""

#: ../../../library/ubinascii.rst:9
msgid ""
"This module implements conversions between binary data and various "
"encodings of it in ASCII form (in both directions)."
msgstr ""
"このモジュールは、バイナリデータと ASCII 形式のさまざまなエンコーディングとの"
"間の変換(両方向)を実装します。"

#: ../../../library/ubinascii.rst:17
msgid "Convert binary data to hexadecimal representation. Returns bytes string."
msgstr "バイナリデータを16進表現に変換します。バイト列を返します。"

#: ../../../library/ubinascii.rst:22
msgid ""
"If additional argument, *sep* is supplied, it is used as a separator "
"between hexadecimal values."
msgstr ""
"追加の引数 *sep* が指定された場合、それは16進値の間のセパレータとして使われます。"

#: ../../../library/ubinascii.rst:27
msgid ""
"Convert hexadecimal data to binary representation. Returns bytes string. "
"(i.e. inverse of hexlify)"
msgstr ""
"16進データをバイナリ表現に変換します。バイト列を返します。(すなわち、hexlify の逆)"

#: ../../../library/ubinascii.rst:32
msgid ""
"Decode base64-encoded data, ignoring invalid characters in the input. "
"Conforms to `RFC 2045 s.6.8 "
"<https://tools.ietf.org/html/rfc2045#section-6.8>`_. Returns a bytes "
"object."
msgstr ""
"base64でエンコードされたデータをデコードします。入力中の無効な文字は無視します。"
"`RFC 2045 s.6.8 <https://tools.ietf.org/html/rfc2045#section-6.8>`_ "
"に準拠しています。バイト列を返します。"

#: ../../../library/ubinascii.rst:38
msgid ""
"Encode binary data in base64 format, as in `RFC 3548 "
"<https://tools.ietf.org/html/rfc3548.html>`_. Returns the encoded data "
"followed by a newline character, as a bytes object."
msgstr ""
"`RFC 3548 <https://tools.ietf.org/html/rfc3548.html>`_ "
"のように、バイナリデータをbase64形式でエンコードします。コード化されたデータの"
"後ろに改行文字を付けて、バイト列として返します。"

#: ../../library/ubluetooth.rst:2
msgid ":mod:`ubluetooth` --- low-level Bluetooth"
msgstr ":mod:`ubluetooth` --- 低レベル Bluetooth"

#: ../../library/ubluetooth.rst:7
msgid ""
"This module provides an interface to a Bluetooth controller on a board. "
"Currently this supports Bluetooth Low Energy (BLE) in Central, "
"Peripheral, Broadcaster, and Observer roles, and a device may operate in "
"multiple roles concurrently."
msgstr ""
"このモジュールは、ボード上の Bluetooth コントローラーへのインターフェースを提供します。"
"現在、これは、セントラル、プリフェラル、ブロードキャスター、オブザーバーのロールで "
"Bluetooth Low Energy（BLE）をサポートしており、デバイスは複数のロールで同時に"
"動作できます。"

#: ../../library/ubluetooth.rst:12
msgid ""
"This API is intended to match the low-level Bluetooth protocol and "
"provide building-blocks for higher-level abstractions such as specific "
"device types."
msgstr ""
"このAPIは、低レベルの Bluetooth プロトコルに相当するもので、特定のデバイスタイプ"
"などの高レベルの抽象化のビルディングブロックを提供します。"

#: ../../library/ubluetooth.rst:15
msgid ""
"This module is still under development and its classes, functions, "
"methods and constants are subject to change."
msgstr ""
"このモジュールはまだ開発中であり、そのクラス、関数、メソッド、定数は変更される"
"可能性があります。"

#: ../../library/ubluetooth.rst:19
msgid "class BLE"
msgstr "クラス BLE"

#: ../../library/ubluetooth.rst:21 ../../library/ubluetooth.rst:323
msgid "Constructor"
msgstr "コンストラクタ"

#: ../../library/ubluetooth.rst:26
msgid "Returns the singleton BLE object."
msgstr "シンゲルトンの BLE オブジェクトを返します。"

#: ../../library/ubluetooth.rst:29
msgid "Configuration"
msgstr "設定"

#: ../../library/ubluetooth.rst:33
msgid ""
"Optionally changes the active state of the BLE radio, and returns the "
"current state."
msgstr ""
"オプションでBLE無線のアクティブ状態を変更し、現在の状態を返します。"

#: ../../library/ubluetooth.rst:36
msgid ""
"The radio must be made active before using any other methods on this "
"class."
msgstr ""
"このクラスの他のメソッドを使用する前には、BLE無線をアクティブにする必要があります。"

#: ../../library/ubluetooth.rst:41
msgid ""
"Get or set configuration values of the BLE interface.  To get a value the"
" parameter name should be quoted as a string, and just one parameter is "
"queried at a time.  To set values use the keyword syntax, and one ore "
"more parameter can be set at a time."
msgstr ""
"BLE インターフェイスの設定値を取得または設定します。値を取得するには、パラメーター名を"
"文字列として一度に１つだけ指定します。値を設定する場合には、キーワード構文を使って、"
"一度に1つ以上のパラメーターを設定できます。"

#: ../../library/ubluetooth.rst:46
msgid "Currently supported values are:"
msgstr "現在サポートされている値は次のとおりです:"

#: ../../library/ubluetooth.rst:48
msgid ""
"``'mac'``: Returns the device MAC address. If a device has a fixed "
"address (e.g. PYBD) then it will be returned. Otherwise (e.g. ESP32) a "
"random address will be generated when the BLE interface is made active."
msgstr ""
"``'mac'``: デバイスの MAC アドレスを返します。（PYBDなど）デバイスに固定アドレスが"
"ある場合には、その固定アドレスを返します。それ以外の場合（ESP32など）には、BLE"
"インターフェイスがアクティブになったときにランダムアドレスが生成されます。"

#: ../../library/ubluetooth.rst:52
msgid ""
"``'rxbuf'``: Get/set the size in bytes of the internal buffer used to "
"store incoming events.  This buffer is global to the entire BLE driver "
"and so handles incoming data for all events, including all "
"characteristics. Increasing this allows better handling of bursty "
"incoming data (for example scan results) and the ability for a central "
"role to receive larger characteristic values."
msgstr ""
"``'rxbuf'``: 着信イベントの保存に使用される内部バッファーのサイズをバイト単位で"
"取得/設定します。このバッファは BLE ドライバー全体に対してグローバルであるため、すべての"
"キャラクタリスティック(Characteristic)を含むすべてのイベントの着信データを処理"
"します。これを増やすと、バーストな受信データ(スキャン結果など)の処理が改善され、"
"セントラル(Central)なロール(Role)がより大きなキャラクタリスティック値を受信"
"できるようになります。"

#: ../../library/ubluetooth.rst:60
msgid "Event Handling"
msgstr "イベント処理"

#: ../../library/ubluetooth.rst:64
msgid ""
"Registers a callback for events from the BLE stack. The *handler* takes "
"two arguments, ``event`` (which will be one of the codes below) and "
"``data`` (which is an event-specific tuple of values)."
msgstr ""
"BLE スタックからのイベントのコールバックを登録します。 *handler* に指定する"
"コールバックは二つの引数 ``event`` （後述するイベントコードのいずれか）と "
"``data`` (イベント固有の値のタプル）をとります。

#: ../../library/ubluetooth.rst:68
msgid ""
"The optional *trigger* parameter allows you to set a mask of events that "
"your program is interested in. The default is all events."
msgstr ""
"オプションの *trigger* パラメーターを指定すると、プログラムが対象とするイベントの"
"マスクを設定できます。デフォルトはすべてのイベントです。"

#: ../../library/ubluetooth.rst:71
msgid ""
"Note: the ``addr``, ``adv_data`` and ``uuid`` entries in the tuples are "
"references to data managed by the :mod:`ubluetooth` module (i.e. the same"
" instance will be re-used across multiple calls to the event handler). If"
" your program wants to use this data outside of the handler, then it must"
" copy them first, e.g. by using ``bytes(addr)`` or "
"``bluetooth.UUID(uuid)``."
msgstr ""
"注記: タプルの ``addr``, ``adv_data``, ``uuid`` 項目は、 :mod:`ubluetooth` "
"モジュールによって管理されるデータへの参照です(つまり、複数のイベントハンドラー"
"呼び出しで同じインスタンスが再利用されます)。プログラムがハンドラの外部でこのデータを"
"使う場合、まず ``bytes(addr)`` または ``bluetooth.UUID(uuid)`` などを使って"
"これらのデータをコピーする必要があります。"

#: ../../library/ubluetooth.rst:77
msgid "An event handler showing all possible events::"
msgstr "すべてのイベントを処理するイベントハンドラーの例を示します:"

#: ../../library/ubluetooth.rst:79
msgid ""
"def bt_irq(event, data):\n"
"    if event == _IRQ_CENTRAL_CONNECT:\n"
"        # A central has connected to this peripheral.\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_CENTRAL_DISCONNECT:\n"
"        # A central has disconnected from this peripheral.\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_GATTS_WRITE:\n"
"        # A central has written to this characteristic or descriptor.\n"
"        conn_handle, attr_handle = data\n"
"    elif event == _IRQ_GATTS_READ_REQUEST:\n"
"        # A central has issued a read. Note: this is a hard IRQ.\n"
"        # Return None to deny the read.\n"
"        # Note: This event is not supported on ESP32.\n"
"        conn_handle, attr_handle = data\n"
"    elif event == _IRQ_SCAN_RESULT:\n"
"        # A single scan result.\n"
"        addr_type, addr, connectable, rssi, adv_data = data\n"
"    elif event == _IRQ_SCAN_COMPLETE:\n"
"        # Scan duration finished or manually stopped.\n"
"        pass\n"
"    elif event == _IRQ_PERIPHERAL_CONNECT:\n"
"        # A successful gap_connect().\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_PERIPHERAL_DISCONNECT:\n"
"        # Connected peripheral has disconnected.\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_GATTC_SERVICE_RESULT:\n"
"        # Called for each service found by gattc_discover_services().\n"
"        conn_handle, start_handle, end_handle, uuid = data\n"
"    elif event == _IRQ_GATTC_CHARACTERISTIC_RESULT:\n"
"        # Called for each characteristic found by "
"gattc_discover_services().\n"
"        conn_handle, def_handle, value_handle, properties, uuid = data\n"
"    elif event == _IRQ_GATTC_DESCRIPTOR_RESULT:\n"
"        # Called for each descriptor found by "
"gattc_discover_descriptors().\n"
"        conn_handle, dsc_handle, uuid = data\n"
"    elif event == _IRQ_GATTC_READ_RESULT:\n"
"        # A gattc_read() has completed.\n"
"        conn_handle, value_handle, char_data = data\n"
"    elif event == _IRQ_GATTC_WRITE_STATUS:\n"
"        # A gattc_write() has completed.\n"
"        conn_handle, value_handle, status = data\n"
"    elif event == _IRQ_GATTC_NOTIFY:\n"
"        # A peripheral has sent a notify request.\n"
"        conn_handle, value_handle, notify_data = data\n"
"    elif event == _IRQ_GATTC_INDICATE:\n"
"        # A peripheral has sent an indicate request.\n"
"        conn_handle, value_handle, notify_data = data"
msgstr ""
"def bt_irq(event, data):\n"
"    if event == _IRQ_CENTRAL_CONNECT:\n"
"        # A central has connected to this peripheral.\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_CENTRAL_DISCONNECT:\n"
"        # A central has disconnected from this peripheral.\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_GATTS_WRITE:\n"
"        # A central has written to this characteristic or descriptor.\n"
"        conn_handle, attr_handle = data\n"
"    elif event == _IRQ_GATTS_READ_REQUEST:\n"
"        # A central has issued a read. Note: this is a hard IRQ.\n"
"        # Return None to deny the read.\n"
"        # Note: This event is not supported on ESP32.\n"
"        conn_handle, attr_handle = data\n"
"    elif event == _IRQ_SCAN_RESULT:\n"
"        # A single scan result.\n"
"        addr_type, addr, connectable, rssi, adv_data = data\n"
"    elif event == _IRQ_SCAN_COMPLETE:\n"
"        # Scan duration finished or manually stopped.\n"
"        pass\n"
"    elif event == _IRQ_PERIPHERAL_CONNECT:\n"
"        # A successful gap_connect().\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_PERIPHERAL_DISCONNECT:\n"
"        # Connected peripheral has disconnected.\n"
"        conn_handle, addr_type, addr = data\n"
"    elif event == _IRQ_GATTC_SERVICE_RESULT:\n"
"        # Called for each service found by gattc_discover_services().\n"
"        conn_handle, start_handle, end_handle, uuid = data\n"
"    elif event == _IRQ_GATTC_CHARACTERISTIC_RESULT:\n"
"        # Called for each characteristic found by "
"gattc_discover_services().\n"
"        conn_handle, def_handle, value_handle, properties, uuid = data\n"
"    elif event == _IRQ_GATTC_DESCRIPTOR_RESULT:\n"
"        # Called for each descriptor found by "
"gattc_discover_descriptors().\n"
"        conn_handle, dsc_handle, uuid = data\n"
"    elif event == _IRQ_GATTC_READ_RESULT:\n"
"        # A gattc_read() has completed.\n"
"        conn_handle, value_handle, char_data = data\n"
"    elif event == _IRQ_GATTC_WRITE_STATUS:\n"
"        # A gattc_write() has completed.\n"
"        conn_handle, value_handle, status = data\n"
"    elif event == _IRQ_GATTC_NOTIFY:\n"
"        # A peripheral has sent a notify request.\n"
"        conn_handle, value_handle, notify_data = data\n"
"    elif event == _IRQ_GATTC_INDICATE:\n"
"        # A peripheral has sent an indicate request.\n"
"        conn_handle, value_handle, notify_data = data"

#: ../../library/ubluetooth.rst:128
msgid "The event codes are::"
msgstr "イベントコードには次のものがあります::"

#: ../../library/ubluetooth.rst:130
msgid ""
"from micropython import const\n"
"_IRQ_CENTRAL_CONNECT                 = const(1 << 0)\n"
"_IRQ_CENTRAL_DISCONNECT              = const(1 << 1)\n"
"_IRQ_GATTS_WRITE                     = const(1 << 2)\n"
"_IRQ_GATTS_READ_REQUEST              = const(1 << 3)\n"
"_IRQ_SCAN_RESULT                     = const(1 << 4)\n"
"_IRQ_SCAN_COMPLETE                   = const(1 << 5)\n"
"_IRQ_PERIPHERAL_CONNECT              = const(1 << 6)\n"
"_IRQ_PERIPHERAL_DISCONNECT           = const(1 << 7)\n"
"_IRQ_GATTC_SERVICE_RESULT            = const(1 << 8)\n"
"_IRQ_GATTC_CHARACTERISTIC_RESULT     = const(1 << 9)\n"
"_IRQ_GATTC_DESCRIPTOR_RESULT         = const(1 << 10)\n"
"_IRQ_GATTC_READ_RESULT               = const(1 << 11)\n"
"_IRQ_GATTC_WRITE_STATUS              = const(1 << 12)\n"
"_IRQ_GATTC_NOTIFY                    = const(1 << 13)\n"
"_IRQ_GATTC_INDICATE                  = const(1 << 14)"
msgstr ""

#: ../../library/ubluetooth.rst:147
msgid ""
"In order to save space in the firmware, these constants are not included "
"on the :mod:`ubluetooth` module. Add the ones that you need from the list"
" above to your program."
msgstr ""
"ファームウェアのスペースを節約するために、これらの定数は ubluetooth モジュールには"
"含まれていません 。上記のリストから必要なものをプログラムに追加してください。"

#: ../../library/ubluetooth.rst:153
msgid "Broadcaster Role (Advertiser)"
msgstr "ブロードキャスターロール(アドバタイザー)"

#: ../../library/ubluetooth.rst:157
msgid ""
"Starts advertising at the specified interval (in **micro**\\ seconds). "
"This interval will be rounded down to the nearest 625us. To stop "
"advertising, set *interval_us* to ``None``."
msgstr ""
"指定された間隔(マイクロ秒単位)でアドバタイジング(Advertising)を開始します。"
"この間隔は、625us に最も近いところで切り捨てられます。アドバタイジングを"
"停止するには *interval_us* を ``None`` に設定します。"

#: ../../library/ubluetooth.rst:161
msgid ""
"*adv_data* and *resp_data* can be any type that implements the buffer "
"protocol (e.g. ``bytes``, ``bytearray``, ``str``). *adv_data* is included"
" in all broadcasts, and *resp_data* is send in reply to an active scan."
msgstr ""
"*adv_data* と *resp_data* はバッファプロトコルを実装する任意のタイプにできます"
"(``bytes``, ``bytearray``, ``str`` など)。 *adv_data* はすべての"
"ブロードキャストに含まれ、 *resp_data* はアクティブスキャンへの返信として送信されます。"

#: ../../library/ubluetooth.rst:165
msgid ""
"Note: if *adv_data* (or *resp_data*) is ``None``, then the data passed to"
" the previous call to ``gap_advertise`` will be re-used. This allows a "
"broadcaster to resume advertising with just "
"``gap_advertise(interval_us)``. To clear the advertising payload pass an "
"empty ``bytes``, i.e. ``b''``."
msgstr ""
"注記: *adv_data* (または *resp_data*)が ``None`` の場合、前の "
"``gap_advertise`` 呼び出しに渡されたデータが再利用されます。これにより "
"``gap_advertise(interval_us)`` だけで、ブロードキャスターは"
"アドバタイジングを再開できます。アドバタイジングペイロードをクリアするには、"
"空の ``bytes`` 、すなわち ``b''`` を渡します。"

#: ../../library/ubluetooth.rst:172
msgid "Observer Role (Scanner)"
msgstr "オブザーバーロール(スキャナー)"

#: ../../library/ubluetooth.rst:176
msgid ""
"Run a scan operation lasting for the specified duration (in **milli**\\ "
"seconds)."
msgstr ""
"指定された期間(**ミリ** 秒単位)持続するスキャン操作を実行します。"

#: ../../library/ubluetooth.rst:178
msgid "To scan indefinitely, set *duration_ms* to ``0``."
msgstr "無期限にスキャンするには *duration_ms* を ``0`` に設定します。"

#: ../../library/ubluetooth.rst:180
msgid "To stop scanning, set *duration_ms* to ``None``."
msgstr "スキャンを停止するには *duration_ms* を ``None`` に設定します。"

#: ../../library/ubluetooth.rst:182
msgid ""
"Use *interval_us* and *window_us* to optionally configure the duty cycle."
" The scanner will run for *window_us* **micro**\\ seconds every "
"*interval_us* **micro**\\ seconds for a total of *duration_ms* "
"**milli**\\ seconds. The default interval and window are 1.28 seconds and"
" 11.25 milliseconds respectively (background scanning)."
msgstr ""
"オプションでデューティサイクル(duty cycle)を設定するには *interval_us* と "
"*window_us* を使います。スキャナは全体の *duration_ms* **ミリ**\\ 秒の間の "
"*interval_us* **マイクロ**\\ 秒毎に *window_us* **マイクロ**\\ 秒間実行します。 "
"*interval_us* と *window_us のデフォルト値はそれぞれ 1.28 と 11.25 です"
"(バックグラウンドスキャン)。"

#: ../../library/ubluetooth.rst:188
msgid "For each scan result, the ``_IRQ_SCAN_RESULT`` event will be raised."
msgstr "スキャン結果ごとに、``_IRQ_SCAN_RESULT`` イベントが発生します。"

#: ../../library/ubluetooth.rst:190
msgid ""
"When scanning is stopped (either due to the duration finishing or when "
"explicitly stopped), the ``_IRQ_SCAN_COMPLETE`` event will be raised."
msgstr ""
"スキャンが終了すると(終了時間になったか、明示的に停止した場合)、 "
"``_IRQ_SCAN_COMPLETE`` イベントが発生します。"

#: ../../library/ubluetooth.rst:195
msgid "Peripheral Role (GATT Server)"
msgstr "ペリフェラルロール(GATT サーバー)"

#: ../../library/ubluetooth.rst:197
msgid ""
"A BLE peripheral has a set of registered services. Each service may "
"contain characteristics, which each have a value. Characteristics can "
"also contain descriptors, which themselves have values."
msgstr ""
"BLE ペリフェラルには登録されたサービスのセットがあります。各サービスには"
"キャラクタリスティック(Characteristic)が含まれていることがあり、"
"各キャラクタリスティックは値を持ちます。キャラクタリスティックには、それ自体に値を"
"持つディスクリプタを含めることもできます。"

#: ../../library/ubluetooth.rst:201
msgid ""
"These values are stored locally, and are accessed by their \"value "
"handle\" which is generated during service registration. They can also be"
" read from or written to by a remote central device. Additionally, a "
"peripheral can \"notify\" a characteristic to a connected central via a "
"connection handle."
msgstr ""
"これらの値はローカルに保存され、サービス登録中に生成される「値ハンドル(value handle)」"
"によってアクセスされます。また、リモートのセントラルデバイスから読み書きすることもできます。"
"さらに、プリフェラルは接続ハンドルを介して接続されたセントラルにキャラクタリスティックを"
"「通知(notify)」できます。"

#: ../../library/ubluetooth.rst:206
msgid ""
"Characteristics and descriptors have a default maximum size of 20 bytes. "
"Anything written to them by a central will be truncated to this length. "
"However, any local write will increase the maximum size, so if you want "
"to allow larger writes from a central to a given characteristic, use "
":meth:`gatts_write<BLE.gatts_write>` after registration. e.g. "
"``gatts_write(char_handle, bytes(100))``."
msgstr ""
"キャラクタリスティックとディスクリプタのデフォルト最大サイズは 20 バイトです。"
"セントラルによってそれらに書き込まれたものはすべて、この長さに切り捨てられます。"
"ただし、セントラルから特定のキャラクタリスティックへのより大きな書き込みを許可したくて、"
"ローカル書き込みの最大サイズを大きくするには、登録後に "
":meth:`gatts_write<BLE.gatts_write>` を使います。"
"たとえば ``gatts_write(char_handle, bytes(100))`` のようにします。"

#: ../../library/ubluetooth.rst:215
msgid ""
"Configures the peripheral with the specified services, replacing any "
"existing services."
msgstr ""
"指定したサービスでプリフェラルを構成し、既存のサービスを置換します。"

#: ../../library/ubluetooth.rst:218
msgid ""
"*services_definition* is a list of **services**, where each **service** "
"is a two-element tuple containing a UUID and a list of "
"**characteristics**."
msgstr ""
"*services_definition* は **サービス** のリストであり、各 **サービス** は "
"UUID と **キャラクタリスティック** のリストを含む２項目のタプルです。"

#: ../../library/ubluetooth.rst:221
msgid ""
"Each **characteristic** is a two-or-three-element tuple containing a "
"UUID, a **flags** value, and optionally a list of *descriptors*."
msgstr ""
"各 **キャラクタリスティック** は、UUID、 **フラグ** 値、およびオプションの "
"*ディスクリプタ* のリストを含む２または３項目のタプルです。"

#: ../../library/ubluetooth.rst:224
msgid ""
"Each **descriptor** is a two-element tuple containing a UUID and a "
"**flags** value."
msgstr ""
"各 **ディスクリプタ** は UUID と **フラグ** 値を含む２項目のタプルです。"

#: ../../library/ubluetooth.rst:227
msgid ""
"The **flags** are a bitwise-OR combination of the "
":data:`ubluetooth.FLAG_READ`, :data:`ubluetooth.FLAG_WRITE` and "
":data:`ubluetooth.FLAG_NOTIFY` values defined below."
msgstr ""
"**フラグ** は、後述する値 :data:`ubluetooth.FLAG_READ`, "
":data:`ubluetooth.FLAG_WRITE`, :data:`ubluetooth.FLAG_NOTIFY` "
"のビット論理和の組み合わせです。"

#: ../../library/ubluetooth.rst:231
msgid ""
"The return value is a list (one element per service) of tuples (each "
"element is a value handle). Characteristics and descriptor handles are "
"flattened into the same tuple, in the order that they are defined."
msgstr ""
"戻り値は、タプル(各項目は値ハンドル)のリスト(サービスごとに1項目)です。"
"キャラクタリスティックとディスクリプタのハンドルは、定義された順序で同じタプルに"
"フラット化されます。"

#: ../../library/ubluetooth.rst:235
msgid ""
"The following example registers two services (Heart Rate, and Nordic "
"UART)::"
msgstr ""
"次の例では、２つのサービス(心拍数と Nordic UART)を登録します。"

#: ../../library/ubluetooth.rst:237
msgid ""
"HR_UUID = bluetooth.UUID(0x180D)\n"
"HR_CHAR = (bluetooth.UUID(0x2A37), bluetooth.FLAG_READ | "
"bluetooth.FLAG_NOTIFY,)\n"
"HR_SERVICE = (HR_UUID, (HR_CHAR,),)\n"
"UART_UUID = bluetooth.UUID('6E400001-B5A3-F393-E0A9-E50E24DCCA9E')\n"
"UART_TX = (bluetooth.UUID('6E400003-B5A3-F393-E0A9-E50E24DCCA9E'), "
"bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY,)\n"
"UART_RX = (bluetooth.UUID('6E400002-B5A3-F393-E0A9-E50E24DCCA9E'), "
"bluetooth.FLAG_WRITE,)\n"
"UART_SERVICE = (UART_UUID, (UART_TX, UART_RX,),)\n"
"SERVICES = (HR_SERVICE, UART_SERVICE,)\n"
"( (hr,), (tx, rx,), ) = bt.gatts_register_services(SERVICES)"
msgstr ""

#: ../../library/ubluetooth.rst:247
msgid ""
"The three value handles (``hr``, ``tx``, ``rx``) can be used with "
":meth:`gatts_read <BLE.gatts_read>`, :meth:`gatts_write "
"<BLE.gatts_write>`, and :meth:`gatts_notify <BLE.gatts_notify>`."
msgstr ""
"３項目のハンドル (``hr``, ``tx``, ``rx``) は "
":meth:`gatts_read <BLE.gatts_read>`, :meth:`gatts_write "
"<BLE.gatts_write>`, :meth:`gatts_notify <BLE.gatts_notify>` "
"で使えます。"

#: ../../library/ubluetooth.rst:251
msgid "**Note:** Advertising must be stopped before registering services."
msgstr ""
"**注記注:** サービスを登録する前に、アドバタイジングを停止する必要があります。"

#: ../../library/ubluetooth.rst:255
msgid ""
"Reads the local value for this handle (which has either been written by "
":meth:`gatts_write <BLE.gatts_write>` or by a remote central)."
msgstr ""
"このハンドルのためのローカル値(:meth:`gatts_write <BLE.gatts_write>` か"
"リモートセントラルで書き込まれたもの)を読み取ります。"

#: ../../library/ubluetooth.rst:260
msgid "Writes the local value for this handle, which can be read by a central."
msgstr ""
"このハンドルのローカル値を書き込みます。これは、セントラルによって読み取ることができます。"

#: ../../library/ubluetooth.rst:264
msgid ""
"Notifies a connected central that this value has changed and that it "
"should issue a read of the current value from this peripheral."
msgstr ""
"接続されているセントラルに、この値が変更されたこと、およびこのペリフェラルから"
"現在の値の読み取りを発行する必要があることを通知します。"

#: ../../library/ubluetooth.rst:267
msgid ""
"If *data* is specified, then the that value is sent to the central as "
"part of the notification, avoiding the need for a separate read request. "
"Note that this will not update the local value stored."
msgstr ""
"*data* が指定されている場合、その値は通知の一部としてセントラルに送られます。"
"これにより個別読み出し要求の必要性を回避します。"
"これは保存されているローカル値が更新されないことに注意してください。"

#: ../../library/ubluetooth.rst:273
msgid ""
"Sets the internal buffer size for a value in bytes. This will limit the "
"largest possible write that can be received. The default is 20."
msgstr ""
"値の内部バッファサイズをバイト数で設定します。これにより、受信可能な最大の書き込みが"
"制限されます。デフォルトは 20 です。"

#: ../../library/ubluetooth.rst:276
msgid ""
"Setting *append* to ``True`` will make all remote writes append to, "
"rather than replace, the current value. At most *len* bytes can be "
"buffered in this way. When you use :meth:`gatts_read <BLE.gatts_read>`, "
"the value will be cleared after reading. This feature is useful when "
"implementing something like the Nordic UART Service."
msgstr ""
"*append* を ``True`` に設定すると、すべてのリモート書き込みが現在の値に"
"置き換えられるのではなく、追加されます。この方法では、最大で *len* バイトを"
"バッファリングできます。 :meth:`gatts_read <BLE.gatts_read>` を使用すると、"
"読み取り後に値がクリアされます。この機能は、Nordic UART サービスのようなものを"
"実装するときに役立ちます。"

#: ../../library/ubluetooth.rst:284
msgid "Central Role (GATT Client)"
msgstr "セントラルロール(GATT クライアント)"

#: ../../library/ubluetooth.rst:288
msgid "Connect to a peripheral."
msgstr "ペリフェラルに接続します。"

#: ../../library/ubluetooth.rst:290
msgid "On success, the ``_IRQ_PERIPHERAL_CONNECT`` event will be raised."
msgstr "成功すると ``_IRQ_PERIPHERAL_CONNECT`` イベントが発生します。"

#: ../../library/ubluetooth.rst:294
msgid "Disconnect the specified connection handle."
msgstr "指定した接続ハンドルを切断します。"

#: ../../library/ubluetooth.rst:296
msgid "On success, the ``_IRQ_PERIPHERAL_DISCONNECT`` event will be raised."
msgstr "成功すると ``_IRQ_PERIPHERAL_DISCONNECT`` イベントが発生します。"

#: ../../library/ubluetooth.rst:298
msgid ""
"Returns ``False`` if the connection handle wasn't connected, and ``True``"
" otherwise."
msgstr ""
"接続ハンドルが接続されていなければ ``False`` が返り、さもなければ ``True`` が返ります。"

#: ../../library/ubluetooth.rst:303
msgid "Query a connected peripheral for its services."
msgstr "サービスについて接続されたペリフェラルを問い合わせます。"

#: ../../library/ubluetooth.rst:305
msgid ""
"For each service discovered, the ``_IRQ_GATTC_SERVICE_RESULT`` event will"
" be raised."
msgstr ""
"検出された各サービスについて ``_IRQ_GATTC_SERVICE_RESULT`` イベントが発生します。"

#: ../../library/ubluetooth.rst:310
msgid "Query a connected peripheral for characteristics in the specified range."
msgstr "指定した範囲のキャラクタリスティックについて接続されたペリフェラルを問い合わせます。"

#: ../../library/ubluetooth.rst:312
msgid ""
"For each characteristic discovered, the "
"``_IRQ_GATTC_CHARACTERISTIC_RESULT`` event will be raised."
msgstr ""
"検出された各キャラクタリスティックについて ``_IRQ_GATTC_CHARACTERISTIC_RESULT`` "
"イベントが発生します。"

#: ../../library/ubluetooth.rst:317
msgid "Query a connected peripheral for descriptors in the specified range."
msgstr "指定した範囲のディスクリプタについて接続されたペリフェラルを問い合わせます。"

#: ../../library/ubluetooth.rst:319
msgid ""
"For each descriptor discovered, the ``_IRQ_GATTC_DESCRIPTOR_RESULT`` "
"event will be raised."
msgstr ""
"検出された各ディスクリプタについて ``_IRQ_GATTC_DESCRIPTOR_RESULT`` "
"イベントが発生します。"

#: ../../library/ubluetooth.rst:324
msgid ""
"Issue a remote read to a connected peripheral for the specified "
"characteristic or descriptor handle."
msgstr ""
"指定したキャラクタリスティックあるいはディスクリプタについて接続されたペリフェラルに"
"リモート読み込みを発行します。"

#: ../../library/ubluetooth.rst:327
msgid "On success, the ``_IRQ_GATTC_READ_RESULT`` event will be raised."
msgstr "成功すると ``_IRQ_GATTC_READ_RESULT`` イベントが発生します。"

#: ../../library/ubluetooth.rst:331
msgid ""
"Issue a remote write to a connected peripheral for the specified "
"characteristic or descriptor handle."
msgstr ""
"指定したキャラクタリスティックあるいはディスクリプタについて接続されたペリフェラルに"
"リモート書き込みを発行します。"

#: ../../library/ubluetooth.rst:334
msgid ""
"The argument *mode* specifies the write behaviour, with the currently "
"supported values being:"
msgstr ""
"引数 *mode* は書き込み動作を指定します。現在サポートされている値は次のとおりです:"

#: ../../library/ubluetooth.rst:337
msgid ""
"``mode=0`` (default) is a write-without-response: the write will be sent "
"to the remote peripheral but no confirmation will be returned, and no "
"event will be raised."
msgstr ""
"``mode=0`` (デフォルト)は応答なしの書き込みです。書き込みはリモートペリフェラルに"
"送信されますが、確認は返されず、イベントは発生しません。"

#: ../../library/ubluetooth.rst:340
msgid ""
"``mode=1`` is a write-with-response: the remote peripheral is requested "
"to send a response/acknowledgement that it received the data."
msgstr ""
"``mode=1`` は応答付きの書き込みです。リモートプリフェラルはデータを受信したという"
"応答/承認(acknowledgement)を送信するように要求されます。"

#: ../../library/ubluetooth.rst:344
msgid ""
"If a response is received from the remote peripheral the "
"``_IRQ_GATTC_WRITE_STATUS`` event will be raised."
msgstr ""
"リモートペリフェラルから応答を受信すると ``_IRQ_GATTC_WRITE_STATUS`` "
"イベントが発生します。"

#: ../../library/ubluetooth.rst:349
msgid "class UUID"
msgstr "クラス UUID"

#: ../../library/ubluetooth.rst:357
msgid "Creates a UUID instance with the specified **value**."
msgstr "指定した **value** で UUID インスタンスを作成します。"

#: ../../library/ubluetooth.rst:359
msgid "The **value** can be either:"
msgstr "**value** は次のいずれかです:"

#: ../../library/ubluetooth.rst:361
msgid "A 16-bit integer. e.g. ``0x2908``."
msgstr "16 ビット整数。たとえば ``0x2908``"

#: ../../library/ubluetooth.rst:362
msgid "A 128-bit UUID string. e.g. ``'6E400001-B5A3-F393-E0A9-E50E24DCCA9E'``."
msgstr "128 ビット UUID 文字列。たとえば ``'6E400001-B5A3-F393-E0A9-E50E24DCCA9E'``"

#: ../../../library/ucollections.rst:2
msgid ":mod:`ucollections` -- collection and container types"
msgstr ":mod:`ucollections` -- コレクションとコンテナのデータ型"

#: ../../../library/ucollections.rst:7
msgid "|see_cpython_module| :mod:`python:collections`."
msgstr ""

#: ../../../library/ucollections.rst:9
msgid ""
"This module implements advanced collection and container types to "
"hold/accumulate various objects."
msgstr ""
"このモジュールは、様々なオブジェクトを保持/蓄積する高度なコレクションと"
"コンテナのデータ型を実装します。"

#: ../../../library/ucollections.rst:17
msgid ""
"Deques (double-ended queues) are a list-like container that support O(1) "
"appends and pops from either side of the deque.  New deques are created "
"using the following arguments:"
msgstr ""
"deques (両端キュー)は、O(1) (処理時間がデータ量に非依存)をサポートするリストの"
"ようなコンテナであり、両端キューのどちらかの側から追加やポップできます。次の引数を"
"使用して新しい deques オブジェクトが作成されます。"

#: ../../../library/ucollections.rst:21
msgid "*iterable* must be the empty tuple, and the new deque is created empty."
msgstr "*iterable* は空のタプルでなければならず、新しい両端キューが空で作成されます。"

#: ../../../library/ucollections.rst:23
msgid ""
"*maxlen* must be specified and the deque will be bounded to this maximum "
"length.  Once the deque is full, any new items added will discard items "
"from the opposite end."
msgstr ""
"*maxlen* を指定する必要があり、両端キューはこの最大長にバインドされます。両端キュー"
"がいっぱいになると、追加された新しいアイテムは反対側のアイテムを破棄します。"

#: ../../../library/ucollections.rst:27
msgid "The optional *flags* can be 1 to check for overflow when adding items."
msgstr "オプションの flags を 1 にすると、項目を追加するときにオーバーフローをチェックするようになります。"

#: ../../../library/ucollections.rst:29
msgid ""
"As well as supporting `bool` and `len`, deque objects have the following "
"methods:"
msgstr ""
"``bool`` や ``len`` をサポートする他に、deque オブジェクトには次のメソッドがあります:"

#: ../../../library/ucollections.rst:34
msgid ""
"Add *x* to the right side of the deque. Raises IndexError if overflow "
"checking is enabled and there is no more room left."
msgstr ""
"両端キューの右側に *x* を追加します。オーバーフローチェックが有効で、もう余地が"
"ない場合には IndexError を発生させます。"

#: ../../../library/ucollections.rst:39
msgid ""
"Remove and return an item from the left side of the deque. Raises "
"IndexError if no items are present."
msgstr ""
"両端キューの左側から項目を削除して返します。項目が存在しない場合は IndexError "
"を発生させます。"

#: ../../../library/ucollections.rst:44
msgid ""
"This is factory function to create a new namedtuple type with a specific "
"name and set of fields. A namedtuple is a subclass of tuple which allows "
"to access its fields not just by numeric index, but also with an "
"attribute access syntax using symbolic field names. Fields is a sequence "
"of strings specifying field names. For compatibility with CPython it can "
"also be a a string with space-separated field named (but this is less "
"efficient). Example of use::"
msgstr ""
"これは特定の名前とフィールドセットを持つ新しい名前付きタプル型を作成するための"
"ファクトリ関数です。namedtuple はタプルのサブクラスで、数値インデックスだけでなく"
"シンボル型フィールド名を使った属性アクセス構文でもフィールドにアクセスできます。"
"Fields は、フィールド名を指定する一連の文字列です。CPython との互換性のために、"
"スペースで区切られたフィールドを持つ文字列にすることもできます(これはあまり効率的"
"ではありません)。使用例::"

#: ../../../library/ucollections.rst:52
msgid ""
"from ucollections import namedtuple\n"
"\n"
"MyTuple = namedtuple(\"MyTuple\", (\"id\", \"name\"))\n"
"t1 = MyTuple(1, \"foo\")\n"
"t2 = MyTuple(2, \"bar\")\n"
"print(t1.name)\n"
"assert t2.name == t2[1]"
msgstr ""

#: ../../../library/ucollections.rst:62
msgid ""
"``dict`` type subclass which remembers and preserves the order of keys "
"added. When ordered dict is iterated over, keys/items are returned in the"
" order they were added::"
msgstr ""
"追加されたキーの順番を記憶して保持する ``dect`` 型のサブクラスです。"
"順序付けされた辞書を反復すると、キー/項目を追加された順番で返します。"

#: ../../../library/ucollections.rst:66
msgid ""
"from ucollections import OrderedDict\n"
"\n"
"# To make benefit of ordered keys, OrderedDict should be initialized\n"
"# from sequence of (key, value) pairs.\n"
"d = OrderedDict([(\"z\", 1), (\"a\", 2)])\n"
"# More items can be added as usual\n"
"d[\"w\"] = 5\n"
"d[\"b\"] = 3\n"
"for k, v in d.items():\n"
"    print(k, v)"
msgstr ""

#: ../../../library/ucollections.rst:77
msgid "Output::"
msgstr "出力::"

#: ../../../library/ucollections.rst:79
msgid ""
"z 1\n"
"a 2\n"
"w 5\n"
"b 3"
msgstr ""

#: ../../../library/ucryptolib.rst:2
msgid ":mod:`ucryptolib` -- cryptographic ciphers"
msgstr ":mod:`ucryptolib` -- 暗号化アルゴリズム"

#: ../../../library/ucryptolib.rst:14
msgid ""
"Initialize cipher object, suitable for encryption/decryption. Note: after"
" initialization, cipher object can be use only either for encryption or "
"decryption. Running decrypt() operation after encrypt() or vice versa is "
"not supported."
msgstr ""
"暗号化/復号化に適した暗号オブジェクトを初期化します。注記: 初期化後、暗号オブジェクト"
"は暗号化または復号化のどちらかにしか使えません。 encrypt() 後の decrypt() 、"
"またはその逆の操作の実行はサポートされていません。"

#: ../../../library/ucryptolib.rst:19
msgid "Parameters are:"
msgstr "パラメータは以下のとおりです:"

#: ../../../library/ucryptolib.rst:21
msgid "*key* is an encryption/decryption key (bytes-like)."
msgstr "*key* は暗号化/復号化キーです(バイト列ライク)。"

#: ../../../library/ucryptolib.rst:22
msgid "*mode* is:"
msgstr "*mode* は以下のいずれかです:"

#: ../../../library/ucryptolib.rst:24
msgid ""
"``1`` (or ``ucryptolib.MODE_ECB`` if it exists) for Electronic Code Book "
"(ECB)."
msgstr ""
"``1`` (または定義されていれば ``ucryptolib.MODE_ECB``) Electronic Code Book (ECB)"

#: ../../../library/ucryptolib.rst:25
msgid ""
"``2`` (or ``ucryptolib.MODE_CBC`` if it exists) for Cipher Block Chaining"
" (CBC)."
msgstr ""
"``2`` (または定義されていれば ``ucryptolib.MODE_CBC``) Cipher Block Chaining (CBC)"

#: ../../../library/ucryptolib.rst:26
msgid ""
"``6`` (or ``ucryptolib.MODE_CTR`` if it exists) for Counter mode (CTR)."
msgstr ""
"``6`` (または定義されていれば  ``ucryptolib.MODE_CTR``) Counter mode (CTR)"

#: ../../../library/ucryptolib.rst:27
msgid "*IV* is an initialization vector for CBC mode."
msgstr "*IV* は CBC モード用の初期化ベクトルです。"

#: ../../../library/ucryptolib.rst:29
msgid "For Counter mode, *IV* is the initial value for the counter."
msgstr "Counter mode で *IV* はカウンターの初期値です。"

#: ../../../library/ucryptolib.rst:33
msgid ""
"Encrypt *in_buf*. If no *out_buf* is given result is returned as a newly "
"allocated `bytes` object. Otherwise, result is written into mutable "
"buffer *out_buf*. *in_buf* and *out_buf* can also refer to the same "
"mutable buffer, in which case data is encrypted in-place."
msgstr ""
"*in_buf* を暗号化します。 *out_buf* が与えられない場合、結果は新しく割り当てられた "
"`bytes` オブジェクトとして返されます。そうでなければ、結果は可変バッファ *out_buf* "
"に書き込まれます。 *in_buf* と *out_buf* は同じ可変バッファを参照することもできます。"
"その場合、データはその場で暗号化されます。"

#: ../../../library/ucryptolib.rst:40
msgid "Like `encrypt()`, but for decryption."
msgstr "`encrypt()` に似ていますが、複合化するメソッドです。"

#: ../../../library/uctypes.rst:2
msgid ":mod:`uctypes` -- access binary data in a structured way"
msgstr ":mod:`uctypes` -- 構造化手法でのバイナリデータアクセス"

#: ../../../library/uctypes.rst:7
msgid ""
"This module implements \"foreign data interface\" for MicroPython. The "
"idea behind it is similar to CPython's ``ctypes`` modules, but the actual"
" API is different, streamlined and optimized for small size. The basic "
"idea of the module is to define data structure layout with about the same"
" power as the C language allows, and then access it using familiar dot-"
"syntax to reference sub-fields."
msgstr ""
"このモジュールは MicroPython 用の「外部データインターフェース」を実装しています。"
"その背後にある考え方は CPython の ``ctypes`` モジュールと似ていますが、実際の API は"
"異なり、サイズを小さくするために合理化、最適化されています。このモジュールの基本的な"
"考え方は、C言語でできることとほぼ同じくデータ構造のレイアウトを定義し、よく知られた"
"ドット構文を使ってサブフィールドにアクセスできるようにすることです。"

#: ../../../library/uctypes.rst:16
msgid ""
"``uctypes`` module allows access to arbitrary memory addresses of the "
"machine (including I/O and control registers). Uncareful usage of it may "
"lead to crashes, data loss, and even hardware malfunction."
msgstr ""
"``uctypes`` モジュールはマシンの任意のメモリアドレス(I/O と制御レジスタを含む)への"
"アクセスを許可します。それを不当に使用すると、クラッシュ、データの損失、さらには"
"ハードウェアの誤動作につながる可能性があります。"

#: ../../../library/uctypes.rst:23
msgid "Module :mod:`ustruct`"
msgstr "モジュール :mod:`ustruct`"

#: ../../../library/uctypes.rst:23
msgid ""
"Standard Python way to access binary data structures (doesn't scale well "
"to large and complex structures)."
msgstr ""
"バイナリデータ構造にアクセスするための標準的な Python の手法(大規模で複雑な構造には"
"適していません)。"

#: ../../../library/uctypes.rst:26
msgid "Usage examples::"
msgstr "使用例::"

#: ../../../library/uctypes.rst:28
msgid ""
"import uctypes\n"
"\n"
"# Example 1: Subset of ELF file header\n"
"# https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header\n"
"ELF_HEADER = {\n"
"    \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8),\n"
"    \"EI_DATA\": 0x5 | uctypes.UINT8,\n"
"    \"e_machine\": 0x12 | uctypes.UINT16,\n"
"}\n"
"\n"
"# \"f\" is an ELF file opened in binary mode\n"
"buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN))\n"
"header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, "
"uctypes.LITTLE_ENDIAN)\n"
"assert header.EI_MAG == b\"\\x7fELF\"\n"
"assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with "
"uctypes.BIG_ENDIAN.\"\n"
"print(\"machine:\", hex(header.e_machine))\n"
"\n"
"\n"
"# Example 2: In-memory data structure, with pointers\n"
"COORD = {\n"
"    \"x\": 0 | uctypes.FLOAT32,\n"
"    \"y\": 4 | uctypes.FLOAT32,\n"
"}\n"
"\n"
"STRUCT1 = {\n"
"    \"data1\": 0 | uctypes.UINT8,\n"
"    \"data2\": 4 | uctypes.UINT32,\n"
"    \"ptr\": (8 | uctypes.PTR, COORD),\n"
"}\n"
"\n"
"# Suppose you have address of a structure of type STRUCT1 in \"addr\"\n"
"# uctypes.NATIVE is optional (used by default)\n"
"struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE)\n"
"print(\"x:\", struct1.ptr[0].x)\n"
"\n"
"\n"
"# Example 3: Access to CPU registers. Subset of STM32F4xx WWDG block\n"
"WWDG_LAYOUT = {\n"
"    \"WWDG_CR\": (0, {\n"
"        # BFUINT32 here means size of the WWDG_CR register\n"
"        \"WDGA\": 7 << uctypes.BF_POS | 1 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"        \"T\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"    }),\n"
"    \"WWDG_CFR\": (4, {\n"
"        \"EWI\": 9 << uctypes.BF_POS | 1 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"        \"WDGTB\": 7 << uctypes.BF_POS | 2 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"        \"W\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | "
"uctypes.BFUINT32,\n"
"    }),\n"
"}\n"
"\n"
"WWDG = uctypes.struct(0x40002c00, WWDG_LAYOUT)\n"
"\n"
"WWDG.WWDG_CFR.WDGTB = 0b10\n"
"WWDG.WWDG_CR.WDGA = 1\n"
"print(\"Current counter:\", WWDG.WWDG_CR.T)"
msgstr ""
"import uctypes\n"
"\n"
"# 例１: ELF ファイルヘッダのサブセット\n"
"# https://wikipedia.org/wiki/Executable_and_Linkable_Format#File_header\n"
"ELF_HEADER = {\n"
"    \"EI_MAG\": (0x0 | uctypes.ARRAY, 4 | uctypes.UINT8),\n"
"    \"EI_DATA\": 0x5 | uctypes.UINT8,\n"
"    \"e_machine\": 0x12 | uctypes.UINT16,\n"
"}\n"
"\n"
"# \"f\" はバイナリモードでオープンした ELF ファイル\n"
"buf = f.read(uctypes.sizeof(ELF_HEADER, uctypes.LITTLE_ENDIAN))\n"
"header = uctypes.struct(uctypes.addressof(buf), ELF_HEADER, uctypes.LITTLE_ENDIAN)\n"
"assert header.EI_MAG == b\"\\x7fELF\"\n"
"assert header.EI_DATA == 1, \"Oops, wrong endianness. Could retry with uctypes.BIG_ENDIAN.\"\n"
"print(\"machine:\", hex(header.e_machine))\n"
"\n"
"\n"
"# 例２: ポインターのあるインメモリデータ構造\n"
"COORD = {\n"
"    \"x\": 0 | uctypes.FLOAT32,\n"
"    \"y\": 4 | uctypes.FLOAT32,\n"
"}\n"
"\n"
"STRUCT1 = {\n"
"    \"data1\": 0 | uctypes.UINT8,\n"
"    \"data2\": 4 | uctypes.UINT32,\n"
"    \"ptr\": (8 | uctypes.PTR, COORD),\n"
"}\n"
"\n"
"# \"addr\" に型 STRUCT1 の構造体のアドレスがあるとします\n"
"# uctypes.NATIVE はオプション(デフォルトで使用)\n"
"struct1 = uctypes.struct(addr, STRUCT1, uctypes.NATIVE)\n"
"print(\"x:\", struct1.ptr[0].x)\n"
"\n"
"\n"
"# 例３: CPU レジスタのアクセス。STM32F4xx WWDG ブロックのサブセット\n"
"WWDG_LAYOUT = {\n"
"    \"WWDG_CR\": (0, {\n"
"        # BFUINT32 here means size of the WWDG_CR register\n"
"        \"WDGA\": 7 << uctypes.BF_POS | 1 << uctypes.BF_LEN | uctypes.BFUINT32,\n"
"        \"T\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | uctypes.BFUINT32,\n"
"    }),\n"
"    \"WWDG_CFR\": (4, {\n"
"        \"EWI\": 9 << uctypes.BF_POS | 1 << uctypes.BF_LEN | uctypes.BFUINT32,\n"
"        \"WDGTB\": 7 << uctypes.BF_POS | 2 << uctypes.BF_LEN | uctypes.BFUINT32,\n"
"        \"W\": 0 << uctypes.BF_POS | 7 << uctypes.BF_LEN | uctypes.BFUINT32,\n"
"    }),\n"
"}\n"
"\n"
"WWDG = uctypes.struct(0x40002c00, WWDG_LAYOUT)\n"
"\n"
"WWDG.WWDG_CFR.WDGTB = 0b10\n"
"WWDG.WWDG_CR.WDGA = 1\n"
"print(\"Current counter:\", WWDG.WWDG_CR.T)"

#: ../../../library/uctypes.rst:85
msgid "Defining structure layout"
msgstr "構造体レイアウトの定義"

#: ../../../library/uctypes.rst:87
msgid ""
"Structure layout is defined by a \"descriptor\" - a Python dictionary "
"which encodes field names as keys and other properties required to access"
" them as associated values::"
msgstr ""
"構造体のレイアウトは「デスクリプター」として定義します。デスクリプターは Python "
"の辞書であり、フィールド名をキー、フィールドにアクセスするためのプロパティを値として"
"エンコードします。"

#: ../../../library/uctypes.rst:91
msgid ""
"{\n"
"    \"field1\": <properties>,\n"
"    \"field2\": <properties>,\n"
"    ...\n"
"}"
msgstr ""

#: ../../../library/uctypes.rst:97
msgid ""
"Currently, ``uctypes`` requires explicit specification of offsets for "
"each field. Offset are given in bytes from the structure start."
msgstr ""
"現在のところ ``uctypes`` は、各フィールドに対してオフセットの明示的な指定が"
"必要です。オフセットは構造体の先頭からのバイト数で与えられます。"

#: ../../../library/uctypes.rst:100
msgid "Following are encoding examples for various field types:"
msgstr "以下は、さまざまなフィールドタイプのエンコード例です:"

#: ../../../library/uctypes.rst:102
msgid "Scalar types::"
msgstr "スカラー型::"

#: ../../../library/uctypes.rst:104
msgid "\"field_name\": offset | uctypes.UINT32"
msgstr "\"フィールド名\": オフセット | uctypes.UINT32"

#: ../../../library/uctypes.rst:106
msgid ""
"in other words, the value is a scalar type identifier ORed with a field "
"offset (in bytes) from the start of the structure."
msgstr ""
"つまり、値は、構造体の先頭からのフィールドオフセット(バイト単位)とスカラ型識別子の"
"ビット論理和です。"

#: ../../../library/uctypes.rst:109
msgid "Recursive structures::"
msgstr "再帰構造::"

#: ../../../library/uctypes.rst:111
msgid ""
"\"sub\": (offset, {\n"
"    \"b0\": 0 | uctypes.UINT8,\n"
"    \"b1\": 1 | uctypes.UINT8,\n"
"})"
msgstr ""

#: ../../../library/uctypes.rst:116
msgid ""
"i.e. value is a 2-tuple, first element of which is an offset, and second "
"is a structure descriptor dictionary (note: offsets in recursive "
"descriptors are relative to the structure it defines). Of course, "
"recursive structures can be specified not just by a literal dictionary, "
"but by referring to a structure descriptor dictionary (defined earlier) "
"by name."
msgstr ""
"つまり、value は２項目のタプルで、１番目の項目はオフセット、２番目の項目は構造体"
"デスクリプター辞書です(注: 再帰記述子のオフセットは、定義している構造体に対する"
"相対位置です)。もちろん、再帰構造はリテラル辞書だけではなく、(以前に定義した)構造体"
"デスクリプター辞書を名前で参照することによっても指定できます。"

#: ../../../library/uctypes.rst:122
msgid "Arrays of primitive types::"
msgstr "プリミティブ型の配列::"

#: ../../../library/uctypes.rst:124
msgid "\"arr\": (offset | uctypes.ARRAY, size | uctypes.UINT8),"
msgstr ""

#: ../../../library/uctypes.rst:126
msgid ""
"i.e. value is a 2-tuple, first element of which is ARRAY flag ORed with "
"offset, and second is scalar element type ORed number of elements in the "
"array."
msgstr ""
"つまり、value は２項目のタプルで、１番目の項目は ARRAY フラグとオフセットの"
"ビット論理和で、２番目の項目はスカラー型と配列要素数のビット論理和です。"

#: ../../../library/uctypes.rst:130
msgid "Arrays of aggregate types::"
msgstr "集約タイプの配列::"

#: ../../../library/uctypes.rst:132
msgid "\"arr2\": (offset | uctypes.ARRAY, size, {\"b\": 0 | uctypes.UINT8}),"
msgstr ""

#: ../../../library/uctypes.rst:134
msgid ""
"i.e. value is a 3-tuple, first element of which is ARRAY flag ORed with "
"offset, second is a number of elements in the array, and third is a "
"descriptor of element type."
msgstr ""
"つまり、valueは３項目のタプルで、１番目の項目は ARRAY フラグと offset のビット論理和、"
"２番目の項目は配列内の要素数、３番目の項目は要素型のデスクリプターです。"

#: ../../../library/uctypes.rst:138
msgid "Pointer to a primitive type::"
msgstr "プリミティブ型へのポインタ::"

#: ../../../library/uctypes.rst:140
msgid "\"ptr\": (offset | uctypes.PTR, uctypes.UINT8),"
msgstr ""

#: ../../../library/uctypes.rst:142
msgid ""
"i.e. value is a 2-tuple, first element of which is PTR flag ORed with "
"offset, and second is a scalar element type."
msgstr ""
"すなわち、valueは2項目のタプルで、１番目の項目はオフセットとPTRフラグのビット論理和、"
"２番目の項目はスカラー要素型です。"

#: ../../../library/uctypes.rst:145
msgid "Pointer to an aggregate type::"
msgstr "集約型へのポインタ::"

#: ../../../library/uctypes.rst:147
msgid "\"ptr2\": (offset | uctypes.PTR, {\"b\": 0 | uctypes.UINT8}),"
msgstr ""

#: ../../../library/uctypes.rst:149
msgid ""
"i.e. value is a 2-tuple, first element of which is PTR flag ORed with "
"offset, second is a descriptor of type pointed to."
msgstr ""
"すなわち、valueは2項目のタプルで、１番目の項目はオフセットとOTRフラグのビット論理和、"
"２番目の項目はポインタが指す型のデスクリプターです。"

#: ../../../library/uctypes.rst:152
msgid "Bitfields::"
msgstr "ビットフィールド::"

#: ../../../library/uctypes.rst:154
msgid ""
"\"bitf0\": offset | uctypes.BFUINT16 | lsbit << uctypes.BF_POS | bitsize "
"<< uctypes.BF_LEN,"
msgstr ""

#: ../../../library/uctypes.rst:156
msgid ""
"i.e. value is a type of scalar value containing given bitfield (typenames"
" are similar to scalar types, but prefixes with ``BF``), ORed with offset"
" for scalar value containing the bitfield, and further ORed with values "
"for bit position and bit length of the bitfield within the scalar value, "
"shifted by BF_POS and BF_LEN bits, respectively. A bitfield position is "
"counted from the least significant bit of the scalar (having position of "
"0), and is the number of right-most bit of a field (in other words, it's "
"a number of bits a scalar needs to be shifted right to extract the "
"bitfield)."
msgstr ""
"すなわち、value は３つのビット論理和で、１つ目は与えたビットフィールドを含む"
"スカラ値の型(typenameはスカラ型に似ていますが、 ``BF`` 接頭辞が付きます)、"
"２つ目はビットフィールドを含むスカラ値のためのオフセット、３つ目はビット位置と"
"ビット長をそれぞれ BF_POS と BF_LEN でシフトされたスカラー値です。ビット"
"フィールド位置は、スカラーの最下位ビット（位置0）からカウントされ、フィールドの"
"右端のビット数です(つまり、スカラーからビットフィールドを抽出するために右に"
"シフトするのに必要なビット数です)。"

#: ../../../library/uctypes.rst:165
msgid ""
"In the example above, first a UINT16 value will be extracted at offset 0 "
"(this detail may be important when accessing hardware registers, where "
"particular access size and alignment are required), and then bitfield "
"whose rightmost bit is *lsbit* bit of this UINT16, and length is "
"*bitsize* bits, will be extracted. For example, if *lsbit* is 0 and "
"*bitsize* is 8, then effectively it will access least-significant byte of"
" UINT16."
msgstr ""
"上記の例では、最初に UINT16 値がオフセット 0 で抽出され(この詳細は、特定の"
"アクセスサイズとアライメントが必要なハードウェアレジスタにアクセスするときに重要です)、"
"次にこの UINT16 の最右ビットが *lsbit* ビットであるビットフィールド長さはビット"
"サイズのビットとして抽出されます。たとえば、 *lsbit* が 0 で *bitsize* が 8 "
"の場合、事実上 UINT16 の最下位バイトにアクセスします。"

#: ../../../library/uctypes.rst:173
msgid ""
"Note that bitfield operations are independent of target byte endianness, "
"in particular, example above will access least-significant byte of UINT16"
" in both little- and big-endian structures. But it depends on the least "
"significant bit being numbered 0. Some targets may use different "
"numbering in their native ABI, but ``uctypes`` always uses the normalized"
" numbering described above."
msgstr ""
"ビットフィールド演算は、ターゲットバイトのエンディアンとは無関係です。特に上の例では、"
"リトルエンディアン構造とビッグエンディアン構造の両方で、UINT16 の最下位バイトに"
"アクセスします。しかし、それは 0 と番号付けされている最下位ビットに依存します。"
"いくつかのターゲットはそれらのネイティブ ABI で異なる番号付けを使用するかも"
"しれませんが、 ``uctypes`` は常に上記の正規化された番号付けを使用します。"

#: ../../../library/uctypes.rst:181
msgid "Module contents"
msgstr "モジュールの内容"

#: ../../../library/uctypes.rst:185
msgid ""
"Instantiate a \"foreign data structure\" object based on structure "
"address in memory, descriptor (encoded as a dictionary), and layout type "
"(see below)."
msgstr ""
"メモリ内の構造体アドレス、デスクリプター(辞書としてエンコードされている)、"
"レイアウトタイプ(下記参照)に基づいて「外部データ構造」オブジェクトを"
"インスタンス化します。"

#: ../../../library/uctypes.rst:190
msgid ""
"Layout type for a little-endian packed structure. (Packed means that "
"every field occupies exactly as many bytes as defined in the descriptor, "
"i.e. the alignment is 1)."
msgstr ""
"リトルエンディアンのパック構造のレイアウトタイプ。(パックとは、すべてのフィールドが"
"デスクリプターで定義されているのとまったく同じバイト数を占めることを意味します。"
"つまり、アライメントは1です)。"

#: ../../../library/uctypes.rst:196
msgid "Layout type for a big-endian packed structure."
msgstr "ビッグエンディアンのパック構造のレイアウトタイプ。"

#: ../../../library/uctypes.rst:200
msgid ""
"Layout type for a native structure - with data endianness and alignment "
"conforming to the ABI of the system on which MicroPython runs."
msgstr ""
"ネイティブ構造体のレイアウトタイプ - MicroPython が実行されているシステムの ABI "
"に準拠したデータのエンディアンとアライメントを持ちます。"

#: ../../../library/uctypes.rst:205
msgid ""
"Return size of data structure in bytes. The *struct* argument can be "
"either a structure class or a specific instantiated structure object (or "
"its aggregate field)."
msgstr ""
"データ構造のサイズをバイト数で返します。struct 引数は、構造体クラスまたは特定の"
"インスタンス化された構造物(またはその集合体フィールド)のいずれかです。"

#: ../../../library/uctypes.rst:211
msgid ""
"Return address of an object. Argument should be bytes, bytearray or other"
" object supporting buffer protocol (and address of this buffer is what "
"actually returned)."
msgstr ""
"オブジェクトのアドレスを返します。引数は、bytes, bytearray, バッファプロトコルを"
"サポートする他のオブジェクトである必要があります(このバッファのアドレスは実際に"
"返されるものです)。"

#: ../../../library/uctypes.rst:217
msgid ""
"Capture memory at the given address and size as bytes object. As bytes "
"object is immutable, memory is actually duplicated and copied into bytes "
"object, so if memory contents change later, created object retains "
"original value."
msgstr ""
"指定されたアドレスとサイズのメモリをバイトオブジェクトとしてキャプチャします。"
"bytes オブジェクトは不変なので、メモリは実際には複製されて bytes オブジェクトに"
"コピーされます。したがって、メモリの内容が後で変更されても、作成されたオブジェクトは"
"元の値を保持します。"

#: ../../../library/uctypes.rst:224
msgid ""
"Capture memory at the given address and size as bytearray object. Unlike "
"bytes_at() function above, memory is captured by reference, so it can be "
"both written too, and you will access current value at the given memory "
"address."
msgstr ""
"与えたアドレスとサイズのメモリを bytearray オブジェクトとしてキャプチャします。"
"上記の bytes_at() 関数とは異なり、メモリは参照によって取得されるため、両方とも"
"書き込むことができ、指定されたメモリアドレスで現在の値にアクセスします。"

#: ../../../library/uctypes.rst:238
msgid ""
"Integer types for structure descriptors. Constants for 8, 16, 32, and 64 "
"bit types are provided, both signed and unsigned."
msgstr ""
"構造体デスクリプターの整数型 符号付きと符号なしの両方の 8, 16, 32, 64 ビット型の"
"定数が提供されています。"

#: ../../../library/uctypes.rst:244
msgid "Floating-point types for structure descriptors."
msgstr "構造体デスクリプターの浮動小数点型"

#: ../../../library/uctypes.rst:248
msgid ""
"``VOID`` is an alias for ``UINT8``, and is provided to conviniently "
"define C's void pointers: ``(uctypes.PTR, uctypes.VOID)``."
msgstr ""
"``VOID`` これは ``UINT8`` の別名であり、C の void ポインターのために定義"
"されています: ``(uctypes.PTR, uctypes.VOID)``"

#: ../../../library/uctypes.rst:254
msgid ""
"Type constants for pointers and arrays. Note that there is no explicit "
"constant for structures, it's implicit: an aggregate type without ``PTR``"
" or ``ARRAY`` flags is a structure."
msgstr ""
"ポインタと配列の型定数。構造体のための明示的な定数がないことに注意してください、"
"それは暗黙のうちに：PTR またはARRAYフラグのない集約型は構造体です。"

#: ../../../library/uctypes.rst:259
msgid "Structure descriptors and instantiating structure objects"
msgstr "構造体デスクリプターと構造化オブジェクトのインスタンス化"

#: ../../../library/uctypes.rst:261
msgid ""
"Given a structure descriptor dictionary and its layout type, you can "
"instantiate a specific structure instance at a given memory address using"
" :class:`uctypes.struct()` constructor. Memory address usually comes from"
" following sources:"
msgstr ""
"構造体デスクリプター辞書とそのレイアウトタイプが与えられた場合、 "
":class:`uctypes.struct()` コンストラクタを使用して特定のメモリインスタンスに"
"特定の構造体インスタンスをインスタンス化できます。メモリアドレスは通常、以下の"
"ソースから取得されます。"

#: ../../../library/uctypes.rst:266
msgid ""
"Predefined address, when accessing hardware registers on a baremetal "
"system. Lookup these addresses in datasheet for a particular MCU/SoC."
msgstr ""
"ベアメタルシステムのハードウェアレジスタにアクセスするときの定義済みアドレス。"
"特定の MCU/SoC のデータシートでこれらのアドレスを検索してください。"

#: ../../../library/uctypes.rst:268
msgid ""
"As a return value from a call to some FFI (Foreign Function Interface) "
"function."
msgstr ""
"FFI (外部関数インタフェース)関数への呼び出しからの戻り値として。"

#: ../../../library/uctypes.rst:270
msgid ""
"From `uctypes.addressof()`, when you want to pass arguments to an FFI "
"function, or alternatively, to access some data for I/O (for example, "
"data read from a file or network socket)."
msgstr ""
"`uctypes.addressof()` から、FFI 関数に引数を渡したいとき、または I/O 用の"
"データ(ファイルやネットワークソケットから読み込んだデータなど)にアクセスしたいとき。"

#: ../../../library/uctypes.rst:275
msgid "Structure objects"
msgstr "構造体オブジェクト"

#: ../../../library/uctypes.rst:277
msgid ""
"Structure objects allow accessing individual fields using standard dot "
"notation: ``my_struct.substruct1.field1``. If a field is of scalar type, "
"getting it will produce a primitive value (Python integer or float) "
"corresponding to the value contained in a field. A scalar field can also "
"be assigned to."
msgstr ""
"構造体オブジェクトは標準のドット表記法 ``my_struct.substruct1.field1`` を"
"使って個々のフィールドにアクセスすることを可能にします。フィールドがスカラー型の場合、"
"それを取得すると、フィールドに含まれる値に対応するプリミティブ値(Python の整数または"
"浮動小数点数）が生成されます。スカラーフィールドも割り当てることができます。"

#: ../../../library/uctypes.rst:283
msgid ""
"If a field is an array, its individual elements can be accessed with the "
"standard subscript operator ``[]`` - both read and assigned to."
msgstr ""
"フィールドが配列の場合、その個々の要素は標準の添字演算子 ``[]`` を使って読み取りと"
"代入の両方でアクセスできます。"

#: ../../../library/uctypes.rst:286
msgid ""
"If a field is a pointer, it can be dereferenced using ``[0]`` syntax "
"(corresponding to C ``*`` operator, though ``[0]`` works in C too). "
"Subscripting a pointer with other integer values but 0 are also "
"supported, with the same semantics as in C."
msgstr ""
"フィールドがポインターの場合は、``[0]`` 構文を使ってポインターの指す先を参照できます"
"(C の ``*`` 演算子に対応しますが、C で ``[0]`` とすることと同様です)。C と同じ"
"セマンティクスで 0 以外の整数値でポインタを添字にすることもサポートされています。"

#: ../../../library/uctypes.rst:291
msgid ""
"Summing up, accessing structure fields generally follows the C syntax, "
"except for pointer dereference, when you need to use ``[0]`` operator "
"instead of ``*``."
msgstr ""
"まとめると、構造体フィールドへのアクセスは一般に C の構文にしたがいますが、"
"ポインタの指す先の参照には ``*`` の代わりに ``[0]`` を使う必要があります。"

#: ../../../library/uctypes.rst:296
msgid "Limitations"
msgstr "制限事項"

#: ../../../library/uctypes.rst:298
msgid ""
"Accessing non-scalar fields leads to allocation of intermediate "
"objects to represent them. This means that special care should be taken "
"to layout a structure which needs to be accessed when memory allocation "
"is disabled (e.g. from an interrupt). The recommendations are:"
msgstr ""
"非スカラーフィールドにアクセスすると、それらを表す中間オブジェクトが割り当て"
"られます。これは、(たとえば割り込みハンドラの処理など)メモリ割り付けが無効になって"
"いるときにアクセスする必要がある構造をレイアウトするのに特別な注意を払うべきである"
"ことを意味します。推奨事項は次のとおりです:"

#: ../../../library/uctypes.rst:303
msgid ""
"Avoid accessing nested structures. For example, instead of "
"``mcu_registers.peripheral_a.register1``, define separate layout "
"descriptors for each peripheral, to be accessed as "
"``peripheral_a.register1``. Or just cache a particular peripheral: "
"``peripheral_a = mcu_registers.peripheral_a``. If a register consists of "
"multiple bitfields, you would need to cache references to a particular "
"register: ``reg_a = mcu_registers.peripheral_a.reg_a``."
msgstr ""
"入れ子構造にアクセスしないでください。たとえば、 "
"``mcu_registers.peripheral_a.register1`` とする代わりに、各ペリフェラルに"
"対して別々のレイアウト記述子を定義して、 ``peripheral_a.register1`` "
"としてアクセスします。あるいは単に特定の周辺機器を "
"``peripheral_a = mcu_registers.peripheral_a`` でキャッシュします。"
"レジスタが複数のビットフィールドで構成されている場合は、特定のレジスタへの参照を "
"``reg_a = mcu_registers.peripheral_a.reg_a`` としてキャッシュする必要が"
"あります。"

#: ../../../library/uctypes.rst:310
msgid ""
"Avoid other non-scalar data, like arrays. For example, instead of "
"``peripheral_a.register[0]`` use ``peripheral_a.register0``. Again, an "
"alternative is to cache intermediate values, e.g. ``register0 = "
"peripheral_a.register[0]``."
msgstr ""
"配列のような他の非スカラデータを避けます。たとえば、 "
"``peripheral_a.register[0]`` の代わりに ``peripheral_a.register0``　を"
"使います。繰り返しになりますが、代替手段は中間値を "
"``register0 = peripheral_a.register[0]`` のようにしてキャッシュすることです。"

#: ../../../library/uctypes.rst:315
msgid ""
"Range of offsets supported by the ``uctypes`` module is limited. The "
"exact range supported is considered an implementation detail, and the "
"general suggestion is to split structure definitions to cover from a few "
"kilobytes to a few dozen of kilobytes maximum. In most cases, this is a "
"natural situation anyway, e.g. it doesn't make sense to define all "
"registers of an MCU (spread over 32-bit address space) in one structure, "
"but rather a peripheral block by peripheral block. In some extreme cases,"
" you may need to split a structure in several parts artificially (e.g. if"
" accessing native data structure with multi-megabyte array in the middle,"
" though that would be a very synthetic case)."
msgstr ""
"``uctypes`` モジュールでサポートされているオフセットの範囲は限られています。"
"サポートされている正確な範囲は実装の詳細と見なされます。一般的な提案は、構造定義を"
"分割して最大で数キロバイトから数十キロバイトまでになるようにすることです。ほとんどの場合、"
"これはとにかく自然な状況です。たとえば、(32ビットアドレス空間に広がる) MCU のすべての"
"レジスタを1つの構造体で定義するのは意味がなく、むしろペリフェラルブロックごとに定義する"
"べきです。極端な場合には、構造をいくつかの部分に人為的に分割する必要があるかもしれません"
"(たとえば、数メガバイトの配列を中央に持つネイティブデータ構造にアクセスする場合などは、"
"人為的な分割せざろうえないケースです)。"

#: ../../../library/uerrno.rst:2
msgid ":mod:`uerrno` -- system error codes"
msgstr ":mod:`uerrno` -- システムエラーコード"

#: ../../../library/uerrno.rst:7
msgid "|see_cpython_module| :mod:`python:errno`."
msgstr ""

#: ../../../library/uerrno.rst:9
msgid ""
"This module provides access to symbolic error codes for `OSError` "
"exception. A particular inventory of codes depends on `MicroPython port`."
msgstr ""
"このモジュールは、OSError 例外のシンボリックエラーコードへのアクセスを提供します。"
"コードに何があるかは `MicroPython ポート` に依存します。"

#: ../../../library/uerrno.rst:17
msgid ""
"Error codes, based on ANSI C/POSIX standard. All error codes start with "
"\"E\". As mentioned above, inventory of the codes depends on `MicroPython"
" port`. Errors are usually accessible as ``exc.args[0]`` where ``exc`` is"
" an instance of `OSError`. Usage example::"
msgstr ""
"ANSI C/POSIX 規格に基づくエラーコードです。すべてのエラーコードは \"E\" で始まります。"
"前述のように、コードに何があるかは `MicroPython ポート` に依存します。"
"``exc`` が `OSError` のインスタンスであるとすると、エラーには通常 ``exc.args[0]`` "
"でアクセス可能です。たとえば次のようにアクセスします::"

#: ../../../library/uerrno.rst:22
msgid ""
"try:\n"
"    uos.mkdir(\"my_dir\")\n"
"except OSError as exc:\n"
"    if exc.args[0] == uerrno.EEXIST:\n"
"        print(\"Directory already exists\")"
msgstr ""

#: ../../../library/uerrno.rst:30
msgid ""
"Dictionary mapping numeric error codes to strings with symbolic error "
"code (see above)::"
msgstr ""
"英数字エラーコードをシンボリックエラーコードの文字列にマッピングする辞書(上記参照)::"

#: ../../../library/uerrno.rst:33
msgid ""
">>> print(uerrno.errorcode[uerrno.EEXIST])\n"
"EEXIST"
msgstr ""

#: ../../../library/uhashlib.rst:2
msgid ":mod:`uhashlib` -- hashing algorithms"
msgstr ":mod:`uhashlib` -- ハッシュ化アルゴリズム"

#: ../../../library/uhashlib.rst:7
msgid "|see_cpython_module| :mod:`python:hashlib`."
msgstr ""

#: ../../../library/uhashlib.rst:9
msgid ""
"This module implements binary data hashing algorithms. The exact "
"inventory of available algorithms depends on a board. Among the "
"algorithms which may be implemented:"
msgstr ""
"このモジュールはバイナリデータハッシュ化アルゴリズムを実装しています。"
"利用可能なアルゴリズムが何であるかはボードによって異なります。実装される"
"アルゴリズムの中には以下のものがあります:"

#: ../../../library/uhashlib.rst:13
msgid ""
"SHA256 - The current generation, modern hashing algorithm (of SHA2 "
"series). It is suitable for cryptographically-secure purposes. Included "
"in the MicroPython core and any board is recommended to provide this, "
"unless it has particular code size constraints."
msgstr ""
"SHA256 - (SHA2 シリーズの)現世代のハッシュ化アルゴリズム。これは、暗号的に安全な"
"目的に適っています。MicroPython コアに含まれており、特定のコードサイズの制約が"
"ない限り、どのボードでもこのアルゴリズムの提供を推奨しています。"

#: ../../../library/uhashlib.rst:18
msgid ""
"SHA1 - A previous generation algorithm. Not recommended for new usages, "
"but SHA1 is a part of number of Internet standards and existing "
"applications, so boards targeting network connectivity and "
"interoperability will try to provide this."
msgstr ""
"SHA1 - 前世代のアルゴリズム。新しい用途には推奨されませんが、SHA1 はインターネット"
"標準や既存のアプリケーションの一部です。そのため、ネットワーク接続と相互運用性を目的"
"としたボードがこれを提供することはあります。"

#: ../../../library/uhashlib.rst:23
msgid ""
"MD5 - A legacy algorithm, not considered cryptographically secure. Only "
"selected boards, targeting interoperability with legacy applications, "
"will offer this."
msgstr ""
"MD5 - 暗号で安全とはみなされないレガシーアルゴリズム。従来のアプリケーションとの"
"相互運用性を目的とした一部のボードのみがこれを提供します。"

#: ../../../library/uhashlib.rst:32
msgid "Create an SHA256 hasher object and optionally feed ``data`` into it."
msgstr ""
"SHA256 ハッシュオブジェクトを作成し、オプションでそのオブジェクトに ``data`` を"
"フィードします。"

#: ../../../library/uhashlib.rst:36
msgid "Create an SHA1 hasher object and optionally feed ``data`` into it."
msgstr ""
"SHA1 ハッシュオブジェクトを作成し、オプションでそのオブジェクトに ``data`` を"
"フィードします。"

#: ../../../library/uhashlib.rst:40
msgid "Create an MD5 hasher object and optionally feed ``data`` into it."
msgstr ""
"MD5 ハッシュオブジェクトを作成し、オプションでそのオブジェクトに ``data`` を"
"フィードします。"

#: ../../../library/uhashlib.rst:47
msgid "Feed more binary data into hash."
msgstr "ハッシュにバイナリデータを追加でフォードします。"

#: ../../../library/uhashlib.rst:51
msgid ""
"Return hash for all data passed through hash, as a bytes object. After "
"this method is called, more data cannot be fed into the hash any longer."
msgstr ""
"ハッシュを介して渡されたすべてのデータのハッシュをバイトオブジェクトとして返します。"
"このメソッドが呼び出された後は、もうデータをハッシュにフィードできなくなります。"

#: ../../../library/uhashlib.rst:56
msgid ""
"This method is NOT implemented. Use ``ubinascii.hexlify(hash.digest())`` "
"to achieve a similar effect."
msgstr ""
"このメソッドは実装されていません。同様の効果を得るには "
"``ubinascii.hexlify(hash.digest())`` を使ってください。"

#: ../../../library/uheapq.rst:2
msgid ":mod:`uheapq` -- heap queue algorithm"
msgstr ":mod:`uheapq` -- ヒープキューアルゴリズム"

#: ../../../library/uheapq.rst:7
msgid "|see_cpython_module| :mod:`python:heapq`."
msgstr ""

#: ../../../library/uheapq.rst:9
msgid "This module implements the heap queue algorithm."
msgstr "このモジュールは、ヒープキューアルゴリズムを実装します。"

#: ../../../library/uheapq.rst:11
msgid ""
"A heap queue is simply a list that has its elements stored in a certain "
"way."
msgstr ""
"ヒープキューは、要素が特定の方法で格納されている単なるリストです。"

#: ../../../library/uheapq.rst:18
msgid "Push the ``item`` onto the ``heap``."
msgstr "``heap`` に ``item`` をプッシュします。"

#: ../../../library/uheapq.rst:22
msgid ""
"Pop the first item from the ``heap``, and return it.  Raises IndexError "
"if heap is empty."
msgstr ""
"``heap`` から最初の要素をポップして返します。ヒープが空の場合には IndexError "
"を発生させます。"

#: ../../../library/uheapq.rst:27
msgid "Convert the list ``x`` into a heap.  This is an in-place operation."
msgstr "リスト ``x`` をヒープに変換します。これは、in-place (追加のメモリをほとんど使わずに行う)操作です。"

#: ../../../library/uio.rst:2
msgid ":mod:`uio` -- input/output streams"
msgstr ":mod:`uio` -- 入出力ストリーム"

#: ../../../library/uio.rst:7
msgid "|see_cpython_module| :mod:`python:io`."
msgstr ""

#: ../../../library/uio.rst:9
msgid ""
"This module contains additional types of `stream` (file-like) objects and"
" helper functions."
msgstr ""
"このモジュールには ``stream`` (ファイルのような)オブジェクトの追加のデータ型と"
"ヘルパー関数が含まれています。"

#: ../../../library/uio.rst:13
msgid "Conceptual hierarchy"
msgstr "概念階層"

#: ../../../library/uio.rst:18
msgid ""
"Conceptual hierarchy of stream base classes is simplified in MicroPython,"
" as described in this section."
msgstr ""
"この章で説明するように、MicroPythonではストリームベースのクラスの概念的な階層が"
"単純化されています。"

#: ../../../library/uio.rst:21
msgid ""
"(Abstract) base stream classes, which serve as a foundation for behavior "
"of all the concrete classes, adhere to few dichotomies (pair-wise "
"classifications) in CPython. In MicroPython, they are somewhat simplified"
" and made implicit to achieve higher efficiencies and save resources."
msgstr ""
"(抽象)基底 stream クラスは、すべての具象クラスの動作の基礎となるものであり、"
"CPython にある二分法(ペアワイズ分類)に固執しません。MicroPython では、"
"これらは幾分単純化されていて、効率化とリソース節約のために暗黙的に役立ちます。"

#: ../../../library/uio.rst:26
msgid ""
"An important dichotomy in CPython is unbuffered vs buffered streams. In "
"MicroPython, all streams are currently unbuffered. This is because all "
"modern OSes, and even many RTOSes and filesystem drivers already perform "
"buffering on their side. Adding another layer of buffering is counter- "
"productive (an issue known as \"bufferbloat\") and takes precious memory."
" Note that there still cases where buffering may be useful, so we may "
"introduce optional buffering support at a later time."
msgstr ""
"CPython の重要な二分法は、バッファされていないストリームとバッファされている"
"ストリームです。MicroPython では、すべてのストリームは現在バッファリング"
"されていません。これは、すべての現代的な OS、さらには多くの RTOS や"
"ファイルシステムドライバでさえも、すでにバッファリングが行われているからです。"
"別のレイヤーにバッファリングを追加することは、生産性を低下させ(\"bufferbloat\" "
"という問題)、貴重なメモリを消費します。バッファリングが便利な場合もあるので、"
"後でオプションのバッファリングサポートを導入するかもしれません。"

#: ../../../library/uio.rst:34
msgid ""
"But in CPython, another important dichotomy is tied with \"bufferedness\""
" - it's whether a stream may incur short read/writes or not. A short read"
" is when a user asks e.g. 10 bytes from a stream, but gets less, "
"similarly for writes. In CPython, unbuffered streams are automatically "
"short operation susceptible, while buffered are guarantee against them. "
"The no short read/writes is an important trait, as it allows to develop "
"more concise and efficient programs - something which is highly desirable"
" for MicroPython. So, while MicroPython doesn't support buffered streams,"
" it still provides for no-short-operations streams. Whether there will be"
" short operations or not depends on each particular class' needs, but "
"developers are strongly advised to favor no-short-operations behavior for"
" the reasons stated above. For example, MicroPython sockets are "
"guaranteed to avoid short read/writes. Actually, at this time, there is "
"no example of a short-operations stream class in the core, and one would "
"be a port-specific class, where such a need is governed by hardware "
"peculiarities."
msgstr ""
"しかし、CPython には別の重要な二分法もあり、それは「バッファされているか」と関連して"
"います。ストリームが短い読み込み/書き込みを起こすかどうかです。短い読み取りとは、"
"たとえばストリームから10バイトを要求しても、それより少ないデータを得ることです。短い"
"書き込みについても同様です。CPython ではバッファリングされていないストリームは"
"自動的に短い操作になる影響を受けますが、バッファされたストリームは要求したサイズを"
"保証します。短くない読み込み/書き込みは重要な特性であり、より簡潔で効率的なプログラム"
"を開発できるので、MicroPython にとっても非常に望ましいものです。したがって、"
"MicroPython はバッファされたストリームをサポートしていませんが、短くない操作の"
"ストリームも提供します。短い操作の有無は、各クラスのニーズに応じて異なりますが、"
"開発者は上記の理由により短くない操作を好むよう強く推奨します。たとえば、"
"MicroPython のソケットは、短い読み取り/書き込みを避けることが保証されています。"
"実際、現時点では、コアには短い操作のストリームクラスの例はなく、あるとすれば"
"ポート固有のクラスとなります。そのような必要性はハードウェアの特性によって管理されます。"

#: ../../../library/uio.rst:51
msgid ""
"The no-short-operations behavior gets tricky in case of non-blocking "
"streams, blocking vs non-blocking behavior being another CPython "
"dichotomy, fully supported by MicroPython. Non-blocking streams never "
"wait for data either to arrive or be written - they read/write whatever "
"possible, or signal lack of data (or ability to write data). Clearly, "
"this conflicts with \"no-short-operations\" policy, and indeed, a case of"
" non-blocking buffered (and this no-short-ops) streams is convoluted in "
"CPython - in some places, such combination is prohibited, in some it's "
"undefined or just not documented, in some cases it raises verbose "
"exceptions. The matter is much simpler in MicroPython: non-blocking "
"stream are important for efficient asynchronous operations, so this "
"property prevails on the \"no-short-ops\" one. So, while blocking streams"
" will avoid short reads/writes whenever possible (the only case to get a "
"short read is if end of file is reached, or in case of error (but errors "
"don't return short data, but raise exceptions)), non-blocking streams may"
" produce short data to avoid blocking the operation."
msgstr ""
"短くない操作の動作は、非ブロックストリームの場合はトリッキーであり、ブロックと"
"非ブロックの動作は別の CPython での二分法です。この２つの動作は MicroPython "
"で完全にサポートされています。非ブロックストリームは、データの到着または書き込みを"
"待つことは決してありません。可能な限りデータの読み込み/書き込みを行うか、"
"データの欠乏(あるいはデータ書き込み可能)の通知します。明らかに、これは「短くない"
"操作」のポリシーと矛盾しています。実際、非ブロックバッファ(で短くない操作)"
"のストリームは、CPython では面倒です。ものによって、そのような組み合わせは禁止"
"されているか、未定義であり、文書化されていないものもあります。場合によっては"
"冗長な例外が発生します。MicroPython では、非ブロックストリームが効率的な"
"非同期操作にとって重要であるため、この特性は「短くない操作」に優先します。"
"したがって、ストリームをブロックすると、可能な限り短い読み込み/書き込みが回避"
"されます(ファイルの終わりに達した場合、またはエラーが発生した場合は短い読み込みを"
"取得する唯一のケースですが、エラーは短いデータを返さず例外を発生させます)。"
"非ブロックストリームは、動作をブロックしないように短いデータを生成する可能性が"
"あります。"

#: ../../../library/uio.rst:68
msgid ""
"The final dichotomy is binary vs text streams. MicroPython of course "
"supports these, but while in CPython text streams are inherently "
"buffered, they aren't in MicroPython. (Indeed, that's one of the cases "
"for which we may introduce buffering support.)"
msgstr ""
"残る二分法は、バイナリとテキストのストリームです。MicroPython はもちろんこれを"
"サポートしていますが、CPython のテキストストリームが本質的にバッファされている"
"のに対して MicroPython ではバッファしていません。(実際、これはバッファを"
"サポートする可能正のある唯一のケースです)。"

#: ../../../library/uio.rst:73
msgid ""
"Note that for efficiency, MicroPython doesn't provide abstract base "
"classes corresponding to the hierarchy above, and it's not possible to "
"implement, or subclass, a stream class in pure Python."
msgstr ""
"効率を上げるために、MicroPython は上記の階層に対応する抽象基底クラスを提供して"
"いないことに注意してください。純粋な Python にあるストリームクラスを実装または"
"サブクラス化することはできません。"

#: ../../../library/uio.rst:82
msgid ""
"Open a file. Builtin ``open()`` function is aliased to this function. All"
" ports (which provide access to file system) are required to support "
"*mode* parameter, but support for other arguments vary by port."
msgstr ""
"ファイルを開きます。組込みの ``open()`` 関数はこの関数の別名になります。"
"すべての(ファイルシステムへのアクセスを提供する)ポートは、 *mode* パラメータを"
"サポートする必要がありますが、他の引数のサポートはポートによって異なります。"

#: ../../../library/uio.rst:91
msgid ""
"This is type of a file open in binary mode, e.g. using ``open(name, "
"\"rb\")``. You should not instantiate this class directly."
msgstr ""
"これは ``open(name, \"rb\")`` などでバイナリモードで開くファイルのデータ型です。"
"このクラスを直接インスタンス化しないでください。"

#: ../../../library/uio.rst:96
msgid ""
"This is type of a file open in text mode, e.g. using ``open(name, "
"\"rt\")``. You should not instantiate this class directly."
msgstr ""
"これは ``open(name, \"rt\")`` などでテキストモードで開くファイルのデータ型です。"
"このクラスを直接インスタンス化しないでください。"

#: ../../../library/uio.rst:102
msgid ""
"In-memory file-like objects for input/output. `StringIO` is used for "
"text-mode I/O (similar to a normal file opened with \"t\" modifier). "
"`BytesIO` is used for binary-mode I/O (similar to a normal file opened "
"with \"b\" modifier). Initial contents of file-like objects can be "
"specified with *string* parameter (should be normal string for `StringIO`"
" or bytes object for `BytesIO`). All the usual file methods like "
"``read()``, ``write()``, ``seek()``, ``flush()``, ``close()`` are "
"available on these objects, and additionally, a following method:"
msgstr ""
"入出力のためのメモリ内の疑似ファイルオブジェクト。 `StringIO` はテキストモードの "
"I/O に使用されます(\"t\" 修飾子で開かれた通常のファイルと同様)。 `BytesIO` は"
"バイナリモードの I/O に使用されます(\"b\" 修飾子で開かれた通常のファイルと同様)。"
"この疑似ファイルオブジェクトの初期の内容は *string* パラメータで指定できます"
"(`StringIO` では通常の文字列、 `BytesIO` ではバイト列オブジェクトでなければ"
"なりません)。このオブジェクトについては、通常のファイルのメソッドのすべて "
"``read()``, ``write()``, ``seek()``, ``flush()``, ``close()`` が使え、"
"加えて以下のメソッドが使えます。"

#: ../../../library/uio.rst:114
msgid "Get the current contents of the underlying buffer which holds data."
msgstr "データを保持するバッファの現在の内容を取得します。"

#: ../../../library/uio.rst:119
msgid ""
"Create an empty `StringIO`/`BytesIO` object, preallocated to hold up to "
"*alloc_size* number of bytes. That means that writing that amount of "
"bytes won't lead to reallocation of the buffer, and thus won't hit out-"
"of-memory situation or lead to memory fragmentation. These constructors "
"are a MicroPython extension and are recommended for usage only in special"
" cases and in system-level libraries, not for end-user applications."
msgstr ""
"*alloc_size* で指定したバイト数を保持するために事前に割り当てられた空の "
"`StringIO`/`BytesIO` オブジェクトを作成します。つまり、その量のバイトを"
"書き込んでもバッファの再割り当てにはつながりません。したがって、メモリ不足の状況に"
"遭遇したり、メモリの断片化につながることはありません。これらのコンストラクタは "
"MicroPython の拡張であり、エンドユーザーアプリケーションではなく、特別な場合"
"およびシステムレベルのライブラリーでのみ使用することをお勧めします。"

#: ../../../library/uio.rst:129
msgid "These constructors are a MicroPython extension."
msgstr "これらのコンストラクタは MicroPython の拡張です。"

#: ../../../library/ujson.rst:2
msgid ":mod:`ujson` -- JSON encoding and decoding"
msgstr ":mod:`ujson` -- JSON のエンコードとデコード"

#: ../../../library/ujson.rst:7
msgid "|see_cpython_module| :mod:`python:json`."
msgstr ""

#: ../../../library/ujson.rst:9
msgid ""
"This modules allows to convert between Python objects and the JSON data "
"format."
msgstr "このモジュールでは、Python オブジェクトと JSON データの間の変換ができます。"

#: ../../../library/ujson.rst:17
msgid "Serialise *obj* to a JSON string, writing it to the given *stream*."
msgstr "*obj* を JSON 文字列にシリアル化し、指定されたストリームに書き込みます。"

#: ../../../library/ujson.rst:21
msgid "Return *obj* represented as a JSON string."
msgstr "JSON 文字列で表される *obj* を返します。"

#: ../../../library/ujson.rst:25
msgid ""
"Parse the given *stream*, interpreting it as a JSON string and "
"deserialising the data to a Python object.  The resulting object is "
"returned."
msgstr ""
"指定した *stream* を解析し、それを JSON 文字列として解釈し、データを Python "
"オブジェクトにデシリアライズします。結果のオブジェクトが返されます。"

#: ../../../library/ujson.rst:29
msgid ""
"Parsing continues until end-of-file is encountered. A :exc:`ValueError` "
"is raised if the data in *stream* is not correctly formed."
msgstr ""
"ファイルの終わりに達するまで解析が続きます。*stream* 内のデータが正しい形式になって"
"いないと、 :exc:`ValueError` 例外が発生します。"

#: ../../../library/ujson.rst:34
msgid ""
"Parse the JSON *str* and return an object.  Raises :exc:`ValueError` if "
"the string is not correctly formed."
msgstr ""
"JSON *str* を解析してオブジェクトを返します。文字列が正しい形式になって"
"いないと、 :exc:`ValueError` 例外が発生します。"

#: ../../../library/uos.rst:2
msgid ":mod:`uos` -- basic \"operating system\" services"
msgstr ":mod:`uos` -- 基本的な「オペレーティングシステム」サービス"

#: ../../../library/uos.rst:7
msgid "|see_cpython_module| :mod:`python:os`."
msgstr ""

#: ../../../library/uos.rst:9
msgid ""
"The ``uos`` module contains functions for filesystem access and mounting,"
" terminal redirection and duplication, and the ``uname`` and ``urandom`` "
"functions."
msgstr ""
"``uos`` モジュールには、ファイルシステムのアクセス、マウント、ターミナルのリダイレクト"
"と複製、``uname`` と ``urandom`` のための関数があります。"

#: ../../../library/uos.rst:14
msgid "General functions"
msgstr "一般関数"

#: ../../../library/uos.rst:18
msgid ""
"Return a tuple (possibly a named tuple) containing information about the "
"underlying machine and/or its operating system.  The tuple has five "
"fields in the following order, each of them being a string:"
msgstr ""
"基盤のマシンやオペレーティングシステムに関する情報を含むタプル(おそらく名前付き"
"タプル)を返します。タプルには次の5つのフィールドがあり、それぞれが文字列です。"

#: ../../../library/uos.rst:22
msgid "``sysname`` -- the name of the underlying system"
msgstr "``sysname`` -- 基盤システムの名前"

#: ../../../library/uos.rst:23
msgid "``nodename`` -- the network name (can be the same as ``sysname``)"
msgstr "``nodename`` -- ネットワーク名(``sysname`` と同じこともあります)"

#: ../../../library/uos.rst:24
msgid "``release`` -- the version of the underlying system"
msgstr "``release`` -- 基盤システムのバージョン"

#: ../../../library/uos.rst:25
msgid "``version`` -- the MicroPython version and build date"
msgstr "``version`` -- MicroPython のバージョンとビルド日付"

#: ../../../library/uos.rst:26
msgid "``machine`` -- an identifier for the underlying hardware (eg board, CPU)"
msgstr "``machine`` -- 基盤ハードウェアの識別子(ボード、CPUなど)"

#: ../../../library/uos.rst:30
msgid ""
"Return a bytes object with *n* random bytes. Whenever possible, it is "
"generated by the hardware random number generator."
msgstr ""
"*n* 個のランダムバイトを持つバイト列オブジェクトを返します。可能な限り、"
"ハードウェア乱数生成器によって乱数を生成します。"

#: ../../../library/uos.rst:34
msgid "Filesystem access"
msgstr "ファイルシステムのアクセス"

#: ../../../library/uos.rst:38
msgid "Change current directory."
msgstr "カレントディレクトリを変更します。"

#: ../../../library/uos.rst:42
msgid "Get the current directory."
msgstr "カレントディレクトリのパスを返します。"

#: ../../../library/uos.rst:46
msgid ""
"This function returns an iterator which then yields tuples corresponding "
"to the entries in the directory that it is listing.  With no argument it "
"lists the current directory, otherwise it lists the directory given by "
"*dir*."
msgstr ""
"この関数はイテレータを返します。イテレータが生成するのは、ディレクトリ内のエントリに"
"対応するタプルです。引数なしの場合はカレントディレクトリを、それ以外の場合は "
"*dir* で指定したディレクトリをリストします。"

#: ../../../library/uos.rst:50
msgid "The tuples have the form *(name, type, inode[, size])*:"
msgstr "タプルの形式は *(name, type, inode [, size])* です。"

#: ../../../library/uos.rst:52
msgid ""
"*name* is a string (or bytes if *dir* is a bytes object) and is the name "
"of the entry;"
msgstr ""
"*name* は文字列(*dir* バイト列オブジェクトの場合はバイト列)であり、エントリの名前です。"

#: ../../../library/uos.rst:54
msgid ""
"*type* is an integer that specifies the type of the entry, with 0x4000 "
"for directories and 0x8000 for regular files;"
msgstr ""
"*type* はエントリのタイプを指定する整数で、ディレクトリの場合は 0x4000、"
"通常のファイルの場合は 0x8000 です。"

#: ../../../library/uos.rst:56
msgid ""
"*inode* is an integer corresponding to the inode of the file, and may be "
"0 for filesystems that don't have such a notion."
msgstr ""
"*inode* はファイルのiノードに対応する整数であり、そのような概念を持たないファイル"
"システムについては 0 になります。"

#: ../../../library/uos.rst:58
msgid ""
"Some platforms may return a 4-tuple that includes the entry's *size*.  "
"For file entries, *size* is an integer representing the size of the file "
"or -1 if unknown.  Its meaning is currently undefined for directory "
"entries."
msgstr ""
"一部のプラットフォームでは、エントリのサイズを含む4タプルが返されることがあります。"
"ファイルエントリの場合、 *size* はファイルのサイズを表す整数で、未知の場合は -1 です。"
"現在のところ、ディレクトリエントリについては未定義です。"

#: ../../../library/uos.rst:65
msgid ""
"With no argument, list the current directory.  Otherwise list the given "
"directory."
msgstr ""
"引数を指定しない場合は、カレントディレクトリ内のエントリを表示します。"
"それ以外の場合は指定されたディレクトリ内のエントリを表示します。"

#: ../../../library/uos.rst:69
msgid "Create a new directory."
msgstr "新規にディレクトリを作成します。"

#: ../../../library/uos.rst:73
msgid "Remove a file."
msgstr "ファイルを削除します。"

#: ../../../library/uos.rst:77
msgid "Remove a directory."
msgstr "ディレクトリを削除します。"

#: ../../../library/uos.rst:81
msgid "Rename a file."
msgstr "ファイルの名前を変更します。"

#: ../../../library/uos.rst:85
msgid "Get the status of a file or directory."
msgstr "ファイルまたはディレクトリのステータスを取得します。"

#: ../../../library/uos.rst:89
msgid "Get the status of a fileystem."
msgstr "ファイルシステムの状態を取得します。"

#: ../../../library/uos.rst:91
msgid "Returns a tuple with the filesystem information in the following order:"
msgstr "次の順序でファイルシステム情報を含むタプルを返します。"

#: ../../../library/uos.rst:93
msgid "``f_bsize`` -- file system block size"
msgstr "``f_bsize`` -- ファイルシステムのブロックサイズ"

#: ../../../library/uos.rst:94
msgid "``f_frsize`` -- fragment size"
msgstr "``f_frsize`` -- フラグメントサイズ"

#: ../../../library/uos.rst:95
msgid "``f_blocks`` -- size of fs in f_frsize units"
msgstr "``f_blocks`` -- f_frsize 単位の fs のサイズ"

#: ../../../library/uos.rst:96
msgid "``f_bfree`` -- number of free blocks"
msgstr "``f_bfree`` -- 空きブロックの数"

#: ../../../library/uos.rst:97
msgid "``f_bavail`` -- number of free blocks for unprivileged users"
msgstr "``f_bavail`` -- 権限なしユーザーのための空きブロック数"

#: ../../../library/uos.rst:98
msgid "``f_files`` -- number of inodes"
msgstr "``f_files`` -- iノード数"

#: ../../../library/uos.rst:99
msgid "``f_ffree`` -- number of free inodes"
msgstr "``f_ffree`` -- フリーのiノードの数"

#: ../../../library/uos.rst:100
msgid "``f_favail`` -- number of free inodes for unprivileged users"
msgstr "``f_favail`` -- 権限なしユーザの空きiノード数"

#: ../../../library/uos.rst:101
msgid "``f_flag`` -- mount flags"
msgstr "``f_flag`` -- マウントフラグ"

#: ../../../library/uos.rst:102
msgid "``f_namemax`` -- maximum filename length"
msgstr "``f_namemax`` -- 最大ファイル名の長さ"

#: ../../../library/uos.rst:104
msgid ""
"Parameters related to inodes: ``f_files``, ``f_ffree``, ``f_avail`` and "
"the ``f_flags`` parameter may return ``0`` as they can be unavailable in "
"a port-specific implementation."
msgstr ""
"iノードに関連するパラメータ ``f_files``, ``f_ffree``, ``f_avail``, "
"``f_flags`` は、ポート固有の実装で使えない場合には 0 になります。"

#: ../../../library/uos.rst:110
msgid "Sync all filesystems."
msgstr "すべてのファイルシステムを同期します。"

#: ../../../library/uos.rst:113
msgid "Terminal redirection and duplication"
msgstr "ターミナルのリダイレクトと複製"

#: ../../../library/uos.rst:117
msgid ""
"Duplicate or switch the MicroPython terminal (the REPL) on the given "
"`stream`-like object. The *stream_object* argument must be a native "
"stream object, or derive from ``uio.IOBase`` and implement the "
"``readinto()`` and ``write()`` methods.  The stream should be in non-"
"blocking mode and ``readinto()`` should return ``None`` if there is no "
"data available for reading."
msgstr ""
"与えた `strean` オブジェクトに MicroPython 端末(REPL)を複製または"
"切り替えを行います。 *stream_object* の引数はネイティブストリームオブジェクトか、"
"``uio.IOBase`` から派生して ``readinto()`` と ``write()`` メソッドを実装した"
"ものでなければなりません。ストリームは非ブロッキングモードで、 ``readinto()`` "
"は読み込み可能なデータがない場合は ``None`` を返すようにします。"

#: ../../../library/uos.rst:123
msgid ""
"After calling this function all terminal output is repeated on this "
"stream, and any input that is available on the stream is passed on to the"
" terminal input."
msgstr ""
"この関数を呼び出した後、すべての端末出力がこのストリーム上で繰り返され、"
"ストリーム上で利用可能なすべての入力がターミナル入力に渡されます。"

#: ../../../library/uos.rst:126
msgid ""
"The *index* parameter should be a non-negative integer and specifies "
"which duplication slot is set.  A given port may implement more than one "
"slot (slot 0 will always be available) and in that case terminal input "
"and output is duplicated on all the slots that are set."
msgstr ""
"*index* パラメータは負でない整数であり、設定されている複製を指定します。"
"ポートは２つ以上のスロットを実装できます(スロット 0 は常に使用可能です)。"
"その場合、端末の入出力は設定されているすべてのスロットに複製されます。"

#: ../../../library/uos.rst:131
msgid ""
"If ``None`` is passed as the *stream_object* then duplication is "
"cancelled on the slot given by *index*."
msgstr ""
"*stream_object* に ``None`` を渡した場合、 *index* によって指定された"
"スロットで重複が取り消されます。"

#: ../../../library/uos.rst:134
msgid "The function returns the previous stream-like object in the given slot."
msgstr "この関数は、指定したスロットの前のストリームオブジェクトを返します。"

#: ../../../library/uos.rst:137
msgid "Filesystem mounting"
msgstr "ファイルシステムのマウント"

#: ../../../library/uos.rst:139
msgid ""
"Some ports provide a Virtual Filesystem (VFS) and the ability to mount "
"multiple \"real\" filesystems within this VFS.  Filesystem objects can be"
" mounted at either the root of the VFS, or at a subdirectory that lives "
"in the root.  This allows dynamic and flexible configuration of the "
"filesystem that is seen by Python programs.  Ports that have this "
"functionality provide the :func:`mount` and :func:`umount` functions, and"
" possibly various filesystem implementations represented by VFS classes."
msgstr ""
"いくつかのポートは仮想ファイルシステム(VFS)を提供し、この VFS 内に複数の「実」"
"ファイルシステムをマウントする機能を備えています。ファイルシステムオブジェクトは、"
"VFS のルート、またはルートに存在するサブディレクトリにマウントできます。これにより、"
"Python プログラムで見られるファイルシステムの動的で柔軟な設定が可能になります。"
"この機能を持つポートは ``mount()`` と ``umount()`` 関数、そしておそらく VFS "
"クラスで表されるさまざまなファイルシステムの実装を提供します。"

#: ../../../library/uos.rst:149
msgid ""
"Mount the filesystem object *fsobj* at the location in the VFS given by "
"the *mount_point* string.  *fsobj* can be a a VFS object that has a "
"``mount()`` method, or a block device.  If it's a block device then the "
"filesystem type is automatically detected (an exception is raised if no "
"filesystem was recognised).  *mount_point* may be ``'/'`` to mount "
"*fsobj* at the root, or ``'/<name>'`` to mount it at a subdirectory under"
" the root."
msgstr ""
"ファイルシステムオブジェクト *fsobj* を *mount_point* 文字列で指定した VFS 内の"
"場所にマウントします。 *fsobj* には ``mount()`` メソッドを持つ VFS オブジェクト、"
"またはブロックデバイスを指定できます。ブロックデバイスであればファイルシステムタイプ"
"が自動的に検出されます(ファイルシステムが認識されない場合は例外が発生します)。 "
"*mount_point* が ``'/'`` であれば *fsobj* をルートににマウントし、"
"``'/<name>'`` であればルート配下のサブディレクトリにマウントします。"

#: ../../../library/uos.rst:156
msgid "If *readonly* is ``True`` then the filesystem is mounted read-only."
msgstr "*readonly* が ``True`` であればファイルシステムが読み取り専用でマウントされています。"

#: ../../../library/uos.rst:158
msgid ""
"During the mount process the method ``mount()`` is called on the "
"filesystem object."
msgstr ""
"マウント処理では、ファイルシステムオブジェクトに対してメソッド ``mount()`` "
"呼出します。"

#: ../../../library/uos.rst:161
msgid "Will raise ``OSError(EPERM)`` if *mount_point* is already mounted."
msgstr "*mount_point* に既にマウントされていれば ``OSError(EPERM)`` 例外が発生します。"

#: ../../../library/uos.rst:165
msgid ""
"Unmount a filesystem. *mount_point* can be a string naming the mount "
"location, or a previously-mounted filesystem object.  During the unmount "
"process the method ``umount()`` is called on the filesystem object."
msgstr ""
"ファイルシステムをアンマウントします。 *mount_point* には、マウント場所を指定する"
"文字列、または以前にマウントされたファイルシステムオブジェクトを指定できます。"
"アンマウント処理では、ファイルシステムオブジェクトに対してメソッド ``unmount()`` "
"呼出します。"

#: ../../../library/uos.rst:169
msgid "Will raise ``OSError(EINVAL)`` if *mount_point* is not found."
msgstr ""*mount_point* が見つからなければ ``OSError(EINVAL)`` 例外が発生します。"

#: ../../../library/uos.rst:173
msgid ""
"Create a filesystem object that uses the FAT filesystem format.  Storage "
"of the FAT filesystem is provided by *block_dev*. Objects created by this"
" constructor can be mounted using :func:`mount`."
msgstr ""
"FAT ファイルシステムのフォーマットを使うファイルシステムオブジェクトを作成します。"
"FAT ファイルシステムのストレージは *block_dev* によって提供されます。この"
"コンストラクタによって作成されたオブジェクトは :func:`mount` を使ってマウント"
"できます。"

#: ../../../library/uos.rst:179
msgid "Build a FAT filesystem on *block_dev*."
msgstr "*block_dev* に FAT ファイルシステムを構築します。"

#: ../../library/uos.rst:183
msgid ""
"Create a filesystem object that uses the `littlefs v1 filesystem "
"format`_. Storage of the littlefs filesystem is provided by *block_dev*, "
"which must support the :ref:`extended interface <block-device-"
"interface>`. Objects created by this constructor can be mounted using "
":func:`mount`."
msgstr ""
"`littlefs v1 filesystem format`_ を使うファイルシステムオブジェクトを作成します。"
"littlefs ファイルシステムのストレージは *block_dev* によって提供されます。 "
"*block_dev* は拡張インターフェースをサポートしている必要があります。"
"このコンストラクタによって作成されたオブジェクトは :func:`mount` を使ってマウントできます。"

#: ../../library/uos.rst:188 ../../library/uos.rst:204
msgid "See :ref:`filesystem` for more information."
msgstr "詳しくは :ref:`filesystem` を参照してください。"

#: ../../library/uos.rst:192
msgid "Build a Lfs1 filesystem on *block_dev*."
msgstr "*block_dev* に Lfs1 ファイルシステムを構築します。"

#: ../../library/uos.rst:194
msgid ""
"There are reports of littlefs v1 failing in certain situations, for "
"details see `littlefs issue 347`_."
msgstr ""
"特定の状況で littlefs v1 が失敗するという報告があります。詳細については "
"`littlefs issue 347`_ を参照してください。"

#: ../../library/uos.rst:199
msgid ""
"Create a filesystem object that uses the `littlefs v2 filesystem "
"format`_. Storage of the littlefs filesystem is provided by *block_dev*, "
"which must support the :ref:`extended interface <block-device-"
"interface>`. Objects created by this constructor can be mounted using "
":func:`mount`."
msgstr ""
"`littlefs v2 filesystem format`_ を使うファイルシステムオブジェクトを作成します。"
"littlefs ファイルシステムのストレージは *block_dev* によって提供されます。 "
"*block_dev* は拡張インターフェースをサポートしている必要があります。"
"このコンストラクタによって作成されたオブジェクトは :func:`mount` を使ってマウントできます。"

#: ../../library/uos.rst:208
msgid "Build a Lfs2 filesystem on *block_dev*."
msgstr "*block_dev* に Lfs2 ファイルシステムを構築します。"

#: ../../library/uos.rst:210
msgid ""
"There are reports of littlefs v2 failing in certain situations, for "
"details see `littlefs issue 295`_."
msgstr ""
"特定の状況で littlefs v2 が失敗するという報告があります。詳細については "
"`littlefs issue 295`_ を参照してください。"

#: ../../../library/uos.rst:219
msgid "Block devices"
msgstr "ブロックデバイス"

#: ../../../library/uos.rst:221
msgid ""
"A block device is an object which implements the block protocol. This "
"enables a device to support MicroPython filesystems. The physical "
"hardware is represented by a user defined class. The "
":class:`AbstractBlockDev` class is a template for the design of such a "
"class: MicroPython does not actually provide that class, but an actual "
"block device class must implement the methods described below."
msgstr ""
"ブロックデバイスは、ブロックプロトコルを実装するオブジェクトです。"
"これによりデバイスが MicroPython ファイルシステムをサポートできるようになります。"
"物理ハードウェアはユーザー定義のクラスによって表されます。 "
":class:`AbstractBlockDev` クラスはそのようなクラスを定義するためのテンプレートです。"
"MicroPython が提供していないブロックデバイスクラスを自作する場合は後述のメソッドを"
"実装する必要があります。"

#: ../../library/uos.rst:227
msgid ""
"A concrete implementation of this class will usually allow access to the "
"memory-like functionality of a piece of hardware (like flash memory). A "
"block device can be formatted to any supported filesystem and mounted "
"using ``uos`` methods."
msgstr ""
"このクラスの具象サブクラスでは通常(フラッシュメモリのような)ハードウェアの一部に"
"メモリのような機能へのアクセスが許可されます。ブロックデバイスはサポートされている"
"ファイルシステムでフォーマットでき、 ``uos`` のメソッドを使ってマウントできます。"

#: ../../library/uos.rst:232
msgid ""
"See :ref:`filesystem` for example implementations of block devices using "
"the two variants of the block protocol described below."
msgstr ""
"後述する２種類のブロックプロトコルを使ったブロックデバイスの実装例については "
":ref:`filesystem` を参照してください。"

#: ../../library/uos.rst:238
msgid "Simple and extended interface"
msgstr "シンプルインタフェースと拡張インタフェース"

#: ../../../library/uos.rst:240
msgid ""
"There are two compatible signatures for the ``readblocks`` and "
"``writeblocks`` methods (see below), in order to support a variety of use"
" cases.  A given block device may implement one form or the other, or "
"both at the same time. The second form (with the offset parameter) is "
"referred to as the \"extended interface\"."
msgstr ""
"さまざまなユースケースをサポートするために、 ``readblocks`` や ``writeblocks`` "
"メソッドには２つの互換性のあるシグネチャがあります(以下を参照)。"
"与えられたブロックデバイスは、どちらか一方、または両方を実装しています。"
"２番目の形式(offset 引数のあるもの)は「拡張インタフェース」といいます。"

#: ../../library/uos.rst:245
msgid ""
"Some filesystems (such as littlefs) that require more control over write "
"operations, for example writing to sub-block regions without erasing, may"
" require that the block device supports the extended interface."
msgstr ""
"書き込み操作をより細かく制御する必要のある一部のファイルシステム(littlefs など)では、"
"たとえば、消去せずにサブブロック領域に書き込む場合、ブロックデバイスが拡張インターフェイスを"
"サポートしている必要がある場合があります。"

#: ../../../library/uos.rst:251
msgid ""
"Construct a block device object.  The parameters to the constructor are "
"dependent on the specific block device."
msgstr ""
"ブロックデバイスオブジェクトを構築します。コンストラクタへのパラメータは、特定の"
"ブロックデバイスに依存します。"

#: ../../../library/uos.rst:257
msgid ""
"The first form reads aligned, multiples of blocks. "
"Starting at the block given by the index *block_num*, read blocks from "
"the device into *buf* (an array of bytes). The number of blocks to read "
"is given by the length of *buf*, which will be a multiple of the block "
"size."
msgstr ""
"最初の形式は、整列した複数のブロックを読み取ります。インデックス *block_num* で"
"指定したブロックを開始点として、デバイスから *buf* (バイト列)にブロックを読み込みます。"
"読み込むブロック数は *buf* の長さで与えられ、ブロックサイズの倍数になります。"

#: ../../../library/uos.rst:263
msgid ""
"The second form allows reading at arbitrary locations within a block, "
"and arbitrary lengths. Starting at block index *block_num*, and byte "
"offset within that block of *offset*, read bytes from the device into "
"*buf* (an array of bytes). The number of bytes to read is given by "
"the length of *buf*."
msgstr ""
"２番目の形式では、ブロック内の任意の場所、任意の長さで読み取ることができます。"
"ブロックインデックス *block_num* とブロック内のバイトオフセット *offset* "
"を開始点として、デバイスから *buf* (バイト列)にブロックを読み込みます。"
"読み込むブロック数は *buf* の長さで与えられ、読み込むバイト数になります。"

#: ../../../library/uos.rst:272
msgid ""
"The first form writes aligned, multiples of blocks, and requires that the "
"blocks that are written to be first erased (if necessary) by this method. "
"Starting at the block given by the index *block_num*, write blocks from "
"*buf* (an array of bytes) to the device. The number of blocks to write is"
" given by the length of *buf*, which will be a multiple of the block "
"size."
msgstr ""
"最初の形式は、整列した複数のブロックを書き込みます。"
"書き込む前には、対象のブロックが（必要に応じて）消去されます。"
"インデックス *block_num* で指定したブロックに *buf* (バイト列)からブロックを"
"書き込みます。書き込むブロック数は *buf* の長さで与えられ、ブロックサイズの倍数に"
"なります。"

#: ../../../library/uos.rst:279
msgid ""
"The second form allows writing at arbitrary locations within a block, "
"and arbitrary lengths.  Only the bytes being written should be changed, "
"and the caller of this method must ensure that the relevant blocks are "
"erased via a prior ``ioctl`` call. "
"Starting at block index *block_num*, and byte offset within that block "
"of *offset*, write bytes from *buf* (an array of bytes) to the device. "
"The number of bytes to write is given by the length of *buf*."
msgstr ""
"２番目の形式では、ブロック内の任意の場所に、任意の長さで書き込むことができます。"
"書き込むバイトのみを変更する必要があり、このメソッドの呼び出し元は、関連する"
"ブロックが事前の ``ioctl`` 呼び出しによって消去されることを保証する必要があります。"
"ブロックインデックス *block_num* とそのブロック内のバイトオフセット *offset* "
"を開始点として、 *buf* （バイト配列）からデバイスに書き込みます。"
"書き込むバイト数は *buf* の長さで指定されます。"

#: ../../../library/uos.rst:287
msgid ""
"Note that implementations must never implicitly erase blocks if the offset "
"argument is specified, even if it is zero."
msgstr ""
"offset 引数が指定されている場合、たとえゼロであっても、実装がブロックを暗黙的に"
"消去してはならないことに注意してください。"

#: ../../../library/uos.rst:292
msgid ""
"Control the block device and query its parameters.  The operation to "
"perform is given by *op* which is one of the following integers:"
msgstr ""
"ブロックデバイスの制御とパラメータ問い合わせをおこないます。実行する操作は *op* に"
"次の整数のうちの１つで指定します。"

#: ../../../library/uos.rst:295
msgid "1 -- initialise the device (*arg* is unused)"
msgstr "1 -- デバイスを初期化します(*arg* は未使用)"

#: ../../../library/uos.rst:296
msgid "2 -- shutdown the device (*arg* is unused)"
msgstr "2 -- デバイスをシャットダウンします(*arg* は未使用)"

#: ../../../library/uos.rst:297
msgid "3 -- sync the device (*arg* is unused)"
msgstr "3 -- デバイスを同期します(*arg* は未使用)"

#: ../../../library/uos.rst:298
msgid ""
"4 -- get a count of the number of blocks, should return an integer (*arg*"
" is unused)"
msgstr "4 -- ブロック数を取得し、整数で返します(*arg* は未使用)"

#: ../../../library/uos.rst:300
msgid ""
"5 -- get the number of bytes in a block, should return an integer, or "
"``None`` in which case the default value of 512 is used (*arg* is unused)"
msgstr ""
"5 -- ブロック内のバイト数を取得し、整数で返します。 ``None`` の場合はデフォルト値"
"の 512 が使われます(*arg* は未使用)"

#: ../../../library/uos.rst:303
msgid ""
"6 -- erase a block, *arg* is the block number to erase"
msgstr ""
"6 -- ブロックを消去します。 *arg* は消去するブロック数です"

#: ../../library/uos.rst:305
msgid ""
"As a minimum ``ioctl(4, ...)`` must be intercepted; for littlefs "
"``ioctl(6, ...)`` must also be intercepted. The need for others is "
"hardware dependent."
msgstr ""
"少なくとも ``ioctl(4, ...)`` は受け付けられる必要があります。"
"littlefs については ``ioctl(6, ...)`` も受け付けられる必要があります。"
"その他の操作が受け付けられるかはハードウェアに依存します。"

#: ../../library/uos.rst:309
msgid ""
"Unless otherwise stated ``ioctl(op, arg)`` can return ``None``. "
"Consequently an implementation can ignore unused values of ``op``. Where "
"``op`` is intercepted, the return value for operations 4 and 5 are as "
"detailed above. Other operations should return 0 on success and non-zero "
"for failure, with the value returned being an ``OSError`` errno code."
msgstr ""
"特に記載のない限り ``ioctl(op, arg)`` は ``None`` を返します。"
"したがって処理系は ``op`` の未使用値を無視できます。"
"``op`` が受け付けられる場合、操作 4 と 5 の戻り値は上記のとおりです。"
"受け付けられる他の操作の戻り値は、成功した場合は 0 を返し、"
"失敗した場合はゼロ以外を返します。失敗した場合の戻り値は ``OSError`` "
"の errno コードです。"

#: ../../../library/ure.rst:2
msgid ":mod:`ure` -- simple regular expressions"
msgstr ":mod:`ure` -- 簡素な正規表現"

#: ../../../library/ure.rst:7
msgid "|see_cpython_module| :mod:`python:re`."
msgstr ""

#: ../../../library/ure.rst:9
msgid ""
"This module implements regular expression operations. Regular expression "
"syntax supported is a subset of CPython ``re`` module (and actually is a "
"subset of POSIX extended regular expressions)."
msgstr ""
"このモジュールは正規表現操作を実装します。サポートされている正規表現構文は CPython の "
"``re`` モジュールのサブセットです(実際には POSIX 拡張正規表現のサブセットです)。"

#: ../../../library/ure.rst:13
msgid "Supported operators and special sequences are:"
msgstr "サポートされている演算子と特殊シーケンスは次のものです:"

#: ../../../library/ure.rst:16
msgid "``.``"
msgstr ""

#: ../../../library/ure.rst:16
msgid "Match any character."
msgstr "任意の文字にマッチします。"

#: ../../../library/ure.rst:20
msgid "``[...]``"
msgstr ""

#: ../../../library/ure.rst:19
msgid ""
"Match set of characters. Individual characters and ranges are supported, "
"including negated sets (e.g. ``[^a-c]``)."
msgstr ""
"文字セットにマッチします。文字の個別指定と範囲指定をサポートします。文字セットには、"
"なしセット(``[^a-c]`` など)も含みます。"

#: ../../../library/ure.rst:23
msgid "``^``"
msgstr ""

#: ../../../library/ure.rst:23
msgid "Match the start of the string."
msgstr "文字列の先頭にマッチします。"

#: ../../../library/ure.rst:26
msgid "``$``"
msgstr ""

#: ../../../library/ure.rst:26
msgid "Match the end of the string."
msgstr "文字列の最後にマッチします。"

#: ../../../library/ure.rst:29
msgid "``?``"
msgstr ""

#: ../../../library/ure.rst:29
msgid "Match zero or one of the previous sub-pattern."
msgstr "直前のサブパターンの0回または1回の繰り返しにマッチします。"

#: ../../../library/ure.rst:32
msgid "``*``"
msgstr ""

#: ../../../library/ure.rst:32
msgid "Match zero or more of the previous sub-pattern."
msgstr "直前のサブパターンの0回以上の繰り返しにマッチします。"

#: ../../../library/ure.rst:35
msgid "``+``"
msgstr ""

#: ../../../library/ure.rst:35
msgid "Match one or more of the previous sub-pattern."
msgstr "直前のサブパターンの1回以上の繰り返しにマッチします。"

#: ../../../library/ure.rst:37
msgid "``??``"
msgstr ""

#: ../../../library/ure.rst:38
msgid "Non-greedy version of ``?``, match zero or one, with the preference for zero."
msgstr "``?`` の非貧欲版で、直前のサブパターンの0回または1回の繰り返しにマッチしますが、0回が優先されます。"

#: ../../../library/ure.rst:41
msgid "``*?``"
msgstr ""

#: ../../../library/ure.rst:42
msgid "Non-greedy version of ``*``, match zero or more, with the preference for the shortest match."
msgstr ""
"``*`` の非貧欲版で、直前のサブパターンの0回以上の繰り返しにマッチしますが、"
"最短の繰り替えしが優先されます。"

#: ../../../library/ure.rst:45
msgid "``+?``"
msgstr ""

#: ../../../library/ure.rst:46
msgid "Non-greedy version of ``+``, match one or more, with the preference for the shortest match."
msgstr ""
"``+`` の非貧欲版で、直前のサブパターンの1回以上の繰り返しにマッチしますが、"
"最短の繰り替えしが優先されます。"

#: ../../../library/ure.rst:49
msgid "``|``"
msgstr ""

#: ../../../library/ure.rst:50
msgid ""
"Match either the left-hand side or the right-hand side sub-patterns of "
"this operator."
msgstr ""
"この演算子の左辺または右辺のどちらかのサブパターンにマッチします。"

#: ../../../library/ure.rst:53
msgid "``(...)``"
msgstr ""

#: ../../../library/ure.rst:54
msgid ""
"Grouping. Each group is capturing (a substring it captures can be "
"accessed with `match.group()` method)."
msgstr ""
"グループ化。各グループについてキャプチャを行います(キャプチャした部分文字列は "
"`match.group()` メソッドでアクセスできます)。"

#: ../../../library/ure.rst:57
msgid "``\\d``"
msgstr ""

#: ../../../library/ure.rst:58
msgid "Matches digit. Equivalent to ``[0-9]``."
msgstr "数字にマッチします。 ``[0-9]`` と同じです。"

#: ../../../library/ure.rst:60
msgid "``\\D``"
msgstr ""

#: ../../../library/ure.rst:61
msgid "Matches non-digit. Equivalent to ``[^0-9]``."
msgstr "数字以外とマッチします。 ``[^0-9]`` と同じです。"

#: ../../../library/ure.rst:63
msgid "``\\s``"
msgstr ""

#: ../../../library/ure.rst:64
msgid "Matches whitespace. Equivalent to ``[ \\t-\\r]``."
msgstr "空白にマッチします。 ``[ \\t-\\r]`` と同じです。"

#: ../../../library/ure.rst:66
msgid "``\\S``"
msgstr ""

#: ../../../library/ure.rst:67
msgid "Matches non-whitespace. Equivalent to ``[^ \\t-\\r]``."
msgstr "空白以外にマッチします。 ``[^ \\t-\\r]`` と同じです。"

#: ../../../library/ure.rst:69
msgid "``\\w``"
msgstr ""

#: ../../../library/ure.rst:70
msgid ""
"Matches \"word characters\" (ASCII only). Equivalent to ``[A-Za-z0-9_]``."
msgstr ""
"単語文字(ASCII のみ)にマッチします。 ``[A-Za-z0-9_]`` と同じです。"

#: ../../../library/ure.rst:72
msgid "``\\W``"
msgstr ""

#: ../../../library/ure.rst:73
msgid ""
"Matches non \"word characters\" (ASCII only). Equivalent to ``[^A-Za-z0-9_]``."
msgstr ""
"単語文字(ASCII のみ)以外にマッチします。 ``[^A-Za-z0-9_]`` と同じです。"

#: ../../../library/ure.rst:75
msgid "``\\``"
msgstr ""

#: ../../../library/ure.rst:76
msgid ""
"Escape character. Any other character following the backslash, except for "
"those listed above, is taken literally. For example, ``\\*`` is equivalent "
"to literal ``*`` (not treated as the ``*`` operator). Note that ``\\r``, "
"``\\n``, etc. are not handled specially, and will be equivalent to literal "
"letters ``r``, ``n``, etc. Due to this, it's not recommended to use raw "
"Python strings (``r\"\"``) for regular expressions. For example, "
"``r\"\\r\\n\"`` when used as the regular expression is equivalent to "
"``\"rn\"``. To match CR character followed by LF, use ``\"\\r\\n\"``."
msgstr ""
"エスケープ文字です。上にあげたもの以外、バックスラッシュの後に続く文字はすべて"
"文字通りに解釈されます。たとえば ``\\*`` はリテラル ``*`` と同等です(``*`` "
"演算子として扱われません)。なお ``\\r``, ``\\n`` などは特別に処理されず、"
"リテラル文字 ``r``, ``n`` などと等価になります。このため、正規表現に Python "
"のraw文字列(``r\"\"``)を使うことはお勧めしません。たとえば r\"\\r\\n\" を"
"正規表現として使った場合は  ``\"rn\"`` と同じになります。CR LF にマッチ"
"させるには ``\"\\r\\n\"`` を使ってください。"

#: ../../../library/ure.rst:86
msgid "**NOT SUPPORTED**:"
msgstr "**未サポート**:"

#: ../../../library/ure.rst:88
msgid "counted repetitions (``{m,n}``)"
msgstr "反復回数 (``{m,n}``)"

#: ../../../library/ure.rst:89
msgid "named groups (``(?P<name>...)``)"
msgstr "名前付きグループ (``(?P<name>...)``)"

#: ../../../library/ure.rst:90
msgid "non-capturing groups (``(?:...)``)"
msgstr "非キャプチャグループ (``(?:...)``)"

#: ../../../library/ure.rst:91
msgid "more advanced assertions (``\\b``, ``\\B``)"
msgstr "より高度なアサーション (``\\b``, ``\\B``)"

#: ../../../library/ure.rst:92
msgid ""
"special character escapes like ``\\r``, ``\\n`` - use Python's own escaping "
"instead"
msgstr ""
"``\\r``, ``\\n`` などの特殊文字エスケープ - 代わりに Python 自体のエスケープを"
"使ってください。"

#: ../../../library/ure.rst:94
msgid "etc."
msgstr "などなど"

#: ../../../library/ure.rst:96
msgid "Example::"
msgstr "サンプルコード::"

#: ../../../library/ure.rst:98
msgid ""
"import ure\n"
"\n"
"# As ure doesn't support escapes itself, use of r\"\" strings is not\n"
"# recommended.\n"
"regex = ure.compile(\"[\\r\\n]\")\n"
"\n"
"regex.split(\"line1\\rline2\\nline3\\r\\n\")\n"
"\n"
"# Result:\n"
"# ['line1', 'line2', 'line3', '', '']"
msgstr ""
"import ure\n"
"\n"
"# ure はエスケープ自体をサポートしていないので、r\"\" 文字列の利用は\n"
"# お勧めしません。\n"
"regex = ure.compile(\"[\\r\\n]\")\n"
"\n"
"regex.split(\"line1\\rline2\\nline3\\r\\n\")\n"
"\n"
"# Result:\n"
"# ['line1', 'line2', 'line3', '', '']"

#: ../../../library/ure.rst:114
msgid "Compile regular expression, return `regex <regex>` object."
msgstr "正規表現をコンパイルし、 `regex <regex>` オブジェクトを返します。"

#: ../../../library/ure.rst:118
msgid ""
"Compile *regex_str* and match against *string*. Match always happens from"
" starting position in a string."
msgstr ""
"*regex_str* をコンパイルし、文字列 *string* とマッチするか照合します。マッチは常に文字列の"
"先頭位置から行います。"

#: ../../../library/ure.rst:123
msgid ""
"Compile *regex_str* and search it in a *string*. Unlike `match`, this "
"will search string for first position which matches regex (which still "
"may be 0 if regex is anchored)."
msgstr ""
"*regex_str* をコンパイルして文字列 *string* を検索します。 `match` とは異なり、"
"正規表現にマッチする最初の位置の文字列を検索します(正規表現がマッチすれば位置 0 の"
"文字列になることもあります)。"

#: ../../../library/ure.rst:129
msgid ""
"Compile *regex_str* and search for it in *string*, replacing all matches "
"with *replace*, and returning the new string."
msgstr ""
"*regex_str* をコンパイルして文字列 *string* を検索し、マッチしたものすべてを "
"*replace* で置換した新しい文字列を返します。"

#: ../../../library/ure.rst:132
msgid ""
"*replace* can be a string or a function.  If it is a string then escape "
"sequences of the form ``\\<number>`` and ``\\g<number>`` can be used to "
"expand to the corresponding group (or an empty string for unmatched "
"groups). If *replace* is a function then it must take a single argument "
"(the match) and should return a replacement string."
msgstr ""
"*replace* には文字列または関数を指定できます。文字列である場合、エスケープシーケンス "
"``\\<number>`` と ``\\g<number>`` が対応するグループに展開するために使われます"
"(マッチしなかったグループについては空文字列)。 *replace* が関数であれば、その関数は"
"単一の引数(match オブジェクト)をとらなければならず、置換した文字列を返す必要が"
"あります。"

#: ../../../library/ure.rst:138
msgid ""
"If *count* is specified and non-zero then substitution will stop after "
"this many substitutions are made.  The *flags* argument is ignored."
msgstr ""
"*count* に 0 で無い値が指定された場合、置換はこの指定の数に達したところで終わります。 "
"*flags* 引数は無視されます。"

#: ../../../library/ure.rst:141
msgid "Note: availability of this function depends on `MicroPython port`."
msgstr "注記: この関数の可用性は `MicroPython ポート` に依存します。"

#: ../../../library/ure.rst:145
msgid ""
"Flag value, display debug information about compiled expression. "
"(Availability depends on `MicroPython port`.)"
msgstr ""
"コンパイルされた正規表現についてのデバッグ情報を表示するフラグ値。"
"(可用性は `MicroPython ポート` に依存します。)"

#: ../../../library/ure.rst:151
msgid "Regex objects"
msgstr "regex オブジェクト"

#: ../../../library/ure.rst:154
msgid ""
"Compiled regular expression. Instances of this class are created using "
"`ure.compile()`."
msgstr ""
"コンパイルされた正規表現です。このクラスのインスタンスは `ure.compile()` を"
"使っって作成されます。"

#: ../../../library/ure.rst:161
msgid ""
"Similar to the module-level functions :meth:`match`, :meth:`search` and "
":meth:`sub`. Using methods is (much) more efficient if the same regex is "
"applied to multiple strings."
msgstr ""
"モジュールレベルの関数 :meth:`match`, :meth:`search`, :meth:`sub` "
"と同様です。同じ regex が複数の文字列に適用されている場合、このメソッドを使ったほうが"
"(ずっと)より効率的です。"

#: ../../../library/ure.rst:168
msgid ""
"Split a *string* using regex. If *max_split* is given, it specifies "
"maximum number of splits to perform. Returns list of strings (there may "
"be up to *max_split+1* elements if it's specified)."
msgstr ""
"regex を使って *string* を分割します。 *max_split* を与えた場合、それは実行する"
"分割の最大数を指定します。文字列のリストを返します(*max_split* を指定した場合は"
"最大 *max_split+1* の数の文字列を返します)。"

#: ../../../library/ure.rst:172
msgid "Match objects"
msgstr "match オブジェクト"

#: ../../../library/ure.rst:175
msgid ""
"Match objects as returned by `match()` and `search()` methods, and passed"
" to the replacement function in `sub()`."
msgstr ""
"match オブジェクトは `match()` と `search()` メソッドが返し、 `sub()` "
"の置換関数に渡すものです。"

#: ../../../library/ure.rst:180
msgid ""
"Return matching (sub)string. *index* is 0 for entire match, 1 and above "
"for each capturing group. Only numeric groups are supported."
msgstr ""
"マッチした(部分)文字列を返します。 *index* が 0 であればマッチした文字列全体を返し、"
"1 以上であれば指定のグループにマッチした文字列です。数字によるグループ指定だけが"
"サポートされます。"

#: ../../../library/ure.rst:185
msgid "Return a tuple containing all the substrings of the groups of the match."
msgstr "マッチしたグループの部分文字列すべてのタプルを返します。"

#: ../../../library/ure.rst:187 ../../../library/ure.rst:202
msgid "Note: availability of this method depends on `MicroPython port`."
msgstr "注記: この関数の可用性は `MicroPython ポート` に依存します。"

#: ../../../library/ure.rst:192
msgid ""
"Return the index in the original string of the start or end of the "
"substring group that was matched.  *index* defaults to the entire group, "
"otherwise it will select a group."
msgstr ""
"マッチした部分文字列グループの先頭または最後の元文字列中のインデックスを返します。"
"*index* を指定しなければデフォルトでグループ全体になります。それ以外の場合は"
"指定したグループになります。"

#: ../../../library/ure.rst:196
msgid "Note: availability of these methods depends on `MicroPython port`."
msgstr "注記: この関数の可用性は `MicroPython ポート` に依存します。"

#: ../../../library/ure.rst:200
msgid "Returns the 2-tuple ``(match.start(index), match.end(index))``."
msgstr "2項目のタプル ``(match.start(index), match.end(index))`` を返します。"

#: ../../../library/uselect.rst:2
msgid ":mod:`uselect` -- wait for events on a set of streams"
msgstr ":mod:`uselect` -- 一連のストリームのイベント待機"

#: ../../../library/uselect.rst:7
msgid "|see_cpython_module| :mod:`python:select`."
msgstr ""

#: ../../../library/uselect.rst:9
msgid ""
"This module provides functions to efficiently wait for events on multiple"
" `streams <stream>` (select streams which are ready for operations)."
msgstr ""
"このモジュールは、複数の `ストリーム <stream>` (操作の準備ができている select ストリーム)"
"のイベントを効率的に待機する機能を提供します。"

#: ../../../library/uselect.rst:17
msgid "Create an instance of the Poll class."
msgstr "Poll クラスのインスタンスを作成します。"

#: ../../../library/uselect.rst:21
msgid "Wait for activity on a set of objects."
msgstr "一連のオブジェクトに対するアクティビティを待機します。"

#: ../../../library/uselect.rst:23
msgid ""
"This function is provided by some MicroPython ports for compatibility and"
" is not efficient. Usage of :class:`Poll` is recommended instead."
msgstr ""
"この関数は、いくつかの MicroPython ポートで互換性のために提供されており、効率的では"
"ありません。代わりに :class:`Poll` の利用を勧めます。"

#: ../../../library/uselect.rst:29
msgid "class ``Poll``"
msgstr "クラス ``Poll``"

#: ../../../library/uselect.rst:36
msgid "Register `stream` *obj* for polling. *eventmask* is logical OR of:"
msgstr "ポーリングのための `ストリーム <stream>` *obj* を登録します。 *eventmask* は以下の論理和です:"

#: ../../../library/uselect.rst:38
msgid "``uselect.POLLIN``  - data available for reading"
msgstr "``uselect.POLLIN``  - データを読込み可能"

#: ../../../library/uselect.rst:39
msgid "``uselect.POLLOUT`` - more data can be written"
msgstr "``uselect.POLLOUT`` - データを書込み可能"

#: ../../../library/uselect.rst:41
msgid ""
"Note that flags like ``uselect.POLLHUP`` and ``uselect.POLLERR`` are "
"*not* valid as input eventmask (these are unsolicited events which will "
"be returned from `poll()` regardless of whether they are asked for). This"
" semantics is per POSIX."
msgstr ""
"``uselect.POLLHUPPP や ``uselect.POLLERR`` のようなフラグは、"
"入力イベントマスクとして有効ではないことに注意してください"
"(これらは要求したかに関わらず `poll()` から返される迷惑なイベントです)。"
"このセマンティクスは POSIX の仕様からきています。"

#: ../../../library/uselect.rst:46
msgid "*eventmask* defaults to ``uselect.POLLIN | uselect.POLLOUT``."
msgstr "*eventmask* のデフォルトは ``uselect.POLLIN | uselect.POLLOUT`` です。"

#: ../../../library/uselect.rst:48
msgid ""
"It is OK to call this function multiple times for the same *obj*. "
"Successive calls will update *obj*'s eventmask to the value of "
"*eventmask* (i.e. will behave as `modify()`)."
msgstr ""
"同じ *obj* に対してこの関数を複数回呼び出しても大丈夫です。"
"連続の呼出しは *obj* のイベントマスクを "*eventmask* の値に更新します"
"(すなわち `modify()` として動作します)。"

#: ../../../library/uselect.rst:54
msgid "Unregister *obj* from polling."
msgstr "*obj* をポーリングから登録解除します。"

#: ../../../library/uselect.rst:58
msgid ""
"Modify the *eventmask* for *obj*. If *obj* is not registered, `OSError` "
"is raised with error of ENOENT."
msgstr ""
"*obj* のイベントマスクを変更します。 *obj* が登録されていない場合は "
"ENOENT のエラーで `OSError` を発生させます。"

#: ../../../library/uselect.rst:63
msgid ""
"Wait for at least one of the registered objects to become ready or have "
"an exceptional condition, with optional timeout in milliseconds (if "
"*timeout* arg is not specified or -1, there is no timeout)."
msgstr ""
"登録済のオブジェクトの少なくとも１つが準備完了になるのを、オプションのタイムアウト値"
"(ミリ秒単位)まで待ちます。 タイムアウト値 *timeout* 引数が指定されていない場合、"
"または -1 を指定した場合はタイムアウトなしとなります。"

#: ../../../library/uselect.rst:67
msgid ""
"Returns list of (``obj``, ``event``, ...) tuples. There may be other "
"elements in tuple, depending on a platform and version, so don't assume "
"that its size is 2. The ``event`` element specifies which events happened"
" with a stream and is a combination of ``uselect.POLL*`` constants "
"described above. Note that flags ``uselect.POLLHUP`` and "
"``uselect.POLLERR`` can be returned at any time (even if were not asked "
"for), and must be acted on accordingly (the corresponding stream "
"unregistered from poll and likely closed), because otherwise all further "
"invocations of `poll()` may return immediately with these flags set for "
"this stream again."
msgstr ""
"戻り値はタプル (``obj``, ``event``, ...) のリストです。プラットフォームや"
"バージョンによってはタプルに他の要素もある可能性がありますので、サイズが 2 であると"
"仮定しないでください。項目 ``event`` はストリームで発生したイベントを表し、 "
"``uselect.POLL*`` 上で説明した定数の組み合わせです。フラグ ``uselect.POLLHUP`` "
"と ``uselect.POLLERR`` はいつでも(要求しなくても)返される可能性があるので、"
"それに応じて振る舞う必要があります(該当ストリームは登録解除されていて、おそらく"
"クローズしています)。なぜなら `poll()` のそれ以降のすべての呼び出しは、この"
"ストリームに設定したこれらのフラグで直ちに返されるからです。"

#: ../../../library/uselect.rst:77
msgid "In case of timeout, an empty list is returned."
msgstr "タイムアウトの場合、空リストが返されます。"

#: ../../../library/uselect.rst:82
msgid "Tuples returned may contain more than 2 elements as described above."
msgstr "返されるタプルは、上記のように２つ以上の要素を含むことがあります。"

#: ../../../library/uselect.rst:86
msgid ""
"Like :meth:`poll.poll`, but instead returns an iterator which yields a "
"`callee-owned tuple`. This function provides an efficient, allocation-"
"free way to poll on streams."
msgstr ""
":meth:`poll.poll` と同様ですが、代わりに「呼出し先所有タプル」をもたらす"
"イテレータを返します。この関数は、ストリームをポーリングするのにの効率的で、"
"メモリ割当てのない手段を提供します。"

#: ../../../library/uselect.rst:90
msgid ""
"If *flags* is 1, one-shot behavior for events is employed: streams for "
"which events happened will have their event masks automatically reset "
"(equivalent to ``poll.modify(obj, 0)``), so new events for such a stream "
"won't be processed until new mask is set with `poll.modify()`. This "
"behavior is useful for asynchronous I/O schedulers."
msgstr ""
"*flags* が 1 の場合、イベントのワンショット動作が採用されます。イベントが発生した"
"ストリームは、イベントマスクが自動的にリセットされるので(``poll.modify(obj, 0)`` "
"と同等)、新しいマスクが設定されるまで、そのストリームの新しいイベントは処理されません。"
"この動作は、非同期 I/O スケジューラに役立ちます。"

#: ../../../library/uselect.rst:99
msgid "This function is a MicroPython extension."
msgstr "この関数は MicroPython の拡張機能です。"

#: ../../../library/usocket.rst:3
msgid ":mod:`usocket` -- socket module"
msgstr ":mod:`usocket` -- ソケットモジュール"

#: ../../../library/usocket.rst:8
msgid "|see_cpython_module| :mod:`python:socket`."
msgstr ""

#: ../../../library/usocket.rst:10
msgid "This module provides access to the BSD socket interface."
msgstr "このモジュールは BSD ソケットインタフェースへのアクセスを提供します。"

#: ../../../library/usocket.rst:15
msgid ""
"For efficiency and consistency, socket objects in MicroPython implement a"
" `stream` (file-like) interface directly. In CPython, you need to convert"
" a socket to a file-like object using `makefile()` method. This method is"
" still supported by MicroPython (but is a no-op), so where compatibility "
"with CPython matters, be sure to use it."
msgstr ""
"効率性と一貫性のために、MicroPython のソケットオブジェクトは `stream` (ファイルライク)"
"インタフェースを直接実装します。CPythonでは `makefile()` メソッドを使ってソケットを"
"ファイルライクなオブジェクトに変換する必要があります。この方法は MicroPython でも"
"サポートされています(ただし何もしません)ので、CPython との互換性が重要な場合は必ず使って"
"ください。"

#: ../../../library/usocket.rst:22
msgid "Socket address format(s)"
msgstr "ソケットアドレスフォーマット"

#: ../../../library/usocket.rst:24
msgid ""
"The native socket address format of the ``usocket`` module is an opaque "
"data type returned by `getaddrinfo` function, which must be used to "
"resolve textual address (including numeric addresses)::"
msgstr ""
"``usocket`` モジュールのネイティブなソケットアドレスフォーマットは `getaddrinfo` "
"関数によって返される不透明なデータ型です。`getaddrinfo` は、テキストアドレス"
"(数値アドレスを含む)を解決するために使う必要があります。"

#: ../../../library/usocket.rst:28
msgid ""
"sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1]\n"
"# You must use getaddrinfo() even for numeric addresses\n"
"sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1]\n"
"# Now you can use that address\n"
"sock.connect(addr)"
msgstr ""
"sockaddr = usocket.getaddrinfo('www.micropython.org', 80)[0][-1]\n"
"# 数値アドレスでも getaddrinfo() を使う必要があります\n"
"sockaddr = usocket.getaddrinfo('127.0.0.1', 80)[0][-1]\n"
"# これでアドレスを使えるようになります\n"
"sock.connect(addr)"

#: ../../../library/usocket.rst:34
msgid ""
"Using `getaddrinfo` is the most efficient (both in terms of memory and "
"processing power) and portable way to work with addresses."
msgstr ""
"`getaddrinfo` を使うことは(メモリと処理能力の両方の点で)最も効率的で、アドレスを"
"扱うための移植性のある手段です。"

#: ../../../library/usocket.rst:37
msgid ""
"However, ``socket`` module (note the difference with native MicroPython "
"``usocket`` module described here) provides CPython-compatible way to "
"specify addresses using tuples, as described below. Note that depending "
"on a `MicroPython port`, ``socket`` module can be builtin or need to be "
"installed from `micropython-lib` (as in the case of `MicroPython Unix "
"port`), and some ports still accept only numeric addresses in the tuple "
"format, and require to use `getaddrinfo` function to resolve domain "
"names."
msgstr ""
"ただし ``socket`` モジュール(ここで説明しているネイティブ MicroPython の "
"``usocket`` との違いに注意)は後述するように、タプルを使ってアドレスを指定する "
"CPython 互換の手段を提供します。 ``socket`` モジュールは組み込み済であるか、"
"(`MicroPython Unix port` の場合のように) `micropython-lib` からインストール"
"が必要で、ポートによってはタプルフォーマットの数値アドレスのみしか受け付けられず、"
"ドメイン名を解決するために `getaddrinfo` 関数を使う必要があります。"

#: ../../../library/usocket.rst:45
msgid "Summing up:"
msgstr "まとめると:"

#: ../../../library/usocket.rst:47
msgid "Always use `getaddrinfo` when writing portable applications."
msgstr "移植性のあるアプリケーションを書くには `getaddrinfo` を必ず使ってください。"

#: ../../../library/usocket.rst:48
msgid ""
"Tuple addresses described below can be used as a shortcut for quick hacks"
" and interactive use, if your port supports them."
msgstr ""
"後述するタプルアドレスは、それがサポートされているなら、クイックハックや対話的な利用の"
"ためのショートカットとして使えます。"

#: ../../../library/usocket.rst:51
msgid "Tuple address format for ``socket`` module:"
msgstr "``socket`` モジュールのタプルアドレスフォーマット"

#: ../../../library/usocket.rst:53
msgid ""
"IPv4: *(ipv4_address, port)*, where *ipv4_address* is a string with dot-"
"notation numeric IPv4 address, e.g. ``\"8.8.8.8\"``, and *port* is and "
"integer port number in the range 1-65535. Note the domain names are not "
"accepted as *ipv4_address*, they should be resolved first using "
"`usocket.getaddrinfo()`."
msgstr ""
"IPv4: *(ipv4_address, port)* -- *ipv4_address* はドット表記の数値の IPv4 "
"アドレスを持つ文字列で、たとえば ``\"8.8.8.8\"`` などです。 *port* は 1〜65535 "
"の範囲の整数のポート番号です。ドメイン名は *ipv4_address* として受け入れられないので、"
"`usocket.getaddrinfo()` を使って事前に解決しておくよう注意してください。"

#: ../../../library/usocket.rst:58
msgid ""
"IPv6: *(ipv6_address, port, flowinfo, scopeid)*, where *ipv6_address* is "
"a string with colon-notation numeric IPv6 address, e.g. "
"``\"2001:db8::1\"``, and *port* is an integer port number in the range "
"1-65535. *flowinfo* must be 0. *scopeid* is the interface scope "
"identifier for link-local addresses. Note the domain names are not "
"accepted as *ipv6_address*, they should be resolved first using "
"`usocket.getaddrinfo()`. Availability of IPv6 support depends on a "
"`MicroPython port`."
msgstr ""
"IPv6: *(ipv6_address, port, flowinfo, scopeid)* -- *ipv6_address* はコロン"
"表記の数値の IPv6 アドレスを持ち文字列で、たとえば ``\"2001:db8::1["`` などです。 "
"*port* は 1〜65535 の範囲の整数のポート番号です。 *flowinfo* は 0 にする必要が"
"あります。 *scopeid* はリンクローカルアドレスのインターフェイススコープ ID です。"
"ドメイン名は *ipv6_address* として受け入れられないので、 `usocket.getaddrinfo()` "
"を使って事前に解決しておくよう注意してください。IPv6 サポートの可用性は "
"`MicroPython port` に依存します。"

#: ../../../library/usocket.rst:71
msgid ""
"Create a new socket using the given address family, socket type and "
"protocol number. Note that specifying *proto* in most cases is not "
"required (and not recommended, as some MicroPython ports may omit "
"``IPPROTO_*`` constants). Instead, *type* argument will select needed "
"protocol automatically::"
msgstr ""
"指定したアドレスファミリ、ソケットタイプ、プロトコル番号を使って新しいソケットを"
"作成します。ほとんどの場合 *proto* を指定する必要はありません(MicroPython の"
"一部のポートでは ``IPPROTO_*`` 定数が省略されている場合があるため、指定はお勧め"
"しません)。代わりに *type* 引数が必要なプロトコルを自動的に選択します。"

#: ../../../library/usocket.rst:77
msgid ""
"# Create STREAM TCP socket\n"
"socket(AF_INET, SOCK_STREAM)\n"
"# Create DGRAM UDP socket\n"
"socket(AF_INET, SOCK_DGRAM)"
msgstr ""
"# STREAM TCP ソケットを作成\n"
"socket(AF_INET, SOCK_STREAM)\n"
"# DGRAM UDP ソケットを作成\n"
"socket(AF_INET, SOCK_DGRAM)"

#: ../../../library/usocket.rst:84
msgid ""
"Translate the host/port argument into a sequence of 5-tuples that contain"
" all the necessary arguments for creating a socket connected to that "
"service. Arguments *af*, *type*, and *proto* (which have the same meaning"
" as for the `socket()` function) can be used to filter which kind of "
"addresses are returned. If a parameter is not specified or zero, all "
"combinations of addresses can be returned (requiring filtering on the "
"user side)."
msgstr ""
"host/port 引数を、そのサービスに接続されたソケットを作成するために必要となるすべての"
"引数を含む一連の５項目のタプルに変換します。引数 *af*, *type*, *proto* (これらは "
"Psocket()` 関数の場合と同じ意味を持つ)を使って、返されるアドレスの種類をフィルタ処理"
"できます。パラメータが指定されていないかゼロの場合、アドレスのすべての組み合わせを返す"
"ことができます(利用者側でのフィルタリングが必要です)。"

#: ../../../library/usocket.rst:91
msgid "The resulting list of 5-tuples has the following structure::"
msgstr "結果として得られる５項目のタプルは次のの構造を持ちます::"

#: ../../../library/usocket.rst:93
msgid "(family, type, proto, canonname, sockaddr)"
msgstr ""

#: ../../../library/usocket.rst:95
msgid "The following example shows how to connect to a given url::"
msgstr "次の例は特定の URL に接続する方法を示しています::"

#: ../../../library/usocket.rst:97
msgid ""
"s = usocket.socket()\n"
"# This assumes that if \"type\" is not specified, an address for\n"
"# SOCK_STREAM will be returned, which may be not true\n"
"s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1])"
msgstr ""
"s = usocket.socket()\n"
"# これは \"type\" が指定されていない場合、SOCK_STREAM のアドレスが返される\n"
"# ことを前提としています。これは正しくない可能性があります\n"
"s.connect(usocket.getaddrinfo('www.micropython.org', 80)[0][-1])"

#: ../../../library/usocket.rst:102
msgid "Recommended use of filtering params::"
msgstr "フィルタリングパラメータの推奨の使用法は次のとおりです::"

#: ../../../library/usocket.rst:104
msgid ""
"s = usocket.socket()\n"
"# Guaranteed to return an address which can be connect'ed to for\n"
"# stream operation.\n"
"s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, "
"SOCK_STREAM)[0][-1])"
msgstr ""
"s = usocket.socket()\n"
"# ストリーム操作のために接続できるアドレスを返すことが保証されています。\n"
"s.connect(usocket.getaddrinfo('www.micropython.org', 80, 0, "
"SOCK_STREAM)[0][-1])"

#: ../../../library/usocket.rst:112
msgid ""
"CPython raises a ``socket.gaierror`` exception (`OSError` subclass) in "
"case of error in this function. MicroPython doesn't have "
"``socket.gaierror`` and raises OSError directly. Note that error numbers "
"of `getaddrinfo()` form a separate namespace and may not match error "
"numbers from the :mod:`uerrno` module. To distinguish `getaddrinfo()` "
"errors, they are represented by negative numbers, whereas standard system"
" errors are positive numbers (error numbers are accessible using "
"``e.args[0]`` property from an exception object). The use of negative "
"values is a provisional detail which may change in the future."
msgstr ""
"この関数でエラーが発生した場合、CPython は ``socket.gaierror`` 例外(`OSError` "
"のサブクラス)を発生させます。MicroPython には ``socket.gaierror`` がなく、 "
"OSError を直接発生させます。 `getaddrinfo()` のエラー番号は別の名前空間を形成し"
"ていて、 :mod:`uerrno` モジュールのエラー番号と一致しない場合があることに注意して"
"ください。 `getaddrinfo()` のエラーは負の数で表され、正の数である標準のシステムエラーと"
"区別できます(エラー番号には例外オブジェクトの ``e.args[0]`` プロパティを使って"
"アクセスできます)。負の値の使用は暫定的な処置であり、将来変更される可能性があります。"

#: ../../../library/usocket.rst:124
msgid ""
"Convert a binary network address *bin_addr* of the given address family "
"*af* to a textual representation::"
msgstr ""
"指定したアドレスファミリ *af* のバイナリ形式ネットワークアドレス *bin_addr* "
"をテキスト表現に変換します。"

#: ../../../library/usocket.rst:127
msgid ""
">>> usocket.inet_ntop(usocket.AF_INET, b\"\\x7f\\0\\0\\1\")\n"
"'127.0.0.1'"
msgstr ""

#: ../../../library/usocket.rst:132
msgid ""
"Convert a textual network address *txt_addr* of the given address family "
"*af* to a binary representation::"
msgstr ""
"指定したアドレスファミリ *af* のテキスト形式のネットワークアドレス *txt_addr* "
"をバイナリ表現に変換します。"

#: ../../../library/usocket.rst:135
msgid ""
">>> usocket.inet_pton(usocket.AF_INET, \"1.2.3.4\")\n"
"b'\\x01\\x02\\x03\\x04'"
msgstr ""

#: ../../../library/usocket.rst:144
msgid ""
"Address family types. Availability depends on a particular `MicroPython "
"port`."
msgstr ""
"アドレスファミリタイプ。可用性は特定の `MicroPython port` に依存します。"

#: ../../../library/usocket.rst:149
msgid "Socket types."
msgstr "ソケットタイプ。"

#: ../../../library/usocket.rst:154
msgid ""
"IP protocol numbers. Availability depends on a particular `MicroPython "
"port`. Note that you don't need to specify these in a call to "
"`usocket.socket()`, because `SOCK_STREAM` socket type automatically "
"selects `IPPROTO_TCP`, and `SOCK_DGRAM` - `IPPROTO_UDP`. Thus, the only "
"real use of these constants is as an argument to `setsockopt()`."
msgstr ""
"IP プロトコル番号。可用性は特定の `MicroPython port` に依存します。"
"`usocket.socket()` の呼び出しに指定する必要がないことに注意してください。"
"なぜなら `SOCK_STREAM` では　`IPPROTO_TCP` 、 `SOCK_DGRAM` では `IPPROTO_UDP` "
"のソケットタイプが自動的に選択されるからです。したがって、これらの定数の唯一の実際に"
"使うのは `setsockopt()` の引数としてです。"

#: ../../../library/usocket.rst:162
msgid ""
"Socket option levels (an argument to `setsockopt()`). The exact inventory"
" depends on a `MicroPython port`."
msgstr ""
"ソケットオプションレベル(`setsockopt()` の引数)。何があるかは `MicroPython port` "
"に依存します。"

#: ../../../library/usocket.rst:167
msgid ""
"Socket options (an argument to `setsockopt()`). The exact inventory "
"depends on a `MicroPython port`."
msgstr ""
"ソケットオプション(`setsockopt()` の引数)。何があるかは `MicroPython port` "
"に依存します。"

#: ../../../library/usocket.rst:170
msgid "Constants specific to WiPy:"
msgstr "WiPy に固有の定数:"

#: ../../../library/usocket.rst:174
msgid "Special protocol value to create SSL-compatible socket."
msgstr "SSL 互換ソケットを作成するための特別なプロトコル値。"

#: ../../../library/usocket.rst:177
msgid "class socket"
msgstr "クラス socket"

#: ../../../library/usocket.rst:184
msgid ""
"Mark the socket closed and release all resources. Once that happens, all "
"future operations on the socket object will fail. The remote end will "
"receive EOF indication if supported by protocol."
msgstr ""
"ソケットを閉じられたものとしてマークし、すべてのリソースを解放します。これを呼び出すと、"
"このソケットオブジェクトに対する操作はすべて失敗します。プロトコルでサポートされている場合、"
"リモート側の端点は EOF 通知を受け取ります。"

#: ../../../library/usocket.rst:188
msgid ""
"Sockets are automatically closed when they are garbage-collected, but it "
"is recommended to `close()` them explicitly as soon you finished working "
"with them."
msgstr ""
"ソケットはガベージコレクション時に自動的にクローズされますが、作業を終えたらすぐに "
"close() を明示的に呼び出すことを勧めます。"

#: ../../../library/usocket.rst:193
msgid "Bind the socket to *address*. The socket must not already be bound."
msgstr "ソケットをアドレス *address* にバインドします。バインド済みのソケットを再バインドする事はできません。"

#: ../../../library/usocket.rst:197
msgid ""
"Enable a server to accept connections. If *backlog* is specified, it must"
" be at least 0 (if it's lower, it will be set to 0); and specifies the "
"number of unaccepted connections that the system will allow before "
"refusing new connections. If not specified, a default reasonable value is"
" chosen."
msgstr ""
"サーバーが接続を受け付けるようにします。バックログ *backlog* が指定されている場合、"
"少なくとも 0 以上でなければなりません(それより低い場合 0 に設定されます)。"
"バックログは、システムが新しい接続を拒否するまでに許可する未受付の接続の数を指定します。"
"指定しない場合、デフォルトの妥当な値が選択されます。"

#: ../../../library/usocket.rst:204
msgid ""
"Accept a connection. The socket must be bound to an address and listening"
" for connections. The return value is a pair (conn, address) where conn "
"is a new socket object usable to send and receive data on the connection,"
" and address is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"接続を受け入れます。ソケットはアドレスにバインド済みで、接続を待機(listen)している"
"必要があります。戻り値は (conn, address) のペアです。conn は接続を通じてデータの"
"送受信を行うための新しいソケットオブジェクト、address は接続先でソケットにバインド"
"しているアドレスです。"

#: ../../../library/usocket.rst:211
msgid "Connect to a remote socket at *address*."
msgstr "アドレス *address* でリモートソケットに接続します。"

#: ../../../library/usocket.rst:215
msgid ""
"Send data to the socket. The socket must be connected to a remote socket."
" Returns number of bytes sent, which may be smaller than the length of "
"data (\"short write\")."
msgstr ""
"ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなければなりません。"
"戻り値として、送信したバイト数を返します。これはデータの長さより短い場合があります"
"(「短い書き込み」")。"

#: ../../../library/usocket.rst:221
msgid ""
"Send all data to the socket. The socket must be connected to a remote "
"socket. Unlike `send()`, this method will try to send all of data, by "
"sending data chunk by chunk consecutively."
msgstr ""
"ソケットにすべてのデータを送信します。ソケットはリモートソケットに接続済みでなければ"
"なりません。 `send()` と異なり、このメソッドはデータをチャンク単位で連続して送信する"
"ことによって、すべてのデータを送信しようとします。"

#: ../../../library/usocket.rst:225
msgid ""
"The behavior of this method on non-blocking sockets is undefined. Due to "
"this, on MicroPython, it's recommended to use `write()` method instead, "
"which has the same \"no short writes\" policy for blocking sockets, and "
"will return number of bytes sent on non-blocking sockets."
msgstr ""
"非ブロッキングソケットでのこのメソッドの動作は未定義です。このため MicroPython では、"
"代わりに `write()` の利用を勧めます。これは、ブロッキングソケットと同じ「短い書き込み禁止」"
"ポリシーを持ち、非ブロッキングソケットで送信されたバイト数を返します。"

#: ../../../library/usocket.rst:232
msgid ""
"Receive data from the socket. The return value is a bytes object "
"representing the data received. The maximum amount of data to be received"
" at once is specified by bufsize."
msgstr ""
"ソケットからデータを受信します。戻り値は受信したデータを表すバイト列オブジェクトです。"
"一度に受信するデータの最大量は *bufsize* で指定します。"

#: ../../../library/usocket.rst:237
msgid ""
"Send data to the socket. The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*."
msgstr ""
"ソケットにデータを送信します。このメソッドでは接続先を *address* で指定するので、"
"ソケットがリモートソケットに接続済みではいけません。"

#: ../../../library/usocket.rst:242
msgid ""
"Receive data from the socket. The return value is a pair *(bytes, "
"address)* where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data."
msgstr ""
"ソケットからデータを受信します。戻り値は *(bytes, address)* のペアです。 "
"*bytes* は受信データを表すバイト列オブジェクトで、 *address* はデータを送信する"
"ソケットのアドレスです。"

#: ../../../library/usocket.rst:248
msgid ""
"Set the value of the given socket option. The needed symbolic constants "
"are defined in the socket module (SO_* etc.). The *value* can be an "
"integer or a bytes-like object representing a buffer."
msgstr ""
"指定されたソケットオプションの値を設定します。必要なシンボリック定数は、socket "
"モジュール(SO_* など)で定義されています。 *value* は整数、None、またはバッファを表す"
"バイト列ライクなオブジェクトのいずれかです。"

#: ../../../library/usocket.rst:254
msgid "**Note**: Not every port supports this method, see below."
msgstr "**注記注**: すべてのポートがこのメソッドをサポートしているわけではありません。下記を参照してください。"

#: ../../../library/usocket.rst:256
msgid ""
"Set a timeout on blocking socket operations. The value argument can be a "
"nonnegative floating point number expressing seconds, or None. If a non-"
"zero value is given, subsequent socket operations will raise an `OSError`"
" exception if the timeout period value has elapsed before the operation "
"has completed. If zero is given, the socket is put in non-blocking mode. "
"If None is given, the socket is put in blocking mode."
msgstr ""
"ブロッキングソケットの操作のタイムアウト値を指定します。 *value* 引数には負でない"
"浮動小数点数値で表した秒数を指定するか、None を指定します。ゼロ以外の値を指定した場合、"
"ソケット操作が完了する前にタイムアウト期間が経過した場合、 `OSError` 例外が発生します。"
"ゼロを指定した場合、ソケットは非ブロッキングモードになります。None を指定した場合、"
"ソケットはブロックモードになります。"

#: ../../../library/usocket.rst:262
msgid ""
"Not every `MicroPython port` supports this method. A more portable and "
"generic solution is to use `uselect.poll` object. This allows to wait on "
"multiple objects at the same time (and not just on sockets, but on "
"generic `stream` objects which support polling). Example::"
msgstr ""
"すべての `MicroPython ポート <MicroPython port>` がこのメソッドをサポートして"
"いるわけではありません。よりポータブルで汎用的な解決策は `uselect.poll` オブジェクト"
"を使うことです。これにより、複数のオブジェクトを同時に待機することができます(ソケット"
"だけでなく、ポーリングをサポートする汎用の `stream` オブジェクトも対象になります)。"
"たとえば次のように使います::"

#: ../../../library/usocket.rst:267
msgid ""
"# Instead of:\n"
"s.settimeout(1.0)  # time in seconds\n"
"s.read(10)  # may timeout\n"
"\n"
"# Use:\n"
"poller = uselect.poll()\n"
"poller.register(s, uselect.POLLIN)\n"
"res = poller.poll(1000)  # time in milliseconds\n"
"if not res:\n"
"    # s is still not ready for input, i.e. operation timed out"
msgstr ""
"# settimeout を使う場合:\n"
"s.settimeout(1.0)  # タイムアウトを秒数で指定\n"
"s.read(10)  # タイムアウトが発生する可能性あり\n"
"\n"
"# 代わりの使用例:\n"
"poller = uselect.poll()\n"
"poller.register(s, uselect.POLLIN)\n"
"res = poller.poll(1000)  # タイムアウトをミリ秒で指定\n"
"if not res:\n"
"    # s から入力されなくなったということは、操作がタイムアウトしている"

#: ../../../library/usocket.rst:281
msgid ""
"CPython raises a ``socket.timeout`` exception in case of timeout, which "
"is an `OSError` subclass. MicroPython raises an OSError directly instead."
" If you use ``except OSError:`` to catch the exception, your code will "
"work both in MicroPython and CPython."
msgstr ""
"CPython はタイムアウトの場合に ``socket.timeout`` 例外を発生させます。この例外は "
"`OSError` のサブクラスです。MicroPython は代わりに OSError を直接発生させます。"
"例外を捕らえるのに ``except OSError:`` を使えば、コードは MicroPython と "
"CPython の両方で動作します。

#: ../../../library/usocket.rst:288
msgid ""
"Set blocking or non-blocking mode of the socket: if flag is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"ソケットをブロッキングモード、または非ブロッキングモードに設定します。flag が False "
"の場合にはソケットは非ブロッキングモードになり、True の場合にはブロッキングモードになります。"

#: ../../../library/usocket.rst:291
msgid "This method is a shorthand for certain `settimeout()` calls:"
msgstr "このメソッドは、次の settimeout() 呼び出しの省略形です:"

#: ../../../library/usocket.rst:293
msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` は ``sock.settimeout(None)`` と等価です"

#: ../../../library/usocket.rst:294
msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0)``"
msgstr "``sock.setblocking(False)`` は ``sock.settimeout(0.0)`` と等価です"

#: ../../../library/usocket.rst:298
msgid ""
"Return a file object associated with the socket. The exact returned type "
"depends on the arguments given to makefile(). The support is limited to "
"binary modes only ('rb', 'wb', and 'rwb'). CPython's arguments: "
"*encoding*, *errors* and *newline* are not supported."
msgstr ""
"ソケットに関連したファイルオブジェクトを返します。戻り値の正確な型は makefile（）"
"に指定した引数によります。サポートはバイナリモード('rb', 'wb', 'rwb')のみに限定"
"されています。CPython の引数: "*encoding*, *errors* and *newline* はサポート"
"されていません。"

#: ../../../library/usocket.rst:305
msgid ""
"As MicroPython doesn't support buffered streams, values of *buffering* "
"parameter is ignored and treated as if it was 0 (unbuffered)."
msgstr ""
"MicroPython はバッファ付きストリームをサポートしていないため、 *buffering* "
"パラメータの値は無視され、0 (バッファなし)のように扱われます。"

#: ../../../library/usocket.rst:311
msgid ""
"Closing the file object returned by makefile() WILL close the original "
"socket as well."
msgstr ""
"makefile() から返されたファイルオブジェクトを閉じると、元のソケットも閉じられます。"

#: ../../../library/usocket.rst:316
msgid ""
"Read up to size bytes from the socket. Return a bytes object. If *size* "
"is not given, it reads all data available from the socket until EOF; as "
"such the method will not return until the socket is closed. This function"
" tries to read as much data as requested (no \"short reads\"). This may "
"be not possible with non-blocking socket though, and then less data will "
"be returned."
msgstr ""
"ソケットから size バイトまで読み込みます。戻り値はバイト列オブジェクトです。 *size* "
"が与えられていない場合、EOF までソケットから利用可能なすべてのデータを読み込みます。"
"そのため、 *size* を指定しないメソッド呼出しはソケットが閉じられるまで戻りません。"
"この関数は要求された量のデータを読み込もうとします(「短い読み込み」ではありません)。"
"ただし、これはノンブロッキングソケットでは不可能なことがあり、そのような場合は返される"
"データが少なくなります。"

#: ../../../library/usocket.rst:324
msgid ""
"Read bytes into the *buf*.  If *nbytes* is specified then read at most "
"that many bytes.  Otherwise, read at most *len(buf)* bytes. Just as "
"`read()`, this method follows \"no short reads\" policy."
msgstr ""
"バイト列を *buf* に読み込みます。 *nbytes* が指定されている場合は、最大でそのバイト数"
"だけ読み込みます。 *nbytes* が指定されない場合は、最大で *len(buf)* バイトを読み込み"
"ます。 `read()` と同様に、このメソッドは「短い読み込みなし」ポリシーにしたがいます。"

#: ../../../library/usocket.rst:328
msgid "Return value: number of bytes read and stored into *buf*."
msgstr "戻り値: *buf* に読み込んで格納されたバイト数。"

#: ../../../library/usocket.rst:332
msgid "Read a line, ending in a newline character."
msgstr "改行文字で終わる行を読みます。"

#: ../../../library/usocket.rst:334
msgid "Return value: the line read."
msgstr "戻り値: 読み込んだ行。"

#: ../../../library/usocket.rst:338
msgid ""
"Write the buffer of bytes to the socket. This function will try to write "
"all data to a socket (no \"short writes\"). This may be not possible with"
" a non-blocking socket though, and returned value will be less than the "
"length of *buf*."
msgstr ""
"ソケットにバイト列のバッファを書き込みます。この関数は、すべてのデータをソケットに"
"書き込もうとします(「短い書き込み」なし)。ただし、これはノンブロッキングソケットでは"
"不可能なことがあり、そのような場合は戻り値が *buf* の長さより短くなります。"

#: ../../../library/usocket.rst:343
msgid "Return value: number of bytes written."
msgstr "戻り値: 書き込んだバイト数"

#: ../../../library/usocket.rst:347
msgid "MicroPython does NOT have this exception."
msgstr "MicroPython にはこの例外がありません。"

#: ../../../library/usocket.rst:352
msgid ""
"CPython used to have a ``socket.error`` exception which is now "
"deprecated, and is an alias of `OSError`. In MicroPython, use `OSError` "
"directly."
msgstr ""
"CPython には ``socket.error`` がありますが廃止予定であり、 `OSError` の別名と"
"なっています。MicroPython では `OSError` を直接使ってください。"

#: ../../../library/ussl.rst:2
msgid ":mod:`ussl` -- SSL/TLS module"
msgstr ":mod:`ussl` -- SSL/TLS モジュール"

#: ../../../library/ussl.rst:7
msgid "|see_cpython_module| :mod:`python:ssl`."
msgstr ""

#: ../../../library/ussl.rst:9
msgid ""
"This module provides access to Transport Layer Security (previously and "
"widely known as “Secure Sockets Layer”) encryption and peer "
"authentication facilities for network sockets, both client-side and "
"server-side."
msgstr ""
"このモジュールは Transport Layer Security (以前は “Secure Sockets Layer” と"
"と呼ばれていて、今でもこの名称で呼ばれることが多々あります)による暗号化と"
"クライアント側とサーバー側のネットワークソケットのピア認証機能へのアクセスを提供"
"します。"

#: ../../../library/ussl.rst:18
msgid ""
"Takes a `stream` *sock* (usually usocket.socket instance of "
"``SOCK_STREAM`` type), and returns an instance of ssl.SSLSocket, which "
"wraps the underlying stream in an SSL context. Returned object has the "
"usual `stream` interface methods like ``read()``, ``write()``, etc. In "
"MicroPython, the returned object does not expose socket interface and "
"methods like ``recv()``, ``send()``. In particular, a server-side SSL "
"socket should be created from a normal socket returned from "
":meth:`~usocket.socket.accept()` on a non-SSL listening server socket."
msgstr ""
"`stream` *sock* (通常は ``SOCK_STREAM`` タイプの usocket.socket インスタンス)を"
"引数としてとり、SSL コンテキストで基本となるストリームをラップした ssl.SSLSocket "
"インスタンスを返します。返されるオブジェクトには ``read()``, ``write()`` のような"
"通常の `stream` インスタンスのインタフェースメソッドをがあります。MicroPython "
"において、返されたオブジェクトは ``recv()``, ``send()`` のようなソケットインタフェースや"
"メソッドを公開していません。特に、サーバー側の SSL ソケットは、非 SSL リスニングサーバー"
"ソケットの :meth:`~usocket.socket.accept()` から返される通常のソケットから作成する"
"必要があります。"

#: ../../../library/ussl.rst:26
msgid ""
"Depending on the underlying module implementation in a particular "
"`MicroPython port`, some or all keyword arguments above may be not "
"supported."
msgstr ""
"特定の `MicroPython ポート` のモジュールの実装によっては、 上記のキーワード"
"引数の一部またはすべてがサポートされていない可能性があります。"

#: ../../../library/ussl.rst:31
msgid ""
"Some implementations of ``ussl`` module do NOT validate server "
"certificates, which makes an SSL connection established prone to man-in-"
"the-middle attacks."
msgstr ""
"``ussl`` モジュールの実装によってはサーバー証明書の検証が行われないため、"
"中間者攻撃を受けやすい SSL 接続になってしまいます。"

#: ../../../library/ussl.rst:39
msgid "This exception does NOT exist. Instead its base class, OSError, is used."
msgstr ""
"この例外は存在しません。代わりにベースクラスの OSError が使われます。"

#: ../../../library/ussl.rst:48
msgid "Supported values for *cert_reqs* parameter."
msgstr "*cert_reqs* パラメーターでサポートされる値です。"

#: ../../../library/ustruct.rst:2
msgid ":mod:`ustruct` -- pack and unpack primitive data types"
msgstr ":mod:`ustruct` -- 基本データ型のパックとアンパック"

#: ../../../library/ustruct.rst:7
msgid "|see_cpython_module| :mod:`python:struct`."
msgstr ""

#: ../../../library/ustruct.rst:9
msgid "Supported size/byte order prefixes: ``@``, ``<``, ``>``, ``!``."
msgstr "サポートするサイズ/バイト順プレフィックス: ``@``, ``<``, ``>``, ``!``."

#: ../../../library/ustruct.rst:11
msgid ""
"Supported format codes: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``, "
"``L``, ``q``, ``Q``, ``s``, ``P``, ``f``, ``d`` (the latter 2 depending "
"on the floating-point support)."
msgstr ""
"サポートする書式コード: ``b``, ``B``, ``h``, ``H``, ``i``, ``I``, ``l``, "
"``L``, ``q``, ``Q``, ``s``, ``P``, ``f``, ``d`` (最後の２つは浮動小数点の"
"サポートに依存)。"

#: ../../../library/ustruct.rst:20
msgid "Return the number of bytes needed to store the given *fmt*."
msgstr "指定した *fmt* で格納するために必要なバイト数を返します。"

#: ../../../library/ustruct.rst:24
msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *fmt*. The"
" return value is a bytes object encoding the values."
msgstr ""
"フォーマット文字列 *fmt* にしたがって、値 *v1*、*v2*、... をパックします。戻り値は、"
"値をエンコードしたバイト列オブジェクトです。"

#: ../../../library/ustruct.rst:29
msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *fmt* into"
" a *buffer* starting at *offset*. *offset* may be negative to count from "
"the end of *buffer*."
msgstr ""
"フォーマット文字列 *fmt* にしたがって、値 *v1*、*v2*、... をパックし、バッファ "
"*buffer* の開始オフセット *offset* に格納します。 *offset* が負の場合は *buffer* "
"の最後からのオフセットになります。"

#: ../../../library/ustruct.rst:35
msgid ""
"Unpack from the *data* according to the format string *fmt*. The return "
"value is a tuple of the unpacked values."
msgstr ""
"フォーマット文字列 *fmt* にしたがって *data* からアンパックします。"
"戻り値はアンパックした値のタプルです。"

#: ../../../library/ustruct.rst:40
msgid ""
"Unpack from the *data* starting at *offset* according to the format "
"string *fmt*. *offset* may be negative to count from the end of *buffer*."
" The return value is a tuple of the unpacked values."
msgstr ""
"フォーマット文字列 *fmt* にしたがって "*data* の開始オフセット *offset* から"
"アンパックします。 *offset* が負の場合は *buffer* の最後からのオフセットになります。"
"戻り値はアンパックした値のタプルです。"

#: ../../../library/utime.rst:2
msgid ":mod:`utime` -- time related functions"
msgstr ":mod:`utime` -- 時間関連の関数"

#: ../../../library/utime.rst:7
msgid "|see_cpython_module| :mod:`python:time`."
msgstr ""

#: ../../../library/utime.rst:9
msgid ""
"The ``utime`` module provides functions for getting the current time and "
"date, measuring time intervals, and for delays."
msgstr ""
"この ``utime`` モジュールには、現在の日時の取得、時間隔の測定、遅延の機能があります。"

#: ../../../library/utime.rst:12
msgid ""
"**Time Epoch**: Unix port uses standard for POSIX systems epoch of "
"1970-01-01 00:00:00 UTC. However, embedded ports use epoch of 2000-01-01 "
"00:00:00 UTC."
msgstr ""
"エポックタイム: Unix ポートは、1970年1月1日 00:00:00 UTC の POSIX システム"
"エポックの標準を使います。ただし、組込み機器へのポートは、2000年1月1日 00:00:00 UTC "
"のエポックを使います。"

#: ../../../library/utime.rst:16
msgid ""
"**Maintaining actual calendar date/time**: This requires a Real Time "
"Clock (RTC). On systems with underlying OS (including some RTOS), an RTC "
"may be implicit. Setting and maintaining actual calendar time is "
"responsibility of OS/RTOS and is done outside of MicroPython, it just "
"uses OS API to query date/time. On baremetal ports however system time "
"depends on ``machine.RTC()`` object. The current calendar time may be set"
" using ``machine.RTC().datetime(tuple)`` function, and maintained by "
"following means:"
msgstr ""
"**実際のカレンダーの日付/時間の維持**: これにはリアルタイムクロック(RTC: Real "
"Time Clock)が必要です。基盤 OS (一部の RTOS も含む)を持つシステムでは、RTC "
"が暗黙的に存在することが前提となっています。実際のカレンダー時間の設定と維持は、"
"OS/RTOS の責務であり、MicroPython の外部で行われ、日時/時間を照会するために "
"OS の API を使うだけです。しかし、ベアメタルポートでは、システム時間は "
"``machine.RTC()`` オブジェクトに依存します。現在のカレンダー時間は "
"``machine.RTC().datetime(tuple)`` 関数を使って設定し、以下の手段によって維持"
"されます。"

#: ../../../library/utime.rst:25
msgid ""
"By a backup battery (which may be an additional, optional component for a"
" particular board)."
msgstr ""
"バックアップバッテリ(特定のボード用の追加オプションコンポーネントとして用意されている"
"こともあります)。"

#: ../../../library/utime.rst:27
msgid "Using networked time protocol (requires setup by a port/user)."
msgstr "NTP (Networked Time Protocol)を利用(ポート/ユーザーによる設定が必須)。"

#: ../../../library/utime.rst:28
msgid ""
"Set manually by a user on each power-up (many boards then maintain RTC "
"time across hard resets, though some may require setting it again in such"
" case)."
msgstr ""
"各電源投入時にユーザが手動で設定(多くのボードはハードリセット時に RTC 時間を設定"
"しますが、再度設定する必要があるボードもあります)。"

#: ../../../library/utime.rst:32
msgid ""
"If actual calendar time is not maintained with a system/MicroPython RTC, "
"functions below which require reference to current absolute time may "
"behave not as expected."
msgstr ""
"実際のカレンダー時間が システム/MicroPython RTC で維持されていない場合、現在の"
"絶対時間を参照する必要がある関数は、期待どおりに動作しない可能性があります。"

#: ../../../library/utime.rst:41
msgid ""
"Convert a time expressed in seconds since the Epoch (see above) into an "
"8-tuple which contains: (year, month, mday, hour, minute, second, "
"weekday, yearday) If secs is not provided or None, then the current time "
"from the RTC is used."
msgstr ""
"エポックからの秒数で表される時間を８項目のタプル (year, month, mday, hour, "
"minute, second, weekday, yearday) に変換します。秒数 *secs* を与えないか "
"None である場合、RTC の現在時間が使われます。"

#: ../../../library/utime.rst:45
msgid "year includes the century (for example 2014)."
msgstr "year: 西暦の年(たとえば 2014)"

#: ../../../library/utime.rst:46
msgid "month   is 1-12"
msgstr "month: 月を表す 1-12"

#: ../../../library/utime.rst:47
msgid "mday    is 1-31"
msgstr "mday: 日を表す 1-31"

#: ../../../library/utime.rst:48
msgid "hour    is 0-23"
msgstr "hour: 時を表す 0-23"

#: ../../../library/utime.rst:49
msgid "minute  is 0-59"
msgstr "minute: 分を表す 0-59"

#: ../../../library/utime.rst:50
msgid "second  is 0-59"
msgstr "second: 秒を表す 0-59"

#: ../../../library/utime.rst:51
msgid "weekday is 0-6 for Mon-Sun"
msgstr "weekday: 月曜-日曜を表す 0-6"

#: ../../../library/utime.rst:52
msgid "yearday is 1-366"
msgstr "yearday: 年内の通算日数を表す 1-366"

#: ../../../library/utime.rst:56
msgid ""
"This is inverse function of localtime. It's argument is a full 8-tuple "
"which expresses a time as per localtime. It returns an integer which is "
"the number of seconds since Jan 1, 2000."
msgstr ""
"これは localtime の逆関数です。引数は、ローカルタイムの時間を表現する完全な"
"８項目のタプルです。この関数は2000年1月1日以降の秒数を整数で返します。"

#: ../../../library/utime.rst:62
msgid ""
"Sleep for the given number of seconds. Some boards may accept *seconds* "
"as a floating-point number to sleep for a fractional number of seconds. "
"Note that other boards may not accept a floating-point argument, for "
"compatibility with them use `sleep_ms()` and `sleep_us()` functions."
msgstr ""
"指定された秒数の間スリープします。ボードによっては秒以下の精度でスリープするために、"
"浮動小数点数で秒を指定できるものがあります。他のボードでは、`sleep_ms()` や "
"`sleep_us()` 関数との整合性のために、浮動小数点の引数を受け付けないことに注意"
"してください。"

#: ../../../library/utime.rst:69
msgid "Delay for given number of milliseconds, should be positive or 0."
msgstr "指定のミリ秒間だけ遅延します。ミリ秒の指定は0以上の整数である必要があります。"

#: ../../../library/utime.rst:73
msgid "Delay for given number of microseconds, should be positive or 0."
msgstr "指定のマイクロ秒間だけ遅延します。マイクロ秒の指定は0以上の整数である必要があります。"

#: ../../../library/utime.rst:77
msgid ""
"Returns an increasing millisecond counter with an arbitrary reference "
"point, that wraps around after some value."
msgstr ""
"呼出し時点での稼働時間をミリ秒単位で返します。稼働時間は最大値に達すると"
"ラップアラウンドします(一周して最低値に戻ります)。"

#: ../../../library/utime.rst:80
msgid ""
"The wrap-around value is not explicitly exposed, but we will refer to it "
"as *TICKS_MAX* to simplify discussion. Period of the values is "
"*TICKS_PERIOD = TICKS_MAX + 1*. *TICKS_PERIOD* is guaranteed to be a "
"power of two, but otherwise may differ from port to port. The same period"
" value is used for all of `ticks_ms()`, `ticks_us()`, `ticks_cpu()` "
"functions (for simplicity). Thus, these functions will return a value in "
"range [*0* .. *TICKS_MAX*], inclusive, total *TICKS_PERIOD* values. Note "
"that only non-negative values are used. For the most part, you should "
"treat values returned by these functions as opaque. The only operations "
"available for them are `ticks_diff()` and `ticks_add()` functions "
"described below."
msgstr ""
"ラップアラウンド値は陽に公開されませんが、説明を簡略化するために "
"*TICKS_MAX* と呼ぶことにします。値の期間は *TICKS_PERIOD = TICKS_MAX + 1* "
"です。 *TICKS_PERIOD* は2の累乗であることが保証されていますが、"
"それ以外の場合はポートごとに異なる場合があります。同じ期間の値が "
"`ticks_ms()`, `ticks_us()`, `ticks_cpu()` 関数のすべてで(簡略化のために)"
"使われます。したがって、これらの関数は、範囲 [*0* .. *TICKS_MAX* ] 内の値"
"(合計 *TICKS_PERIOD* の数だけの値)を返します。負でない値だけが使われることに"
"注意してください。ほとんどの場合、これらの関数によって返された値はを不透明なもの"
"として扱う必要があります。利用できる操作は後述するように `ticks_diff()` と "
"`ticks_add()` 関数です。"

#: ../../../library/utime.rst:91
msgid ""
"Note: Performing standard mathematical operations (+, -) or relational "
"operators (<, <=, >, >=) directly on these value will lead to invalid "
"result. Performing mathematical operations and then passing their results"
" as arguments to `ticks_diff()` or `ticks_add()` will also lead to "
"invalid results from the latter functions."
msgstr ""
"注記: 標準的な数値演算子(+,  -)または関係演算子(<, <=, >, >=)をこれらの値に"
"直接実行すると無効な結果になります。数値演算を実行し、その結果を引数として "
"`ticks_diff()` か `ticks_add()` に渡すと無効な結果につながります。"

#: ../../../library/utime.rst:99
msgid "Just like `ticks_ms()` above, but in microseconds."
msgstr "上記の `ticks_ms()` と同様ですが、マイクロ秒単位となります。"

#: ../../../library/utime.rst:103
msgid ""
"Similar to `ticks_ms()` and `ticks_us()`, but with the highest possible "
"resolution in the system. This is usually CPU clocks, and that's why the "
"function is named that way. But it doesn't have to be a CPU clock, some "
"other timing source available in a system (e.g. high-resolution timer) "
"can be used instead. The exact timing unit (resolution) of this function "
"is not specified on ``utime`` module level, but documentation for a "
"specific port may provide more specific information. This function is "
"intended for very fine benchmarking or very tight real-time loops. Avoid "
"using it in portable code."
msgstr ""
"`ticks_ms()` や `ticks_us()` に似ていますが、システムの可能な限り高い精度でとなります。"
"これは通常 CPU クロックです。そのため、このような名前が付けられています。しかし、"
"CPU クロックである必要はなく、代わりにシステム内で使用可能な他のタイミングソース(たとえば、"
"高分解能タイマー)を使用することもできます。この機能の正確なタイミング単位(精度)は、 "
"``utime`` モジュールレベルでは指定されていませんが、特定のポートのドキュメントによって、"
"より具体的な情報が提供される場合があります。この関数は、非常に細かいベンチマークや非常に"
"タイトなリアルタイムループで使うことを目的としています。ポータブルコードでの使用は避けてください。"

#: ../../../library/utime.rst:112
msgid "Availability: Not every port implements this function."
msgstr "可用性: すべてのポートがこの機能を実装しているわけではありません。"

#: ../../../library/utime.rst:117
msgid ""
"Offset ticks value by a given number, which can be either positive or "
"negative. Given a *ticks* value, this function allows to calculate ticks "
"value *delta* ticks before or after it, following modular-arithmetic "
"definition of tick values (see `ticks_ms()` above). *ticks* parameter "
"must be a direct result of call to `ticks_ms()`, `ticks_us()`, or "
"`ticks_cpu()` functions (or from previous call to `ticks_add()`). "
"However, *delta* can be an arbitrary integer number or numeric "
"expression. `ticks_add()` is useful for calculating deadlines for "
"events/tasks. (Note: you must use `ticks_diff()` function to work with "
"deadlines.)"
msgstr ""
"与えた数をティック値からのオフセットとして加算した値を返します。引数の値は正でも負でも"
"かまいません。この関数は、ティック値のモジュール算術定義(上記の `ticks_ms()` "
"を参照)にしたがい、与えた *ticks* 値とその前後の *delta* ティックからティック値を"
"算出します。 *ticks* パラメータには `ticks_ms()`, `ticks_us()`, `ticks_cpu()` "
"を呼出した直の結果(または `ticks_add()` を前に呼出したの結果)を与えなければ"
"なりません。ただし *delta* は任意の整数または数値式にすることができます。"
"`ticks_add()` はイベント/タスクのデッドラインを算出するのに便利です。"
"(注記: デッドラインを扱うには `ticks_diff()` を使う必要があります。)"

#: ../../../library/utime.rst:127
msgid "Examples::"
msgstr "サンプルコード::"

#: ../../../library/utime.rst:129
msgid ""
"# Find out what ticks value there was 100ms ago\n"
"print(ticks_add(time.ticks_ms(), -100))\n"
"\n"
"# Calculate deadline for operation and test for it\n"
"deadline = ticks_add(time.ticks_ms(), 200)\n"
"while ticks_diff(deadline, time.ticks_ms()) > 0:\n"
"    do_a_little_of_something()\n"
"\n"
"# Find out TICKS_MAX used by this port\n"
"print(ticks_add(0, -1))"
msgstr ""
"# 100ms 前のティック値を調べます\n"
"print(ticks_add(time.ticks_ms(), -100))\n"
"\n"
"# 操作やテストのためのデッドラインを算出します\n"
"deadline = ticks_add(time.ticks_ms(), 200)\n"
"while ticks_diff(deadline, time.ticks_ms()) > 0:\n"
"    do_a_little_of_something()\n"
"\n"
"# このポートの TICKS_MAX を調べます\n"
"print(ticks_add(0, -1))"

#: ../../../library/utime.rst:143
msgid ""
"Measure ticks difference between values returned from `ticks_ms()`, "
"`ticks_us()`, or `ticks_cpu()` functions, as a signed value which may "
"wrap around."
msgstr ""
"`ticks_ms()`, `ticks_us()`, `ticks_cpu()` 関数の戻り値(ラップアラウンド"
"である可能性のある符号付きの値)の間のティック値の差を計算します。"

#: ../../../library/utime.rst:146
msgid ""
"The argument order is the same as for subtraction operator, "
"``ticks_diff(ticks1, ticks2)`` has the same meaning as ``ticks1 - "
"ticks2``. However, values returned by `ticks_ms()`, etc. functions may "
"wrap around, so directly using subtraction on them will produce incorrect"
" result. That is why `ticks_diff()` is needed, it implements modular (or "
"more specifically, ring) arithmetics to produce correct result even for "
"wrap-around values (as long as they not too distant inbetween, see "
"below). The function returns **signed** value in the range "
"[*-TICKS_PERIOD/2* .. *TICKS_PERIOD/2-1*] (that's a typical range "
"definition for two's-complement signed binary integers). If the result is"
" negative, it means that *ticks1* occurred earlier in time than *ticks2*."
" Otherwise, it means that *ticks1* occurred after *ticks2*. This holds "
"**only** if *ticks1* and *ticks2* are apart from each other for no more "
"than *TICKS_PERIOD/2-1* ticks. If that does not hold, incorrect result "
"will be returned. Specifically, if two tick values are apart for "
"*TICKS_PERIOD/2-1* ticks, that value will be returned by the function. "
"However, if *TICKS_PERIOD/2* of real-time ticks has passed between them, "
"the function will return *-TICKS_PERIOD/2* instead, i.e. result value "
"will wrap around to the negative range of possible values."
msgstr ""
"引数の順序は減算演算子と同じで、 ``ticks_diff(ticks1, ticks2)``  は "
"``ticks1 - ticks2`` と同じ意味を持ちます。しかし、 `ticks_ms()` などの関数が"
"返す値はラップアラウンドになるえるので、減算演算子を使うと不正な結果になるかもしれません。"
"そのため `ticks_diff()` が用意されています。この関数を使えばラップアラウンド値で"
"あっても正しい結果を生み出すために合同(より具体的には剰余環)算術を実装しています"
"(２つの値が離れすぎていない限りという条件がつきます: 下記参照)。"
"この関数は [*-TICKS_PERIOD/2 .. TICKS_PERIOD/2-1*] の範囲(2の補数の"
"符号付き2進整数の典型的な範囲定義です)の **符号付きの** 値を返します。"
"結果が負の場合は *ticks1* が *ticks2* より早く発生したことを意味します。"
"さもなければ、 *ticks1* が *ticks2* の後に発生したことを意味し ます。"
"これは *ticks1* と *ticks2* が *TICKS_PERIOD/2-1* ティック以下で"
"互いに離れている場合にのみ維持されます。それが維持されない場合、不正確な"
"結果が返されます。特に、2つのティック値が *TICKS_PERIOD/2-1* "
"ティックだけ離れている場合、その値が関数によって返されます。しかし、リアルタイム"
"ティック *TICKS_PERIOD/2* になると、関数は代わりに *-TICKS_PERIOD/2* "
"を返します。つまり、結果値は可能な値の負の範囲にラップアラウンドします。"

#: ../../../library/utime.rst:164
msgid ""
"Informal rationale of the constraints above: Suppose you are locked in a "
"room with no means to monitor passing of time except a standard 12-notch "
"clock. Then if you look at dial-plate now, and don't look again for "
"another 13 hours (e.g., if you fall for a long sleep), then once you "
"finally look again, it may seem to you that only 1 hour has passed. To "
"avoid this mistake, just look at the clock regularly. Your application "
"should do the same. \"Too long sleep\" metaphor also maps directly to "
"application behavior: don't let your application run any single task for "
"too long. Run tasks in steps, and do time-keeping inbetween."
msgstr ""
"上記の制約の形式的でない理論的根拠: 部屋に閉じ込められていて、普通の１２時間式の時計"
"以外に時間の経過を調べる手段がないとします。ある時刻をチェックした後、１３時間経過する"
"まで再度の時刻チェックをしていなかったとします(たとえば、長い眠りに陥っていたなど)。"
"そこで時刻をチェックすると、1時間しか経過していないように見えるでしょう。この間違いを"
"避けるためには、定期的に時計をチェックする必要があります。アプリケーションでも同じことを"
"する必要があります。「長すぎる睡眠」のメタファーは、アプリケーションの振る舞いに直接あて"
"はまります。アプリケーションが単一のタスクを長時間実行しないようにしてください。"
"ステップ単位にタスクを実行し、ステップの間で時間を計測するようにしてください。"

#: ../../../library/utime.rst:173
msgid ""
"`ticks_diff()` is designed to accommodate various usage patterns, among "
"them:"
msgstr ""
"`ticks_diff()` は、さまざまな使用パターンに対応するように設計されています:"

#: ../../../library/utime.rst:175
msgid ""
"Polling with timeout. In this case, the order of events is known, and you"
" will deal only with positive results of `ticks_diff()`::"
msgstr ""
"タイムアウトのポーリング - この場合、イベントの順序は既知であり、次のように "
"`ticks_diff()` の正の結果のみを処理します::"

#: ../../../library/utime.rst:178
msgid ""
"# Wait for GPIO pin to be asserted, but at most 500us\n"
"start = time.ticks_us()\n"
"while pin.value() == 0:\n"
"    if time.ticks_diff(time.ticks_us(), start) > 500:\n"
"        raise TimeoutError"
msgstr ""
"# GPIOピンから入力があるのを待つが、最大でも50usまで\n"
"start = time.ticks_us()\n"
"while pin.value() == 0:\n"
"    if time.ticks_diff(time.ticks_us(), start) > 500:\n"
"        raise TimeoutError"

#: ../../../library/utime.rst:184
msgid ""
"Scheduling events. In this case, `ticks_diff()` result may be negative if"
" an event is overdue::"
msgstr ""
"イベントのスケジューリング - この場合、イベントが期限切れになると `ticks_diff()` "
"の結果が負になります::"

#: ../../../library/utime.rst:187
msgid ""
"# This code snippet is not optimized\n"
"now = time.ticks_ms()\n"
"scheduled_time = task.scheduled_time()\n"
"if ticks_diff(scheduled_time, now) > 0:\n"
"    print(\"Too early, let's nap\")\n"
"    sleep_ms(ticks_diff(scheduled_time, now))\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) == 0:\n"
"    print(\"Right at time!\")\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) < 0:\n"
"    print(\"Oops, running late, tell task to run faster!\")\n"
"    task.run(run_faster=true)"
msgstr ""
"# このコードは最適化されていません\n"
"now = time.ticks_ms()\n"
"scheduled_time = task.scheduled_time()\n"
"if ticks_diff(scheduled_time, now) > 0:\n"
"    print(\"Too early, let's nap\")\n"
"    sleep_ms(ticks_diff(scheduled_time, now))\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) == 0:\n"
"    print(\"Right at time!\")\n"
"    task.run()\n"
"elif ticks_diff(scheduled_time, now) < 0:\n"
"    print(\"Oops, running late, tell task to run faster!\")\n"
"    task.run(run_faster=true)"

#: ../../../library/utime.rst:201
msgid ""
"Note: Do not pass `time()` values to `ticks_diff()`, you should use "
"normal mathematical operations on them. But note that `time()` may (and "
"will) also overflow. This is known as "
"https://en.wikipedia.org/wiki/Year_2038_problem ."
msgstr ""
"注記: `ticks_diff()` には `time()` の値を渡さないでください。 `time()` の値に"
"ついては、通常の算術演算を使用する必要があります。ただし、 `time()` もオーバーフロー"
"する可能性はあります。"
"これは `2038年問題 <https://ja.wikipedia.org/wiki/2038%E5%B9%B4%E5%95%8F%E9%A1%8C>`_ "
"として知られています。"

#: ../../../library/utime.rst:208
msgid ""
"Returns the number of seconds, as an integer, since the Epoch, assuming "
"that underlying RTC is set and maintained as described above. If an RTC "
"is not set, this function returns number of seconds since a port-specific"
" reference point in time (for embedded boards without a battery-backed "
"RTC, usually since power up or reset). If you want to develop portable "
"MicroPython application, you should not rely on this function to provide "
"higher than second precision. If you need higher precision, use "
"`ticks_ms()` and `ticks_us()` functions, if you need calendar time, "
"`localtime()` without an argument is a better choice."
msgstr ""
"上記のように基礎となる RTC が設定され、維持されていると仮定して、エポック以降の秒数を"
"整数で返します。RTC が設定されていない場合、この関数はポート固有の参照ポイントからの"
"秒数を返します(バッテリバックアップされた RTC のない組込みボードの場合、通常は"
"電源投入またはリセット以降の値となります）。移植性のある MicroPython アプリケーション"
"を開発したい場合は、この関数を使用して秒より高い精度の値を提供するべきではありません。"
"より高い精度が必要なのであれば、 `ticks_ms()` や `ticks_us()` の関数を使ってください。"
"カレンダー時間が必要な場合は  `localtime()` を引数なしで呼び出すのがよいでしょう。"

#: ../../../library/utime.rst:220
msgid ""
"In CPython, this function returns number of seconds since Unix epoch, "
"1970-01-01 00:00 UTC, as a floating-point, usually having microsecond "
"precision. With MicroPython, only Unix port uses the same Epoch, and if "
"floating-point precision allows, returns sub-second precision. Embedded "
"hardware usually doesn't have floating-point precision to represent both "
"long time ranges and subsecond precision, so they use integer value with "
"second precision. Some embedded hardware also lacks battery-powered RTC, "
"so returns number of seconds since last power-up or from other relative, "
"hardware-specific point (e.g. reset)."
msgstr ""
"CPythonでは、この関数は Unix エポック 1970-01-01 00:00 UTC からの秒数を"
"浮動小数点として返します。通常はマイクロ秒の精度を持ちます。MicroPython では "
"Unix ポートだけが同じエポックを使い、浮動小数点精度が許せば秒未満の精度で返します。"
"組込みハードウェアは、通常、長い時間範囲と1秒未満の精度の両方を表現するための"
"浮動小数点精度を持たないため、秒精度で整数値を使用します。一部の組込みハードウェアには"
"バッテリ駆動の RTC がないため、最後の電源投入から、または他の相対的なハードウェア固有の"
"ポイント(リセットなど)からの秒数が返されます。"

#: ../../../library/uzlib.rst:2
msgid ":mod:`uzlib` -- zlib decompression"
msgstr ":mod:`uzlib` -- zlib 展開"

#: ../../../library/uzlib.rst:7
msgid "|see_cpython_module| :mod:`python:zlib`."
msgstr ""

#: ../../../library/uzlib.rst:9
msgid ""
"This module allows to decompress binary data compressed with `DEFLATE "
"algorithm <https://en.wikipedia.org/wiki/DEFLATE>`_ (commonly used in "
"zlib library and gzip archiver). Compression is not yet implemented."
msgstr ""
"このモジュールは `DEFLATE アルゴリズム <https://ja.wikipedia.org/wiki/Deflate>`_ "
"(一般に zlib ライブラリや gzip で使われている)で圧縮されたバイナリデータを展開することを"
"可能にします。圧縮はまだ実装されていません。"

#: ../../../library/uzlib.rst:19
msgid ""
"Return decompressed *data* as bytes. *wbits* is DEFLATE dictionary window"
" size used during compression (8-15, the dictionary size is power of 2 of"
" that value). Additionally, if value is positive, *data* is assumed to be"
" zlib stream (with zlib header). Otherwise, if it's negative, it's "
"assumed to be raw DEFLATE stream. *bufsize* parameter is for "
"compatibility with CPython and is ignored."
msgstr ""
"展開した *data* をバイト列で返します。 *wbits* は圧縮中に使用される DEFLATE 辞書"
"ウィンドウのサイズです(8-15、辞書サイズはその値の2のべき乗です)。さらに、値が正の場合、 "
"*data* は zlib ストリーム(zlib ヘッダー付き)であると見なされます。値が負の場合は"
"生の DEFLATE ストリームであるとみなされます。 *bufsize* パラメータは CPython との"
"互換性のためのものであり、無視されます。"

#: ../../../library/uzlib.rst:28
msgid ""
"Create a `stream` wrapper which allows transparent decompression of "
"compressed data in another *stream*. This allows to process compressed "
"streams with data larger than available heap size. In addition to values "
"described in :func:`decompress`, *wbits* may take values 24..31 (16 + "
"8..15), meaning that input stream has gzip header."
msgstr ""
"圧縮されたデータの透過的な展開を別の *stream* でできるようにする `stream` ラッパーを"
"作成します。これにより、利用可能なヒープサイズよりも大きいデータで圧縮ストリームを処理"
"できます。 :func:`decompress` で説明されている値に加えて、 *wbits* は値 24..31 "
"(16 + 8..15) を取ることができ、これは入力ストリームが gzip ヘッダを持っていることを"
"意味します。"

#: ../../../library/uzlib.rst:37
msgid ""
"This class is MicroPython extension. It's included on provisional basis "
"and may be changed considerably or removed in later versions."
msgstr ""
"この関数は MicroPython の拡張です。これは暫定的に入れられているもので、かなり変更"
"される可能性がありますし、後のバージョンでは削除されるかもしれません。"

#: ../../../library/wipy.rst:3
msgid ":mod:`wipy` -- WiPy specific features"
msgstr ""

#: ../../../library/wipy.rst:8
msgid ""
"The ``wipy`` module contains functions to control specific features of "
"the WiPy, such as the heartbeat LED."
msgstr ""

#: ../../../library/wipy.rst:16
msgid ""
"Get or set the state (enabled or disabled) of the heartbeat LED. Accepts "
"and returns boolean values (``True`` or ``False``)."
msgstr ""

