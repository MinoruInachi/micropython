# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014-2019, Damien P. George, Paul Sokolovsky, and contributors
# contributors
# This file is distributed under the same license as the MicroPython
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MicroPython 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-26 09:54+0900\n"
"PO-Revision-Date: 2020-04-04 18:26+0900\n"
"Last-Translator: Minoru Inachi\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../../reference/asm_thumb2_arith.rst:2
msgid "Arithmetic instructions"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:5
#: ../../../reference/asm_thumb2_compare.rst:9
#: ../../../reference/asm_thumb2_float.rst:17
#: ../../../reference/asm_thumb2_index.rst:18
#: ../../../reference/asm_thumb2_label_branch.rst:16
#: ../../../reference/asm_thumb2_ldr.rst:5
#: ../../../reference/asm_thumb2_logical_bit.rst:5
#: ../../../reference/asm_thumb2_mov.rst:5
#: ../../../reference/asm_thumb2_stack.rst:5
#: ../../../reference/asm_thumb2_str.rst:5
msgid "Document conventions"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:7
msgid ""
"Notation: ``Rd, Rm, Rn`` denote ARM registers R0-R7. ``immN`` denotes an "
"immediate value having a width of N bits e.g. ``imm8``, ``imm3``. "
"``carry`` denotes the carry condition flag, ``not(carry)`` denotes its "
"complement. In the case of instructions with more than one register "
"argument, it is permissible for some to be identical. For example the "
"following will add the contents of R0 to itself, placing the result in "
"R0:"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:13
msgid "add(r0, r0, r0)"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:15
msgid "Arithmetic instructions affect the condition flags except where stated."
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:18
msgid "Addition"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:20
msgid "add(Rdn, imm8) ``Rdn = Rdn + imm8``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:21
msgid "add(Rd, Rn, imm3) ``Rd = Rn + imm3``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:22
msgid "add(Rd, Rn, Rm) ``Rd = Rn +Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:23
msgid "adc(Rd, Rn) ``Rd = Rd + Rn + carry``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:26
msgid "Subtraction"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:28
msgid "sub(Rdn, imm8) ``Rdn = Rdn - imm8``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:29
msgid "sub(Rd, Rn, imm3) ``Rd = Rn - imm3``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:30
msgid "sub(Rd, Rn, Rm) ``Rd = Rn - Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:31
msgid "sbc(Rd, Rn) ``Rd = Rd - Rn - not(carry)``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:34
msgid "Negation"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:36
msgid "neg(Rd, Rn) ``Rd = -Rn``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:39
msgid "Multiplication and division"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:41
msgid "mul(Rd, Rn) ``Rd = Rd * Rn``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:43
msgid ""
"This produces a 32 bit result with overflow lost. The result may be "
"treated as signed or unsigned according to the definition of the "
"operands."
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:46
msgid "sdiv(Rd, Rn, Rm) ``Rd = Rn / Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:47
msgid "udiv(Rd, Rn, Rm) ``Rd = Rn / Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_arith.rst:49
msgid ""
"These functions perform signed and unsigned division respectively. "
"Condition flags are not affected."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:2
#: ../../../reference/asm_thumb2_compare.rst:49
msgid "Comparison instructions"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:4
msgid ""
"These perform an arithmetic or logical instruction on two arguments, "
"discarding the result but setting the condition flags. Typically these "
"are used to test data values without changing them prior to executing a "
"conditional branch."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:11
msgid ""
"Notation: ``Rd, Rm, Rn`` denote ARM registers R0-R7. ``imm8`` denotes an "
"immediate value having a width of 8 bits."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:15
msgid "The Application Program Status Register (APSR)"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:17
msgid ""
"This contains four bits which are tested by the conditional branch "
"instructions. Typically a conditional branch will test multiple bits, for"
" example ``bge(LABEL)``. The meaning of condition codes can depend on "
"whether the operands of an arithmetic instruction are viewed as signed or"
" unsigned integers. Thus ``bhi(LABEL)`` assumes unsigned numbers were "
"processed while ``bgt(LABEL)`` assumes signed operands."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:24
msgid "APSR Bits"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:26
msgid "Z (zero)"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:28
msgid ""
"This is set if the result of an operation is zero or the operands of a "
"comparison are equal."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:30
msgid "N (negative)"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:32
msgid "Set if the result is negative."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:34
msgid "C (carry)"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:36
msgid ""
"An addition sets the carry flag when the result overflows out of the MSB,"
" for example adding 0x80000000 and 0x80000000. By the nature of two's "
"complement arithmetic this behaviour is reversed on subtraction, with a "
"borrow indicated by the carry bit being clear. Thus 0x10 - 0x01 is "
"executed as 0x10 + 0xffffffff which will set the carry bit."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:41
msgid "V (overflow)"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:43
msgid ""
"The overflow flag is set if the result, viewed as a two's compliment "
"number, has the \"wrong\" sign in relation to the operands. For example "
"adding 1 to 0x7fffffff will set the overflow bit because the result "
"(0x8000000), viewed as a two's complement integer, is negative. Note that"
" in this instance the carry bit is not set."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:51
msgid ""
"These set the APSR (Application Program Status Register) N (negative), Z "
"(zero), C (carry) and V (overflow) flags."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:54
msgid "cmp(Rn, imm8) ``Rn - imm8``"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:55
msgid "cmp(Rn, Rm) ``Rn - Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:56
msgid "cmn(Rn, Rm) ``Rn + Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:57
msgid "tst(Rn, Rm) ``Rn & Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:60
msgid "Conditional execution"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:62
msgid ""
"The ``it`` and ``ite`` instructions provide a means of conditionally "
"executing from one to four subsequent instructions without the need for a"
" label."
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:65
msgid "it(<condition>) If then"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:67
msgid "Execute the next instruction if <condition> is true:"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:71
msgid ""
"cmp(r0, r1)\n"
"it(eq)\n"
"mov(r0, 100) # runs if r0 == r1\n"
"# execution continues here"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:76
msgid "ite(<condition>) If then else"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:78
msgid ""
"If <condtion> is true, execute the next instruction, otherwise execute "
"the subsequent one. Thus:"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:83
msgid ""
"cmp(r0, r1)\n"
"ite(eq)\n"
"mov(r0, 100) # runs if r0 == r1\n"
"mov(r0, 200) # runs if r0 != r1\n"
"# execution continues here"
msgstr ""

#: ../../../reference/asm_thumb2_compare.rst:89
msgid ""
"This may be extended to control the execution of upto four subsequent "
"instructions: it[x[y[z]]] where x,y,z=t/e; e.g. itt, itee, itete, ittte, "
"itttt, iteee, etc."
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:2
msgid "Assembler directives"
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:5
msgid "Labels"
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:7
msgid "label(INNER1)"
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:9
msgid ""
"This defines a label for use in a branch instruction. Thus elsewhere in "
"the code a ``b(INNER1)`` will cause execution to continue with the "
"instruction after the label directive."
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:13
msgid "Defining inline data"
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:15
msgid ""
"The following assembler directives facilitate embedding data in an "
"assembler code block."
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:17
msgid "data(size, d0, d1 .. dn)"
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:19
msgid ""
"The data directive creates n array of data values in memory. The first "
"argument specifies the size in bytes of the subsequent arguments. Hence "
"the first statement below will cause the assembler to put three bytes "
"(with values 2, 3 and 4) into consecutive memory locations while the "
"second will cause it to emit two four byte words."
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:26
msgid ""
"data(1, 2, 3, 4)\n"
"data(4, 2, 100000)"
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:29
msgid ""
"Data values longer than a single byte are stored in memory in little-"
"endian format."
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:31
msgid "align(nBytes)"
msgstr ""

#: ../../../reference/asm_thumb2_directives.rst:33
msgid ""
"Align the following instruction to an nBytes value. ARM Thumb-2 "
"instructions must be two byte aligned, hence it's advisable to issue "
"``align(2)`` after ``data`` directives and prior to any subsequent code. "
"This ensures that the code will run irrespective of the size of the data "
"array."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:2
msgid "Floating point instructions"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:4
msgid ""
"These instructions support the use of the ARM floating point coprocessor "
"(on platforms such as the Pyboard which are equipped with one). The FPU "
"has 32 registers known as ``s0-s31`` each of which can hold a single "
"precision float. Data can be passed between the FPU registers and the ARM"
" core registers with the ``vmov`` instruction."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:10
msgid ""
"Note that MicroPython doesn't support passing floats to assembler "
"functions, nor can you put a float into ``r0`` and expect a reasonable "
"result. There are two ways to overcome this. The first is to use arrays, "
"and the second is to pass and/or return integers and convert to and from "
"floats in code."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:19
msgid ""
"Notation: ``Sd, Sm, Sn`` denote FPU registers, ``Rd, Rm, Rn`` denote ARM "
"core registers. The latter can be any ARM core register although "
"registers ``R13-R15`` are unlikely to be appropriate in this context."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:24
msgid "Arithmetic"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:26
msgid "vadd(Sd, Sn, Sm) ``Sd = Sn + Sm``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:27
msgid "vsub(Sd, Sn, Sm) ``Sd = Sn - Sm``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:28
msgid "vneg(Sd, Sm) ``Sd = -Sm``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:29
msgid "vmul(Sd, Sn, Sm) ``Sd = Sn * Sm``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:30
msgid "vdiv(Sd, Sn, Sm) ``Sd = Sn / Sm``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:31
msgid "vsqrt(Sd, Sm) ``Sd = sqrt(Sm)``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:33
msgid ""
"Registers may be identical: ``vmul(S0, S0, S0)`` will execute ``S0 = "
"S0*S0``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:36
msgid "Move between ARM core and FPU registers"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:38
msgid "vmov(Sd, Rm) ``Sd = Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:39
msgid "vmov(Rd, Sm) ``Rd = Sm``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:41
msgid ""
"The FPU has a register known as FPSCR, similar to the ARM core's APSR, "
"which stores condition codes plus other data. The following instructions "
"provide access to this."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:44
msgid "vmrs(APSR\\_nzcv, FPSCR)"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:46
msgid ""
"Move the floating-point N, Z, C, and V flags to the APSR N, Z, C, and V "
"flags."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:48
msgid ""
"This is done after an instruction such as an FPU comparison to enable the"
" condition codes to be tested by the assembler code. The following is a "
"more general form of the instruction."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:52
msgid "vmrs(Rd, FPSCR) ``Rd = FPSCR``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:55
msgid "Move between FPU register and memory"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:57
msgid "vldr(Sd, [Rn, offset]) ``Sd = [Rn + offset]``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:58
msgid "vstr(Sd, [Rn, offset]) ``[Rn + offset] = Sd``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:60
msgid ""
"Where ``[Rn + offset]`` denotes the memory address obtained by adding Rn "
"to the offset. This is specified in bytes. Since each float value "
"occupies a 32 bit word, when accessing arrays of floats the offset must "
"always be a multiple of four bytes."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:65
msgid "Data comparison"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:67
msgid "vcmp(Sd, Sm)"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:69
msgid ""
"Compare the values in Sd and Sm and set the FPU N, Z, C, and V flags. "
"This would normally be followed by ``vmrs(APSR_nzcv, FPSCR)`` to enable "
"the results to be tested."
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:74
msgid "Convert between integer and float"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:76
msgid "vcvt\\_f32\\_s32(Sd, Sm) ``Sd = float(Sm)``"
msgstr ""

#: ../../../reference/asm_thumb2_float.rst:77
msgid "vcvt\\_s32\\_f32(Sd, Sm) ``Sd = int(Sm)``"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:2
msgid "Hints and tips"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:4
msgid ""
"The following are some examples of the use of the inline assembler and "
"some information on how to work around its limitations. In this document "
"the term \"assembler function\" refers to a function declared in Python "
"with the ``@micropython.asm_thumb`` decorator, whereas \"subroutine\" "
"refers to assembler code called from within an assembler function."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:11
msgid "Code branches and subroutines"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:13
msgid ""
"It is important to appreciate that labels are local to an assembler "
"function. There is currently no way for a subroutine defined in one "
"function to be called from another."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:17
msgid ""
"To call a subroutine the instruction ``bl(LABEL)`` is issued. This "
"transfers control to the instruction following the ``label(LABEL)`` "
"directive and stores the return address in the link register (``lr`` or "
"``r14``). To return the instruction ``bx(lr)`` is issued which causes "
"execution to continue with the instruction following the subroutine call."
" This mechanism implies that, if a subroutine is to call another, it must"
" save the link register prior to the call and restore it before "
"terminating."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:25
msgid ""
"The following rather contrived example illustrates a function call. Note "
"that it's necessary at the start to branch around all subroutine calls: "
"subroutines end execution with ``bx(lr)`` while the outer function simply"
" \"drops off the end\" in the style of Python functions."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:32
msgid ""
"@micropython.asm_thumb\n"
"def quad(r0):\n"
"    b(START)\n"
"    label(DOUBLE)\n"
"    add(r0, r0, r0)\n"
"    bx(lr)\n"
"    label(START)\n"
"    bl(DOUBLE)\n"
"    bl(DOUBLE)\n"
"\n"
"print(quad(10))"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:44
msgid ""
"The following code example demonstrates a nested (recursive) call: the "
"classic Fibonacci sequence. Here, prior to a recursive call, the link "
"register is saved along with other registers which the program logic "
"requires to be preserved."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:50
msgid ""
"@micropython.asm_thumb\n"
"def fib(r0):\n"
"    b(START)\n"
"    label(DOFIB)\n"
"    push({r1, r2, lr})\n"
"    cmp(r0, 1)\n"
"    ble(FIBDONE)\n"
"    sub(r0, 1)\n"
"    mov(r2, r0) # r2 = n -1\n"
"    bl(DOFIB)\n"
"    mov(r1, r0) # r1 = fib(n -1)\n"
"    sub(r0, r2, 1)\n"
"    bl(DOFIB)   # r0 = fib(n -2)\n"
"    add(r0, r0, r1)\n"
"    label(FIBDONE)\n"
"    pop({r1, r2, lr})\n"
"    bx(lr)\n"
"    label(START)\n"
"    bl(DOFIB)\n"
"\n"
"for n in range(10):\n"
"    print(fib(n))"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:74
msgid "Argument passing and return"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:76
msgid ""
"The tutorial details the fact that assembler functions can support from "
"zero to three arguments, which must (if used) be named ``r0``, ``r1`` and"
" ``r2``. When the code executes the registers will be initialised to "
"those values."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:80
msgid ""
"The data types which can be passed in this way are integers and memory "
"addresses. With current firmware all possible 32 bit values may be passed"
" and returned. If the return value may have the most significant bit set "
"a Python type hint should be employed to enable MicroPython to determine "
"whether the value should be interpreted as a signed or unsigned integer: "
"types are ``int`` or ``uint``."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:89
msgid ""
"@micropython.asm_thumb\n"
"def uadd(r0, r1) -> uint:\n"
"    add(r0, r0, r1)"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:93
msgid ""
"``hex(uadd(0x40000000,0x40000000))`` will return 0x80000000, "
"demonstrating the passing and return of integers where bits 30 and 31 "
"differ."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:96
msgid ""
"The limitations on the number of arguments and return values can be "
"overcome by means of the ``array`` module which enables any number of "
"values of any type to be accessed."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:100
msgid "Multiple arguments"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:102
msgid ""
"If a Python array of integers is passed as an argument to an assembler "
"function, the function will receive the address of a contiguous set of "
"integers. Thus multiple arguments can be passed as elements of a single "
"array. Similarly a function can return multiple values by assigning them "
"to array elements. Assembler functions have no means of determining the "
"length of an array: this will need to be passed to the function."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:109
msgid ""
"This use of arrays can be extended to enable more than three arrays to be"
" used. This is done using indirection: the ``uctypes`` module supports "
"``addressof()`` which will return the address of an array passed as its "
"argument. Thus you can populate an integer array with the addresses of "
"other arrays:"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:116
msgid ""
"from uctypes import addressof\n"
"@micropython.asm_thumb\n"
"def getindirect(r0):\n"
"    ldr(r0, [r0, 0]) # Address of array loaded from passed array\n"
"    ldr(r0, [r0, 4]) # Return element 1 of indirect array (24)\n"
"\n"
"def testindirect():\n"
"    a = array.array('i',[23, 24])\n"
"    b = array.array('i',[0,0])\n"
"    b[0] = addressof(a)\n"
"    print(getindirect(b))"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:129
msgid "Non-integer data types"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:131
msgid ""
"These may be handled by means of arrays of the appropriate data type. For"
" example, single precision floating point data may be processed as "
"follows. This code example takes an array of floats and replaces its "
"contents with their squares."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:138
msgid ""
"from array import array\n"
"\n"
"@micropython.asm_thumb\n"
"def square(r0, r1):\n"
"    label(LOOP)\n"
"    vldr(s0, [r0, 0])\n"
"    vmul(s0, s0, s0)\n"
"    vstr(s0, [r0, 0])\n"
"    add(r0, 4)\n"
"    sub(r1, 1)\n"
"    bgt(LOOP)\n"
"\n"
"a = array('f', (x for x in range(10)))\n"
"square(a, len(a))\n"
"print(a)"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:154
msgid ""
"The uctypes module supports the use of data structures beyond simple "
"arrays. It enables a Python data structure to be mapped onto a bytearray "
"instance which may then be passed to the assembler function."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:159
msgid "Named constants"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:161
msgid ""
"Assembler code may be made more readable and maintainable by using named "
"constants rather than littering code with numbers. This may be achieved "
"thus:"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:167
msgid ""
"MYDATA = const(33)\n"
"\n"
"@micropython.asm_thumb\n"
"def foo():\n"
"    mov(r0, MYDATA)"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:173
msgid ""
"The const() construct causes MicroPython to replace the variable name "
"with its value at compile time. If constants are declared in an outer "
"Python scope they can be shared between multiple assembler functions and "
"with Python code."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:179
msgid "Assembler code as class methods"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:181
msgid ""
"MicroPython passes the address of the object instance as the first "
"argument to class methods. This is normally of little use to an assembler"
" function. It can be avoided by declaring the function as a static method"
" thus:"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:187
msgid ""
"class foo:\n"
"  @staticmethod\n"
"  @micropython.asm_thumb\n"
"  def bar(r0):\n"
"    add(r0, r0, r0)"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:194
msgid "Use of unsupported instructions"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:196
msgid ""
"These can be coded using the data statement as shown below. While "
"``push()`` and ``pop()`` are supported the example below illustrates the "
"principle. The necessary machine code may be found in the ARM v7-M "
"Architecture Reference Manual. Note that the first argument of data calls"
" such as"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:204
msgid "data(2, 0xe92d, 0x0f00) # push r8,r9,r10,r11"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:206
msgid "indicates that each subsequent argument is a two byte quantity."
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:209
msgid "Overcoming MicroPython's integer restriction"
msgstr ""

#: ../../../reference/asm_thumb2_hints_tips.rst:211
msgid ""
"The Pyboard chip includes a CRC generator. Its use presents a problem in "
"MicroPython because the returned values cover the full gamut of 32 bit "
"quantities whereas small integers in MicroPython cannot have differing "
"values in bits 30 and 31. This limitation is overcome with the following "
"code, which uses assembler to put the result into an array and Python "
"code to coerce the result into an arbitrary precision unsigned integer."
msgstr ""

#: ../../../<rst_epilog>:220
msgid ""
"from array import array\n"
"import stm\n"
"\n"
"def enable_crc():\n"
"    stm.mem32[stm.RCC + stm.RCC_AHB1ENR] |= 0x1000\n"
"\n"
"def reset_crc():\n"
"    stm.mem32[stm.CRC+stm.CRC_CR] = 1\n"
"\n"
"@micropython.asm_thumb\n"
"def getval(r0, r1):\n"
"    movwt(r3, stm.CRC + stm.CRC_DR)\n"
"    str(r1, [r3, 0])\n"
"    ldr(r2, [r3, 0])\n"
"    str(r2, [r0, 0])\n"
"\n"
"def getcrc(value):\n"
"    a = array('i', [0])\n"
"    getval(a, value)\n"
"    return a[0] & 0xffffffff # coerce to arbitrary precision\n"
"\n"
"enable_crc()\n"
"reset_crc()\n"
"for x in range(20):\n"
"    print(hex(getcrc(0)))"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:4
msgid "Inline assembler for Thumb2 architectures"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:6
msgid ""
"This document assumes some familiarity with assembly language programming"
" and should be read after studying the :ref:`tutorial "
"<pyboard_tutorial_assembler>`. For a detailed description of the "
"instruction set consult the Architecture Reference Manual detailed below."
" The inline assembler supports a subset of the ARM Thumb-2 instruction "
"set described here. The syntax tries to be as close as possible to that "
"defined in the above ARM manual, converted to Python function calls."
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:12
msgid ""
"Instructions operate on 32 bit signed integer data except where stated "
"otherwise. Most supported instructions operate on registers ``R0-R7`` "
"only: where ``R8-R15`` are supported this is stated. Registers ``R8-R12``"
" must be restored to their initial value before return from a function. "
"Registers ``R13-R15`` constitute the Link Register, Stack Pointer and "
"Program Counter respectively."
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:20
msgid ""
"Where possible the behaviour of each instruction is described in Python, "
"for example"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:22
msgid "add(Rd, Rn, Rm) ``Rd = Rn + Rm``"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:24
msgid ""
"This enables the effect of instructions to be demonstrated in Python. In "
"certain case this is impossible because Python doesn't support concepts "
"such as indirection. The pseudocode employed in such cases is described "
"on the relevant page."
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:29
msgid "Instruction categories"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:31
msgid ""
"The following sections details the subset of the ARM Thumb-2 instruction "
"set supported by MicroPython."
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:50
msgid "Usage examples"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:52
msgid ""
"These sections provide further code examples and hints on the use of the "
"assembler."
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:61
#: ../../../reference/packages.rst:308
msgid "References"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:63
msgid ":ref:`Assembler Tutorial <pyboard_tutorial_assembler>`"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:64
msgid ""
"`Wiki hints and tips "
"<http://wiki.micropython.org/platforms/boards/pyboard/assembler>`__"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:66
msgid ""
"`uPy Inline Assembler source-code, emitinlinethumb.c "
"<https://github.com/micropython/micropython/blob/master/py/emitinlinethumb.c>`__"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:68
msgid ""
"`ARM Thumb2 Instruction Set Quick Reference Card "
"<http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf>`__"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:70
#, python-format
msgid ""
"`RM0090 Reference Manual "
"<http://www.google.ae/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&sqi=2&ved=0CBoQFjAA&url=http%3A%2F%2Fwww.st.com"
"%2Fst-web-"
"ui%2Fstatic%2Factive%2Fen%2Fresource%2Ftechnical%2Fdocument%2Freference_manual%2FDM00031020.pdf&ei=G0rSU66xFeuW0QWYwoD4CQ&usg=AFQjCNFuW6TgzE4QpahO_U7g3f3wdwecAg&sig2"
"=iET-R0y9on_Pbflzf9aYDw&bvm=bv.71778758,bs.1,d.bGQ>`__"
msgstr ""

#: ../../../reference/asm_thumb2_index.rst:72
msgid ""
"ARM v7-M Architecture Reference Manual (Available on the ARM site after a"
" simple registration procedure. Also available on academic sites but "
"beware of out of date versions.)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:2
msgid "Branch instructions"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:4
msgid ""
"These cause execution to jump to a target location usually specified by a"
" label (see the ``label`` assembler directive). Conditional branches and "
"the ``it`` and ``ite`` instructions test the Application Program Status "
"Register (APSR) N (negative), Z (zero), C (carry) and V (overflow) flags "
"to determine whether the branch should be executed."
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:9
msgid ""
"Most of the exposed assembler instructions (including move operations) "
"set the flags but there are explicit comparison instructions to enable "
"values to be tested."
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:12
msgid ""
"Further detail on the meaning of the condition flags is provided in the "
"section describing comparison functions."
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:18
msgid ""
"Notation: ``Rm`` denotes ARM registers R0-R15. ``LABEL`` denotes a label "
"defined with the ``label()`` assembler directive. ``<condition>`` "
"indicates one of the following condition specifiers:"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:22
msgid "eq Equal to (result was zero)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:23
msgid "ne Not equal"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:24
msgid "cs Carry set"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:25
msgid "cc Carry clear"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:26
msgid "mi Minus (negative)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:27
msgid "pl Plus (positive)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:28
msgid "vs Overflow set"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:29
msgid "vc Overflow clear"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:30
msgid "hi > (unsigned comparison)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:31
msgid "ls <= (unsigned comparison)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:32
msgid "ge >= (signed comparison)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:33
msgid "lt < (signed comparison)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:34
msgid "gt > (signed comparison)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:35
msgid "le <= (signed comparison)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:38
msgid "Branch to label"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:40
msgid "b(LABEL) Unconditional branch"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:41
msgid "beq(LABEL) branch if equal"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:42
msgid "bne(LABEL) branch if not equal"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:43
msgid "bge(LABEL) branch if greater than or equal"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:44
msgid "bgt(LABEL) branch if greater than"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:45
msgid "blt(LABEL) branch if less than (<) (signed)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:46
msgid "ble(LABEL) branch if less than or equal to (<=) (signed)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:47
msgid "bcs(LABEL) branch if carry flag is set"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:48
msgid "bcc(LABEL) branch if carry flag is clear"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:49
msgid "bmi(LABEL) branch if negative"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:50
msgid "bpl(LABEL) branch if positive"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:51
msgid "bvs(LABEL) branch if overflow flag set"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:52
msgid "bvc(LABEL) branch if overflow flag is clear"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:53
msgid "bhi(LABEL) branch if higher (unsigned)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:54
msgid "bls(LABEL) branch if lower or equal (unsigned)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:57
msgid "Long branches"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:59
msgid ""
"The code produced by the branch instructions listed above uses a fixed "
"bit width to specify the branch destination, which is PC relative. "
"Consequently in long programs where the branch instruction is remote from"
" its destination the assembler will produce a \"branch not in range\" "
"error. This can be overcome with the \"wide\" variants such as"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:64
msgid "beq\\_w(LABEL) long branch if equal"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:66
msgid ""
"Wide branches use 4 bytes to encode the instruction (compared with 2 "
"bytes for standard branch instructions)."
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:69
msgid "Subroutines (functions)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:71
msgid ""
"When entering a subroutine the processor stores the return address in "
"register r14, also known as the link register (lr). Return to the "
"instruction after the subroutine call is performed by updating the "
"program counter (r15 or pc) from the link register, This process is "
"handled by the following instructions."
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:76
msgid "bl(LABEL)"
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:78
msgid ""
"Transfer execution to the instruction after ``LABEL`` storing the return "
"address in the link register (r14)."
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:81
msgid "bx(Rm) Branch to address specified by Rm."
msgstr ""

#: ../../../reference/asm_thumb2_label_branch.rst:83
msgid ""
"Typically ``bx(lr)`` is issued to return from a subroutine. For nested "
"subroutines the link register of outer scopes must be saved (usually on "
"the stack) before performing inner subroutine calls."
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:2
msgid "Load register from memory"
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:7
msgid ""
"Notation: ``Rt, Rn`` denote ARM registers R0-R7 except where stated. "
"``immN`` represents an immediate value having a width of N bits hence "
"``imm5`` is constrained to the range 0-31. ``[Rn + immN]`` is the "
"contents of the memory address obtained by adding Rn and the offset "
"``immN``. Offsets are measured in bytes. These instructions affect the "
"condition flags."
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:13
msgid "Register Load"
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:15
msgid "ldr(Rt, [Rn, imm7]) ``Rt = [Rn + imm7]`` Load a 32 bit word"
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:16
msgid "ldrb(Rt, [Rn, imm5]) ``Rt = [Rn + imm5]`` Load a byte"
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:17
msgid "ldrh(Rt, [Rn, imm6]) ``Rt = [Rn + imm6]`` Load a 16 bit half word"
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:19
msgid "Where a byte or half word is loaded, it is zero-extended to 32 bits."
msgstr ""

#: ../../../reference/asm_thumb2_ldr.rst:21
msgid ""
"The specified immediate offsets are measured in bytes. Hence in the case "
"of ``ldr`` the 7 bit value enables 32 bit word aligned values to be "
"accessed with a maximum offset of 31 words. In the case of ``ldrh`` the 6"
" bit value enables 16 bit half-word aligned values to be accessed with a "
"maximum offset of 31 half-words."
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:2
msgid "Logical & bitwise instructions"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:7
msgid ""
"Notation: ``Rd, Rn`` denote ARM registers R0-R7 except in the case of the"
" special instructions where R0-R15 may be used. ``Rn<a-b>`` denotes an "
"ARM register whose contents must lie in range ``a <= contents <= b``. In "
"the case of instructions with two register arguments, it is permissible "
"for them to be identical. For example the following will zero R0 (Python "
"``R0 ^= R0``) regardless of its initial contents."
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:13
msgid "eor(r0, r0)"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:15
msgid "These instructions affect the condition flags except where stated."
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:18
msgid "Logical instructions"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:20
msgid "and\\_(Rd, Rn) ``Rd &= Rn``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:21
msgid "orr(Rd, Rn) ``Rd |= Rn``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:22
msgid "eor(Rd, Rn) ``Rd ^= Rn``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:23
msgid "mvn(Rd, Rn) ``Rd = Rn ^ 0xffffffff`` i.e. Rd = 1's complement of Rn"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:24
msgid "bic(Rd, Rn) ``Rd &= ~Rn`` bit clear Rd using mask in Rn"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:26
msgid ""
"Note the use of \"and\\_\" instead of \"and\", because \"and\" is a "
"reserved keyword in Python."
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:29
msgid "Shift and rotation instructions"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:31
msgid "lsl(Rd, Rn<0-31>) ``Rd <<= Rn``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:32
msgid "lsr(Rd, Rn<1-32>) ``Rd = (Rd & 0xffffffff) >> Rn`` Logical shift right"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:33
msgid "asr(Rd, Rn<1-32>) ``Rd >>= Rn`` arithmetic shift right"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:34
msgid ""
"ror(Rd, Rn<1-31>) ``Rd = rotate_right(Rd, Rn)`` Rd is rotated right Rn "
"bits."
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:36
msgid ""
"A rotation by (for example) three bits works as follows. If Rd initially "
"contains bits ``b31 b30..b0`` after rotation it will contain ``b2 b1 b0 "
"b31 b30..b3``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:40
msgid "Special instructions"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:42
msgid "Condition codes are unaffected by these instructions."
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:44
msgid "clz(Rd, Rn) ``Rd = count_leading_zeros(Rn)``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:46
msgid ""
"count_leading_zeros(Rn) returns the number of binary zero bits before the"
" first binary one bit in Rn."
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:48
msgid "rbit(Rd, Rn) ``Rd = bit_reverse(Rn)``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:50
msgid ""
"bit_reverse(Rn) returns the bit-reversed contents of Rn. If Rn contains "
"bits ``b31 b30..b0`` Rd will be set to ``b0 b1 b2..b31``"
msgstr ""

#: ../../../reference/asm_thumb2_logical_bit.rst:53
msgid ""
"Trailing zeros may be counted by performing a bit reverse prior to "
"executing clz."
msgstr ""

#: ../../../reference/asm_thumb2_misc.rst:2
msgid "Miscellaneous instructions"
msgstr ""

#: ../../../reference/asm_thumb2_misc.rst:4
msgid "nop() ``pass`` no operation."
msgstr ""

#: ../../../reference/asm_thumb2_misc.rst:5
msgid "wfi() Suspend execution in a low power state until an interrupt occurs."
msgstr ""

#: ../../../reference/asm_thumb2_misc.rst:6
msgid "cpsid(flags) set the Priority Mask Register - disable interrupts."
msgstr ""

#: ../../../reference/asm_thumb2_misc.rst:7
msgid "cpsie(flags) clear the Priority Mask Register - enable interrupts."
msgstr ""

#: ../../../reference/asm_thumb2_misc.rst:8
msgid ""
"mrs(Rd, special_reg) ``Rd = special_reg`` copy a special register to a "
"general register. The special register may be IPSR (Interrupt Status "
"Register) or BASEPRI (Base Priority Register). The IPSR provides a means "
"of determining the exception number of an interrupt being processed. It "
"contains zero if no interrupt is being processed."
msgstr ""

#: ../../../reference/asm_thumb2_misc.rst:12
msgid ""
"Currently the ``cpsie()`` and ``cpsid()`` functions are partially "
"implemented. They require but ignore the flags argument and serve as a "
"means of enabling and disabling interrupts."
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:2
msgid "Register move instructions"
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:7
msgid ""
"Notation: ``Rd, Rn`` denote ARM registers R0-R15. ``immN`` denotes an "
"immediate value having a width of N bits. These instructions affect the "
"condition flags."
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:11
msgid "Register moves"
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:13
msgid ""
"Where immediate values are used, these are zero-extended to 32 bits. Thus"
" ``mov(R0, 0xff)`` will set R0 to 255."
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:16
msgid "mov(Rd, imm8) ``Rd = imm8``"
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:17
msgid "mov(Rd, Rn) ``Rd = Rn``"
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:18
msgid "movw(Rd, imm16) ``Rd = imm16``"
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:19
msgid "movt(Rd, imm16) ``Rd = (Rd & 0xffff) | (imm16 << 16)``"
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:21
msgid ""
"movt writes an immediate value to the top halfword of the destination "
"register. It does not affect the contents of the bottom halfword."
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:24
msgid "movwt(Rd, imm32) ``Rd = imm32``"
msgstr ""

#: ../../../reference/asm_thumb2_mov.rst:26
msgid ""
"movwt is a pseudo-instruction: the MicroPython assembler emits a ``movw``"
" followed by a ``movt`` to move a 32-bit value into Rd."
msgstr ""

#: ../../../reference/asm_thumb2_stack.rst:2
msgid "Stack push and pop"
msgstr ""

#: ../../../reference/asm_thumb2_stack.rst:7
msgid ""
"The ``push()`` and ``pop()`` instructions accept as their argument a "
"register set containing a subset, or possibly all, of the general-purpose"
" registers R0-R12 and the link register (lr or R14). As with any Python "
"set the order in which the registers are specified is immaterial. Thus "
"the in the following example the pop() instruction would restore R1, R7 "
"and R8 to their contents prior to the push():"
msgstr ""

#: ../../../reference/asm_thumb2_stack.rst:13
msgid "push({r1, r8, r7}) Save three registers on the stack."
msgstr ""

#: ../../../reference/asm_thumb2_stack.rst:14
msgid "pop({r7, r1, r8}) Restore them"
msgstr ""

#: ../../../reference/asm_thumb2_stack.rst:17
msgid "Stack operations"
msgstr ""

#: ../../../reference/asm_thumb2_stack.rst:19
msgid "push({regset}) Push a set of registers onto the stack"
msgstr ""

#: ../../../reference/asm_thumb2_stack.rst:20
msgid "pop({regset}) Restore a set of registers from the stack"
msgstr ""

#: ../../../reference/asm_thumb2_str.rst:2
msgid "Store register to memory"
msgstr ""

#: ../../../reference/asm_thumb2_str.rst:7
msgid ""
"Notation: ``Rt, Rn`` denote ARM registers R0-R7 except where stated. "
"``immN`` represents an immediate value having a width of N bits hence "
"``imm5`` is constrained to the range 0-31. ``[Rn + imm5]`` is the "
"contents of the memory address obtained by adding Rn and the offset "
"``imm5``. Offsets are measured in bytes. These instructions do not affect"
" the condition flags."
msgstr ""

#: ../../../reference/asm_thumb2_str.rst:13
msgid "Register Store"
msgstr ""

#: ../../../reference/asm_thumb2_str.rst:15
msgid "str(Rt, [Rn, imm7]) ``[Rn + imm7] = Rt`` Store a 32 bit word"
msgstr ""

#: ../../../reference/asm_thumb2_str.rst:16
msgid "strb(Rt, [Rn, imm5]) ``[Rn + imm5] = Rt`` Store a byte (b0-b7)"
msgstr ""

#: ../../../reference/asm_thumb2_str.rst:17
msgid ""
"strh(Rt, [Rn, imm6]) ``[Rn + imm6] = Rt`` Store a 16 bit half word "
"(b0-b15)"
msgstr ""

#: ../../../reference/asm_thumb2_str.rst:19
msgid ""
"The specified immediate offsets are measured in bytes. Hence in the case "
"of ``str`` the 7 bit value enables 32 bit word aligned values to be "
"accessed with a maximum offset of 31 words. In the case of ``strh`` the 6"
" bit value enables 16 bit half-word aligned values to be accessed with a "
"maximum offset of 31 half-words."
msgstr ""

#: ../../../reference/constrained.rst:4
msgid "MicroPython on microcontrollers"
msgstr "マイクロコントローラ上の MicroPython"

#: ../../../reference/constrained.rst:6
msgid ""
"MicroPython is designed to be capable of running on microcontrollers. "
"These have hardware limitations which may be unfamiliar to programmers "
"more familiar with conventional computers. In particular the amount of "
"RAM and nonvolatile \"disk\" (flash memory) storage is limited. This "
"tutorial offers ways to make the most of the limited resources. Because "
"MicroPython runs on controllers based on a variety of architectures, the "
"methods presented are generic: in some cases it will be necessary to "
"obtain detailed information from platform specific documentation."
msgstr ""
"MicroPython はマイクロコントローラ上で動作するように設計されています。"
"マイクロコントローラにはハードウェアの制限があり、従来のコンピュータに慣れている"
"プログラマにはなじみがないかもしれません。特に RAM および不揮発性の「ディスク」"
"(フラッシュメモリ)ストレージの容量に制限があります。このチュートリアルでは、"
"限られたリソースを最大限に活用する方法を紹介します。MicroPython はさまざまな"
"アーキテクチャに基づいたコントローラ上で動作するため、ここで紹介する方法は一般的な"
"ものです。場合によっては、プラットフォーム固有のドキュメントから詳細な情報を"
"入手する必要があります。"

#: ../../../reference/constrained.rst:16
msgid "Flash memory"
msgstr "フラッシュメモリ"

#: ../../../reference/constrained.rst:18
msgid ""
"On the Pyboard the simple way to address the limited capacity is to fit a"
" micro SD card. In some cases this is impractical, either because the "
"device does not have an SD card slot or for reasons of cost or power "
"consumption; hence the on-chip flash must be used. The firmware including"
" the MicroPython subsystem is stored in the onboard flash. The remaining "
"capacity is available for use. For reasons connected with the physical "
"architecture of the flash memory part of this capacity may be "
"inaccessible as a filesystem. In such cases this space may be employed by"
" incorporating user modules into a firmware build which is then flashed "
"to the device."
msgstr ""
"pyboard 上での限られた容量に対処する簡単な方法は、マイクロ SD カードを取り付ける"
"ことです。動作環境によっては、デバイスに SD カードスロットがないとか、コストや電力消費"
"の理由により、この対処は実用的ではありません。したがって、内蔵フラッシュを使用する"
"必要があります。MicroPython サブシステムを含むファームウェアは、オンボードのフラッシュに"
"保存されています。残りの容量は使用可能です。フラッシュメモリの物理的アーキテクチャと"
"関連した理由から、この容量の一部はファイルシステムとしてアクセスできない場合があります。"
"そのような場合でも、ユーザモジュールをファームウェアビルドに組み込んで、デバイスに"
"フラッシュするようにすれば、この空きを利用できます。"

#: ../../../reference/constrained.rst:28
msgid ""
"There are two ways to achieve this: frozen modules and frozen bytecode. "
"Frozen modules store the Python source with the firmware. Frozen bytecode"
" uses the cross compiler to convert the source to bytecode which is then "
"stored with the firmware. In either case the module may be accessed with "
"an import statement:"
msgstr ""
"これを実現する２つの手段があります。凍結モジュールと凍結バイトコードです。凍結"
"モジュールは Python ソースコードをファームウェアと一緒に保存します。凍結バイト"
"コードはクロスコンパイラを使用してソースをバイトコードに変換し、変換後のバイトコードを"
"ファームウェアに保存します。どちらの場合でも、モジュールには import 文でアクセスできます:"

#: ../../../reference/constrained.rst:36
msgid "import mymodule"
msgstr ""

#: ../../../reference/constrained.rst:37
msgid ""
"The procedure for producing frozen modules and bytecode is platform "
"dependent; instructions for building the firmware can be found in the "
"README files in the relevant part of the source tree."
msgstr ""
"凍結したモジュールとバイトコードを生成するための手順はプラットフォームに依存します。"
"ファームウェアを構築するための手順は関連するソースツリー中の README ファイルに"
"あります。"

#: ../../../reference/constrained.rst:41
msgid "In general terms the steps are as follows:"
msgstr "一般的な手順は次のとおりです:"

#: ../../../reference/constrained.rst:43
msgid ""
"Clone the MicroPython `repository "
"<https://github.com/micropython/micropython>`_."
msgstr ""
"MicroPython の `リポジトリ <https://github.com/micropython/micropython>`_ "
"をクローンします。"

#: ../../../reference/constrained.rst:44
msgid "Acquire the (platform specific) toolchain to build the firmware."
msgstr "ファームウェアをビルドするための(プラットフォーム固有の)ツールチェーンを"
"入手します。"

#: ../../../reference/constrained.rst:45
msgid "Build the cross compiler."
msgstr "クロスコンパイラをビルドします。"

#: ../../../reference/constrained.rst:46
msgid ""
"Place the modules to be frozen in a specified directory (dependent on "
"whether the module is to be frozen as source or as bytecode)."
msgstr ""
"凍結するモジュールを指定したディレクトリに配置します(モジュールをソース"
"として固定するかバイトコードとして固定するかによって異なります)。"

#: ../../../reference/constrained.rst:48
msgid ""
"Build the firmware. A specific command may be required to build frozen "
"code of either type - see the platform documentation."
msgstr ""
"ファームウェアをビルドします。どちらかのタイプの凍結コードをビルドするには、"
"特定のコマンドが必要な場合があります - プラットフォームのドキュメントを"
"参照してください。"

#: ../../../reference/constrained.rst:50
msgid "Flash the firmware to the device."
msgstr "ファームウェアをデバイスにフラッシュします。"

#: ../../../reference/constrained.rst:53
msgid "RAM"
msgstr ""

#: ../../../reference/constrained.rst:55
msgid ""
"When reducing RAM usage there are two phases to consider: compilation and"
" execution. In addition to memory consumption, there is also an issue "
"known as heap fragmentation. In general terms it is best to minimise the "
"repeated creation and destruction of objects. The reason for this is "
"covered in the section covering the `heap`_."
msgstr ""
"RAM の使用量を減らすときには、コンパイルと実行という2つの段階を考慮する必要があります。"
"メモリ消費量に加えて、ヒープフラグメンテーションとして知られている問題もあります。"
"一般的には、オブジェクトの作成と消去の繰り返しを最小限に抑えることが最善です。その理由"
"については、ヒープについての章で説明します。"

#: ../../../reference/constrained.rst:62
msgid "Compilation phase"
msgstr "コンパイルフェーズ"

#: ../../../reference/constrained.rst:64
msgid ""
"When a module is imported, MicroPython compiles the code to bytecode "
"which is then executed by the MicroPython virtual machine (VM). The "
"bytecode is stored in RAM. The compiler itself requires RAM, but this "
"becomes available for use when the compilation has completed."
msgstr ""
"モジュールがインポートされると、MicroPython はコードをバイトコードに"
"コンパイルし、それが MicroPython 仮想マシン(VM)によって実行されます。"
"バイトコードは RAM に保存されます。コンパイラ自体も RAM を必要としますが、"
"コンパイルが完了した後は解放されます。"

#: ../../../reference/constrained.rst:69
msgid ""
"If a number of modules have already been imported the situation can arise"
" where there is insufficient RAM to run the compiler. In this case the "
"import statement will produce a memory exception."
msgstr ""
"多数のモジュールがすでにインポートされている場合、コンパイラを実行するのに十分な "
"RAM がないという状況が発生する可能性があります。この場合、import 文はメモリ例外を"
"発生します。"

#: ../../../reference/constrained.rst:73
msgid ""
"If a module instantiates global objects on import it will consume RAM at "
"the time of import, which is then unavailable for the compiler to use on "
"subsequent imports. In general it is best to avoid code which runs on "
"import; a better approach is to have initialisation code which is run by "
"the application after all modules have been imported. This maximises the "
"RAM available to the compiler."
msgstr ""
"モジュールのインポート時にグローバルオブジェクトをインスタンス化する場合、インポート時に "
"RAM を消費します。この消費した RAM は、その後のインポートでも解放されないので、"
"コンパイラで利用することはできません。一般に、インポート時に実行されるコードを避ける"
"ことが最善です。より良い方法は、すべてのモジュールがインポートされた後にアプリケーションに"
"よって実行される初期化コードを持つことです。これにより、コンパイラが利用できる RAM が"
"最大化されます。"

#: ../../../reference/constrained.rst:80
msgid ""
"If RAM is still insufficient to compile all modules one solution is to "
"precompile modules. MicroPython has a cross compiler capable of compiling"
" Python modules to bytecode (see the README in the mpy-cross directory). "
"The resulting bytecode file has a .mpy extension; it may be copied to the"
" filesystem and imported in the usual way. Alternatively some or all "
"modules may be implemented as frozen bytecode: on most platforms this "
"saves even more RAM as the bytecode is run directly from flash rather "
"than being stored in RAM."
msgstr ""
"RAM がまだすべてのモジュールをコンパイルするのに不十分であるならば、１つの解決策は"
"モジュールをプリコンパイルすることです。MicroPython は Python モジュールを"
"バイトコードにコンパイルすることができるクロスコンパイラを持っています(mpy-cross "
"ディレクトリの README を見てください)。結果のバイトコードファイルの拡張子は .mpy "
"です。通常の方法でファイルシステムにコピーしインポートすることができます。"
"あるいは、モジュールの一部または全部を凍結バイトコードとして実装することもできます。"
"ほとんどのプラットフォームでは、バイトコードが RAM に格納されるのではなくフラッシュ"
"から直接実行されるため、RAM がさらに節約されます。"

#: ../../../reference/constrained.rst:89
msgid "Execution phase"
msgstr "実行フェーズ"

#: ../../../reference/constrained.rst:91
msgid "There are a number of coding techniques for reducing RAM usage."
msgstr "RAM の使用量を減らすためのコーディング手法は数多くあります。"

#: ../../../reference/constrained.rst:93
msgid "**Constants**"
msgstr "**定数**"

#: ../../../reference/constrained.rst:95
msgid "MicroPython provides a ``const`` keyword which may be used as follows:"
msgstr "MicroPythonには const キーワードがあり、次のように使えます:"

#: ../../../reference/constrained.rst:104
msgid ""
"from micropython import const\n"
"ROWS = const(33)\n"
"_COLS = const(0x10)\n"
"a = ROWS\n"
"b = _COLS"
msgstr ""

#: ../../../reference/constrained.rst:105
msgid ""
"In both instances where the constant is assigned to a variable the "
"compiler will avoid coding a lookup to the name of the constant by "
"substituting its literal value. This saves bytecode and hence RAM. "
"However the ``ROWS`` value will occupy at least two machine words, one "
"each for the key and value in the globals dictionary. The presence in the"
" dictionary is necessary because another module might import or use it. "
"This RAM can be saved by prepending the name with an underscore as in "
"``_COLS``: this symbol is not visible outside the module so will not "
"occupy RAM."
msgstr ""
"定数を変数に代入する両方の場合において、コンパイラはそのリテラル値で置換を行うので、"
"定数の名前を検索する処理が避けられます。これによりバイトコード、ひいては RAM を"
"節約できます。ただし、 ``ROWS`` 値については少なくとも２つの機械語が必要となります。"
"それは、グローバル辞書のキーと値です。別のモジュールがそれをインポートまたは使う"
"可能性があるため、辞書内に格納しておくことは必要となります。この RAM は ``_COLS`` "
"のように名前の前にアンダースコアを付けることで節約できます。このシンボルはモジュールの"
"外側には表示されないので、RAMを占有することはありません。"

#: ../../../reference/constrained.rst:114
msgid ""
"The argument to ``const()`` may be anything which, at compile time, "
"evaluates to an integer e.g. ``0x100`` or ``1 << 8``. It can even include"
" other const symbols that have already been defined, e.g. ``1 << BIT``."
msgstr ""
"``const()`` の引数には、``0x100`` や ``1 << 8`` など、コンパイル時に整数に"
"評価できるものであれば何でも指定できます。 ``1 << BIT`` など、定義済の const "
"シンボルを含めることもできます。"

#: ../../../reference/constrained.rst:118
msgid "**Constant data structures**"
msgstr "**定数データ構造**"

#: ../../../reference/constrained.rst:120
msgid ""
"Where there is a substantial volume of constant data and the platform "
"supports execution from Flash, RAM may be saved as follows. The data "
"should be located in Python modules and frozen as bytecode. The data must"
" be defined as `bytes` objects. The compiler 'knows' that `bytes` objects"
" are immutable and ensures that the objects remain in flash memory rather"
" than being copied to RAM. The `ustruct` module can assist in converting "
"between `bytes` types and other Python built-in types."
msgstr ""
"かなりの量の定数データが​​あり、プラットフォームがフラッシュからの実行をサポートしている"
"場合、RAM　は次のように節約できます。データは Python モジュールに配置し、バイトコード"
"として凍結されるべきです。データは `bytes` オブジェクトとして定義してください。"
"コンパイラは、 `bytes` オブジェクトが不変であることを「認識」しているので、 `bytes` "
"オブジェクトを RAM にコピーするのではなく、フラッシュメモリに残したままにします。 "
"`bytes` 型と他の Python 組み込み型との間の変換には `ustruct` モジュールが役立ちます。"

#: ../../../reference/constrained.rst:128
msgid ""
"When considering the implications of frozen bytecode, note that in Python"
" strings, floats, bytes, integers and complex numbers are immutable. "
"Accordingly these will be frozen into flash. Thus, in the line"
msgstr ""
"凍結バイトコードの内容を考慮すると、Python の文字列、浮動小数点数、バイト列、整数、"
"複素数は不変であることに注意してください。つまり、これらはフラッシュに凍結されます。"
"次のような行がある場合、"

#: ../../../reference/constrained.rst:135
msgid "mystring = \"The quick brown fox\""
msgstr ""

#: ../../../reference/constrained.rst:136
msgid ""
"the actual string \"The quick brown fox\" will reside in flash. At "
"runtime a reference to the string is assigned to the *variable* "
"``mystring``. The reference occupies a single machine word. In principle "
"a long integer could be used to store constant data:"
msgstr ""
"実際の文字列 \"The quick brown fox\" はフラッシュに存在します。実行時に、"
"文字列への参照が変数 ``mystring`` に割り当てられます。参照は単一の機械語に"
"なります。原理上は長整数を使って定数データを格納できます。"

#: ../../../reference/constrained.rst:144
msgid "bar = 0xDEADBEEF0000DEADBEEF"
msgstr ""

#: ../../../reference/constrained.rst:145
msgid ""
"As in the string example, at runtime a reference to the arbitrarily large"
" integer is assigned to the variable ``bar``. That reference occupies a "
"single machine word."
msgstr ""
"文字列の例のように、実行時に、任意の大きい整数への参照が変数 ``bar`` に割り当て"
"られます。その参照は単一の機械語になります。"

#: ../../../reference/constrained.rst:149
msgid ""
"It might be expected that tuples of integers could be employed for the "
"purpose of storing constant data with minimal RAM use. With the current "
"compiler this is ineffective (the code works, but RAM is not saved)."
msgstr ""
"定数データの格納につかう RAM 容量を最小限に抑える目的で、整数のタプルが使える"
"のではないかと予想されるかもしれません。現在のコンパイラではこれは無効です"
"(コードは機能しますが、RAM は節約されません)。"

#: ../../../reference/constrained.rst:156
msgid "foo = (1, 2, 3, 4, 5, 6, 100000)"
msgstr ""

#: ../../../reference/constrained.rst:157
msgid ""
"At runtime the tuple will be located in RAM. This may be subject to "
"future improvement."
msgstr ""
"実行時にタプルは RAM に配置されます。これは将来改善されるかもしれません。"

#: ../../../reference/constrained.rst:160
msgid "**Needless object creation**"
msgstr "**不要なオブジェクト作成**"

#: ../../../reference/constrained.rst:162
msgid ""
"There are a number of situations where objects may unwittingly be created"
" and destroyed. This can reduce the usability of RAM through "
"fragmentation. The following sections discuss instances of this."
msgstr ""
"無意識のうちにオブジェクトが作成され消去される可能性のある状況は数多くあります。"
"これによりフラグメンテーションが発生して、RAM 可用性は低下することがありえます。"
"以降の章では、この事例について説明します。"

#: ../../../reference/constrained.rst:166
msgid "**String concatenation**"
msgstr "**文字列の結合**"

#: ../../../reference/constrained.rst:168
msgid ""
"Consider the following code fragments which aim to produce constant "
"strings:"
msgstr ""
"定数文字列を生成することを目的とした次のコードフラグメントを検討してください:"

#: ../../../reference/constrained.rst:177
msgid ""
"var = \"foo\" + \"bar\"\n"
"var1 = \"foo\" \"bar\"\n"
"var2 = \"\"\"\\\n"
"foo\\\n"
"bar\"\"\""
msgstr ""

#: ../../../reference/constrained.rst:178
msgid ""
"Each produces the same outcome, however the first needlessly creates two "
"string objects at runtime, allocates more RAM for concatenation before "
"producing the third. The others perform the concatenation at compile time"
" which is more efficient, reducing fragmentation."
msgstr ""
"それぞれが同じ結果を生成しますが、１番目のものは実行時に２つの文字列オブジェクトを"
"不必要に作成し、結果を生成する前に連結用に RAM を追加で割り当てます。他のものは"
"コンパイル時に連結を実行します。これはより効率的で、フラグメンテーションを減らします。"

#: ../../../reference/constrained.rst:183
msgid ""
"Where strings must be dynamically created before being fed to a stream "
"such as a file it will save RAM if this is done in a piecemeal fashion. "
"Rather than creating a large string object, create a substring and feed "
"it to the stream before dealing with the next."
msgstr ""
"ファイルのようなストリームに送る前に文字列を動的に作成しなければならない場合、"
"これを少しずつ行うようにすれば RAM を節約できます。大きな文字列オブジェクトを"
"作成するのではなく、部分文字列を作成して送りってから、次の部分文字列を扱うようにします。"

#: ../../../reference/constrained.rst:188
msgid ""
"The best way to create dynamic strings is by means of the string "
"``format()`` method:"
msgstr ""
"動的文字列を作成する最良の方法は、文字列の ``format()`` メソッドを使うことです:"

#: ../../../reference/constrained.rst:194
msgid "var = \"Temperature {:5.2f} Pressure {:06d}\\n\".format(temp, press)"
msgstr ""

#: ../../../reference/constrained.rst:195
msgid "**Buffers**"
msgstr "**バッファ**"

#: ../../../reference/constrained.rst:197
msgid ""
"When accessing devices such as instances of UART, I2C and SPI interfaces,"
" using pre-allocated buffers avoids the creation of needless objects. "
"Consider these two loops:"
msgstr ""
"UART, I2C, SPI インタフェースなどのデバイスにアクセスするときに、事前に割り当てた"
"バッファを使うようにすると、不要なオブジェクトが作成されなくなります。次の２つのループに"
"ついて考えてみましょう:"

#: ../../../reference/constrained.rst:211
msgid ""
"while True:\n"
"    var = spi.read(100)\n"
"    # process data\n"
"\n"
"buf = bytearray(100)\n"
"while True:\n"
"    spi.readinto(buf)\n"
"    # process data in buf"
msgstr ""
"while True:\n"
"    var = spi.read(100)\n"
"    # データを処理\n"
"\n"
"buf = bytearray(100)\n"
"while True:\n"
"    spi.readinto(buf)\n"
"    # buf でデータを処理"

#: ../../../reference/constrained.rst:212
msgid ""
"The first creates a buffer on each pass whereas the second re-uses a pre-"
"allocated buffer; this is both faster and more efficient in terms of "
"memory fragmentation."
msgstr ""
"１つ目のループでは各パスで毎回バッファを作成するのに対して、２つ目のループは"
"事前に割り当てられたバッファを再利用します。これにより、より高速になりますし、"
"メモリのフラグメンテーションという点でも効率的です。"

#: ../../../reference/constrained.rst:215
msgid "**Bytes are smaller than ints**"
msgstr "**バイトは整数より小さい**"

#: ../../../reference/constrained.rst:217
msgid ""
"On most platforms an integer consumes four bytes. Consider the two calls "
"to the function ``foo()``:"
msgstr ""
"ほとんどのプラットフォームで、整数は4バイトを消費します。次の関数 ``foo()`` への"
"２つの呼び出しについて考えてみましょう:"

#: ../../../reference/constrained.rst:227
msgid ""
"def foo(bar):\n"
"    for x in bar:\n"
"        print(x)\n"
"foo((1, 2, 0xff))\n"
"foo(b'\\1\\2\\xff')"
msgstr ""

#: ../../../reference/constrained.rst:228
msgid ""
"In the first call a tuple of integers is created in RAM. The second "
"efficiently creates a `bytes` object consuming the minimum amount of RAM."
" If the module were frozen as bytecode, the `bytes` object would reside "
"in flash."
msgstr ""
"１つ目の呼び出しでは、整数のタプルが RAM に作成されます。２つ目は最小量の RAM を"
"消費する bytes オブジェクトを効率的に作成します。モジュールがバイトコードとして"
"凍結されている場合、bytes オブジェクトはフラッシュ内に置かれます。"

#: ../../../reference/constrained.rst:232
msgid "**Strings Versus Bytes**"
msgstr "**文字列とバイト列**"

#: ../../../reference/constrained.rst:234
msgid ""
"Python3 introduced Unicode support. This introduced a distinction between"
" a string and an array of bytes. MicroPython ensures that Unicode strings"
" take no additional space so long as all characters in the string are "
"ASCII (i.e. have a value < 126). If values in the full 8-bit range are "
"required `bytes` and `bytearray` objects can be used to ensure that no "
"additional space will be required. Note that most string methods (e.g. "
":meth:`str.strip()`) apply also to `bytes` instances so the process of "
"eliminating Unicode can be painless."
msgstr ""
"Python3 は Unicode サポートを導入しました。これは文字列とバイトの配列の間の区別を"
"もたらしました。MicroPython は文字列内のすべての文字が ASCII である(つまり < 126 "
"の値を持つ)限り、Unicode 文字列が追加のスペースを取らないことを保証します。8 ビット"
"全域の値が必要であれば、追加のスペースが不要になるように `bytes` や `bytearray` "
"オブジェクトが使えます。ほとんどの文字列メソッド(たとえば `str.strip()`) は "
"`bytes` インスタンスにも適用されるため、Unicode を排除する処理は簡単です。"

#: ../../../reference/constrained.rst:246
msgid ""
"s = 'the quick brown fox'   # A string instance\n"
"b = b'the quick brown fox'  # A bytes instance"
msgstr ""

#: ../../../reference/constrained.rst:247
msgid ""
"Where it is necessary to convert between strings and bytes the "
":meth:`str.encode` and the :meth:`bytes.decode` methods can be used. Note"
" that both strings and bytes are immutable. Any operation which takes as "
"input such an object and produces another implies at least one RAM "
"allocation to produce the result. In the second line below a new bytes "
"object is allocated. This would also occur if ``foo`` were a string."
msgstr ""
"文字列とバイトを変換する必要がある場合は、 ":meth:`str.encode` と "
":meth:`bytes.decode` メソッドを使えます。文字列とバイト列の両方が不変であることに"
"注意してください。そのようなオブジェクトを入力として受け取り、別のオブジェクトを"
"生成する演算は、結果を生成するために少なくとも1つのRAM割り当てを意味します。次の"
"コードの２行目には、新しい bytes オブジェクトが割り当てられています。foo が"
"文字列の場合も同様です。"

#: ../../../reference/constrained.rst:258
msgid ""
"foo = b'   empty whitespace'\n"
"foo = foo.lstrip()"
msgstr ""

#: ../../../reference/constrained.rst:259
msgid "**Runtime compiler execution**"
msgstr "**ランタイムコンパイラの実行**"

#: ../../../reference/constrained.rst:261
msgid ""
"The Python funcitons `eval` and `exec` invoke the compiler at runtime, "
"which requires significant amounts of RAM. Note that the ``pickle`` "
"library from `micropython-lib` employs `exec`. It may be more RAM "
"efficient to use the `ujson` library for object serialisation."
msgstr ""
"Python で `eval` や `exec` を呼び出して、実行時にコンパイラを機能させることは、"
"かなりの量の RAM が必要となります。 `micropython-lib` の ``pickle`` "
"ライブラリは `exec` を利用していることに注意してください。オブジェクトのシリアル化"
"については `ujson` ライブラリを使うと、RAM の効率が上がる可能性があります 。"

#: ../../../reference/constrained.rst:266
msgid "**Storing strings in flash**"
msgstr "**文字列をフラッシュに保存する**"

#: ../../../reference/constrained.rst:268
msgid ""
"Python strings are immutable hence have the potential to be stored in "
"read only memory. The compiler can place in flash strings defined in "
"Python code. As with frozen modules it is necessary to have a copy of the"
" source tree on the PC and the toolchain to build the firmware. The "
"procedure will work even if the modules have not been fully debugged, so "
"long as they can be imported and run."
msgstr ""
"Python の文字列は不変なので、読み取り専用メモリに格納できる可能性があります。"
"コンパイラは、Python コードで定義された文字列をフラッシュに配置できます。"
"凍結モジュールと同様に、ファームウェアを構築するには、PC 上にソースツリーのコピーと"
"ツールチェーンを用意する必要があります。モジュールをインポートして実行できる限り、"
"モジュールが完全にデバッグされていなくても、この手順を実行できます。"

#: ../../../reference/constrained.rst:274
msgid "After importing the modules, execute:"
msgstr "モジュールをインポートした後に次を実行してください:"

#: ../../../reference/constrained.rst:279
#: ../../../reference/constrained.rst:290
msgid "micropython.qstr_info(1)"
msgstr ""

#: ../../../reference/constrained.rst:280
msgid ""
"Then copy and paste all the Q(xxx) lines into a text editor. Check for "
"and remove lines which are obviously invalid. Open the file "
"qstrdefsport.h which will be found in ports/stm32 (or the equivalent "
"directory for the architecture in use). Copy and paste the corrected "
"lines at the end of the file. Save the file, rebuild and flash the "
"firmware. The outcome can be checked by importing the modules and again "
"issuing:"
msgstr ""
"次に、すべての Q(xxx) 行をテキストエディタにコピーして貼り付けます。明らかに無効な"
"行をチェックして削除します。ports/stm32 (または使用中のアーキテクチャに相当する"
"ディレクトリ)にあるファイル qstrdefsport.h を開きます。修正した行をコピーして"
"ファイルの末尾に貼り付けます。ファイルを保存し、ファームウェアを再構築してフラッシュ"
"します。結果はモジュールをインポートして再度発行することで確認できます:"

#: ../../../reference/constrained.rst:291
msgid "The Q(xxx) lines should be gone."
msgstr "Q(xxx) 行は消えます。"

#: ../../../reference/constrained.rst:296
msgid "The heap"
msgstr "ヒープ"

#: ../../../reference/constrained.rst:298
msgid ""
"When a running program instantiates an object the necessary RAM is "
"allocated from a fixed size pool known as the heap. When the object goes "
"out of scope (in other words becomes inaccessible to code) the redundant "
"object is known as \"garbage\". A process known as \"garbage collection\""
" (GC) reclaims that memory, returning it to the free heap. This process "
"runs automatically, however it can be invoked directly by issuing "
"`gc.collect()`."
msgstr ""
"実行中のプログラムがオブジェクトをインスタンス化すると、必要な RAM がヒープと呼ばれる"
"固定サイズのプールから割り当てられます。オブジェクトがスコープ外になると(つまり、"
"コードにアクセスできなくなると)、この不要オブジェクトは「ガベージ」というものになります。"
"「ガベージコレクション」(Garbage Collection: GC)と呼ばれるプロセスがそのメモリを"
"回収し、空きヒープに戻します。このプロセスは自動的に実行されますが、 `gc.collect()` "
"によって直接呼び出すこともできます。"

#: ../../../reference/constrained.rst:305
msgid ""
"The discourse on this is somewhat involved. For a 'quick fix' issue the "
"following periodically:"
msgstr ""
"これについての説明は多少複雑です。「迅速な修正」のために、定期的に以下を発行してください:"

#: ../../../reference/constrained.rst:312
#: ../../../reference/constrained.rst:413
msgid ""
"gc.collect()\n"
"gc.threshold(gc.mem_free() // 4 + gc.mem_alloc())"
msgstr ""

#: ../../../reference/constrained.rst:314
msgid "Fragmentation"
msgstr "フラグメンテーション"

#: ../../../reference/constrained.rst:316
msgid ""
"Say a program creates an object ``foo``, then an object ``bar``. "
"Subsequently ``foo`` goes out of scope but ``bar`` remains. The RAM used "
"by ``foo`` will be reclaimed by GC. However if ``bar`` was allocated to a"
" higher address, the RAM reclaimed from ``foo`` will only be of use for "
"objects no bigger than ``foo``. In a complex or long running program the "
"heap can become fragmented: despite there being a substantial amount of "
"RAM available, there is insufficient contiguous space to allocate a "
"particular object, and the program fails with a memory error."
msgstr ""
"プログラムがオブジェクト foo を作成し、次にオブジェクト ``bar`` を作成したとします。"
"その後 ``foo`` がスコープ外になり、 ``bar`` が残ります。 ``foo`` によって使用された "
"RAM は、GCによって回収されます。ただし  ``bar`` が、より高いアドレスに割り当てられて"
"いる場合、 ``foo`` から再利用される RAM は、それより大きくないオブジェクトにのみ使用"
"されます。複雑なプログラムや長時間実行されているプログラムでは、ヒープが断片化する可能性が"
"あります。使用可能な RAM がかなりあるにもかかわらず、特定のオブジェクトを割り当てるための"
"隣接スペースが不足し、プログラムがメモリーエラーで失敗します。"

#: ../../../reference/constrained.rst:325
msgid ""
"The techniques outlined above aim to minimise this. Where large permanent"
" buffers or other objects are required it is best to instantiate these "
"early in the process of program execution before fragmentation can occur."
" Further improvements may be made by monitoring the state of the heap and"
" by controlling GC; these are outlined below."
msgstr ""
"先に概説した技法はこれを最小にすることを目的としています。大きな永続バッファや他の"
"オブジェクトが必要な場合は、フラグメンテーションが発生する前にプログラム実行のプロセスの"
"早い段階でこれらをインスタンス化するのが最善です。ヒープの状態を監視し、GC を制御"
"することで、さらに改善することができます。これらの概要は以下の通りです。"

#: ../../../reference/constrained.rst:332
msgid "Reporting"
msgstr "レポート機能"

#: ../../../reference/constrained.rst:334
msgid ""
"A number of library functions are available to report on memory "
"allocation and to control GC. These are to be found in the `gc` and "
"`micropython` modules. The following example may be pasted at the REPL "
"(``ctrl e`` to enter paste mode, ``ctrl d`` to run it)."
msgstr ""
"メモリ割り当てと GC 制御のレポートを行う多くのライブラリ関数が用意されています。"
"これらの関数は `gc` と `micropython` モジュールにあります。次の例は REPL に"
"貼り付けることができます(``Ctrl-e`` で貼り付けモードに入り、 ``Ctrl-d`` "
"で実行します)。"

#: ../../../reference/constrained.rst:357
msgid ""
"import gc\n"
"import micropython\n"
"gc.collect()\n"
"micropython.mem_info()\n"
"print('-----------------------------')\n"
"print('Initial free: {} allocated: {}'.format(gc.mem_free(), "
"gc.mem_alloc()))\n"
"def func():\n"
"    a = bytearray(10000)\n"
"gc.collect()\n"
"print('Func definition: {} allocated: {}'.format(gc.mem_free(), "
"gc.mem_alloc()))\n"
"func()\n"
"print('Func run free: {} allocated: {}'.format(gc.mem_free(), "
"gc.mem_alloc()))\n"
"gc.collect()\n"
"print('Garbage collect free: {} allocated: {}'.format(gc.mem_free(), "
"gc.mem_alloc()))\n"
"print('-----------------------------')\n"
"micropython.mem_info(1)"
msgstr ""

#: ../../../reference/constrained.rst:358
msgid "Methods employed above:"
msgstr "上記で採用したメソッド:"

#: ../../../reference/constrained.rst:360
msgid "`gc.collect()` Force a garbage collection. See footnote."
msgstr "`gc.collect()` ガベージコレクションを強制します。脚注を参照してください。"

#: ../../../reference/constrained.rst:361
msgid "`micropython.mem_info()` Print a summary of RAM utilisation."
msgstr "`micropython.mem_info()` RAM 使用率の要約を表示します。"

#: ../../../reference/constrained.rst:362
msgid "`gc.mem_free()` Return the free heap size in bytes."
msgstr "`gc.mem_free()` 空きヒープサイズをバイト数で返します。"

#: ../../../reference/constrained.rst:363
msgid "`gc.mem_alloc()` Return the number of bytes currently allocated."
msgstr "`gc.mem_alloc()` 現在割り当てられているバイト数を返します。"

#: ../../../reference/constrained.rst:364
msgid ""
"``micropython.mem_info(1)`` Print a table of heap utilisation (detailed "
"below)."
msgstr ""
"``micropython.mem_info(1)`` ヒープ使用率の表を表示します(詳細は後述)。"

#: ../../../reference/constrained.rst:366
msgid ""
"The numbers produced are dependent on the platform, but it can be seen "
"that declaring the function uses a small amount of RAM in the form of "
"bytecode emitted by the compiler (the RAM used by the compiler has been "
"reclaimed). Running the function uses over 10KiB, but on return ``a`` is "
"garbage because it is out of scope and cannot be referenced. The final "
"`gc.collect()` recovers that memory."
msgstr ""
"生成される数値はプラットフォームによって異なりますが、関数の宣言ではコンパイラに"
"よって出力されるバイトコードの形成に少量の RAM が使われていることがわかります"
"(コンパイラによって使用された RAM は再利用されています)。この関数を実行すると "
"10KiB 以上が使われますが、戻り時に a はスコープ外となり、ガベージとなります。"
"最後は gc.collect() そのメモリが回収されます。"

#: ../../../reference/constrained.rst:373
msgid ""
"The final output produced by ``micropython.mem_info(1)`` will vary in "
"detail but may be interpreted as follows:"
msgstr ""
"``micropython.mem_info(1)`` によって生成される最終的な出力は、詳細は異なって"
"いるかもしれませんが、次のように解釈される場合があります。"

#: ../../../reference/constrained.rst:377
msgid "Symbol"
msgstr "シンボル"

#: ../../../reference/constrained.rst:377
msgid "Meaning"
msgstr "意味"

#: ../../../reference/constrained.rst:379
msgid "."
msgstr ""

#: ../../../reference/constrained.rst:379
msgid "free block"
msgstr "フリーブロック"

#: ../../../reference/constrained.rst:380
msgid "h"
msgstr ""

#: ../../../reference/constrained.rst:380
msgid "head block"
msgstr "ヘッドブロック"

#: ../../../reference/constrained.rst:381
msgid "="
msgstr ""

#: ../../../reference/constrained.rst:381
msgid "tail block"
msgstr "テイルブロック"

#: ../../../reference/constrained.rst:382
msgid "m"
msgstr ""

#: ../../../reference/constrained.rst:382
msgid "marked head block"
msgstr "マーク付きヘッドブロック"

#: ../../../reference/constrained.rst:383
msgid "T"
msgstr ""

#: ../../../reference/constrained.rst:383
msgid "tuple"
msgstr "タプル"

#: ../../../reference/constrained.rst:384
msgid "L"
msgstr ""

#: ../../../reference/constrained.rst:384
msgid "list"
msgstr "リスト"

#: ../../../reference/constrained.rst:385
msgid "D"
msgstr ""

#: ../../../reference/constrained.rst:385
msgid "dict"
msgstr "辞書"

#: ../../../reference/constrained.rst:386
msgid "F"
msgstr ""

#: ../../../reference/constrained.rst:386
msgid "float"
msgstr "浮動小数点"

#: ../../../reference/constrained.rst:387
msgid "B"
msgstr ""

#: ../../../reference/constrained.rst:387
msgid "byte code"
msgstr "バイトコード"

#: ../../../reference/constrained.rst:388
msgid "M"
msgstr ""

#: ../../../reference/constrained.rst:388
msgid "module"
msgstr "モジュール"

#: ../../../reference/constrained.rst:391
msgid ""
"Each letter represents a single block of memory, a block being 16 bytes. "
"So each line of the heap dump represents 0x400 bytes or 1KiB of RAM."
msgstr ""
"各文字は1ブロックのメモリを表し、1ブロックは16バイトです。したがって、"
"ヒープダンプの各行は 0x400 バイトまたは 1KB の RAM を表します。"

#: ../../../reference/constrained.rst:395
msgid "Control of garbage collection"
msgstr "ガベージコレクションの制御"

#: ../../../reference/constrained.rst:397
msgid ""
"A GC can be demanded at any time by issuing `gc.collect()`. It is "
"advantageous to do this at intervals, firstly to pre-empt fragmentation "
"and secondly for performance. A GC can take several milliseconds but is "
"quicker when there is little work to do (about 1ms on the Pyboard). An "
"explicit call can minimise that delay while ensuring it occurs at points "
"in the program when it is acceptable."
msgstr ""
"GC は `gc.collect()` の実行によっていつでも要求できます。第一にフラグメンテーション"
"解消のために、第二にパフォーマンスのために、間隔を置いてこれを実行することが有利です。"
"GCには数ミリ秒かかることがありますが、実行する作業がほとんどない場合は速くなります"
"(pyboardでは約1ms)。明示的な呼び出しは、プログラム内の適切な時点で確実に発生する"
"ようにしながら、GC による遅延を最小限に抑えることができます。"

#: ../../../reference/constrained.rst:403
msgid ""
"Automatic GC is provoked under the following circumstances. When an "
"attempt at allocation fails, a GC is performed and the allocation re-"
"tried. Only if this fails is an exception raised. Secondly an automatic "
"GC will be triggered if the amount of free RAM falls below a threshold. "
"This threshold can be adapted as execution progresses:"
msgstr ""
"自動 GC は次の状況で引き起こされます。割り当ての試みが失敗すると、GC が実行され、"
"割り当てが再試行されます。これが失敗した場合にのみ、例外が発生します。次に、空き "
"RAM の量がしきい値を下回ると、自動 GC がトリガーされます。実行が進むにつれて、"
"このしきい値を調整することができます。"

#: ../../../reference/constrained.rst:414
#, python-format
msgid ""
"This will provoke a GC when more than 25% of the currently free heap "
"becomes occupied."
msgstr ""
"これは、現在の空きヒープの25％以上が占有されるようになると、GCを引き起こします。"

#: ../../../reference/constrained.rst:417
msgid ""
"In general modules should instantiate data objects at runtime using "
"constructors or other initialisation functions. The reason is that if "
"this occurs on initialisation the compiler may be starved of RAM when "
"subsequent modules are imported. If modules do instantiate data on import"
" then `gc.collect()` issued after the import will ameliorate the problem."
msgstr ""
"一般的にモジュールはコンストラクタや他の初期化関数を使って実行時にデータオブジェクトを"
"インスタンス化するべきです。このようにする理由は、モジュールのインポート時にこれが"
"発生すると、後続のモジュールのインポート時にコンパイラのRAMが不足する可能性があるため"
"です。モジュールがインポート時にデータをインスタンス化する場合は、インポート後に "
"`gc.collect()` を実行すると、問題が改善します。"

#: ../../../reference/constrained.rst:424
msgid "String operations"
msgstr "文字列操作"

#: ../../../reference/constrained.rst:426
msgid ""
"MicroPython handles strings in an efficient manner and understanding this"
" can help in designing applications to run on microcontrollers. When a "
"module is compiled, strings which occur multiple times are stored once "
"only, a process known as string interning. In MicroPython an interned "
"string is known as a ``qstr``. In a module imported normally that single "
"instance will be located in RAM, but as described above, in modules "
"frozen as bytecode it will be located in flash."
msgstr ""
"MicroPython は文字列を効率的に処理します。これを理解することは、マイクロコントローラ"
"上で動作するようにアプリケーションを設計するのに役立ちます。モジュールがコンパイル"
"されると、複数回出現する文字列は１回だけ格納されます。これを文字列の隔離化といいます。"
"MicroPython では隔離化された文字列を ``qstr`` と呼びます。通常インポート"
"されたモジュールでは、その単一のインスタンスは RAM に配置されますが、前述のように、"
"バイトコードとして凍結されたモジュールではフラッシュに配置されます。"

#: ../../../reference/constrained.rst:433
msgid ""
"String comparisons are also performed efficiently using hashing rather "
"than character by character. The penalty for using strings rather than "
"integers may hence be small both in terms of performance and RAM usage - "
"a fact which may come as a surprise to C programmers."
msgstr ""
"文字列比較も、文字ごとではなくハッシュを使用して効率的に実行されます。したがって、"
"整数ではなく文字列を使用することによるペナルティは、パフォーマンスと RAM の使用量の"
"両方の点で小さい場合があります。これは、C プログラマにとっては驚くべきことです。"

#: ../../../reference/constrained.rst:439
msgid "Postscript"
msgstr "あとがき"

#: ../../../reference/constrained.rst:441
msgid ""
"MicroPython passes, returns and (by default) copies objects by reference."
" A reference occupies a single machine word so these processes are "
"efficient in RAM usage and speed."
msgstr ""
"MicroPython は、参照によってオブジェクトの受け渡しと(デフォルトで)コピーを行います。"
"参照は単一のマシンワードを占有するため、これらのプロセスは RAM の使用と速度の点で"
"効率的です。"

#: ../../../reference/constrained.rst:445
msgid ""
"Where variables are required whose size is neither a byte nor a machine "
"word there are standard libraries which can assist in storing these "
"efficiently and in performing conversions. See the `array`, `ustruct` and"
" `uctypes` modules."
msgstr ""
"サイズがバイトでも１機械語でもない変数が必要な場合は、これらを効率的に格納して変換を"
"実行するのを助けることができる標準ライブラリがあります。"
"`array`, `ustruct`, `uctypes` モジュールを参照してください。"

#: ../../../reference/constrained.rst:451
msgid "Footnote: gc.collect() return value"
msgstr "脚注: gc.collect（）の戻り値"

#: ../../../reference/constrained.rst:453
msgid ""
"On Unix and Windows platforms the `gc.collect()` method returns an "
"integer which signifies the number of distinct memory regions that were "
"reclaimed in the collection (more precisely, the number of heads that "
"were turned into frees). For efficiency reasons bare metal ports do not "
"return this value."
msgstr ""
"Unix および Windows プラットフォームでは、この `gc.collect()` メソッドは、"
"コレクション内で回収された個別のメモリ領域の数(より正確には、空きになったヘッドの数)"
"を表す整数を返します。効率上の理由から、ベアメタルポートはこの値を返しません。"

#: ../../reference/filesystem.rst:4
msgid "Working with filesystems"
msgstr ""

#: ../../reference/filesystem.rst:8
msgid ""
"This tutorial describes how MicroPython provides an on-device filesystem,"
" allowing standard Python file I/O methods to be used with persistent "
"storage."
msgstr ""

#: ../../reference/filesystem.rst:11
msgid ""
"MicroPython automatically creates a default configuration and auto-"
"detects the primary filesystem, so this tutorial will be mostly useful if"
" you want to modify the partitioning, filesystem type, or use custom "
"block devices."
msgstr ""

#: ../../reference/filesystem.rst:15
msgid ""
"The filesystem is typically backed by internal flash memory on the "
"device, but can also use external flash, RAM, or a custom block device."
msgstr ""

#: ../../reference/filesystem.rst:18
msgid ""
"On some ports (e.g. STM32), the filesystem may also be available over USB"
" MSC to a host PC. :ref:`pyboard_py` also provides a way for the host PC "
"to access to the filesystem on all ports."
msgstr ""

#: ../../reference/filesystem.rst:22
msgid ""
"Note: This is mainly for use on bare-metal ports like STM32 and ESP32. On"
" ports with an operating system (e.g. the Unix port) the filesystem is "
"provided by the host OS."
msgstr ""

#: ../../reference/filesystem.rst:27
msgid "VFS"
msgstr ""

#: ../../reference/filesystem.rst:29
msgid ""
"MicroPython implements a Unix-like Virtual File System (VFS) layer. All "
"mounted filesystems are combined into a single virtual filesystem, "
"starting at the root ``/``. Filesystems are mounted into directories in "
"this structure, and at startup the working directory is changed to where "
"the primary filesystem is mounted."
msgstr ""

#: ../../reference/filesystem.rst:35
msgid ""
"On STM32 / Pyboard, the internal flash is mounted at ``/flash``, and "
"optionally the SDCard at ``/sd``. On ESP8266/ESP32, the primary "
"filesystem is mounted at ``/``."
msgstr ""

#: ../../reference/filesystem.rst:40
msgid "Block devices"
msgstr ""

#: ../../reference/filesystem.rst:42
msgid ""
"A block device is an instance of a class that implements the "
":class:`uos.AbstractBlockDev` protocol."
msgstr ""

#: ../../reference/filesystem.rst:46
msgid "Built-in block devices"
msgstr ""

#: ../../reference/filesystem.rst:48
msgid "Ports provide built-in block devices to access their primary flash."
msgstr ""

#: ../../reference/filesystem.rst:50
msgid ""
"On power-on, MicroPython will attempt to detect the filesystem on the "
"default flash and configure and mount it automatically. If no filesystem "
"is found, MicroPython will attempt to create a FAT filesystem spanning "
"the entire flash. Ports can also provide a mechanism to \"factory reset\""
" the primary flash, usually by some combination of button presses at "
"power on."
msgstr ""

#: ../../reference/filesystem.rst:57
msgid "STM32 / Pyboard"
msgstr ""

#: ../../reference/filesystem.rst:59
msgid ""
"The :ref:`pyb.Flash <pyb.Flash>` class provides access to the internal "
"flash. On some boards which have larger external flash (e.g. Pyboard D), "
"it will use that instead. The ``start`` kwarg should always be specified,"
" i.e. ``pyb.Flash(start=0)``."
msgstr ""

#: ../../reference/filesystem.rst:64
msgid ""
"Note: For backwards compatibility, when constructed with no arguments "
"(i.e. ``pyb.Flash()``), it only implements the simple block interface and"
" reflects the virtual device presented to USB MSC (i.e. it includes a "
"virtual partition table at the start)."
msgstr ""

#: ../../reference/filesystem.rst:70
msgid "ESP8266"
msgstr ""

#: ../../reference/filesystem.rst:72
msgid ""
"The internal flash is exposed as a block device object which is created "
"in the ``flashbdev`` module on start up. This object is by default added "
"as a global variable so it can usually be accessed simply as ``bdev``. "
"This implements the extended interface."
msgstr ""

#: ../../reference/filesystem.rst:78 ../../reference/filesystem.rst:182
msgid "ESP32"
msgstr ""

#: ../../reference/filesystem.rst:80
msgid ""
"The :class:`esp32.Partition` class implements a block device for "
"partitions defined for the board. Like ESP8266, there is a global "
"variable ``bdev`` which points to the default partition. This implements "
"the extended interface."
msgstr ""

#: ../../reference/filesystem.rst:85
msgid "Custom block devices"
msgstr ""

#: ../../reference/filesystem.rst:87
msgid ""
"The following class implements a simple block device that stores its data"
" in RAM using a ``bytearray``::"
msgstr ""

#: ../../reference/filesystem.rst:90
msgid ""
"class RAMBlockDev:\n"
"    def __init__(self, block_size, num_blocks):\n"
"        self.block_size = block_size\n"
"        self.data = bytearray(block_size * num_blocks)\n"
"\n"
"    def readblocks(self, block_num, buf):\n"
"        for i in range(len(buf)):\n"
"            buf[i] = self.data[block_num * self.block_size + i]\n"
"\n"
"    def writeblocks(self, block_num, buf):\n"
"        for i in range(len(buf)):\n"
"            self.data[block_num * self.block_size + i] = buf[i]\n"
"\n"
"    def ioctl(self, op, arg):\n"
"        if op == 4: # get number of blocks\n"
"            return len(self.data) // self.block_size\n"
"        if op == 5: # get block size\n"
"            return self.block_size"
msgstr ""
"class RAMBlockDev:\n"
"    def __init__(self, block_size, num_blocks):\n"
"        self.block_size = block_size\n"
"        self.data = bytearray(block_size * num_blocks)\n"
"\n"
"    def readblocks(self, block_num, buf):\n"
"        for i in range(len(buf)):\n"
"            buf[i] = self.data[block_num * self.block_size + i]\n"
"\n"
"    def writeblocks(self, block_num, buf):\n"
"        for i in range(len(buf)):\n"
"            self.data[block_num * self.block_size + i] = buf[i]\n"
"\n"
"    def ioctl(self, op, arg):\n"
"        if op == 4: # ブロック数を取得\n"
"            return len(self.data) // self.block_size\n"
"        if op == 5: # ブロックサイズを取得\n"
"            return self.block_size"

#: ../../reference/filesystem.rst:109
msgid "It can be used as follows::"
msgstr "次のように使えます::"

#: ../../reference/filesystem.rst:111
msgid ""
"import os\n"
"\n"
"bdev = RAMBlockDev(512, 50)\n"
"os.VfsFat.mkfs(bdev)\n"
"os.mount(bdev, '/ramdisk')"
msgstr ""

#: ../../reference/filesystem.rst:117
msgid ""
"An example of a block device that supports both the simple and extended "
"interface (i.e. both signatures and behaviours of the "
":meth:`uos.AbstractBlockDev.readblocks` and "
":meth:`uos.AbstractBlockDev.writeblocks` methods) is::"
msgstr ""

#: ../../reference/filesystem.rst:122
msgid ""
"class RAMBlockDev:\n"
"    def __init__(self, block_size, num_blocks):\n"
"        self.block_size = block_size\n"
"        self.data = bytearray(block_size * num_blocks)\n"
"\n"
"    def readblocks(self, block_num, buf, offset=0):\n"
"        addr = block_num * self.block_size + offset\n"
"        for i in range(len(buf)):\n"
"            buf[i] = self.data[addr + i]\n"
"\n"
"    def writeblocks(self, block_num, buf, offset=None):\n"
"        if offset is None:\n"
"            # do erase, then write\n"
"            for i in range(len(buf) // self.block_size):\n"
"                self.ioctl(6, block_num + i)\n"
"            offset = 0\n"
"        addr = block_num * self.block_size + offset\n"
"        for i in range(len(buf)):\n"
"            self.data[addr + i] = buf[i]\n"
"\n"
"    def ioctl(self, op, arg):\n"
"        if op == 4: # block count\n"
"            return len(self.data) // self.block_size\n"
"        if op == 5: # block size\n"
"            return self.block_size\n"
"        if op == 6: # block erase\n"
"            return 0"
msgstr ""

#: ../../reference/filesystem.rst:150
msgid ""
"As it supports the extended interface, it can be used with "
":class:`littlefs <uos.VfsLfs2>`::"
msgstr ""

#: ../../reference/filesystem.rst:153
msgid ""
"import os\n"
"\n"
"bdev = RAMBlockDev(512, 50)\n"
"os.VfsLfs2.mkfs(bdev)\n"
"os.mount(bdev, '/ramdisk')"
msgstr ""

#: ../../reference/filesystem.rst:159
msgid ""
"Once mounted, the filesystem (regardless of its type) can be used as it "
"normally would be used from Python code, for example::"
msgstr ""

#: ../../reference/filesystem.rst:162
msgid ""
"with open('/ramdisk/hello.txt', 'w') as f:\n"
"    f.write('Hello world')\n"
"print(open('/ramdisk/hello.txt').read())"
msgstr ""

#: ../../reference/filesystem.rst:167
msgid "Filesystems"
msgstr ""

#: ../../reference/filesystem.rst:169
msgid ""
"MicroPython ports can provide implementations of :class:`FAT "
"<uos.VfsFat>`, :class:`littlefs v1 <uos.VfsLfs1>` and :class:`littlefs v2"
" <uos.VfsLfs2>`."
msgstr ""

#: ../../reference/filesystem.rst:172
msgid ""
"The following table shows which filesystems are included in the firmware "
"by default for given port/board combinations, however they can be "
"optionally enabled in a custom firmware build."
msgstr ""

#: ../../reference/filesystem.rst:177
msgid "Board"
msgstr ""

#: ../../reference/filesystem.rst:177 ../../reference/filesystem.rst:186
msgid "FAT"
msgstr ""

#: ../../reference/filesystem.rst:177
msgid "littlefs v1"
msgstr ""

#: ../../reference/filesystem.rst:177
msgid "littlefs v2"
msgstr ""

#: ../../reference/filesystem.rst:179
msgid "pyboard 1.0, 1.1, D"
msgstr ""

#: ../../reference/filesystem.rst:179 ../../reference/filesystem.rst:180
#: ../../reference/filesystem.rst:181 ../../reference/filesystem.rst:182
msgid "Yes"
msgstr ""

#: ../../reference/filesystem.rst:179 ../../reference/filesystem.rst:180
#: ../../reference/filesystem.rst:181 ../../reference/filesystem.rst:182
msgid "No"
msgstr ""

#: ../../reference/filesystem.rst:180
msgid "Other STM32"
msgstr ""

#: ../../reference/filesystem.rst:181
msgid "ESP8266 (1M)"
msgstr ""

#: ../../reference/filesystem.rst:182
msgid "ESP8266 (2M+)"
msgstr ""

#: ../../reference/filesystem.rst:189
msgid ""
"The main advantage of the FAT filesystem is that it can be accessed over "
"USB MSC on supported boards (e.g. STM32) without any additional drivers "
"required on the host PC."
msgstr ""

#: ../../reference/filesystem.rst:193
msgid ""
"However, FAT is not tolerant to power failure during writes and this can "
"lead to filesystem corruption. For applications that do not require USB "
"MSC, it is recommended to use littlefs instead."
msgstr ""

#: ../../reference/filesystem.rst:197
msgid "To format the entire flash using FAT::"
msgstr ""

#: ../../reference/filesystem.rst:199
msgid ""
"# ESP8266 and ESP32\n"
"import os\n"
"os.umount('/')\n"
"os.VfsFat.mkfs(bdev)\n"
"os.mount(bdev, '/')\n"
"\n"
"# STM32\n"
"import os, pyb\n"
"os.umount('/flash')\n"
"os.VfsFat.mkfs(pyb.Flash(start=0))\n"
"os.mount(pyb.Flash(start=0), '/flash')\n"
"os.chdir('/flash')"
msgstr ""

#: ../../reference/filesystem.rst:213
msgid "Littlefs"
msgstr ""

#: ../../reference/filesystem.rst:215
msgid ""
"Littlefs_ is a filesystem designed for flash-based devices, and is much "
"more resistant to filesystem corruption."
msgstr ""

#: ../../reference/filesystem.rst:218
msgid ""
"There are reports of littlefs v1 and v2 failing in certain situations, "
"for details see `littlefs issue 347`_  and `littlefs issue 295`_."
msgstr ""

#: ../../reference/filesystem.rst:223
msgid ""
"Note: It can be still be accessed over USB MSC using the `littlefs FUSE "
"driver`_. Note that you must use the ``-b=4096`` option to override the "
"block size."
msgstr ""

#: ../../reference/filesystem.rst:231
msgid "To format the entire flash using littlefs v2::"
msgstr ""

#: ../../reference/filesystem.rst:233
msgid ""
"# ESP8266 and ESP32\n"
"import os\n"
"os.umount('/')\n"
"os.VfsLfs2.mkfs(bdev)\n"
"os.mount(bdev, '/')\n"
"\n"
"# STM32\n"
"import os, pyb\n"
"os.umount('/flash')\n"
"os.VfsLfs2.mkfs(pyb.Flash(start=0))\n"
"os.mount(pyb.Flash(start=0), '/flash')\n"
"os.chdir('/flash')"
msgstr ""

#: ../../reference/filesystem.rst:247
msgid "Hybrid (STM32)"
msgstr ""

#: ../../reference/filesystem.rst:249
msgid ""
"By using the ``start`` and ``len`` kwargs to :class:`pyb.Flash`, you can "
"create block devices spanning a subset of the flash device."
msgstr ""

#: ../../reference/filesystem.rst:252
msgid ""
"For example, to configure the first 256kiB as FAT (and available over USB"
" MSC), and the remainder as littlefs::"
msgstr ""

#: ../../reference/filesystem.rst:255
msgid ""
"import os, pyb\n"
"os.umount('/flash')\n"
"p1 = pyb.Flash(start=0, len=256*1024)\n"
"p2 = pyb.Flash(start=256*1024)\n"
"os.VfsFat.mkfs(p1)\n"
"os.VfsLfs2.mkfs(p2)\n"
"os.mount(p1, '/flash')\n"
"os.mount(p2, '/data')\n"
"os.chdir('/flash')"
msgstr ""

#: ../../reference/filesystem.rst:265
msgid ""
"This might be useful to make your Python files, configuration and other "
"rarely-modified content available over USB MSC, but allowing for "
"frequently changing application data to reside on littlefs with better "
"resilience to power failure, etc."
msgstr ""

#: ../../reference/filesystem.rst:270
msgid ""
"The partition at offset ``0`` will be mounted automatically (and the "
"filesystem type automatically detected), but you can add::"
msgstr ""

#: ../../reference/filesystem.rst:273
msgid ""
"import os, pyb\n"
"p2 = pyb.Flash(start=256*1024)\n"
"os.mount(p2, '/data')"
msgstr ""

#: ../../reference/filesystem.rst:277
msgid "to ``boot.py`` to mount the data partition."
msgstr ""

#: ../../reference/filesystem.rst:280
msgid "Hybrid (ESP32)"
msgstr ""

#: ../../reference/filesystem.rst:282
msgid ""
"On ESP32, if you build custom firmware, you can modify ``partitions.csv``"
" to define an arbitrary partition layout."
msgstr ""

#: ../../reference/filesystem.rst:285
msgid ""
"At boot, the partition named \"vfs\" will be mounted at ``/`` by default,"
" but any additional partitions can be mounted in your ``boot.py`` using::"
msgstr ""

#: ../../reference/filesystem.rst:288
msgid ""
"import esp32, os\n"
"p = esp32.Partition.find(esp32.Partition.TYPE_DATA, label='foo')\n"
"os.mount(p, '/foo')"
msgstr ""

#: ../../../reference/glossary.rst:2
msgid "Glossary"
msgstr "用語集"

#: ../../../reference/glossary.rst:5
msgid "baremetal"
msgstr "ベアメタル"

#: ../../../reference/glossary.rst:7
msgid ""
"A system without a (full-fledged) operating system, for example "
"an :term:`MCU`-based system. When running on a baremetal system, "
"MicroPython effectively functions like a small operating system, "
"running user programs and providing a command interpreter "
"(:term:`REPL`)."
msgstr ""
":term:`MCU` ベースのシステムなど、(本格的な) OSのないシステム。ベアメタルのシステム上で"
"は MicroPython が事実上、コマンドインタプリタ(REPL)を備えた小さなOSのように"
"機能します。"

#: ../../../reference/glossary.rst:13
msgid "buffer protocol"
msgstr "バッファプロトコル"

#: ../../../reference/glossary.rst:14
msgid ""
"Any Python object that can be automatically converted into bytes, such "
"as ``bytes``, ``bytearray``, ``memoryview`` and ``str`` objects, which "
"all implement the \"buffer protocol\"."
msgstr ""
"``bytes``, ``bytearray``, ``memoryview``, ``str`` オブジェクトなど、"
"自動的にバイト列に変換することができる任意の Python オブジェクトはどれも"
"「バッファプロトコル」を備えています。"

#: ../../../reference/glossary.rst:18
msgid "board"
msgstr "ボード"

#: ../../../reference/glossary.rst:13
msgid ""
"Typically this refers to a printed circuit board (PCB) containing a "
":term:`microcontroller <MCU>` and supporting components. "
"MicroPython firmware is typically provided per-board, as the firmware "
"contains both MCU-specific functionality but also board-level "
"functionality such as drivers or pin names."
msgstr ""
"通常、これは、 :term:`マイクロコントローラ <MCU>` とサポートコンポーネントを含む"
"プリント回路基板（PCB）を指します。MicroPython ファームウェアは通常、ボードごとに"
"提供されます。ファームウェアには、MCU 固有の機能だけでなく、ドライバーやピン名などの"
"ボードレベルの機能も含まれているためです。"

#: ../../../reference/glossary.rst:25
msgid "bytecode"
msgstr "バイトコード"

#: ../../../reference/glossary.rst:26
msgid ""
"A compact representation of a Python program that generated by "
"compiling the Python source code. This is what the VM actually "
"executes. Bytecode is typically generated automatically at runtime and "
"is invisible to the user. Note that while :term:`CPython` and "
"MicroPython both use bytecode, the format is different. You can also "
"pre-compile source code offline using the :term:`cross-compiler`."
msgstr ""
"Python ソースコードをコンパイルして生成された Python プログラムのコンパクトな表現。"
"これは、VM が実際に実行するものです。バイトコードは通常、実行時に自動的に生成され、"
"ユーザーには見えません。CPython と MicroPython はどちらもバイトコードを使用しますが、"
"形式は異なることに注意してください。また、クロスコンパイラを使用してソースコードを"
"オフラインでプリコンパイルすることもできます。"

#: ../../../reference/glossary.rst:33
msgid "callee-owned tuple"
msgstr "呼出し先所有タプル"

#: ../../../reference/glossary.rst:34
msgid ""
"This is a MicroPython-specific construct where, for efficiency "
"reasons, some built-in functions or methods may re-use the same "
"underlying tuple object to return data. This avoids having to allocate "
"a new tuple for every call, and reduces heap fragmentation. Programs "
"should not hold references to callee-owned tuples and instead only "
"extract data from them (or make a copy)."
msgstr ""
"これは、効率上の理由から一部の組み込み関数またはメソッドが同じ基本タプルオブジェクトを"
"再利用してデータを返す MicroPython 固有の構造です。これにより呼び出しごとに新しい"
"タプルを割り当てる必要がなくなり、ヒープの断片化が減少します。プログラムは、呼び出し先が"
"所有するタプルへの参照を保持せず、代わりにそれらからデータを抽出する（またはコピーする）"
"だけである必要があります。"

#: ../../../reference/glossary.rst:41
msgid "CircuitPython"
msgstr ""

#: ../../../reference/glossary.rst:42
msgid ""
"A variant of MicroPython developed by `Adafruit Industries "
"<https://circuitpython.org>`_."
msgstr ""
"`Adafruit Industries <https://circuitpython.org>`_ が開発"
"した MicroPython の亜種。"

#: ../../../reference/glossary.rst:41
msgid "CPython"
msgstr ""

#: ../../../reference/glossary.rst:43
msgid ""
"CPython is the reference implementation of the Python programming "
"language, and the most well-known one. It is, however, one of many "
"implementations (including Jython, IronPython, PyPy, and MicroPython). "
"While MicroPython's implementation differs substantially from CPython, "
"it aims to maintain as much compatibility as possible."
msgstr ""
"CPython は Python プログラミング言語のリファレンス実装であり、最も有名なものです。"
"それでも多くの処理系（Jython, IronPython, PyPy, MicroPython を含む）の中の"
"一つです。MicroPython の実装は CPython とは大幅に異なりますが、可能な限り互換性を"
"維持することを目指しています。"

#: ../../../reference/glossary.rst:52
msgid "cross-compiler"
msgstr "クロスコンパイラ"

#: ../../../reference/glossary.rst:53
msgid ""
"Also known as ``mpy-cross``. This tool runs on your PC and converts a "
":term:`.py file` containing MicroPython code into a :term:`.mpy file` "
"containing MicroPython bytecode. This means it loads faster (the board "
"doesn't have to compile the code), and uses less space on flash (the "
"bytecode is more space efficient)."
msgstr ""
"``mpy-cross`` としても知られています。このツールは PC 上で動作し、MicroPython "
"コードで書いた :term:`.py ファイル` を MicroPython バイトコードを含んだ "
":term:`.mpy ファイル` ファイルに変換します。 これにより、ロードが高速になり"
"（ボードがコードをコンパイルする必要がない）、フラッシュ上のスペースが少なくなります"
"（バイトコードはスペース効率が高い）。"

#: ../../../reference/glossary.rst:59
msgid "driver"
msgstr "ドライバ"

#: ../../../reference/glossary.rst:60
msgid ""
"A MicroPython library that implements support for a particular "
"component, such as a sensor or display."
msgstr ""
"センサーやディスプレイなどの特定のコンポーネントのサポートを実装する "
"MicroPython ライブラリ。"

#: ../../../reference/glossary.rst:63
msgid "FFI"
msgstr ""

#: ../../../reference/glossary.rst:64
msgid ""
"Acronym for Foreign Function Interface. A mechanism used by the "
":term:`MicroPython Unix port` to access operating system functionality. "
"This is not available on :term:`baremetal` ports."
msgstr ""
"Foreign Function Interface の頭字語。MicroPython Unix ポートが"
"オペレーティングシステムの機能にアクセスするために使用するメカニズム。"
"これは、ベアメタルポートでは使用できません。"

#: ../../../reference/glossary.rst:68
msgid "filesystem"
msgstr "ファイルシステム"

#: ../../../reference/glossary.rst:69
msgid ""
"Most MicroPython ports and boards provide a filesystem stored in flash "
"that is available to user code via the standard Python file APIs such "
"as ``open()``. Some boards also make this internal filesystem "
"accessible to the host via USB mass-storage."
msgstr ""
"ほとんどの MicroPython ポートおよびボードは、フラッシュに保存されるファイルシステムを"
"提供します。これは ``open()`` などの標準 Python ファイル API を介してユーザーコード"
"から利用できます。一部のボードでは、この内部ファイルシステムを USB マスストレージを"
"介してホストからアクセス可能にします。"

#: ../../../reference/glossary.rst:74
msgid "frozen module"
msgstr "凍結モジュール"

#: ../../../reference/glossary.rst:75
msgid ""
"A Python module that has been cross compiled and bundled into the "
"firmware image. This reduces RAM requirements as the code is executed "
"directly from flash."
msgstr ""
"クロスコンパイルされ、ファームウェアイメージにバンドルされている Python モジュール。"
"これにより、コードがフラッシュから直接実行されるため、RAM の使用量が軽減されます。"

#: ../../../reference/glossary.rst:79
msgid "Garbage Collector"
msgstr "ガベージコレクター"

#: ../../../reference/glossary.rst:80
msgid ""
"A background process that runs in Python (and MicroPython) to reclaim "
"unused memory in the :term:`heap`."
msgstr ""
":term:`ヒープ`　内の未使用メモリを再利用するために Python（およびMicroPython）で"
"実行されるバックグラウンドプロセス。"

#: ../../../reference/glossary.rst:83
msgid "GPIO"
msgstr ""

#: ../../../reference/glossary.rst:84
msgid ""
"General-purpose input/output. The simplest means to control electrical "
"signals (commonly referred to as \"pins\") on a microcontroller. GPIO "
"typically allows pins to be either input or output, and to set or get "
"their digital value (logical \"0\" or \"1\"). MicroPython abstracts GPIO "
"access using the :class:`machine.Pin` and :class:`machine.Signal` "
"classes."
msgstr ""
"汎用入出力(General-purpose input/output)のこと。電気信号（一般的に「ピン」と"
"呼びます）を制御する最も簡単な手段です。GPIO を使用すると、ハードウェア信号ピンを"
"入力または出力に設定し、デジタル信号値(論理 \"0\" または \"1\")を設定または取得"
"できます。MicroPython は :class:`machine.Pin` と :class:`machine.Signal` "
"クラスを使って GPIO アクセスを抽象化しています。"

#: ../../../reference/glossary.rst:91
msgid "GPIO port"
msgstr "GPIO ポート"

#: ../../../reference/glossary.rst:92
msgid ""
"A group of :term:`GPIO` pins, usually based on hardware properties of "
"these pins (e.g. controllable by the same register)."
msgstr ""
"`GPIO` ピンのグループのことで、通常、これらのピンのハードウェア特性に基づいています"
"(たとえば、同じレジスタで制御可能であるなど)。"

#: ../../../reference/glossary.rst:95
msgid "heap"
msgstr "ヒープ"

#: ../../../reference/glossary.rst:96
msgid ""
"A region of RAM where MicroPython stores dynamic data. It is managed "
"automatically by the :term:`Garbage Collector`. Different MCUs and "
"boards have vastly different amounts of RAM available for the heap, so "
"this will affect how complex your program can be."
msgstr ""
"MicroPython が動的データを保存する RAM 領域。ヒープは :term:`ガベージコレクター` "
"によって自動的に管理されます。MCU や ボードによって、ヒープに使用できるRAMの容量が"
"大きく異なるため、どれだけ複雑なプログラムを作れるかに影響します。"

#: ../../../reference/glossary.rst:101
msgid "interned string"
msgstr "隔離化文字列"

#: ../../../reference/glossary.rst:102
msgid ""
"An optimisation used by MicroPython to improve the efficiency of "
"working with strings. An interned string is referenced by its (unique) "
"identity rather than its address and can therefore be quickly compared "
"just by its identifier. It also means that identical strings can be "
"de-duplicated in memory. String interning is almost always invisible to "
"the user."
msgstr ""
"MicroPython が文字列の処理効率を向上させるために使う最適化。隔離化文字列は、"
"アドレスではなくその（一意の）識別子で参照するため、識別子だけで高速に比較できます。"
"また、同じ文字列をメモリ内で重複排除できることも意味します。文字列の隔離については、"
"ユーザが意識することはほとんどありません。"

#: ../../../reference/glossary.rst:83
msgid "MCU"
msgstr ""

#: ../../../reference/glossary.rst:85
msgid ""
"Microcontroller. Microcontrollers usually have much less resources "
"than a desktop, laptop, or phone, but are smaller, cheaper and "
"require much less power. MicroPython is designed to be small and "
"optimized enough to run on an average modern microcontroller."
msgstr ""
"マイクロコントローラのこと。マイクロコントローラは通常、デスクトップ、ラップトップ、"
"スマートフォンよりもはるかに少ないリソースしかありませんが、小型で安価であり、"
"消費電力は非常に少なくて済みます。MicroPython は、平均的な最新の"
"マイクロコントローラで動作するよう、十分小さく、最適化されています。"

#: ../../../reference/glossary.rst:115
msgid "micropython-lib"
msgstr ""

#: ../../../reference/glossary.rst:116
msgid ""
"MicroPython is (usually) distributed as a single executable/binary "
"file with just few builtin modules. There is no extensive standard "
"library comparable with :term:`CPython`'s. Instead, there is a related, "
"but separate project `micropython-lib "
"<https://github.com/micropython/micropython-lib>`_ which provides "
"implementations for many modules from CPython's standard library."
msgstr ""
"MicroPython は(通常)わずかな組込みモジュールしか持たない単一の実行可能/バイナリ"
"ファイルとして配布されます。 :term:`CPython` に匹敵する広範な標準ライブラリは"
"ありません。代わりに、関連しているが別個のプロジェクト "
"`micropython-lib <https://github.com/micropython/micropython-lib>`_ "
"があり、CPython の標準ライブラリにある多くのモジュールの実装を提供しています。"

#: ../../../reference/glossary.rst:123
msgid ""
"Some of the modules are are implemented in pure Python, and are able to "
"be used on all ports. However, the majority of these modules use "
":term:`FFI` to access operating system functionality, and as such can "
"only be used on the :term:`MicroPython Unix port` (with limited support "
"for Windows)."
msgstr ""
"一部のモジュールは純粋な Python で実装されており、すべてのポートで使用できます。"
"しかし、micropython-lib のモジュールの大部分は、 FFIを使用してオペレーティング"
"システムの機能にアクセスするため、MicroPython Unixポートでのみしか利用できません"
"（Windows のサポートも限定的です）。"

#: ../../../reference/glossary.rst:129
msgid ""
"Unlike the :term:`CPython` stdlib, micropython-lib modules are "
"intended to be installed individually - either using manual copying or "
"using :term:`upip`."
msgstr ""
":term:`CPython` の stdlib とは異なり、micropython-lib モジュールは、"
"個別にインストールしなければなりません。この手段としては手動コピーするか、 "
":term:`upip` を使います。"

#: ../../../reference/glossary.rst:133
msgid "MicroPython port"
msgstr "MicroPython ポート"

#: ../../../reference/glossary.rst:134
msgid ""
"MicroPython supports different :term:`boards <board>`, RTOSes, and "
"OSes, and can be relatively easily adapted to new systems. MicroPython "
"with support for a particular system is called a \"port\" to that "
"system. Different ports may have widely different functionality. This "
"documentation is intended to be a reference of the generic APIs "
"available across different ports (\"MicroPython core\"). Note that some "
"ports may still omit some APIs described here (e.g. due to resource "
"constraints). Any such differences, and port-specific extensions "
"beyond the MicroPython core functionality, would be described in the "
"separate port-specific documentation."
msgstr ""
"MicroPython はさまざまな :term:`ボード <board>` 、RTOS、OS をサポートしており、"
"新しいシステムに比較的容易に適応できます。特定のシステムをサポートする MicroPython "
"は、そのシステムの「ポート」と呼ばれます。異なるポートは、機能が大きく異なる場合が"
"あります。このドキュメントは、異なるポート間で利用可能な汎用API (「MicroPythonコア」）の"
"リファレンスを意図しています。一部のポートでは、ここで説明されているいくつかの "
"API (リソースの制約など)がまだ省略されていることに注意してください。このような"
"違いや、MicroPython のコア機能を超えるポート固有の拡張機能については、それぞれの"
"ポート固有のマニュアルに記載されています。"

#: ../../../reference/glossary.rst:145
msgid "MicroPython Unix port"
msgstr "MicroPython Unix ポート"

#: ../../../reference/glossary.rst:146
msgid ""
"The unix port is one of the major :term:`MicroPython ports "
"<MicroPython port>`. It is intended to run on POSIX-compatible "
"operating systems, like Linux, MacOS, FreeBSD, Solaris, etc. It also "
"serves as the basis of Windows port. The Unix port is very useful for "
"quick development and testing of the MicroPython language and "
"machine-independent features. It can also function in a similar way to "
":term:`CPython`'s ``python`` executable."
msgstr ""
"Unix ポートは、主要な :term:`MicroPython ポート <MicroPython port>` の"
"１つです。これは、Linux, MacOS, FreeBSD, Solaris などの POSIX 互換"
"オペレーティングシステム上で動作するように意図されています。これは、Windows "
"ポートの基礎としても機能します。Unixポートは、MicroPython 言語とマシンに"
"依存しない機能の迅速な開発とテストに非常に役立ちます。 ":term:`CPython` の "
"``python`` 実行ファイルと同様の方法で機能することもできます。"

#: ../../../reference/glossary.rst:154
msgid ".mpy file"
msgstr ".mpy ファイル"

#: ../../../reference/glossary.rst:155
msgid ""
"The output of the :term:`cross-compiler`. A compiled form of a "
":term:`.py file` that contains MicroPython bytecode instead of Python "
"source code."
msgstr ""
":term:`クロスコンパイラ` の出力。 :term:`.py ファイル` からコンパイル"
"したものであり、Python ソースコードの代わりに MicroPython バイトコードを"
"含みます。"

#: ../../../reference/glossary.rst:159
msgid "native"
msgstr "ネイティブ"

#: ../../../reference/glossary.rst:160
msgid ""
"Usually refers to \"native code\", i.e. machine code for the target "
"microcontroller (such as ARM Thumb, Xtensa, x86/x64). The ``@native`` "
"decorator can be applied to a MicroPython function to generate native "
"code instead of bytecode for that function, which will likely be "
"faster but use more RAM."
msgstr ""
"通常、「ネイティブコード」、つまりターゲットマイクロコントローラーのマシンコード"
"（ARM Thumb, Xtensa, x86/x64 など）を指します。 ``@native`` デコレータを"
"MacroPython 関数に適用すると、バイトコードを生成する代わりにネイティブコードを"
"生成するようになり、おそらく高速にはなりますが、RAM をより多く使ってしまいます。"

#: ../../../reference/glossary.rst:166
msgid "port"
msgstr "ポート"

#: ../../../reference/glossary.rst:167
msgid ""
"Usually short for :term:`MicroPython port`, but could also refer to "
":term:`GPIO port`."
msgstr ""
"通常は :term:`MicroPython ポート` の略ですが、 :term:`GPIOポート` "
"を指していることもあります。"

#: ../../../reference/glossary.rst:166
msgid ".py file"
msgstr ".py ファイル"

#: ../../../reference/glossary.rst:167
msgid ""
"A file containing Python source code."
msgstr ""
"Python ソースコードが書き込まれたファイル。"

#: ../../../reference/glossary.rst:173
msgid "REPL"
msgstr ""

#: ../../../reference/glossary.rst:174
msgid ""
"An acronym for \"Read, Eval, Print, Loop\". This is the interactive "
"Python prompt, useful for debugging or testing short snippets of code. "
"Most MicroPython boards make a REPL available over a UART, and this is "
"typically accessible on a host PC via USB."
msgstr ""
"「Read（読み取り）、Eval（評価）、Print（印字）、Loop（ループ）」の頭字語。"
"これは対話的な Python プロンプト であり、短いコードスニペットのデバッグや"
"テストをするのに便利です。ほとんどの MicroPython ボードでは、UART を介して "
"REPL を利用できます。これは通常、ホストPCでUSB経由でアクセスできます。"

#: ../../../reference/glossary.rst:179
msgid "stream"
msgstr "ストリーム"

#: ../../../reference/glossary.rst:180
msgid ""
"Also known as a \"file-like object\". An Python object which provides "
"sequential read-write access to the underlying data. A stream object "
"implements a corresponding interface, which consists of methods like "
"``read()``, ``write()``, ``readinto()``, ``seek()``, ``flush()``, "
"``close()``, etc. A stream is an important concept in MicroPython; "
"many I/O objects implement the stream interface, and thus can be used "
"consistently and interchangeably in different contexts. For more "
"information on streams in MicroPython, see the `uio` module."
msgstr ""
"「ファイルのようなオブジェクト」とも呼ばれます。基礎となるデータへの連続的な読み書き"
"アクセスを提供するオブジェクトです。ストリームオブジェクトは対応するインタフェースを"
"実装したもので、 ``read()``, ``write()``, ``readinto()``, ``seek()``, "
"``flush()``, ``close()`` などのメソッドを持ちます。ストリームは MicroPython "
"における重要な概念であり、多くの I/O オブジェクトはストリームインタフェースを実装"
"しているので、異なるコンテキスト間でも一貫かつ交換可能に使えます。"
"MicroPython のストリームの詳細については、 `uio` モジュールを参照してください。"

#: ../../../reference/glossary.rst:189
msgid "UART"
msgstr ""

#: ../../../reference/glossary.rst:190
msgid ""
"Acronym for \"Universal Asynchronous Receiver/Transmitter\". This is a "
"peripheral that sends data over a pair of pins (TX & RX). Many boards "
"include a way to make at least one of the UARTs available to a host PC "
"as a serial port over USB."
msgstr ""
"\"Universal Asynchronous Receiver/Transmitter\" の頭字語。"
"これは、ピンのペア(TX と RX）を介してデータを送信するペリフェラルです。"
"多くのボードには、少なくとも１つの UART をホストPCの USB 経由の"
"シリアルポートとして使えるようになっています。"

#: ../../../reference/glossary.rst:195
msgid "upip"
msgstr ""

#: ../../../reference/glossary.rst:196
msgid ""
"(Literally, \"micro pip\"). A package manager for MicroPython, inspired "
"by :term:`CPython`'s pip, but much smaller and with reduced "
"functionality. "
"upip runs both on the :term:`Unix port <MicroPython Unix port>` and on "
":term:`baremetal` ports which offer filesystem and networking support."
msgstr ""
"(言い換えれば「マイクロ pip」)。MicroPython のパッケージマネージャーは "
":term:`CPython` の pip に影響されていますが、はるかに小さく、限定された"
"機能になっています。upip は :term:`Unix ポート <MicroPython Unix port>` "
"と、ファイルシステムとネットワークをサポートした :term:`ベアメタル` ポート"
"の両方で動作します。"

#: ../../../reference/index.rst:2
msgid "MicroPython language and implementation"
msgstr "MicroPython 言語と処理系"

#: ../../../reference/index.rst:4
msgid ""
"MicroPython aims to implement the Python 3.4 standard (with selected "
"features from later versions) with respect to language syntax, and most "
"of the features of MicroPython are identical to those described by the "
"\"Language Reference\" documentation at `docs.python.org "
"<https://docs.python.org/3/reference/index.html>`_."
msgstr ""
"MicroPython は、言語の構文に関しては Python 3.4 標準(と後のバージョン"
"から選択した機能)の実装を目指しています。MicroPython のほとんどの機能は、"
"`docs.python.org <https://docs.python.org/ja/3/reference/index.html>`_ "
"にある「言語リファレンス」ドキュメントで説明しているものと同じです。"

#: ../../../reference/index.rst:10
msgid ""
"The MicroPython standard library is described in the :ref:`corresponding "
"chapter <micropython_lib>`. The :ref:`cpython_diffs` chapter describes "
"differences between MicroPython and CPython (which mostly concern "
"standard library and types, but also some language-level features)."
msgstr ""
"MicroPython の標準ライブラリについては、 :ref:該当する章 <micropython_lib>` "
"で説明しています。 :ref:`cpython_diffs` 章では、MicroPython と CPython の間の"
"違いについて説明しています(主に標準ライブラリとデータ型についての注意となりますが、"
"言語レベルの機能についてもいくつかあります)。"

#: ../../../reference/index.rst:16
msgid ""
"This chapter describes features and peculiarities of MicroPython "
"implementation and the best practices to use them."
msgstr ""
"この章では MicroPython 処理系の機能と特徴、およびそれらを使用するための"
"ベストプラクティスについて説明します。"

#: ../../../reference/isr_rules.rst:4
msgid "Writing interrupt handlers"
msgstr "割り込みハンドラの作成"

#: ../../../reference/isr_rules.rst:6
msgid ""
"On suitable hardware MicroPython offers the ability to write interrupt "
"handlers in Python. Interrupt handlers - also known as interrupt service "
"routines (ISR's) - are defined as callback functions. These are executed "
"in response to an event such as a timer trigger or a voltage change on a "
"pin. Such events can occur at any point in the execution of the program "
"code. This carries significant consequences, some specific to the "
"MicroPython language. Others are common to all systems capable of "
"responding to real time events. This document covers the language "
"specific issues first, followed by a brief introduction to real time "
"programming for those new to it."
msgstr ""
"適切なハードウェア上で MicroPython は、Python で割り込みハンドラを書く能力を提供"
"します。割り込みハンドラ(割り込みサービスルーチン - ISR とも呼ばれます)は、コール"
"バック関数として定義されています。これらはタイマトリガやピンの電圧変化などのイベントに"
"応答して実行されます。このような事象は、プログラムコードの実行中の任意の時点で発生する"
"可能性があります。これは MicroPython 言語に特有の重要な結果をもたらします。その他の"
"ものは、リアルタイムイベントに応答することができるすべてのシステムに共通です。この"
"ドキュメントでは、まず言語特有の問題について説明し、それに続いてリアルタイム"
"プログラミングの概要を説明します。"

#: ../../../reference/isr_rules.rst:13
msgid ""
"This introduction uses vague terms like \"slow\" or \"as fast as "
"possible\". This is deliberate, as speeds are application dependent. "
"Acceptable durations for an ISR are dependent on the rate at which "
"interrupts occur, the nature of the main program, and the presence of "
"other concurrent events."
msgstr ""
"ここの紹介では、「遅い」または「できるだけ早く」のような曖昧な用語を使っています。"
"速度はアプリケーションに依存するため、これは意図的なものです。ISR の許容可能な"
"期間は、割り込みが発生する速度、メインプログラムの性質、および他の同時発生イベントの"
"存在に依存します。"

#: ../../../reference/isr_rules.rst:18
msgid "Tips and recommended practices"
msgstr "ヒントと推奨される方法"

#: ../../../reference/isr_rules.rst:20
msgid ""
"This summarises the points detailed below and lists the principal "
"recommendations for interrupt handler code."
msgstr ""
"ここでは、下記の点を要約し、割り込みハンドラコードの主な推奨事項を示します。"

#: ../../../reference/isr_rules.rst:22
msgid "Keep the code as short and simple as possible."
msgstr "コードはできるだけ短く簡単にするようにしてください。"

#: ../../../reference/isr_rules.rst:23
msgid ""
"Avoid memory allocation: no appending to lists or insertion into "
"dictionaries, no floating point."
msgstr ""
"メモリ割り当てを避ける: リストへの追加や辞書への挿入、浮動小数点の"
"追加をしないでください。"

#: ../../../reference/isr_rules.rst:24
msgid ""
"Consider using ``micropython.schedule`` to work around the above "
"constraint."
msgstr ""
"上記の制約を回避するために ``micropython.schedule`` を使うことを検討してください。"

#: ../../../reference/isr_rules.rst:25
msgid ""
"Where an ISR returns multiple bytes use a pre-allocated ``bytearray``. If"
" multiple integers are to be shared between an ISR and the main program "
"consider an array (``array.array``)."
msgstr ""
"ISR が複数のバイトを返す場合は、事前に割り当てた ``bytearray`` を使うようにして"
"ください。ISR とメインプログラムの間で複数の整数を共有する場合は array "
"(``array.array``)の利用を検討してください。"

#: ../../../reference/isr_rules.rst:27
msgid ""
"Where data is shared between the main program and an ISR, consider "
"disabling interrupts prior to accessing the data in the main program and "
"re-enabling them immediately afterwards (see Critical Sections)."
msgstr ""
"メインプログラムと ISR 間でデータを共有する場合は、メインプログラムのデータに"
"アクセスする前に割り込みを無効にし、直後に割り込みを再度有効にすることを検討して"
"ください(クリティカルセクションを参照)。"

#: ../../../reference/isr_rules.rst:29
msgid "Allocate an emergency exception buffer (see below)."
msgstr "緊急例外バッファを割り当ててください(下記参照)。"

#: ../../../reference/isr_rules.rst:33
msgid "MicroPython issues"
msgstr "MicroPython の問題"

#: ../../../reference/isr_rules.rst:36
msgid "The emergency exception buffer"
msgstr "緊急例外バッファ"

#: ../../../reference/isr_rules.rst:38
msgid ""
"If an error occurs in an ISR, MicroPython is unable to produce an error "
"report unless a special buffer is created for the purpose. Debugging is "
"simplified if the following code is included in any program using "
"interrupts."
msgstr ""
"ISR でエラーが発生した場合、MicroPython はエラーレポートのための特別なバッファが"
"作成されていないかぎりエラーレポートを生成できません。次のコードが割り込みを使用する"
"プログラムに含まれていると、デバッグが簡単になります。"

#: ../../../reference/isr_rules.rst:45
msgid ""
"import micropython\n"
"micropython.alloc_emergency_exception_buf(100)"
msgstr ""

#: ../../../reference/isr_rules.rst:47
msgid "Simplicity"
msgstr "簡素性"

#: ../../../reference/isr_rules.rst:49
msgid ""
"For a variety of reasons it is important to keep ISR code as short and "
"simple as possible. It should do only what has to be done immediately "
"after the event which caused it: operations which can be deferred should "
"be delegated to the main program loop. Typically an ISR will deal with "
"the hardware device which caused the interrupt, making it ready for the "
"next interrupt to occur. It will communicate with the main loop by "
"updating shared data to indicate that the interrupt has occurred, and it "
"will return. An ISR should return control to the main loop as quickly as "
"possible. This is not a specific MicroPython issue so is covered in more "
"detail :ref:`below <ISR>`."
msgstr ""
"さまざまな理由から、ISR コードをできるだけ短く簡単に保つことが重要です。割り込みを"
"引き起こしたイベントの直後に行われなければならないことだけをすべきです。延期できる"
"操作はメインプログラムのループに委ねられるべきです。通常、ISRは割り込みを発生させた"
"ハードウェアデバイスを処理し、次の割り込みが発生する準備ができます。割り込みが発生"
"したことを示す共有データを更新することでメインループと通信し、復帰します。ISR は、"
"できるだけ迅速にメインループに制御を戻す必要があります。これは特定の MicroPython "
"の問題ではありませんので、以下で詳しく説明します。"

#: ../../../reference/isr_rules.rst:57
msgid "Communication between an ISR and the main program"
msgstr "ISR とメインプログラムとの間の通信"

#: ../../../reference/isr_rules.rst:59
msgid ""
"Normally an ISR needs to communicate with the main program. The simplest "
"means of doing this is via one or more shared data objects, either "
"declared as global or shared via a class (see below). There are various "
"restrictions and hazards around doing this, which are covered in more "
"detail below. Integers, ``bytes`` and ``bytearray`` objects are commonly "
"used for this purpose along with arrays (from the array module) which can"
" store various data types."
msgstr ""
"通常、ISR はメインプログラムと通信する必要があります。これを行う最も簡単な方法は、"
"グローバルとして宣言されているか、クラスを介して共有されている１つ以上の共有データ"
"オブジェクトを経由することです(以降を参照)。これを行う際には、さまざまな制限や危険が"
"あり、詳しくは以降で説明します。データの共有には、整数、 ``bytes`` 、 ``bytearray`` "
"オブジェクトが、さまざまなデータ型を格納できる配列(array モジュールから)とともに"
"よく使われます。"

#: ../../../reference/isr_rules.rst:65
msgid "The use of object methods as callbacks"
msgstr "コールバックとしてのオブジェクトメソッドの使用"

#: ../../../reference/isr_rules.rst:67
msgid ""
"MicroPython supports this powerful technique which enables an ISR to "
"share instance variables with the underlying code. It also enables a "
"class implementing a device driver to support multiple device instances. "
"The following example causes two LED's to flash at different rates."
msgstr ""
"MicroPython は基盤コードとのインスタンス変数共有を ISR で可能とする強力な手法を"
"サポートしています。また、デバイスドライバを実装するクラスが複数のデバイスインスタンスを"
"サポートできるようにします。次の例では２つの LED を異なる速度で点滅させます。"

#: ../../../reference/isr_rules.rst:84
msgid ""
"import pyb, micropython\n"
"micropython.alloc_emergency_exception_buf(100)\n"
"class Foo(object):\n"
"    def __init__(self, timer, led):\n"
"        self.led = led\n"
"        timer.callback(self.cb)\n"
"    def cb(self, tim):\n"
"        self.led.toggle()\n"
"\n"
"red = Foo(pyb.Timer(4, freq=1), pyb.LED(1))\n"
"green = Foo(pyb.Timer(2, freq=0.8), pyb.LED(2))"
msgstr ""

#: ../../../reference/isr_rules.rst:85
msgid ""
"In this example the ``red`` instance associates timer 4 with LED 1: when "
"a timer 4 interrupt occurs ``red.cb()`` is called causing LED 1 to change"
" state. The ``green`` instance operates similarly: a timer 2 interrupt "
"results in the execution of ``green.cb()`` and toggles LED 2. The use of "
"instance methods confers two benefits. Firstly a single class enables "
"code to be shared between multiple hardware instances. Secondly, as a "
"bound method the callback function's first argument is ``self``. This "
"enables the callback to access instance data and to save state between "
"successive calls. For example, if the class above had a variable "
"``self.count`` set to zero in the constructor, ``cb()`` could increment "
"the counter. The ``red`` and ``green`` instances would then maintain "
"independent counts of the number of times each LED had changed state."
msgstr ""
"この例では、 ``red`` インスタンスはタイマー 4 を LED 1 に関連付けます。"
"タイマー4 の割り込みが発生すると、LED 1 の状態を変えるよう ``red.cb()`` を"
"呼び出します。 ``green`` インスタンスも同様に動作です: 実行中にタイマー 2 "
"の割り込みが発生すると、LED 2 の点灯/消灯を切り替えるために ``green.cb()`` "
"を呼び出します。インスタンスメソッドの利用には２つの利点があります。１つは、"
"単一のクラスのコードを複数のハードウェアインスタンス間で共有できることです。"
"もう１つは、バインドされたのがメソッドであると、コールバック関数の第１引数が "
"``self`` となることです。これにより、コールバックはインスタンスデータに"
"アクセスし、連続する呼び出し間で状態を保存できます。たとえば、上記のクラス "
"``self.count`` がコンストラクターで変数をゼロに設定していた場合、 ``cb()`` "
"はカウンターをインクリメントできます。 ``red`` と ``green`` インスタンスは、"
"各 LED が状態を変化させた回数を個別にカウントしていきます。"

#: ../../../reference/isr_rules.rst:95
msgid "Creation of Python objects"
msgstr "Python オブジェクトの作成"

#: ../../../reference/isr_rules.rst:97
msgid ""
"ISR's cannot create instances of Python objects. This is because "
"MicroPython needs to allocate memory for the object from a store of free "
"memory block called the heap. This is not permitted in an interrupt "
"handler because heap allocation is not re-entrant. In other words the "
"interrupt might occur when the main program is part way through "
"performing an allocation - to maintain the integrity of the heap the "
"interpreter disallows memory allocations in ISR code."
msgstr ""
"ISR は Python オブジェクトのインスタンスを作成できません。これは、MicroPython "
"がヒープと呼ばれる空きメモリブロックのストアからオブジェクトのメモリを割り当てる"
"必要があるためです。これは、ヒープ割り当てが再入可能ではないため、割り込みハンドラ"
"では許可されません。言い換えれば、メインプログラムが割り当てを実行する途中で割り込みが"
"発生する可能性があります。インタープリタがヒープの整合性を維持するために ISR "
"コード内でのメモリ割り当てを許可しません。"

#: ../../../reference/isr_rules.rst:103
msgid ""
"A consequence of this is that ISR's can't use floating point arithmetic; "
"this is because floats are Python objects. Similarly an ISR can't append "
"an item to a list. In practice it can be hard to determine exactly which "
"code constructs will attempt to perform memory allocation and provoke an "
"error message: another reason for keeping ISR code short and simple."
msgstr ""
"この結果、ISRでは浮動小数点演算を使えません。これは、float が Python オブジェクト"
"であるためです。同様に、ISR はアイテムをリストに追加することはできません。実際には、"
"どのコード構成がメモリ割り当てを試み、エラーメッセージを出すのかを正確に判断するのは"
"難しいかもしれません: これが ISR コードを短く簡潔に保つようにするもう一つの理由です。"

#: ../../../reference/isr_rules.rst:107
msgid ""
"One way to avoid this issue is for the ISR to use pre-allocated buffers. "
"For example a class constructor creates a ``bytearray`` instance and a "
"boolean flag. The ISR method assigns data to locations in the buffer and "
"sets the flag. The memory allocation occurs in the main program code when"
" the object is instantiated rather than in the ISR."
msgstr ""
"この問題を回避する１つの方法は、ISR が事前に割り当てられたバッファを使用することです。"
"たとえば、クラスコンストラクターは ``bytearray`` インスタンスとブール値フラグを"
"作成します。ISR メソッドは、バッファ内の場所にデータを割り当て、フラグを設定します。"
"メモリ割り当ては、ISR 内ではなく、オブジェクトがインスタンス化されたときにメイン"
"プログラムコードで行うようにします。"

#: ../../../reference/isr_rules.rst:111
msgid ""
"The MicroPython library I/O methods usually provide an option to use a "
"pre-allocated buffer. For example ``pyb.i2c.recv()`` can accept a mutable"
" buffer as its first argument: this enables its use in an ISR."
msgstr ""
"MicroPython ライブラリの I/O メソッドは、通常、事前に割り当てられたバッファを使用"
"するオプションを提供します。たとえば ``pyb.i2c.recv()`` は、第１引数として可変"
"バッファを受け入れることができます。これは ISR 内で使えます。"

#: ../../../reference/isr_rules.rst:114
msgid ""
"A means of creating an object without employing a class or globals is as "
"follows:"
msgstr ""
"クラスやグローバルを使わずにオブジェクトを作成する方法は次のとおりです。"

#: ../../../reference/isr_rules.rst:123
msgid ""
"def set_volume(t, buf=bytearray(3)):\n"
"    buf[0] = 0xa5\n"
"    buf[1] = t >> 4\n"
"    buf[2] = 0x5a\n"
"    return buf"
msgstr ""

#: ../../../reference/isr_rules.rst:124
msgid ""
"The compiler instantiates the default ``buf`` argument when the function "
"is loaded for the first time (usually when the module it's in is "
"imported)."
msgstr ""
"コンパイラは、関数が最初にロードされたとき(普通は関数が定義されているモジュールが "
"import されたとき)、デフォルトの ``buf`` 引数をインスタンス化します。"

#: ../../../reference/isr_rules.rst:127
msgid ""
"An instance of object creation occurs when a reference to a bound method "
"is created. This means that an ISR cannot pass a bound method to a "
"function. One solution is to create a reference to the bound method in "
"the class constructor and to pass that reference in the ISR. For example:"
msgstr ""
"オブジェクトのインスタンス作成は、バインドされたメソッドへの参照が作成されたときに"
"発生します。これは ISR がバインドされたメソッドを関数に渡すことができないことを"
"意味します。1つの解決策は、クラスコンストラクターでバインドされたメソッドへの参照を"
"作成し、その参照をISRに渡すことです。たとえば次のようにします:"

#: ../../../reference/isr_rules.rst:149
msgid ""
"class Foo():\n"
"    def __init__(self):\n"
"        self.bar_ref = self.bar  # Allocation occurs here\n"
"        self.x = 0.1\n"
"        tim = pyb.Timer(4)\n"
"        tim.init(freq=2)\n"
"        tim.callback(self.cb)\n"
"\n"
"    def bar(self, _):\n"
"        self.x *= 1.2\n"
"        print(self.x)\n"
"\n"
"    def cb(self, t):\n"
"        # Passing self.bar would cause allocation.\n"
"        micropython.schedule(self.bar_ref, 0)"
msgstr ""
"class Foo():\n"
"    def __init__(self):\n"
"        self.bar_ref = self.bar  # ここで割り当て発生\n"
"        self.x = 0.1\n"
"        tim = pyb.Timer(4)\n"
"        tim.init(freq=2)\n"
"        tim.callback(self.cb)\n"
"\n"
"    def bar(self, _):\n"
"        self.x *= 1.2\n"
"        print(self.x)\n"
"\n"
"    def cb(self, t):\n"
"        # self.bar を渡す割り当て発生\n"
"        micropython.schedule(self.bar_ref, 0)"

#: ../../../reference/isr_rules.rst:150
msgid ""
"Other techniques are to define and instantiate the method in the "
"constructor or to pass :meth:`Foo.bar` with the argument *self*."
msgstr ""
"他の手法は、コンストラクター内でメソッドを定義してインスタンス化するか、 "
":meth:`Foo.bar` を引数 *self* と渡すかです。"

#: ../../../reference/isr_rules.rst:154
msgid "Use of Python objects"
msgstr "Python オブジェクトの使用について"

#: ../../../reference/isr_rules.rst:156
msgid ""
"A further restriction on objects arises because of the way Python works. "
"When an ``import`` statement is executed the Python code is compiled to "
"bytecode, with one line of code typically mapping to multiple bytecodes. "
"When the code runs the interpreter reads each bytecode and executes it as"
" a series of machine code instructions. Given that an interrupt can occur"
" at any time between machine code instructions, the original line of "
"Python code may be only partially executed. Consequently a Python object "
"such as a set, list or dictionary modified in the main loop may lack "
"internal consistency at the moment the interrupt occurs."
msgstr ""
"Python が動作する仕組みから、オブジェクトに対するさらなる制限が生じます。"
"``import`` 文が実行されると、その Python コードがバイトコードにコンパイルされ、"
"1行のコードを、典型的には複数のバイトコードにマッピングします。コードが実行されると、"
"インタープリタは各バイトコードを読み取り、それを一連のマシンコード命令として実行します。"
"マシンコード命令の間にいつでも割り込みが発生することがあるとすれば、Pythonコードの"
"元の行は部分的にしか実行されない可能性があります。その結果、メインループで変更された"
"集合、リスト、辞書などの Python オブジェクトは、割り込みが発生した瞬間に内部整合性が"
"欠落することがあります。"

#: ../../../reference/isr_rules.rst:163
msgid ""
"A typical outcome is as follows. On rare occasions the ISR will run at "
"the precise moment in time when the object is partially updated. When the"
" ISR tries to read the object, a crash results. Because such problems "
"typically occur on rare, random occasions they can be hard to diagnose. "
"There are ways to circumvent this issue, described in :ref:`Critical "
"Sections <Critical>` below."
msgstr ""
"典型的なパターンは次のとおりです。オブジェクトの一部が更新されている状況で、"
"ごくまれに ISR が実行されるパターンです。このような状況で ISR がオブジェクトを"
"読み取ろうとすると、クラッシュが発生します。このような問題は、通常、まれにしか"
"発生しないため、診断が難しい場合があります。この問題を回避する方法は、後の"
"「クリティカルセクション」で説明します。"

#: ../../../reference/isr_rules.rst:168
msgid ""
"It is important to be clear about what constitutes the modification of an"
" object. An alteration to a built-in type such as a dictionary is "
"problematic. Altering the contents of an array or bytearray is not. This "
"is because bytes or words are written as a single machine code "
"instruction which is not interruptible: in the parlance of real time "
"programming the write is atomic. A user defined object might instantiate "
"an integer, array or bytearray. It is valid for both the main loop and "
"the ISR to alter the contents of these."
msgstr ""
"オブジェクトの修正内容を明確にしておくことは重要です。辞書などの組み込み型の変更は"
"問題があります。array または bytearray の内容を変更することは問題ありません。"
"これは、バイトまたはワードが中断されない単一のマシンコード命令で書き込まれるからです。"
"リアルタイムプログラミングの用語で、書き込みはアトミックです。ユーザ定義オブジェクトは、"
"整数、array、bytearray をインスタンス化することがあります。メインループと ISR "
"の両方がこれらの内容を変更することは有効です。"

#: ../../../reference/isr_rules.rst:174
msgid ""
"MicroPython supports integers of arbitrary precision. Values between "
"2**30 -1 and -2**30 will be stored in a single machine word. Larger "
"values are stored as Python objects. Consequently changes to long "
"integers cannot be considered atomic. The use of long integers in ISR's "
"is unsafe because memory allocation may be attempted as the variable's "
"value changes."
msgstr ""
"MicroPython は任意の精度の整数をサポートします。 2**30 -1 と -2**30 の間の値は、"
"単一の機械語で格納されます。大きな値は Python オブジェクトとして格納されます。"
"したがって、長い整数への変更はアトミックとはみなされません。変数の値が変わると"
"メモリ割り当てが試みられる可能性があるため、ISR での長い整数の使用は安全ではありません。"

#: ../../../reference/isr_rules.rst:180
msgid "Overcoming the float limitation"
msgstr "浮動小数点の制限を克服する"

#: ../../../reference/isr_rules.rst:182
msgid ""
"In general it is best to avoid using floats in ISR code: hardware devices"
" normally handle integers and conversion to floats is normally done in "
"the main loop. However there are a few DSP algorithms which require "
"floating point. On platforms with hardware floating point (such as the "
"Pyboard) the inline ARM Thumb assembler can be used to work round this "
"limitation. This is because the processor stores float values in a "
"machine word; values can be shared between the ISR and main program code "
"via an array of floats."
msgstr ""
"通常、ISR コードでは浮動小数点数を使わないでください。ハードウェアデバイスは"
"整数を扱い、浮動小数点への変換はメインループで行うようにしてください。しかし、浮動小数点を"
"必要とするいくつかの DSP アルゴリズムがあります。ハードウェア浮動小数点(Pyboardなど)の"
"プラットフォームでは、インライン ARM Thumb アセンブラを使用してこの制限を回避できます。"
"これは、プロセッサが浮動小数点値を機械語に格納するためです。浮動小数点数の配列を使用して "
"ISR とメインプログラムコード間で値を共有できます。"

#: ../../../reference/isr_rules.rst:189
msgid "Using micropython.schedule"
msgstr "micropython.schedule の利用"

#: ../../../reference/isr_rules.rst:191
msgid ""
"This function enables an ISR to schedule a callback for execution \"very "
"soon\". The callback is queued for execution which will take place at a "
"time when the heap is not locked. Hence it can create Python objects and "
"use floats. The callback is also guaranteed to run at a time when the "
"main program has completed any update of Python objects, so the callback "
"will not encounter partially updated objects."
msgstr ""
"この機能により、ISR は実行のコールバックを「非常に早く」スケジュールできます。"
"コールバックは実行のためにキューに入れられ、ヒープがロックされていないときに実行されます。"
"したがって、Python オブジェクトを作成して浮動小数点数を使用することができます。"
"コールバックは、メインプログラムが Python オブジェクトの更新を完了した時点で実行"
"されることも保証されているため、コールバックは部分的に更新されたオブジェクトに遭遇しません。"

#: ../../../reference/isr_rules.rst:196
msgid ""
"Typical usage is to handle sensor hardware. The ISR acquires data from "
"the hardware and enables it to issue a further interrupt. It then "
"schedules a callback to process the data."
msgstr ""
"典型的な使用法は、センサのハードウェアを扱うことです。ISR はハードウェアから"
"データを取得し、さらに割り込みを発行することができます。その後、データを"
"処理するコールバックをスケジュールします。"

#: ../../../reference/isr_rules.rst:199
msgid ""
"Scheduled callbacks should comply with the principles of interrupt "
"handler design outlined below. This is to avoid problems resulting from "
"I/O activity and the modification of shared data which can arise in any "
"code which pre-empts the main program loop."
msgstr ""
"スケジュールされたコールバックは、以下に説明する割り込みハンドラの設計の原則に"
"したがう必要があります。これは、I/O アクティビティおよびメインプログラムループを"
"先取りするコードで発生する可能性のある共有データの変更に起因する問題を回避するためです。"

#: ../../../reference/isr_rules.rst:203
msgid ""
"Execution time needs to be considered in relation to the frequency with "
"which interrupts can occur. If an interrupt occurs while the previous "
"callback is executing, a further instance of the callback will be queued "
"for execution; this will run after the current instance has completed. A "
"sustained high interrupt repetition rate therefore carries a risk of "
"unconstrained queue growth and eventual failure with a ``RuntimeError``."
msgstr ""
"実行時間は、割り込みが発生する頻度に関連して考慮する必要があります。直前のコールバックの"
"実行中に割り込みが発生すると、コールバックのさらなるインスタンスが実行のためにキューに"
"入れられます。現在のインスタンスが完了した後に実行されます。したがって、継続的な高い"
"割り込みの繰り返し率は、制約のないキューの増加と最終的な失敗のリスクを持ち "
"``RuntimeError`` ます。"

#: ../../../reference/isr_rules.rst:208
msgid ""
"If the callback to be passed to `schedule()` is a bound method, consider "
"the note in \"Creation of Python objects\"."
msgstr ""
"渡されるコールバックが schedule() バインドされたメソッドの場合は、"
"「Pythonオブジェクトの作成」の注意を考慮してください。"

#: ../../../reference/isr_rules.rst:212
msgid "Exceptions"
msgstr "例外"

#: ../../../reference/isr_rules.rst:214
msgid ""
"If an ISR raises an exception it will not propagate to the main loop. The"
" interrupt will be disabled unless the exception is handled by the ISR "
"code."
msgstr ""
"ISR が例外を発生させると、メインループには伝播しません。例外が ISR コードによって"
"処理されない限り、割り込みは無効になります。"

#: ../../../reference/isr_rules.rst:218
msgid "General issues"
msgstr "一般的な問題"

#: ../../../reference/isr_rules.rst:220
msgid ""
"This is merely a brief introduction to the subject of real time "
"programming. Beginners should note that design errors in real time "
"programs can lead to faults which are particularly hard to diagnose. This"
" is because they can occur rarely and at intervals which are essentially "
"random. It is crucial to get the initial design right and to anticipate "
"issues before they arise. Both interrupt handlers and the main program "
"need to be designed with an appreciation of the following issues."
msgstr ""
"これは、リアルタイムプログラミングの主題の簡単な紹介にすぎません。初心者は、"
"リアルタイムプログラムの設計ミスは、特に診断が難しい障害につながる可能性があることに"
"注意してください。これは、まれに、本質的にランダムな間隔で発生する可能性があるからです。"
"初期設計の権利を取得し、問題が発生する前に予測することが重要です。割り込みハンドラと"
"メインプログラムは、次の問題を認識して設計する必要があります。"

#: ../../../reference/isr_rules.rst:229
msgid "Interrupt handler design"
msgstr "割り込みハンドラの設計"

#: ../../../reference/isr_rules.rst:231
msgid ""
"As mentioned above, ISR's should be designed to be as simple as possible."
" They should always return in a short, predictable period of time. This "
"is important because when the ISR is running, the main loop is not: "
"inevitably the main loop experiences pauses in its execution at random "
"points in the code. Such pauses can be a source of hard to diagnose bugs "
"particularly if their duration is long or variable. In order to "
"understand the implications of ISR run time, a basic grasp of interrupt "
"priorities is required."
msgstr ""
"上記のように、ISR はできるだけシンプルに設計する必要があります。ISR からはは常に"
"短期間で予測可能な期間に戻るべきです。これは、ISR が実行されているときにメインループが"
"実行されないため重要です。必然的に、メインループはコード内のランダムなポイントで実行を"
"一時停止します。そのような一時停止は、特にその持続時間が長いか可変である場合に、バグを"
"診断するのが難しい原因となり得る。ISR 実行時間の意味を理解するためには、割り込み"
"優先順位の基本的な把握が必要です。"

#: ../../../reference/isr_rules.rst:237
msgid ""
"Interrupts are organised according to a priority scheme. ISR code may "
"itself be interrupted by a higher priority interrupt. This has "
"implications if the two interrupts share data (see Critical Sections "
"below). If such an interrupt occurs it interposes a delay into the ISR "
"code. If a lower priority interrupt occurs while the ISR is running, it "
"will be delayed until the ISR is complete: if the delay is too long, the "
"lower priority interrupt may fail. A further issue with slow ISR's is the"
" case where a second interrupt of the same type occurs during its "
"execution. The second interrupt will be handled on termination of the "
"first. However if the rate of incoming interrupts consistently exceeds "
"the capacity of the ISR to service them the outcome will not be a happy "
"one."
msgstr ""
"割込みは、優先順位スキームに従って編成されます。ISR コード自体がより高い優先度の"
"割り込みによって割り込みされる可能性があります。これは、2つの割込みがデータを共有する"
"場合に意味を持ちます(下記のクリティカルセクションを参照)。このような割り込みが発生すると、"
"ISR コードに遅延が挿入されます。ISRの実行中に優先度の低い割り込みが発生すると、ISR が"
"完了するまで遅延します。遅延が長すぎる場合は、優先度の低い割り込みが失敗する可能性が"
"あります。遅い ISR のさらなる問題は、実行中に同じタイプの2番目の割り込みが発生する場合"
"です。2番目の割り込みは最初の割り込みの終了時に処理されます。しかし、着信割り込みの"
"レートがISRのサービス能力を一貫して超えている場合、結果は幸いなことではありません。"

#: ../../../reference/isr_rules.rst:245
msgid ""
"Consequently looping constructs should be avoided or minimised. I/O to "
"devices other than to the interrupting device should normally be avoided:"
" I/O such as disk access, ``print`` statements and UART access is "
"relatively slow, and its duration may vary. A further issue here is that "
"filesystem functions are not reentrant: using filesystem I/O in an ISR "
"and the main program would be hazardous. Crucially ISR code should not "
"wait on an event. I/O is acceptable if the code can be guaranteed to "
"return in a predictable period, for example toggling a pin or LED. "
"Accessing the interrupting device via I2C or SPI may be necessary but the"
" time taken for such accesses should be calculated or measured and its "
"impact on the application assessed."
msgstr ""
"したがって、ループ構造を避けるか、最小化する必要があります。通常、ディスクアクセス、"
"print ステートメント、UART アクセスなどの I/O は比較的遅く、その継続時間は変動する"
"可能性があります。ここでのさらなる問題は、ファイルシステムの機能が再入可能ではないと"
"いうことです。ISR でファイルシステム I/O を使用すると、メインプログラムは危険です。"
"決定的に ISR コードはイベントを待つべきではありません。ピンまたは LED のトグルなど、"
"予測可能な期間にコードが返されることが保証されている場合は、I/O は許容されます。"
"I2C または SPI を介して割り込みデバイスにアクセスすることが必要な場合がありますが、"
"そのようなアクセスに要する時間を計算または測定し、アプリケーションへの影響を評価する"
"必要があります。"

#: ../../../reference/isr_rules.rst:253
msgid ""
"There is usually a need to share data between the ISR and the main loop. "
"This may be done either through global variables or via class or instance"
" variables. Variables are typically integer or boolean types, or integer "
"or byte arrays (a pre-allocated integer array offers faster access than a"
" list). Where multiple values are modified by the ISR it is necessary to "
"consider the case where the interrupt occurs at a time when the main "
"program has accessed some, but not all, of the values. This can lead to "
"inconsistencies."
msgstr ""
"通常、ISR とメインループの間でデータを共有する必要があります。これは、グローバル変数"
"またはクラス変数やインスタンス変数を介して実行できます。変数は、通常、整数またはブール型、"
"または整数またはバイト配列です(事前に割り当てられた整数配列はリストよりも高速なアクセスを"
"提供します)。複数の値が ISR によって変更される場合、メインプログラムがすべての値ではなく"
"一部にアクセスしたときに割り込みが発生する場合を考慮する必要があります。これは矛盾を"
"引き起こす可能性があります。"

#: ../../../reference/isr_rules.rst:259
msgid ""
"Consider the following design. An ISR stores incoming data in a "
"bytearray, then adds the number of bytes received to an integer "
"representing total bytes ready for processing. The main program reads the"
" number of bytes, processes the bytes, then clears down the number of "
"bytes ready. This will work until an interrupt occurs just after the main"
" program has read the number of bytes. The ISR puts the added data into "
"the buffer and updates the number received, but the main program has "
"already read the number, so processes the data originally received. The "
"newly arrived bytes are lost."
msgstr ""
"次の設計を考えてみましょう。ISR は着信データをバイアルに格納し、受信したバイト数を"
"処理可能な総バイト数を表す整数に加算します。メインプログラムはバイト数を読み取り、"
"バイトを処理した後、準備されたバイト数をクリアします。これは、メインプログラムが"
"バイト数を読み取った直後に割り込みが発生するまで機能します。ISR は追加されたデータを"
"バッファに入れ、受信した番号を更新しますが、メインプログラムは既に番号を読み取って"
"いるため、最初に受信したデータを処理します。新しく到着したバイトは失われます。"

#: ../../../reference/isr_rules.rst:266
msgid ""
"There are various ways of avoiding this hazard, the simplest being to use"
" a circular buffer. If it is not possible to use a structure with "
"inherent thread safety other ways are described below."
msgstr ""
"この危険を回避するにはさまざまな方法があります。最も簡単なのは循環バッファを使用する"
"ことです。固有のスレッド安全性を持つ構造体を使用することができない場合は、他の方法を"
"以下で説明します。"

#: ../../../reference/isr_rules.rst:270
msgid "Reentrancy"
msgstr "リエントラント性"

#: ../../../reference/isr_rules.rst:272
msgid ""
"A potential hazard may occur if a function or method is shared between "
"the main program and one or more ISR's or between multiple ISR's. The "
"issue here is that the function may itself be interrupted and a further "
"instance of that function run. If this is to occur, the function must be "
"designed to be reentrant. How this is done is an advanced topic beyond "
"the scope of this tutorial."
msgstr ""
"関数またはメソッドがメインプログラムと1つまたは複数の ISR 間で、または複数の ISR "
"間で共有される場合、潜在的な危険が生じる可能性があります。ここでの問題は、関数自体が"
"中断され、その関数のさらなるインスタンスが実行されることです。これが発生する場合は、"
"関数はリエントラントになるように設計する必要があります。これがどのように行われるかは、"
"このチュートリアルの範囲を超えた高度なトピックです。"

#: ../../../reference/isr_rules.rst:280
msgid "Critical sections"
msgstr "クリティカルセクション"

#: ../../../reference/isr_rules.rst:282
msgid ""
"An example of a critical section of code is one which accesses more than "
"one variable which can be affected by an ISR. If the interrupt happens to"
" occur between accesses to the individual variables, their values will be"
" inconsistent. This is an instance of a hazard known as a race condition:"
" the ISR and the main program loop race to alter the variables. To avoid "
"inconsistency a means must be employed to ensure that the ISR does not "
"alter the values for the duration of the critical section. One way to "
"achieve this is to issue ``pyb.disable_irq()`` before the start of the "
"section, and ``pyb.enable_irq()`` at the end. Here is an example of this "
"approach:"
msgstr ""
"コードのクリティカルセクションの例は、ISR の影響を受ける可能性のある複数の変数に"
"アクセスするコードです。個々の変数へのアクセスの間に割り込みが発生した場合、その値は"
"不一致になります。これは、競合状態として知られるハザードのインスタンスです: ISR と"
"メインプログラムのループ競合が変数を変更します。矛盾を避けるためには、ISR が"
"クリティカルセクションの期間の値を変更しないようにする手段が必要です。これを達成する"
"１つの方法は、セクションの開始前に ``pyb.disable_irq()`` を発行し、最後に "
"``pyb.enable_irq()`` を発行することです。このアプローチの例を次に示します:"

#: ../../../reference/isr_rules.rst:322
msgid ""
"import pyb, micropython, array\n"
"micropython.alloc_emergency_exception_buf(100)\n"
"\n"
"class BoundsException(Exception):\n"
"    pass\n"
"\n"
"ARRAYSIZE = const(20)\n"
"index = 0\n"
"data = array.array('i', 0 for x in range(ARRAYSIZE))\n"
"\n"
"def callback1(t):\n"
"    global data, index\n"
"    for x in range(5):\n"
"        data[index] = pyb.rng() # simulate input\n"
"        index += 1\n"
"        if index >= ARRAYSIZE:\n"
"            raise BoundsException('Array bounds exceeded')\n"
"\n"
"tim4 = pyb.Timer(4, freq=100, callback=callback1)\n"
"\n"
"for loop in range(1000):\n"
"    if index > 0:\n"
"        irq_state = pyb.disable_irq() # Start of critical section\n"
"        for x in range(index):\n"
"            print(data[x])\n"
"        index = 0\n"
"        pyb.enable_irq(irq_state) # End of critical section\n"
"        print('loop {}'.format(loop))\n"
"    pyb.delay(1)\n"
"\n"
"tim4.callback(None)"
msgstr ""

#: ../../../reference/isr_rules.rst:323
msgid ""
"A critical section can comprise a single line of code and a single "
"variable. Consider the following code fragment."
msgstr ""
"クリティカルセクションは、1行のコードと1つの変数で構成できます。"
"以下のコード断片を考えてみましょう。"

#: ../../../reference/isr_rules.rst:334
msgid ""
"count = 0\n"
"def cb(): # An interrupt callback\n"
"    count +=1\n"
"def main():\n"
"    # Code to set up the interrupt callback omitted\n"
"    while True:\n"
"        count += 1"
msgstr ""

#: ../../../reference/isr_rules.rst:335
msgid ""
"This example illustrates a subtle source of bugs. The line ``count += 1``"
" in the main loop carries a specific race condition hazard known as a "
"read-modify-write. This is a classic cause of bugs in real time systems. "
"In the main loop MicroPython reads the value of ``t.counter``, adds 1 to "
"it, and writes it back. On rare occasions the  interrupt occurs after the"
" read and before the write. The interrupt modifies ``t.counter`` but its "
"change is overwritten by the main loop when the ISR returns. In a real "
"system this could lead to rare, unpredictable failures."
msgstr ""
"この例は、微妙なバグの原因を示しています。メインループ内の行 ``count += 1`` は、"
"リードモディファイライトと呼ばれる特定の競合状態の危険を伴います。これはリアルタイム"
"システムのバグの古典的な原因です。メインループで MicroPython は ``t.counter`` 値を"
"読み取り、1を加算して書き戻します。ごくまれに、読み込みの後で書き込みの前に割り込みが"
"発生します。割り込みは ``t.counter`` を変更しますが、ISR が復帰するとメインループに"
"よってその変更が上書きされます。実際のシステムでは、これはまれな、予期しない障害に"
"つながる可能性があります。"

#: ../../../reference/isr_rules.rst:341
msgid ""
"As mentioned above, care should be taken if an instance of a Python built"
" in type is modified in the main code and that instance is accessed in an"
" ISR. The code performing the modification should be regarded as a "
"critical section to ensure that the instance is in a valid state when the"
" ISR runs."
msgstr ""
"前述のように、Python の組込み型のインスタンスがメインコードで変更され、その"
"インスタンスが ISR でアクセスされる場合は注意が必要です。変更を実行するコードは、"
"ISR の実行時にインスタンスが有効な状態にあることを確認するためのクリティカルセクション"
"とみなす必要があります。"

#: ../../../reference/isr_rules.rst:345
msgid ""
"Particular care needs to be taken if a dataset is shared between "
"different ISR's. The hazard here is that the higher priority interrupt "
"may occur when the lower priority one has partially updated the shared "
"data. Dealing with this situation is an advanced topic beyond the scope "
"of this introduction other than to note that mutex objects described "
"below can sometimes be used."
msgstr ""
"異なる ISR 間でデータセットを共有する場合は、特別な注意が必要です。ここでの危険は、"
"プライオリティの低い割り込みが部分的に共有データを更新したときに、より高い優先度の"
"割り込みが発生する可能性があることです。この状況を扱うことは、以下で説明する mutex "
"オブジェクトを使用することがあることに注意する以外にも、この紹介の範囲を超えた"
"高度なトピックです。"

#: ../../../reference/isr_rules.rst:350
msgid ""
"Disabling interrupts for the duration of a critical section is the usual "
"and simplest way to proceed, but it disables all interrupts rather than "
"merely the one with the potential to cause problems. It is generally "
"undesirable to disable an interrupt for long. In the case of timer "
"interrupts it introduces variability to the time when a callback occurs. "
"In the case of device interrupts, it can lead to the device being "
"serviced too late with possible loss of data or overrun errors in the "
"device hardware. Like ISR's, a critical section in the main code should "
"have a short, predictable duration."
msgstr ""
"クリティカルセクションの間の割り込みの無効化は、通常の最も簡単な方法で行うのですが、"
"問題を引き起こす可能性のある割り込みだけでなく、すべての割り込みを無効にします。"
"一般的に、割り込みを無効にすることは望ましくありません。タイマー割込みの場合は、"
"コールバックが発生する時間が変動してしまいます。デバイス割り込みの場合は、デバイス"
"ハードウェアのデータ消失やオーバーランエラーの可能性に対してのデバイスの復旧が"
"遅すぎとなる可能性があります。ISR と同様に、メインコードのクリティカルセクションは、"
"短く、予測可能な期間を持つようにする必要があります。"

#: ../../../reference/isr_rules.rst:357
msgid ""
"An approach to dealing with critical sections which radically reduces the"
" time for which interrupts are disabled is to use an object termed a "
"mutex (name derived from the notion of mutual exclusion). The main "
"program locks the mutex before running the critical section and unlocks "
"it at the end. The ISR tests whether the mutex is locked. If it is, it "
"avoids the critical section and returns. The design challenge is defining"
" what the ISR should do in the event that access to the critical "
"variables is denied. A simple example of a mutex may be found `here "
"<https://github.com/peterhinch/micropython-samples.git>`_. Note that the "
"mutex code does disable interrupts, but only for the duration of eight "
"machine instructions: the benefit of this approach is that other "
"interrupts are virtually unaffected."
msgstr ""
"割り込みを無効する時間を根本的に縮めたクリティカルセクションを扱うには、"
"mutex (mutual exclusion - 相互排除の概念から派生した名前)というオブジェクトを使います。"
"メインプログラムは、クリティカルセクションを実行する前に mutex をロックし、最後にロックを"
"解除します。ISRは、ミューテックスがロックされているかどうかをテストします。そうであれば、"
"クリティカルセクションを避けて戻ります。設計上の課題は、重要な変数へのアクセスが拒否された"
"場合に ISR が行うべきことを定義することです。mutex の簡単な例が "
"`ここ <https://github.com/peterhinch/micropython-samples.git>`_ にあります。"
"mutex コードは割り込みを無効にしますが、８つのマシン語命令の間のみ有効です。
"このアプローチの利点は、他の割り込みにはほとんど影響がないことです。"

#: ../../../reference/isr_rules.rst:367
msgid "Interrupts and the REPL"
msgstr "割り込みと REPL"

#: ../../../reference/isr_rules.rst:369
msgid ""
"Interrupt handlers, such as those associated with timers, can continue to"
" run after a program terminates.  This may produce unexpected results "
"where you might have expected the object raising the callback to have "
"gone out of scope.  For example on the Pyboard:"
msgstr ""
"タイマーに関連付けられているなどの割り込みハンドラは、プログラムの終了後も引き続き"
"実行できます。これにより、コールバックを発生させるオブジェクトがスコープ外になることが"
"予想される場合に、予期しない結果が生じることがあります。"
"次は pyboardの場合 の例です:"

#: ../../../reference/isr_rules.rst:380
msgid ""
"def bar():\n"
"    foo = pyb.Timer(2, freq=4, callback=lambda t: print('.', end=''))\n"
"\n"
"bar()"
msgstr ""

#: ../../../reference/isr_rules.rst:381
msgid ""
"This continues to run until the timer is explicitly disabled or the board"
" is reset with ``ctrl D``."
msgstr ""
"これはタイマーが明示的に無効にされるか、ボードが ``ctrl D`` でリセットされるまで続きます。"

#: ../../reference/mpyfiles.rst:4
msgid "MicroPython .mpy files"
msgstr "MicroPython .mpy ファイル"

#: ../../reference/mpyfiles.rst:6
msgid ""
"MicroPython defines the concept of an .mpy file which is a binary "
"container file format that holds precompiled code, and which can be "
"imported like a normal .py module.  The file ``foo.mpy`` can be imported "
"via ``import foo``, as long as ``foo.mpy`` can be found in the usual way "
"by the import machinery. Usually, each directory listed in ``sys.path`` "
"is searched in order.  When searching a particular directory ``foo.py`` "
"is looked for first and if that is not found then ``foo.mpy`` is looked "
"for, then the search continues in the next directory if neither is found."
"  As such, ``foo.py`` will take precedence over ``foo.mpy``."
msgstr ""
"MicroPython は .mpy ファイルのコンセプトを定義します。これはプリコンパイルされた"
"コードを保持するバイナリコンテナファイル形式であり、通常の .py モジュールのように"
"インポートできます。ファイル ``foo.mpy`` は、``foo.mpy`` をインポート機構が"
"通常の方法で見つけることができる限り ``import foo`` でインポートできます。"
"通常 ``sys.path`` にリストされている各ディレクトリが順番に検索されます。"
"特定のディレクトリを検索で ``foo.py`` が最初に検索され、それが見つからなければ "
"``foo.mpy`` が検索されます。どちらも見つからない場合は次のディレクトリで検索が"
"続行されます。そのため ``foo.py`` は ``foo.mpy`` に優先します。"

#: ../../reference/mpyfiles.rst:16
msgid ""
"These .mpy files can contain bytecode which is usually generated from "
"Python source files (.py files) via the ``mpy-cross`` program.  For some "
"architectures an .mpy file can also contain native machine code, which "
"can be generated in a variety of ways, most notably from C source code."
msgstr ""
"これらの .mpy ファイルには、通常 ``mpy-cross`` プログラムで Python ソースファイル"
"(.py ファイル)から生成されるバイトコードを含めることができます。一部のアーキテクチャでは "
".mpy ファイルにネイティブマシンコードを含めることもできます。ネイティブコードはマシンコード"
"はさまざまな方法で生成できますが、C 言語ソースコードから生成することが特に多いです。"

#: ../../reference/mpyfiles.rst:22
msgid "Versioning and compatibility of .mpy files"
msgstr ".mpy ファイルのバージョンと互換性"

#: ../../reference/mpyfiles.rst:24
msgid ""
"A given .mpy file may or may not be compatible with a given MicroPython "
"system. Compatibility is based on the following:"
msgstr ""
"利用しようとする .mpy ファイルは、特定の MicroPython システムと互換性がある場合と"
"互換性がない場合があります。互換性は以下に基づいています:"

#: ../../reference/mpyfiles.rst:27
msgid ""
"Version of the .mpy file: the version of the file must match the version "
"supported by the system loading it."
msgstr ""
".mpy ファイルのバージョン: ファイルのバージョンは、それをロードするシステムで"
"サポートされているバージョンと一致する必要があります。"

#: ../../reference/mpyfiles.rst:30
msgid ""
"Bytecode features used in the .mpy file: there are two bytecode features "
"which must match between the file and the system: unicode support and "
"inline caching of map lookups in the bytecode."
msgstr ""
".mpy ファイルで使用されるバイトコード機能: ファイルとシステムの間で一致する必要が"
"ある２つのバイトコード機能があります。ユニコードサポートとバイトコードでのマップ"
"検索のインラインキャッシュです。"

#: ../../reference/mpyfiles.rst:34
msgid ""
"Small integer bits: the .mpy file will require a minimum number of bits "
"in a small integer and the system loading it must support at least this "
"many bits."
msgstr ""
"スモール整数ビット: .mpy ファイルにはスモール整数の最小ビット数の要求があり、"
".mpy をロードするシステムは少なくともこの数のビットをサポートする必要があります。"

#: ../../reference/mpyfiles.rst:38
msgid ""
"Qstr compression window size: the .mpy file will require a minimum window"
" size for qstr decompression and the system loading it must have a window"
" greater or equal to this size."
msgstr ""
"qstr 圧縮ウィンドウサイズ: .mpy ファイルには qstr 解凍のための最小ウィンドウサイズの"
"要求があり、.mpy をロードするシステムにはこのサイズ以上のウィンドウが必要です。"

#: ../../reference/mpyfiles.rst:42
msgid ""
"Native architecture: if the .mpy file contains native machine code then "
"it will specify the architecture of that machine code and the system "
"loading it must support execution of that architecture's code."
msgstr ""
"ネイティブアーキテクチャ: .mpyファイルにネイティブマシンコードが含まれている場合、"
"そのマシンコードのアーキテクチャの指定があり、.mpy をロードするシステムはその"
"アーキテクチャのコードの実行をサポートする必要があります。"

#: ../../reference/mpyfiles.rst:46
msgid ""
"If a MicroPython system supports importing .mpy files then the "
"``sys.implementation.mpy`` field will exist and return an integer which "
"encodes the version (lower 8 bits), features and native architecture."
msgstr ""
"MicroPython システムが .mpy ファイルのインポートをサポートしている場合には、 "
"``sys.implementation.mpy`` フィールドが存在し、バージョン(下位8ビット)、"
"機能、ネイティブアーキテクチャをエンコードした整数を返します。"

#: ../../reference/mpyfiles.rst:50
msgid ""
"Trying to import an .mpy file that fails one of the first four tests will"
" raise ``ValueError('incompatible .mpy file')``.  Trying to import an "
".mpy file that fails the native architecture test (if it contains native "
"machine code) will raise ``ValueError('incompatible .mpy arch')``."
msgstr ""
"最初の４つのテストの１つに失敗した .mpy ファイルをインポートしようとすると "
"``ValueError('incompatible .mpy file')`` が発生します。"
"(ネイティブマシンコードが含まれている場合)ネイティブアーキテクチャのテストに失敗した "
".mpy　ファイルをインポートしようとすると ``ValueError('incompatible .mpy arch')`` "
"が発生します。"

#: ../../reference/mpyfiles.rst:55
msgid "If importing an .mpy file fails then try the following:"
msgstr ".mpy ファイルのインポートに失敗した場合は、次を試してください:"

#: ../../reference/mpyfiles.rst:57
msgid ""
"Determine the .mpy version and flags supported by your MicroPython system"
" by executing::"
msgstr ""
"以下を実行して、MicroPython システムでサポートされている .mpy バージョンとフラグを"
"確認します::"

#: ../../reference/mpyfiles.rst:60
msgid ""
"import sys\n"
"sys_mpy = sys.implementation.mpy\n"
"arch = [None, 'x86', 'x64',\n"
"    'armv6', 'armv6m', 'armv7m', 'armv7em', 'armv7emsp', 'armv7emdp',\n"
"    'xtensa', 'xtensawin'][sys_mpy >> 10]\n"
"print('mpy version:', sys_mpy & 0xff)\n"
"print('mpy flags:', end='')\n"
"if arch:\n"
"    print(' -march=' + arch, end='')\n"
"if sys_mpy & 0x100:\n"
"    print(' -mcache-lookup-bc', end='')\n"
"if not sys_mpy & 0x200:\n"
"    print(' -mno-unicode', end='')\n"
"print()"
msgstr ""

#: ../../reference/mpyfiles.rst:75
msgid ""
"Check the validity of the .mpy file by inspecting the first two bytes of "
"the file.  The first byte should be an uppercase 'M' and the second byte "
"will be the version number, which should match the system version from "
"above. If it doesn't match then rebuild the .mpy file."
msgstr ""
"ファイルの先頭２バイトを調べて、.mpy ファイルの妥当性を確認します。"
"先頭バイトは大文字の 'M' で、2バイト目はバージョン番号です。"
"このバージョン番号は、上記のシステムバージョンと一致する必要があります。"
"一致しない場合は .mpy ファイルを再作成してください。"

#: ../../reference/mpyfiles.rst:80
msgid ""
"Check if the system .mpy version matches the version emitted by ``mpy-"
"cross`` that was used to build the .mpy file, found by ``mpy-cross "
"--version``. If it doesn't match then recompile ``mpy-cross`` from the "
"Git repository checked out at the tag (or hash) reported by ``mpy-cross "
"--version``."
msgstr ""
".mpy ファイルを作成するのに使った ``mpy-cross`` の出した .mpy バーションが"
"システムの .mpy バージョンと一致するかを確認します。 ``mpy-cross`` の出す"
"バージョンは ``mpy-cross --version`` でわかります。"
"一致しない場合は ``mpy-cross --version`` によって報告されたタグ(またはハッシュ)で"
"チェックアウトした Git リポジトリにある ``mpy-cross`` で再コンパイルします。"

#: ../../reference/mpyfiles.rst:85
msgid ""
"Make sure you are using the correct ``mpy-cross`` flags, found by the "
"code above, or by inspecting the ``MPY_CROSS_FLAGS`` Makefile variable "
"for the port that you are using."
msgstr ""
"``mpy-cross`` フラグが正しいかを確認します。"
"フラグは上記のコードで見つけるか、使っているポートの "
"``MPY_CROSS_FLAGS`` Makefile 変数を調べてください。"

#: ../../reference/mpyfiles.rst:89
msgid ""
"The following table shows the correspondence between MicroPython release "
"and .mpy version."
msgstr ""
"次の表は、MicroPythonリリースと.mpyバージョンの対応を示しています。"

#: ../../reference/mpyfiles.rst:93
msgid "MicroPython release"
msgstr "MicroPython リリース"

#: ../../reference/mpyfiles.rst:93
msgid ".mpy version"
msgstr ".mpy バージョン"

#: ../../reference/mpyfiles.rst:95
msgid "v1.12 and up"
msgstr "v1.12 以上"

#: ../../reference/mpyfiles.rst:95
msgid "5"
msgstr ""

#: ../../reference/mpyfiles.rst:96
msgid "v1.11"
msgstr ""

#: ../../reference/mpyfiles.rst:96
msgid "4"
msgstr ""

#: ../../reference/mpyfiles.rst:97
msgid "v1.9.3 - v1.10"
msgstr ""

#: ../../reference/mpyfiles.rst:97
msgid "3"
msgstr ""

#: ../../reference/mpyfiles.rst:98
msgid "v1.9 - v1.9.2"
msgstr ""

#: ../../reference/mpyfiles.rst:98
msgid "2"
msgstr ""

#: ../../reference/mpyfiles.rst:99
msgid "v1.5.1 - v1.8.7"
msgstr ""

#: ../../reference/mpyfiles.rst:99
msgid "0"
msgstr ""

#: ../../reference/mpyfiles.rst:102
msgid ""
"For completeness, the next table shows the Git commit of the main "
"MicroPython repository at which the .mpy version was changed."
msgstr ""
"完全を期すため、次の表は .mpy バージョンが変更されたメイン MicroPython "
"リポジトリの Git コミットを示しています。"

#: ../../reference/mpyfiles.rst:106
msgid ".mpy version change"
msgstr ".mpy バージョン変更"

#: ../../reference/mpyfiles.rst:106
msgid "Git commit"
msgstr "Git コミット"

#: ../../reference/mpyfiles.rst:108
msgid "4 to 5"
msgstr "4 から 5"

#: ../../reference/mpyfiles.rst:108
msgid "5716c5cf65e9b2cb46c2906f40302401bdd27517"
msgstr ""

#: ../../reference/mpyfiles.rst:109
msgid "3 to 4"
msgstr "3 から 4"

#: ../../reference/mpyfiles.rst:109
msgid "9a5f92ea72754c01cc03e5efcdfe94021120531e"
msgstr ""

#: ../../reference/mpyfiles.rst:110
msgid "2 to 3"
msgstr "2 から 3"

#: ../../reference/mpyfiles.rst:110
msgid "ff93fd4f50321c6190e1659b19e64fef3045a484"
msgstr ""

#: ../../reference/mpyfiles.rst:111
msgid "1 to 2"
msgstr "1 から 2"

#: ../../reference/mpyfiles.rst:111
msgid "dd11af209d226b7d18d5148b239662e30ed60bad"
msgstr ""

#: ../../reference/mpyfiles.rst:112
msgid "0 to 1"
msgstr "0 から 1"

#: ../../reference/mpyfiles.rst:112
msgid "6a11048af1d01c78bdacddadd1b72dc7ba7c6478"
msgstr ""

#: ../../reference/mpyfiles.rst:113
msgid "initial version 0"
msgstr "初期バージョン 0"

#: ../../reference/mpyfiles.rst:113
msgid "d8c834c95d506db979ec871417de90b7951edc30"
msgstr ""

#: ../../reference/mpyfiles.rst:117
msgid "Binary encoding of .mpy files"
msgstr ".mpy ファイルのバイナリエンコーディング"

#: ../../reference/mpyfiles.rst:119
msgid ""
"MicroPython .mpy files are a binary container format with code objects "
"stored internally in a nested hierarchy.  To keep files small while still"
" providing a large range of possible values it uses the concept of a "
"variably-encoded-unsigned-integer (vuint) in many places.  Similar to "
"utf-8 encoding, this encoding stores 7 bits per byte with the 8th bit "
"(MSB) set if one or more bytes follow.  The bits of the unsigned integer "
"are stored in the vuint in LSB form."
msgstr ""
"MicroPython .mpy ファイルは、ネストされた階層内にコードオブジェクトを格納した"
"バイナリコンテナー形式です。大きな範囲の値を提供しながらもファイルを小さく保つために、"
"多くの場所で可変エンコード符号なし整数(variably-encoded-unsigned-integer: "
"vuint)の概念を使用します。utf-8 エンコーディングと同様に、このエンコーディングは"
"1バイトあたり7ビットを格納し、1つ以上のバイトが続く場合は8ビット目(MSB)が設定されます。"
"符号なし整数のビットは、LSB 形式で vuint に格納されます。"

#: ../../reference/mpyfiles.rst:127
msgid "The top-level of an .mpy file consists of two parts:"
msgstr ".mpyファイルのトップレベルは2つの部分で構成されています:"

#: ../../reference/mpyfiles.rst:129
msgid "The header."
msgstr "ヘッダー"

#: ../../reference/mpyfiles.rst:131
msgid ""
"The raw-code for the outer scope of the module. This outer scope is "
"executed when the .mpy file is imported."
msgstr ""
"モジュールの外部スコープの raw コード。この外部スコープは .mpy ファイルがインポート"
"されるときに実行されます。"

#: ../../reference/mpyfiles.rst:135
msgid "The header"
msgstr "ヘッダー"

#: ../../reference/mpyfiles.rst:137
msgid "The .mpy header is:"
msgstr ".mpy のヘッダーは次のとおりです:"

#: ../../reference/mpyfiles.rst:140 ../../reference/mpyfiles.rst:156
msgid "size"
msgstr "サイズ"

#: ../../reference/mpyfiles.rst:140 ../../reference/mpyfiles.rst:156
msgid "field"
msgstr "フォールド"

#: ../../reference/mpyfiles.rst:142 ../../reference/mpyfiles.rst:143
#: ../../reference/mpyfiles.rst:144 ../../reference/mpyfiles.rst:145
msgid "byte"
msgstr "バイト"

#: ../../reference/mpyfiles.rst:142
msgid "value 0x4d (ASCII 'M')"
msgstr "値 0x4d (ASCII の "M')"

#: ../../reference/mpyfiles.rst:143
msgid ".mpy version number"
msgstr ".mpy バージョン番号"

#: ../../reference/mpyfiles.rst:144
msgid "feature flags"
msgstr "機能フラグ"

#: ../../reference/mpyfiles.rst:145
msgid "number of bits in a small int"
msgstr "スモール整数のビット数"

#: ../../reference/mpyfiles.rst:146 ../../reference/mpyfiles.rst:158
#: ../../reference/mpyfiles.rst:160 ../../reference/mpyfiles.rst:161
msgid "vuint"
msgstr ""

#: ../../reference/mpyfiles.rst:146
msgid "size of qstr window"
msgstr "qstr ウィンドウのサイズ"

#: ../../reference/mpyfiles.rst:150
msgid "Raw code elements"
msgstr "raw コードの要素"

#: ../../reference/mpyfiles.rst:152
msgid ""
"A raw-code element contains code, either bytecode or native machine code."
"  Its contents are:"
msgstr ""
"raw コードの要素には、バイトコードまたはネイティブマシンコードのコードが含まれます。"
"その内容は次のとおりです:"

#: ../../reference/mpyfiles.rst:158
msgid "type and size"
msgstr "タイプとサイズ"

#: ../../reference/mpyfiles.rst:159 ../../reference/mpyfiles.rst:162
#: ../../reference/mpyfiles.rst:163
msgid "..."
msgstr ""

#: ../../reference/mpyfiles.rst:159
msgid "code (bytecode or machine code)"
msgstr "コード(バイトコードまたはマシンコード)"

#: ../../reference/mpyfiles.rst:160
msgid "number of constant objects"
msgstr "定数オブジェクトの数"

#: ../../reference/mpyfiles.rst:161
msgid "number of sub-raw-code elements"
msgstr "副 raw コード要素の数"

#: ../../reference/mpyfiles.rst:162
msgid "constant objects"
msgstr "定数オブジェクト"

#: ../../reference/mpyfiles.rst:163
msgid "sub-raw-code elements"
msgstr "副 raw コード要素"

#: ../../reference/mpyfiles.rst:166
msgid ""
"The first vuint in a raw-code element encodes the type of code stored in "
"this element (the two least-significant bits), and the decompressed "
"length of the code (the amount of RAM to allocate for it)."
msgstr ""
"raw コード要素の最初の vuint は、この要素に格納されているコードのタイプ"
"(最下位2ビット)と、圧縮解除されたコードの長さ(割り当てられるRAMの量)を"
"エンコードしています。"

#: ../../reference/mpyfiles.rst:170
msgid ""
"Following the vuint comes the code itself.  In the case of bytecode it "
"also contains compressed qstr values."
msgstr ""
"vuint に続いてコード自体が続きます。バイトコードの場合、圧縮された qstr 値も含まれます。"

#: ../../reference/mpyfiles.rst:173
msgid ""
"Following the code comes a vuint counting the number of constant objects,"
" and another vuint counting the number of sub-raw-code elements."
msgstr ""
"コードに続いて、定数オブジェクトの数を数える vuint と、副 raw コード要素数の "
"vuint が続きます。"

#: ../../reference/mpyfiles.rst:176
msgid "The constant objects are then stored next."
msgstr "定数オブジェクトは次に保存されます。"

#: ../../reference/mpyfiles.rst:178
msgid "Finally any sub-raw-code elements are stored, recursively."
msgstr "最後に 副 raw コード要素が再帰的に保存されます。"

#: ../../../reference/packages.rst:2
msgid "Distribution packages, package management, and deploying applications"
msgstr ""

#: ../../../reference/packages.rst:4
msgid ""
"Just as the \"big\" Python, MicroPython supports creation of \"third "
"party\" packages, distributing them, and easily installing them in each "
"user's environment. This chapter discusses how these actions are "
"achieved. Some familiarity with Python packaging is recommended."
msgstr ""

#: ../../../reference/packages.rst:10
msgid "Overview"
msgstr ""

#: ../../../reference/packages.rst:12
msgid ""
"Steps below represent a high-level workflow when creating and consuming "
"packages:"
msgstr ""

#: ../../../reference/packages.rst:15
msgid ""
"Python modules and packages are turned into distribution package "
"archives, and published at the Python Package Index (PyPI)."
msgstr ""

#: ../../../reference/packages.rst:17
msgid ""
"`upip` package manager can be used to install a distribution package on a"
" `MicroPython port` with networking capabilities (for example, on the "
"Unix port)."
msgstr ""

#: ../../../reference/packages.rst:20
msgid ""
"For ports without networking capabilities, an \"installation image\" can "
"be prepared on the Unix port, and transferred to a device by suitable "
"means."
msgstr ""

#: ../../../reference/packages.rst:23
msgid ""
"For low-memory ports, the installation image can be frozen as the "
"bytecode into MicroPython executable, thus minimizing the memory storage "
"overheads."
msgstr ""

#: ../../../reference/packages.rst:27
msgid "The sections below describe this process in details."
msgstr ""

#: ../../../reference/packages.rst:30
msgid "Distribution packages"
msgstr ""

#: ../../../reference/packages.rst:32
msgid ""
"Python modules and packages can be packaged into archives suitable for "
"transfer between systems, storing at the well-known location (PyPI), and "
"downloading on demand for deployment. These archives are known as "
"*distribution packages* (to differentiate them from Python packages "
"(means to organize Python source code))."
msgstr ""

#: ../../../reference/packages.rst:38
msgid ""
"The MicroPython distribution package format is a well-known tar.gz "
"format, with some adaptations however. The Gzip compressor, used as an "
"external wrapper for TAR archives, by default uses 32KB dictionary size, "
"which means that to uncompress a compressed stream, 32KB of contiguous "
"memory needs to be allocated. This requirement may be not satisfiable on "
"low-memory devices, which may have total memory available less than that "
"amount, and even if not, a contiguous block like that may be hard to "
"allocate due to memory fragmentation. To accommodate these constraints, "
"MicroPython distribution packages use Gzip compression with the "
"dictionary size of 4K, which should be a suitable compromise with still "
"achieving some compression while being able to uncompressed even by the "
"smallest devices."
msgstr ""

#: ../../../reference/packages.rst:51
msgid ""
"Besides the small compression dictionary size, MicroPython distribution "
"packages also have other optimizations, like removing any files from the "
"archive which aren't used by the installation process. In particular, "
"`upip` package manager doesn't execute ``setup.py`` during installation "
"(see below), and thus that file is not included in the archive."
msgstr ""

#: ../../../reference/packages.rst:57
msgid ""
"At the same time, these optimizations make MicroPython distribution "
"packages not compatible with `CPython`'s package manager, ``pip``. This "
"isn't considered a big problem, because:"
msgstr ""

#: ../../../reference/packages.rst:61
msgid ""
"Packages can be installed with `upip`, and then can be used with CPython "
"(if they are compatible with it)."
msgstr ""

#: ../../../reference/packages.rst:63
msgid ""
"In the other direction, majority of CPython packages would be "
"incompatible with MicroPython by various reasons, first of all, the "
"reliance on features not implemented by MicroPython."
msgstr ""

#: ../../../reference/packages.rst:67
msgid ""
"Summing up, the MicroPython distribution package archives are highly "
"optimized for MicroPython's target environments, which are highly "
"resource constrained devices."
msgstr ""

#: ../../../reference/packages.rst:73
msgid "``upip`` package manager"
msgstr ""

#: ../../../reference/packages.rst:75
msgid ""
"MicroPython distribution packages are intended to be installed using the "
"`upip` package manager. `upip` is a Python application which is usually "
"distributed (as frozen bytecode) with network-enabled `MicroPython ports "
"<MicroPython port>`. At the very least, `upip` is available in the "
"`MicroPython Unix port`."
msgstr ""

#: ../../../reference/packages.rst:81
msgid ""
"On any `MicroPython port` providing `upip`, it can be accessed as "
"following::"
msgstr ""

#: ../../../reference/packages.rst:84
msgid ""
"import upip\n"
"upip.help()\n"
"upip.install(package_or_package_list, [path])"
msgstr ""

#: ../../../reference/packages.rst:88
msgid ""
"Where *package_or_package_list* is the name of a distribution package to "
"install, or a list of such names to install multiple packages. Optional "
"*path* parameter specifies filesystem location to install under and "
"defaults to the standard library location (see below)."
msgstr ""

#: ../../../reference/packages.rst:94
msgid "An example of installing a specific package and then using it::"
msgstr ""

#: ../../../reference/packages.rst:96
msgid ""
">>> import upip\n"
">>> upip.install(\"micropython-pystone_lowmem\")\n"
"[...]\n"
">>> import pystone_lowmem\n"
">>> pystone_lowmem.main()"
msgstr ""

#: ../../../reference/packages.rst:102
msgid ""
"Note that the name of Python package and the name of distribution package"
" for it in general don't have to match, and oftentimes they don't. This "
"is because PyPI provides a central package repository for all different "
"Python implementations and versions, and thus distribution package names "
"may need to be namespaced for a particular implementation. For example, "
"all packages from `micropython-lib` follow this naming convention: for a "
"Python module or package named ``foo``, the distribution package name is "
"``micropython-foo``."
msgstr ""

#: ../../../reference/packages.rst:111
msgid ""
"For the ports which run MicroPython executable from the OS command "
"prompts (like the Unix port), `upip` can be (and indeed, usually is) run "
"from the command line instead of MicroPython's own REPL. The commands "
"which corresponds to the example above are::"
msgstr ""

#: ../../../reference/packages.rst:116
msgid ""
"micropython -m upip -h\n"
"micropython -m upip install [-p <path>] <packages>...\n"
"micropython -m upip install micropython-pystone_lowmem"
msgstr ""

#: ../../../reference/packages.rst:120
msgid "[TODO: Describe installation path.]"
msgstr ""

#: ../../../reference/packages.rst:124
msgid "Cross-installing packages"
msgstr ""

#: ../../../reference/packages.rst:126
msgid ""
"For `MicroPython ports <MicroPython port>` without native networking "
"capabilities, the recommend process is \"cross-installing\" them into a "
"\"directory image\" using the `MicroPython Unix port`, and then "
"transferring this image to a device by suitable means."
msgstr ""

#: ../../../reference/packages.rst:131
msgid "Installing to a directory image involves using ``-p`` switch to `upip`::"
msgstr ""

#: ../../../reference/packages.rst:133
msgid "micropython -m upip install -p install_dir micropython-pystone_lowmem"
msgstr ""

#: ../../../reference/packages.rst:135
msgid ""
"After this command, the package content (and contents of every dependency "
"packages) will be available in the ``install_dir/`` subdirectory. You "
"would need to transfer contents of this directory (without the "
"``install_dir/`` prefix) to the device, at the suitable location, where "
"it can be found by the Python ``import`` statement (see discussion of the"
" `upip` installation path above)."
msgstr ""

#: ../../../reference/packages.rst:144
msgid "Cross-installing packages with freezing"
msgstr ""

#: ../../../reference/packages.rst:146
msgid ""
"For the low-memory `MicroPython ports <MicroPython port>`, the process "
"described in the previous section does not provide the most efficient "
"resource usage,because the packages are installed in the source form, so "
"need to be compiled to the bytecome on each import. This compilation "
"requires RAM, and the resulting bytecode is also stored in RAM, reducing "
"its amount available for storing application data. Moreover, the process "
"above requires presence of the filesystem on a device, and the most "
"resource-constrained devices may not even have it."
msgstr ""

#: ../../../reference/packages.rst:155
msgid ""
"The bytecode freezing is a process which resolves all the issues "
"mentioned above:"
msgstr ""

#: ../../../reference/packages.rst:158
msgid "The source code is pre-compiled into bytecode and store as such."
msgstr ""

#: ../../../reference/packages.rst:159
msgid "The bytecode is stored in ROM, not RAM."
msgstr ""

#: ../../../reference/packages.rst:160
msgid "Filesystem is not required for frozen packages."
msgstr ""

#: ../../../reference/packages.rst:162
msgid ""
"Using frozen bytecode requires building the executable (firmware) for a "
"given `MicroPython port` from the C source code. Consequently, the "
"process is:"
msgstr ""

#: ../../../reference/packages.rst:166
msgid ""
"Follow the instructions for a particular port on setting up a toolchain "
"and building the port. For example, for ESP8266 port, study instructions "
"in ``ports/esp8266/README.md`` and follow them. Make sure you can build "
"the port and deploy the resulting executable/firmware successfully before"
" proceeding to the next steps."
msgstr ""

#: ../../../reference/packages.rst:171
msgid ""
"Build `MicroPython Unix port` and make sure it is in your PATH and you "
"can execute ``micropython``."
msgstr ""

#: ../../../reference/packages.rst:173
msgid "Change to port's directory (e.g. ``ports/esp8266/`` for ESP8266)."
msgstr ""

#: ../../../reference/packages.rst:174
msgid ""
"Run ``make clean-frozen``. This step cleans up any previous modules which"
" were installed for freezing (consequently, you need to skip this step to"
" add additional modules, instead of starting from scratch)."
msgstr ""

#: ../../../reference/packages.rst:178
msgid ""
"Run ``micropython -m upip install -p modules <packages>...`` to install "
"packages you want to freeze."
msgstr ""

#: ../../../reference/packages.rst:180
msgid "Run ``make clean``."
msgstr ""

#: ../../../reference/packages.rst:181
msgid "Run ``make``."
msgstr ""

#: ../../../reference/packages.rst:183
msgid ""
"After this, you should have the executable/firmware with modules as the "
"bytecode inside, which you can deploy the usual way."
msgstr ""

#: ../../../reference/packages.rst:186
msgid "Few notes:"
msgstr ""

#: ../../../reference/packages.rst:188
msgid ""
"Step 5 in the sequence above assumes that the distribution package is "
"available from PyPI. If that is not the case, you would need to copy "
"Python source files manually to ``modules/`` subdirectory of the port "
"port directory. (Note that upip does not support installing from e.g. "
"version control repositories)."
msgstr ""

#: ../../../reference/packages.rst:193
msgid ""
"The firmware for baremetal devices usually has size restrictions, so "
"adding too many frozen modules may overflow it. Usually, you would get a "
"linking error if this happens. However, in some cases, an image may be "
"produced, which is not runnable on a device. Such cases are in general "
"bugs, and should be reported and further investigated. If you face such a"
" situation, as an initial step, you may want to decrease the amount of "
"frozen modules included."
msgstr ""

#: ../../../reference/packages.rst:203
msgid "Creating distribution packages"
msgstr ""

#: ../../../reference/packages.rst:205
msgid ""
"Distribution packages for MicroPython are created in the same manner as "
"for CPython or any other Python implementation, see references at the end"
" of chapter. Setuptools (instead of distutils) should be used, because "
"distutils do not support dependencies and other features. \"Source "
"distribution\" (``sdist``) format is used for packaging. The post-"
"processing discussed above, (and pre-processing discussed in the "
"following section) is achieved by using custom ``sdist`` command for "
"setuptools. Thus, packaging steps remain the same as for the standard "
"setuptools, the user just needs to override ``sdist`` command "
"implementation by passing the appropriate argument to ``setup()`` call::"
msgstr ""

#: ../../../reference/packages.rst:216
msgid ""
"from setuptools import setup\n"
"import sdist_upip\n"
"\n"
"setup(\n"
"    ...,\n"
"    cmdclass={'sdist': sdist_upip.sdist}\n"
")"
msgstr ""

#: ../../../reference/packages.rst:224
msgid ""
"The sdist_upip.py module as referenced above can be found in "
"`micropython-lib`: https://github.com/micropython/micropython-"
"lib/blob/master/sdist_upip.py"
msgstr ""

#: ../../../reference/packages.rst:230
msgid "Application resources"
msgstr ""

#: ../../../reference/packages.rst:232
msgid ""
"A complete application, besides the source code, oftentimes also consists"
" of data files, e.g. web page templates, game images, etc. It's clear how"
" to deal with those when application is installed manually - you just put"
" those data files in the filesystem at some location and use the normal "
"file access functions."
msgstr ""

#: ../../../reference/packages.rst:238
msgid ""
"The situation is different when deploying applications from packages - "
"this is more advanced, streamlined and flexible way, but also requires "
"more advanced approach to accessing data files. This approach is treating"
" the data files as \"resources\", and abstracting away access to them."
msgstr ""

#: ../../../reference/packages.rst:243
msgid ""
"Python supports resource access using its \"setuptools\" library, using "
"``pkg_resources`` module. MicroPython, following its usual approach, "
"implements subset of the functionality of that module, specifically "
"``pkg_resources.resource_stream(package, resource)`` function. The idea "
"is that an application calls this function, passing a resource "
"identifier, which is a relative path to data file within the specified "
"package (usually top-level application package). It returns a stream "
"object which can be used to access resource contents. Thus, the "
"``resource_stream()`` emulates interface of the standard `open()` "
"function."
msgstr ""

#: ../../../reference/packages.rst:254
msgid ""
"Implementation-wise, ``resource_stream()`` uses file operations "
"underlyingly, if distribution package is install in the filesystem. "
"However, it also supports functioning without the underlying filesystem, "
"e.g. if the package is frozen as the bytecode. This however requires an "
"extra intermediate step when packaging application - creation of \"Python"
" resource module\"."
msgstr ""

#: ../../../reference/packages.rst:261
msgid ""
"The idea of this module is to convert binary data to a Python bytes "
"object, and put it into the dictionary, indexed by the resource name. "
"This conversion is done automatically using overridden ``sdist`` command "
"described in the previous section."
msgstr ""

#: ../../../reference/packages.rst:266
msgid ""
"Let's trace the complete process using the following example. Suppose "
"your application has the following structure::"
msgstr ""

#: ../../../reference/packages.rst:269
msgid ""
"my_app/\n"
"    __main__.py\n"
"    utils.py\n"
"    data/\n"
"        page.html\n"
"        image.png"
msgstr ""

#: ../../../reference/packages.rst:276
msgid ""
"``__main__.py`` and ``utils.py`` should access resources using the "
"following calls::"
msgstr ""

#: ../../../reference/packages.rst:279
msgid ""
"import pkg_resources\n"
"\n"
"pkg_resources.resource_stream(__name__, \"data/page.html\")\n"
"pkg_resources.resource_stream(__name__, \"data/image.png\")"
msgstr ""

#: ../../../reference/packages.rst:284
msgid ""
"You can develop and debug using the `MicroPython Unix port` as usual. "
"When time comes to make a distribution package out of it, just use "
"overridden \"sdist\" command from sdist_upip.py module as described in "
"the previous section."
msgstr ""

#: ../../../reference/packages.rst:289
msgid ""
"This will create a Python resource module named ``R.py``, based on the "
"files declared in ``MANIFEST`` or ``MANIFEST.in`` files (any non-``.py`` "
"file will be considered a resource and added to ``R.py``) - before "
"proceeding with the normal packaging steps."
msgstr ""

#: ../../../reference/packages.rst:294
msgid ""
"Prepared like this, your application will work both when deployed to "
"filesystem and as frozen bytecode."
msgstr ""

#: ../../../reference/packages.rst:297
msgid "If you would like to debug ``R.py`` creation, you can run::"
msgstr ""

#: ../../../reference/packages.rst:299
msgid "python3 setup.py sdist --manifest-only"
msgstr ""

#: ../../../reference/packages.rst:301
msgid ""
"Alternatively, you can use tools/mpy_bin2res.py script from the "
"MicroPython distribution, in which can you will need to pass paths to all"
" resource files::"
msgstr ""

#: ../../../reference/packages.rst:305
msgid "mpy_bin2res.py data/page.html data/image.png"
msgstr ""

#: ../../../reference/packages.rst:310
msgid "Python Packaging User Guide: https://packaging.python.org/"
msgstr ""

#: ../../../reference/packages.rst:311
msgid "Setuptools documentation: https://setuptools.readthedocs.io/"
msgstr ""

#: ../../../reference/packages.rst:312
msgid "Distutils documentation: https://docs.python.org/3/library/distutils.html"
msgstr ""

#: ../../reference/pyboard.py.rst:4
msgid "The pyboard.py tool"
msgstr ""

#: ../../reference/pyboard.py.rst:6
msgid ""
"This is a standalone Python tool that runs on your PC that provides a way"
" to:"
msgstr ""

#: ../../reference/pyboard.py.rst:8
msgid ""
"Quickly run a Python script or command on a MicroPython device. This is "
"useful while developing MicroPython programs to quickly test code without"
" needing to copy files to/from the device."
msgstr ""

#: ../../reference/pyboard.py.rst:12
msgid ""
"Access the filesystem on a device. This allows you to deploy your code to"
" the device (even if the board doesn't support USB MSC)."
msgstr ""

#: ../../reference/pyboard.py.rst:15
msgid ""
"Despite the name, ``pyboard.py`` works on all MicroPython ports that "
"support the raw REPL (including STM32, ESP32, ESP8266, NRF)."
msgstr ""

#: ../../reference/pyboard.py.rst:18
msgid ""
"You can download the latest version from `GitHub "
"<https://github.com/micropython/micropython/blob/master/tools/pyboard.py>`_."
" The only dependency is the ``pyserial`` library which can be installed "
"from PiPy or your system package manager."
msgstr ""

#: ../../reference/pyboard.py.rst:23
msgid "Running ``pyboard.py --help`` gives the following output:"
msgstr ""

#: ../../reference/pyboard.py.rst:25
msgid ""
"usage: pyboard [-h] [-d DEVICE] [-b BAUDRATE] [-u USER] [-p PASSWORD]\n"
"               [-c COMMAND] [-w WAIT] [--follow | --no-follow] [-f]\n"
"               [files [files ...]]\n"
"\n"
"Run scripts on the pyboard.\n"
"\n"
"positional arguments:\n"
"  files                 input files\n"
"\n"
"optional arguments:\n"
"  -h, --help            show this help message and exit\n"
"  -d DEVICE, --device DEVICE\n"
"                        the serial device or the IP address of the "
"pyboard\n"
"  -b BAUDRATE, --baudrate BAUDRATE\n"
"                        the baud rate of the serial device\n"
"  -u USER, --user USER  the telnet login username\n"
"  -p PASSWORD, --password PASSWORD\n"
"                        the telnet login password\n"
"  -c COMMAND, --command COMMAND\n"
"                        program passed in as string\n"
"  -w WAIT, --wait WAIT  seconds to wait for USB connected board to become"
"\n"
"                        available\n"
"  --follow              follow the output after running the scripts\n"
"                        [default if no scripts given]\n"
"  -f, --filesystem      perform a filesystem action"
msgstr ""

#: ../../reference/pyboard.py.rst:54
msgid "Running a command on the device"
msgstr ""

#: ../../reference/pyboard.py.rst:56
msgid ""
"This is useful for testing short snippets of code, or to script an "
"interaction with the device.::"
msgstr ""

#: ../../reference/pyboard.py.rst:59
msgid ""
"$ pyboard.py --device /dev/ttyACM0 -c 'print(1+1)'\n"
"2"
msgstr ""

#: ../../reference/pyboard.py.rst:62
msgid ""
"If you are often interacting with the same device, you can set the "
"environment variable ``PYBOARD_DEVICE`` as an alternative to using the "
"``--device`` command line option.  For example, the following is "
"equivalent to the previous example::"
msgstr ""

#: ../../reference/pyboard.py.rst:67
msgid ""
"$ export PYBOARD_DEVICE=/dev/ttyACM0\n"
"$ pyboard.py -c 'print(1+1)'"
msgstr ""

#: ../../reference/pyboard.py.rst:70
msgid ""
"Similarly, the ``PYBOARD_BAUDRATE`` environment variable can be used to "
"set the default for the `--baudrate` option."
msgstr ""

#: ../../reference/pyboard.py.rst:74
msgid "Running a script on the device"
msgstr ""

#: ../../reference/pyboard.py.rst:76
msgid ""
"If you have a script, ``app.py`` that you want to run on a device, then "
"use::"
msgstr ""

#: ../../reference/pyboard.py.rst:78
msgid "$ pyboard.py --device /dev/ttyACM0 app.py"
msgstr ""

#: ../../reference/pyboard.py.rst:80
msgid ""
"Note that this doesn't actually copy app.py to the device's filesystem, "
"it just loads the code into RAM and executes it. Any output generated by "
"the program will be displayed."
msgstr ""

#: ../../reference/pyboard.py.rst:84
msgid ""
"If the program app.py does not finish then you'll need to stop "
"``pyboard.py``, eg with Ctrl-C. The program ``app.py`` will still "
"continue to run on the MicroPython device."
msgstr ""

#: ../../reference/pyboard.py.rst:89
msgid "Filesystem access"
msgstr ""

#: ../../reference/pyboard.py.rst:91
msgid "Using the ``-f`` flag, the following filesystem operations are supported:"
msgstr ""

#: ../../reference/pyboard.py.rst:93
msgid "``cp src [src...] dest`` Copy files to/from the device."
msgstr ""

#: ../../reference/pyboard.py.rst:94
msgid "``cat path`` Print the contents of a file on the device."
msgstr ""

#: ../../reference/pyboard.py.rst:95
msgid ""
"``ls [path]`` List contents of a directory (defaults to current working "
"directory)."
msgstr ""

#: ../../reference/pyboard.py.rst:96
msgid "``rm path`` Remove a file."
msgstr ""

#: ../../reference/pyboard.py.rst:97
msgid "``mkdir path`` Create a directory."
msgstr ""

#: ../../reference/pyboard.py.rst:98
msgid "``rmdir path`` Remove a directory."
msgstr ""

#: ../../reference/pyboard.py.rst:100
msgid ""
"The ``cp`` command uses a ``ssh``-like convention for referring to local "
"and remote files. Any path starting with a ``:`` will be interpreted as "
"on the device, otherwise it will be local. So::"
msgstr ""

#: ../../reference/pyboard.py.rst:104
msgid "$ pyboard.py --device /dev/ttyACM0 -f cp main.py :main.py"
msgstr ""

#: ../../reference/pyboard.py.rst:106
msgid ""
"will copy main.py from the current directory on the PC to a file named "
"main.py on the device. The filename can be omitted, e.g.::"
msgstr ""

#: ../../reference/pyboard.py.rst:109
msgid "$ pyboard.py --device /dev/ttyACM0 -f cp main.py :"
msgstr ""

#: ../../reference/pyboard.py.rst:111
msgid "is equivalent to the above."
msgstr ""

#: ../../reference/pyboard.py.rst:113
msgid "Some more examples::"
msgstr ""

#: ../../reference/pyboard.py.rst:115
msgid ""
"# Copy main.py from the device to the local PC.\n"
"$ pyboard.py --device /dev/ttyACM0 -f cp :main.py main.py\n"
"# Same, but using . instead.\n"
"$ pyboard.py --device /dev/ttyACM0 -f cp :main.py .\n"
"\n"
"# Copy three files to the device, keeping their names\n"
"# and paths (note: `lib` must exist on the device)\n"
"$ pyboard.py --device /dev/ttyACM0 -f cp main.py app.py lib/foo.py :\n"
"\n"
"# Remove a file from the device.\n"
"$ pyboard.py --device /dev/ttyACM0 -f rm util.py\n"
"\n"
"# Print the contents of a file on the device.\n"
"$ pyboard.py --device /dev/ttyACM0 -f cat boot.py\n"
"...contents of boot.py..."
msgstr ""

#: ../../reference/pyboard.py.rst:132
msgid "Using the pyboard library"
msgstr ""

#: ../../reference/pyboard.py.rst:134
msgid ""
"You can also use ``pyboard.py`` as a library for scripting interactions "
"with a MicroPython board."
msgstr ""

#: ../../reference/pyboard.py.rst:137
msgid ""
"import pyboard\n"
"pyb = pyboard.Pyboard('/dev/ttyACM0', 115200)\n"
"pyb.enter_raw_repl()\n"
"ret = pyb.exec('print(1+1)')\n"
"print(ret)\n"
"pyb.exit_raw_repl()"
msgstr ""

#: ../../../reference/repl.rst:2
msgid "The MicroPython Interactive Interpreter Mode (aka REPL)"
msgstr "MicroPython 対話インタプリタモード (別名 REPL)"

#: ../../../reference/repl.rst:4
msgid ""
"This section covers some characteristics of the MicroPython Interactive "
"Interpreter Mode. A commonly used term for this is REPL (read-eval-print-"
"loop) which will be used to refer to this interactive prompt."
msgstr ""
"この章は、MicroPython の対話インタプリタモードのいくつかの特性を扱います。"
"この機能の一般的に使用される用語は、REPL(read-eval-print-loop)です。"
"以後、この用語を対話プロンプトを示すものとして使います。"

#: ../../../reference/repl.rst:9
msgid "Auto-indent"
msgstr "自動インデント"

#: ../../../reference/repl.rst:11
msgid ""
"When typing python statements which end in a colon (for example if, for, "
"while) then the prompt will change to three dots (...) and the cursor "
"will be indented by 4 spaces. When you press return, the next line will "
"continue at the same level of indentation for regular statements or an "
"additional level of indentation where appropriate. If you press the "
"backspace key then it will undo one level of indentation."
msgstr ""
"python の文をコロンで終わるところまで入力すると(if, for while など)、プロンプトが"
"３つのドット(...)に変わり、カーソルは４文字の空白でインデントされます。リターンを"
"押すと、次の行は通常の文のために同じレベルでインデントを継続するか、適切な追加の"
"インデントレベルになります。バックスペースキーを押すと、インデントのレベルが１つ"
"取り消されます。"

#: ../../../reference/repl.rst:18
msgid ""
"If your cursor is all the way back at the beginning, pressing RETURN will"
" then execute the code that you've entered. The following shows what "
"you'd see after entering a for statement (the underscore shows where the "
"cursor winds up):"
msgstr ""
"カーソルを先頭に戻して RETURN を押すと、入力したコードを実行します。以下は、"
"for 文を入力した後にどうなっているかを示しています(下線はカーソル位置を示して"
"います)。"

#: ../../../reference/repl.rst:25
msgid ""
"If you then enter an if statement, an additional level of indentation "
"will be provided:"
msgstr ""
"if 文を入力すると、インデントの追加のレベルが提供されます。"

#: ../../../reference/repl.rst:32
msgid "Now enter ``break`` followed by RETURN and press BACKSPACE:"
msgstr "ここで ``break`` を入力して RETURN キーを押し、BACKSPACE キーを押してください。"

#: ../../../reference/repl.rst:39
msgid ""
"Finally type ``print(i)``, press RETURN, press BACKSPACE and press RETURN"
" again:"
msgstr ""
"最後に ``print(i)`` を入力し、RETURN キーを押し、BACKSPACE キーを押して、"
"再び RETURN キーを押してください。"

#: ../../../reference/repl.rst:52
msgid ""
"Auto-indent won't be applied if the previous two lines were all spaces.  "
"This means that you can finish entering a compound statement by pressing "
"RETURN twice, and then a third press will finish and execute."
msgstr ""
"前の２行がすべてスペースであった場合には、自動インデントが適用されません。これは、"
"２回 RETURN を押せば、複合文を入力し終えることができ、その後、３回目の押下で入力が"
"終了し、実行することを意味します。"

#: ../../../reference/repl.rst:57
msgid "Auto-completion"
msgstr "自動補間"

#: ../../../reference/repl.rst:59
msgid ""
"While typing a command at the REPL, if the line typed so far corresponds "
"to the beginning of the name of something, then pressing TAB will show "
"possible things that could be entered. For example, first import the "
"machine module by entering ``import machine`` and pressing RETURN. Then "
"type ``m`` and press TAB and it should expand to ``machine``. Enter a dot"
" ``.`` and press TAB again. You should see something like:"
msgstr ""
"REPL でコマンドを入力しているとき、入力中のものが、何かの名前の先頭部分に該当して"
"いれば、次に TAB を押すことにより入力している可能性のあるものが表示されます。"
"たとえば ``m`` を入力して TAB キーを押すと、 ``machine`` に展開されます。"
"続けてドット ``.`` を入力して もう一度　TAB キーを押してください。次のような"
"ものが表示されるはずです。"

#: ../../../reference/repl.rst:72
msgid ""
"The word will be expanded as much as possible until multiple "
"possibilities exist. For example, type ``machine.Pin.AF3`` and press TAB "
"and it will expand to ``machine.Pin.AF3_TIM``. Pressing TAB a second time"
" will show the possible expansions:"
msgstr ""
"複数の候補があれば、それだけのワードが展開されます。たとえば ``machine.Pin.AF3`` "
"を入力して TAB キーを押すと、 ``machine.Pin.AF3_TIM`` に展開されます。TAB "
"をもう一度押すと、次の候補が表示されます。"

#: ../../../reference/repl.rst:82
msgid "Interrupting a running program"
msgstr "実行中のプログラムの中断"

#: ../../../reference/repl.rst:84
msgid ""
"You can interrupt a running program by pressing Ctrl-C. This will raise a"
" KeyboardInterrupt which will bring you back to the REPL, providing your "
"program doesn't intercept the KeyboardInterrupt exception."
msgstr ""
"Ctrl+C キーを押すことで実行中のプログラムを中断できます。これは KeyboardInterrupt "
"例外を発生させ、REPL に戻ります。KeyboardInterrupt をプログラム中で捕らえることは"
"できません。"

#: ../../../reference/repl.rst:88
msgid "For example:"
msgstr "中断の例:"

#: ../../../reference/repl.rst:107
msgid "Paste mode"
msgstr "貼付けモード"

#: ../../../reference/repl.rst:109
msgid ""
"If you want to paste some code into your terminal window, the auto-indent"
" feature will mess things up. For example, if you had the following "
"python code: ::"
msgstr ""
"ターミナルウィンドウで何かのコードを貼り付けたい場合、自動インデント機能のせいでうまく"
"いかないことがあります。たとえば、次の Python コードがある場合:"

#: ../../../reference/repl.rst:112
msgid ""
"def foo():\n"
"    print('This is a test to show paste mode')\n"
"    print('Here is a second line')\n"
"foo()"
msgstr ""

#: ../../../reference/repl.rst:117
msgid ""
"and you try to paste this into the normal REPL, then you will see "
"something like this:"
msgstr ""
"通常の REPL にこれを貼り付けてみると、次のようになってしまいます。"

#: ../../../reference/repl.rst:129
msgid ""
"If you press Ctrl-E, then you will enter paste mode, which essentially "
"turns off the auto-indent feature, and changes the prompt from ``>>>`` to"
" ``===``. For example:"
msgstr ""
"Ctrl-E を押すと、貼付けモードとなり、基本的に自動インデント機能が無効となり、"
"プロンプトが ``>>>`` から ``===`` に変わります。次に例を示します。"

#: ../../../reference/repl.rst:143
msgid ""
"Paste Mode allows blank lines to be pasted. The pasted text is compiled "
"as if it were a file. Pressing Ctrl-D exits paste mode and initiates the "
"compilation."
msgstr ""
"貼付けモードでは、空白行を貼り付けることができるようになります。ファイルであるかの"
"ように貼り付けたテキストがコンパイルされます。Ctrl+Dキーを押すと、ペーストモードを"
"終了し、コンパイルを開始します。"

#: ../../../reference/repl.rst:147
msgid "Soft reset"
msgstr "ソフトリセット"

#: ../../../reference/repl.rst:149
msgid ""
"A soft reset will reset the python interpreter, but tries not to reset "
"the method by which you're connected to the MicroPython board (USB-"
"serial, or Wifi)."
msgstr ""
"ソフトリセットは python インタプリタをリセットしますが、MicroPython ボード"
"に接続している手段(USBシリアル、または無線LAN)をリセットしないよう試みます。"

#: ../../../reference/repl.rst:152
msgid ""
"You can perform a soft reset from the REPL by pressing Ctrl-D, or from "
"your python code by executing: ::"
msgstr ""
"ソフトリセットは Ctrl-D を押すことで起こせます。python コード中からも次を実行"
"することでソフトリセットを起こせます。"

#: ../../../reference/repl.rst:155
msgid "machine.soft_reset()"
msgstr ""

#: ../../../reference/repl.rst:157
msgid ""
"For example, if you reset your MicroPython board, and you execute a dir()"
" command, you'd see something like this:"
msgstr ""
"たとえば MicroPython ボードをリセットし、dir() 命令を実行すると、次のようになる"
"でしょう。"

#: ../../../reference/repl.rst:163
msgid "Now create some variables and repeat the dir() command:"
msgstr "ここで、いくつかの変数の作成と dir() 命令を繰り返します。"

#: ../../../reference/repl.rst:172
msgid ""
"Now if you enter Ctrl-D, and repeat the dir() command, you'll see that "
"your variables no longer exist:"
msgstr ""
"ここで Ctrl-D を押して、再度 dir() を行ってみれば、変数がもはや存在しないことが"
"わかります。"

#: ../../../reference/repl.rst:175
msgid ""
"MPY: sync filesystems\n"
"MPY: soft reboot\n"
"MicroPython v1.5-51-g6f70283-dirty on 2015-10-30; PYBv1.0 with "
"STM32F405RG\n"
"Type \"help()\" for more information.\n"
">>> dir()\n"
"['__name__', 'pyb']\n"
">>>"
msgstr ""

#: ../../../reference/repl.rst:186
msgid "The special variable _ (underscore)"
msgstr "特殊変数 _ (下線)"

#: ../../../reference/repl.rst:188
msgid ""
"When you use the REPL, you may perform computations and see the results. "
"MicroPython stores the results of the previous statement in the variable "
"_ (underscore). So you can use the underscore to save the result in a "
"variable. For example:"
msgstr ""
"REPL を使っているときには、計算を実行した結果を使いたいことがあります。"
"MicroPython は、前の文の結果を変数 _　(下線)に格納します。ですから、"
"変数に結果を保存するために、アンダースコアが使えます。たとえば"
"次のように使えます。"

#: ../../../reference/repl.rst:200
msgid "Raw mode"
msgstr "raw モード"

#: ../../../reference/repl.rst:202
msgid ""
"Raw mode is not something that a person would normally use. It is "
"intended for programmatic use. It essentially behaves like paste mode "
"with echo turned off."
msgstr ""
"raw モードは、人が通常使うものではありません。これは、プログラムで使うよう意図"
"されています。本質的には、エコーが無効になったペーストモードのように動作します。"

#: ../../../reference/repl.rst:205
msgid ""
"Raw mode is entered using Ctrl-A. You then send your python code, "
"followed by a Ctrl-D. The Ctrl-D will be acknowledged by 'OK' and then "
"the python code will be compiled and executed. Any output (or errors) "
"will be sent back. Entering Ctrl-B will leave raw mode and return the the"
" regular (aka friendly) REPL."
msgstr ""
"raw モードには、Ctrl+A キーを使って入ります。続いて python コード と Ctrl-D を"
"送信します。Ctrl-D は「OK」によって承認され、その後 python コードがコンパイルされ、"
"実行されます。任意の出力(またはエラー)が戻ってきます。Ctrl-B を入力すると、raw "
"モードを終了して、通常の(フレンドリーな) REPL に戻ります。"

#: ../../../reference/repl.rst:210
msgid ""
"The ``tools/pyboard.py`` program uses the raw REPL to execute python "
"files on the MicroPython board."
msgstr ""
"``tools/pyboard.py`` プログラムは MicroPython ボード上の python ファイルを"
"実行するために、raw REPL を使っています。"

#: ../../../reference/speed_python.rst:2
msgid "Maximising MicroPython speed"
msgstr "MicroPython 性能の最大化"

#: ../../../reference/speed_python.rst:6
msgid "contents::"
msgstr "目次::"

#: ../../../reference/speed_python.rst:8
msgid ""
"This tutorial describes ways of improving the performance of MicroPython "
"code. Optimisations involving other languages are covered elsewhere, "
"namely the use of modules written in C and the MicroPython inline "
"assembler."
msgstr ""
"このチュートリアルでは、MicroPython コードの性能を向上させる方法について説明します。"
"他の言語も使った最適化としては、C言語で書かれたモジュールと MicroPython インライン"
"アセンブラを扱っています。"

#: ../../../reference/speed_python.rst:12
msgid ""
"The process of developing high performance code comprises the following "
"stages which should be performed in the order listed."
msgstr ""
"高性能なコードを開発するプロセスは、次の段階を順番に実施します。"

#: ../../../reference/speed_python.rst:15
msgid "Design for speed."
msgstr "性能のための設計"

#: ../../../reference/speed_python.rst:16
msgid "Code and debug."
msgstr "コーディングとデバッグ"

#: ../../../reference/speed_python.rst:18
msgid "Optimisation steps:"
msgstr "最適化の段階:"

#: ../../../reference/speed_python.rst:20
msgid "Identify the slowest section of code."
msgstr "コードの最も遅い部分を特定。"

#: ../../../reference/speed_python.rst:21
msgid "Improve the efficiency of the Python code."
msgstr "Python コードの効率を向上。"

#: ../../../reference/speed_python.rst:22
msgid "Use the native code emitter."
msgstr "ネイティブコードエミッターを使用。"

#: ../../../reference/speed_python.rst:23
msgid "Use the viper code emitter."
msgstr "バイパーコードエミッタを使用。"

#: ../../../reference/speed_python.rst:24
msgid "Use hardware-specific optimisations."
msgstr "ハードウェア固有の最適化を使用。"

#: ../../../reference/speed_python.rst:27
msgid "Designing for speed"
msgstr "性能のための設計"

#: ../../../reference/speed_python.rst:29
msgid ""
"Performance issues should be considered at the outset. This involves "
"taking a view on the sections of code which are most performance critical"
" and devoting particular attention to their design. The process of "
"optimisation begins when the code has been tested: if the design is "
"correct at the outset optimisation will be straightforward and may "
"actually be unnecessary."
msgstr ""
"性能の問題は最初から考慮する必要があります。これには、性能が最も重要となるコードの"
"セクションを見て、その設計に特に注意を払うことが含まれます。最適化のプロセスは、"
"コードがテストされたときに始まります。設計が最初から正しい場合、最適化は簡単で"
"実際には不要な場合があります。"

#: ../../../reference/speed_python.rst:36
msgid "Algorithms"
msgstr "アルゴリズム"

#: ../../../reference/speed_python.rst:38
msgid ""
"The most important aspect of designing any routine for performance is "
"ensuring that the best algorithm is employed. This is a topic for "
"textbooks rather than for a MicroPython guide but spectacular performance"
" gains can sometimes be achieved by adopting algorithms known for their "
"efficiency."
msgstr ""
"性能のためにルーチンを設計する際の最も重要な側面は、最良のアルゴリズムが採用されることを"
"確実にすることです。これは MicroPython でガイドするようなことではなく教科書のトピック"
"ですが、効率がよく知られているアルゴリズムを採用することで、パフォーマンスが大幅に向上"
"することがあります。"

#: ../../../reference/speed_python.rst:44
msgid "RAM allocation"
msgstr "RAM の割り当て"

#: ../../../reference/speed_python.rst:46
msgid ""
"To design efficient MicroPython code it is necessary to have an "
"understanding of the way the interpreter allocates RAM. When an object is"
" created or grows in size (for example where an item is appended to a "
"list) the necessary RAM is allocated from a block known as the heap. This"
" takes a significant amount of time; further it will on occasion trigger "
"a process known as garbage collection which can take several "
"milliseconds."
msgstr ""
"効率的な MicroPython コードを設計するには、インタプリタが RAM を割り当てる方法を"
"理解しておく必要があります。オブジェクトが作成されるかサイズが大きくなると(たとえば、"
"項目がリストに追加される場合など)、必要な RAM はヒープと呼ばれるブロックから割り当て"
"られます。これにはかなりの時間がかかります。さらに場合によっては、ガベージコレクション"
"として知られるプロセスを起動します。"

#: ../../../reference/speed_python.rst:53
msgid ""
"Consequently the performance of a function or method can be improved if "
"an object is created once only and not permitted to grow in size. This "
"implies that the object persists for the duration of its use: typically "
"it will be instantiated in a class constructor and used in various "
"methods."
msgstr ""
"したがって、オブジェクトが１回しか作成されず、サイズが大きくなることを許可されて"
"いない場合、関数またはメソッドのパフォーマンスは向上します。これは、オブジェクトが"
"その使用期間中存続することを意味します。通常、クラスコンストラクタ内でインスタンス化"
"され、さまざまなメソッドで使用されます。"

#: ../../../reference/speed_python.rst:58
msgid ""
"This is covered in further detail :ref:`Controlling garbage collection "
"<controlling_gc>` below."
msgstr ""
"これについては、後述の :ref:`ガベージコレクションの制御 <controlling_gc>` "
"でさらに詳しく説明します。"

#: ../../../reference/speed_python.rst:61
msgid "Buffers"
msgstr "バッファ"

#: ../../../reference/speed_python.rst:63
msgid ""
"An example of the above is the common case where a buffer is required, "
"such as one used for communication with a device. A typical driver will "
"create the buffer in the constructor and use it in its I/O methods which "
"will be called repeatedly."
msgstr ""
"先に、デバイスとの通信にバッファを必要とする一般的な例がありました。典型的なドライバは、"
"コンストラクタ内にバッファを作成し、それを繰り返し呼び出される I/O メソッドで使います。"

#: ../../../reference/speed_python.rst:67
msgid ""
"The MicroPython libraries typically provide support for pre-allocated "
"buffers. For example, objects which support stream interface (e.g., file "
"or UART) provide ``read()`` method which allocates new buffer for read "
"data, but also a ``readinto()`` method to read data into an existing "
"buffer."
msgstr ""
"MicroPython ライブラリは通常、事前に割り当てられたバッファをサポートします。たとえば、"
"ストリームインタフェースをサポートするオブジェクト(ファイルや UART など)は、"
"読み取りデータ用に新しいバッファを割り当てる ``read()`` メソッドを提供し、"
"既存のバッファにデータを読み取る ``readinto()`` メソッドも提供します。"

#: ../../../reference/speed_python.rst:73
msgid "Floating point"
msgstr "浮動小数点"

#: ../../../reference/speed_python.rst:75
msgid ""
"Some MicroPython ports allocate floating point numbers on heap. Some "
"other ports may lack dedicated floating-point coprocessor, and perform "
"arithmetic operations on them in \"software\" at considerably lower speed"
" than on integers. Where performance is important, use integer operations"
" and restrict the use of floating point to sections of the code where "
"performance is not paramount. For example, capture ADC readings as "
"integers values to an array in one quick go, and only then convert them "
"to floating-point numbers for signal processing."
msgstr ""
"MicroPython ポートによっては浮動小数点数をヒープに割り当てます。ポートによっては"
"専用の浮動小数点コプロセッサを欠いていて、整数よりもかなり低い速度で算術演算を"
"「ソフトウェア」実行するかもしれません。性能が重要な場合は、整数演算を使用し、"
"浮動小数点の利用を性能が重要ではないコードのセクションに制限します。たとえば、"
"ADC の読み値を整数値として１回の配列で取得し、その後で信号処理のためにそれらを"
"浮動小数点数に変換します。"

#: ../../../reference/speed_python.rst:84
msgid "Arrays"
msgstr "配列"

#: ../../../reference/speed_python.rst:86
msgid ""
"Consider the use of the various types of array classes as an alternative "
"to lists. The `array` module supports various element types with 8-bit "
"elements supported by Python's built in `bytes` and `bytearray` classes. "
"These data structures all store elements in contiguous memory locations. "
"Once again to avoid memory allocation in critical code these should be "
"pre-allocated and passed as arguments or as bound objects."
msgstr ""
"リストに代わるものとして、さまざまなタイプの配列クラスの利用を検討してください。"
"`array` モジュールは、Python の組み込みクラス `bytes` や `bytearray` クラスで"
"サポートされている８ビット要素を含むさまざまな要素型をサポートしています。これらの"
"データ構造はすべて、隣接するメモリ位置に要素を格納しています。クリティカルコードでの"
"メモリ割り当てを避けるために、これらは事前に割り当てられ、引数またはバインドされた"
"オブジェクトとして渡されるべきです。"

#: ../../../reference/speed_python.rst:92
msgid ""
"When passing slices of objects such as `bytearray` instances, Python "
"creates a copy which involves allocation of the size proportional to the "
"size of slice. This can be alleviated using a `memoryview` object. "
"`memoryview` itself is allocated on heap, but is a small, fixed-size "
"object, regardless of the size of slice it points too."
msgstr ""
"`bytearray` インスタンスなどのオブジェクトのスライスを渡すとき、Python はスライスの"
"サイズに比例したサイズの割り当てを含むコピーを作成します。これは `memoryview` "
"オブジェクトを使用して軽減できます。 `memoryview` それ自体はヒープ上に割り当て"
"られますが、それが指すスライスのサイズに関係なく、小さい固定サイズのオブジェクトです。"

#: ../../../reference/speed_python.rst:104
msgid ""
"ba = bytearray(10000)  # big array\n"
"func(ba[30:2000])      # a copy is passed, ~2K new allocation\n"
"mv = memoryview(ba)    # small object is allocated\n"
"func(mv[30:2000])      # a pointer to memory is passed"
msgstr ""
"ba = bytearray(10000)  # 巨大な配列\n"
"func(ba[30:2000])      # 新規に 2K のコピーを割り当てて、渡されます\n"
"mv = memoryview(ba)    # 小さなオブジェクトが割り当てられます\n"
"func(mv[30:2000])      # メモリのポインターが渡されます"

#: ../../../reference/speed_python.rst:105
msgid ""
"A `memoryview` can only be applied to objects supporting the buffer "
"protocol - this includes arrays but not lists. Small caveat is that while"
" memoryview object is live, it also keeps alive the original buffer "
"object. So, a memoryview isn't a universal panacea. For instance, in the "
"example above, if you are done with 10K buffer and just need those bytes "
"30:2000 from it, it may be better to make a slice, and let the 10K buffer"
" go (be ready for garbage collection), instead of making a long-living "
"memoryview and keeping 10K blocked for GC."
msgstr ""
"`memoryview` はバッファプロトコルをサポートするオブジェクトにのみ適用できます。"
"これには配列は含まれますがリストは含まれません。ちょっとした注意点は、 `memoryview` "
"オブジェクトが生きている間は、元のバッファオブジェクトも生き続けているということです。"
"だから、 memoryview は普遍的な万能薬ではありません。たとえば、上の例で、10Kバッファを"
"使い終わって、そこからそれらのバイト 30:2000 だけが必要な場合は、代わりにスライスを"
"作成して、10K バッファを移動させます(ガベージコレクションの対象となるようにします)。"
"こうすることで、長命の memoryview を作成して、10K が GC からブロックされたままになる"
"ようなことがなくなります。"

#: ../../../reference/speed_python.rst:113
msgid ""
"Nonetheless, `memoryview` is indispensable for advanced preallocated "
"buffer management. ``readinto()`` method discussed above puts data at the"
" beginning of buffer and fills in entire buffer. What if you need to put "
"data in the middle of existing buffer? Just create a memoryview into the "
"needed section of buffer and pass it to ``readinto()``."
msgstr ""
"それでも、 `memoryview` は高度な事前割り当てバッファ管理に欠かせません。"
"先にとりあげた ``readinto()`` メソッドでは、データをバッファの先頭から置いていき、"
"バッファ全体を埋めます。既存のバッファの途中にデータを配置する必要がある場合はどうしますか？ "
"バッファの必要なセクションにメモリビューを作成してそれを ``readinto()`` に渡すだけです。"

#: ../../../reference/speed_python.rst:120
msgid "Identifying the slowest section of code"
msgstr "コードの最も遅い部分を特定する"

#: ../../../reference/speed_python.rst:122
msgid ""
"This is a process known as profiling and is covered in textbooks and (for"
" standard Python) supported by various software tools. For the type of "
"smaller embedded application likely to be running on MicroPython "
"platforms the slowest function or method can usually be established by "
"judicious use of the timing ``ticks`` group of functions documented in "
"`utime`. Code execution time can be measured in ms, us, or CPU cycles."
msgstr ""
"これはプロファイリングとして知られている手続きで、教科書でもとりあげられていて、"
"(標準的な Python のために)さまざまなソフトウェアツールでサポートされています。"
"MicroPython プラットフォーム上で実行される可能性が高い小型の組込みアプリケーション"
"について、最も遅い関数またはメソッドは `utime` モジュールにある ``ticks`` 関数群を"
"賢明に使うことで特定できます。コードの実行時間は、ms, us, または CPU サイクルで"
"測定できます。"

#: ../../../reference/speed_python.rst:129
msgid ""
"The following enables any function or method to be timed by adding an "
"``@timed_function`` decorator:"
msgstr ""
"以下を ``@timed_function`` デコレータとして任意の関数またはメソッドに追加する"
"ことで、実行時間の計測が可能になります。"

#: ../../../reference/speed_python.rst:143
msgid ""
"def timed_function(f, *args, **kwargs):\n"
"    myname = str(f).split(' ')[1]\n"
"    def new_func(*args, **kwargs):\n"
"        t = utime.ticks_us()\n"
"        result = f(*args, **kwargs)\n"
"        delta = utime.ticks_diff(utime.ticks_us(), t)\n"
"        print('Function {} Time = {:6.3f}ms'.format(myname, delta/1000))\n"
"        return result\n"
"    return new_func"
msgstr ""

#: ../../../reference/speed_python.rst:145
msgid "MicroPython code improvements"
msgstr "MicroPython コードの改良"

#: ../../../reference/speed_python.rst:148
msgid "The const() declaration"
msgstr "const() 宣言"

#: ../../../reference/speed_python.rst:150
msgid ""
"MicroPython provides a ``const()`` declaration. This works in a similar "
"way to ``#define`` in C in that when the code is compiled to bytecode the"
" compiler substitutes the numeric value for the identifier. This avoids a"
" dictionary lookup at runtime. The argument to ``const()`` may be "
"anything which, at compile time, evaluates to an integer e.g. ``0x100`` "
"or ``1 << 8``."
msgstr ""
"MicroPython は ``const()`` 宣言を提供します。これは C 言語の ``#define`` と同様に"
"作用するもので、コードがバイトコードにコンパイルされるときにコンパイラが識別子に数値を"
"置換します。これにより、実行時の辞書検索が回避されます。 `const()` の引数はコンパイル時に、"
"整数値に評価されるものであれば何でもありです(``0x100`` や ``1 << 8`` など)。"

#: ../../../reference/speed_python.rst:159
msgid "Caching object references"
msgstr "オブジェクト参照のキャッシュ"

#: ../../../reference/speed_python.rst:161
msgid ""
"Where a function or method repeatedly accesses objects performance is "
"improved by caching the object in a local variable:"
msgstr ""
"関数またはメソッドが繰り返しオブジェクトにアクセスする場合、オブジェクトをローカル"
"変数にキャッシュすることでパフォーマンスが向上します。"

#: ../../../reference/speed_python.rst:173
msgid ""
"class foo(object):\n"
"    def __init__(self):\n"
"        ba = bytearray(100)\n"
"    def bar(self, obj_display):\n"
"        ba_ref = self.ba\n"
"        fb = obj_display.framebuffer\n"
"        # iterative code using these two objects"
msgstr ""
"class foo(object):\n"
"    def __init__(self):\n"
"        self.ba = bytearray(100)\n"
"    def bar(self, obj_display):\n"
"        ba_ref = self.ba\n"
"        fb = obj_display.framebuffer\n"
"        # ２つのオブジェクト用いた反復処理"

#: ../../../reference/speed_python.rst:174
msgid ""
"This avoids the need repeatedly to look up ``self.ba`` and "
"``obj_display.framebuffer`` in the body of the method ``bar()``."
msgstr ""
"これは ``bar()`` メソッド本体で ``self.ba`` と ``obj_display.framebuffer`` "
"を繰り返し探す必要性を回避します。"

#: ../../../reference/speed_python.rst:180
msgid "Controlling garbage collection"
msgstr "ガベージコレクションを制御する"

#: ../../../reference/speed_python.rst:182
msgid ""
"When memory allocation is required, MicroPython attempts to locate an "
"adequately sized block on the heap. This may fail, usually because the "
"heap is cluttered with objects which are no longer referenced by code. If"
" a failure occurs, the process known as garbage collection reclaims the "
"memory used by these redundant objects and the allocation is then tried "
"again - a process which can take several milliseconds."
msgstr ""
"メモリ割り当てが必要な場合、MicroPython はヒープ上で適切なサイズのブロックを"
"見つけようとします。これは失敗する可能性があります。これは通常、コード内で
"参照されなくなったオブジェクトでヒープが雑然としているためです。メモリ割り当てに"
"失敗した場合、ガベージコレクションと呼ばれるプロセスが参照されなくなったオブジェクトが"
"使っているメモリを回収し、割り当てが再試行されます。このプロセスには数ミリ秒"
"かかることがあります。"

#: ../../../reference/speed_python.rst:189
msgid ""
"There may be benefits in pre-empting this by periodically issuing "
"`gc.collect()`. Firstly doing a collection before it is actually required"
" is quicker - typically on the order of 1ms if done frequently. Secondly "
"you can determine the point in code where this time is used rather than "
"have a longer delay occur at random points, possibly in a speed critical "
"section. Finally performing collections regularly can reduce "
"fragmentation in the heap. Severe fragmentation can lead to non-"
"recoverable allocation failures."
msgstr ""
"`gc.collect()` を定期的に実行することで、ガベージコレクションを先取りすることに"
"利点があるかもしれません。第１に、ガベージコレクションが実際に必要とされる前に"
"行ってけばより速く終わります - 頻繁に行うならば通常 1ms のオーダーで終わります。"
"第２に、ガベージコレクションで時間が消費されるコード内のポイントを決定でき、"
"ランダムなポイント(おそらくスピードが重視されるセクション)でより長い遅延が"
"発生するのを回避できます。最後に、定期的にガベージコレクションを実行すると、"
"ヒープ内の断片化を減らすことができます。重大な断片化は、回復不可能な割り当ての"
"失敗につながる可能性があります。"

#: ../../../reference/speed_python.rst:198
msgid "The Native code emitter"
msgstr "ネイティブコードエミッター"

#: ../../../reference/speed_python.rst:200
msgid ""
"This causes the MicroPython compiler to emit native CPU opcodes rather "
"than bytecode. It covers the bulk of the MicroPython functionality, so "
"most functions will require no adaptation (but see below). It is invoked "
"by means of a function decorator:"
msgstr ""
"これにより、MicroPython コンパイラはバイトコードではなくネイティブの CPU オペコードを"
"発行します。MicroPython の機能の大部分をカバーしているので、ほとんどの機能は調整を"
"必要としません(ただし下記参照)。これは関数デコレータによって呼び出されます。"

#: ../../../reference/speed_python.rst:210
msgid ""
"@micropython.native\n"
"def foo(self, arg):\n"
"    buf = self.linebuf # Cached object\n"
"    # code"
msgstr ""
"@micropython.native\n"
"def foo(self, arg):\n"
"    buf = self.linebuf # オブジェクトをキャッシュ\n"
"    # コード"

#: ../../../reference/speed_python.rst:211
msgid ""
"There are certain limitations in the current implementation of the native"
" code emitter."
msgstr ""
"ネイティブコードエミッターの現在の実装には一定の制限があります。"

#: ../../../reference/speed_python.rst:213
msgid "Context managers are not supported (the ``with`` statement)."
msgstr ""
"コンテキストマネージャはサポートされていません(``with`` ステートメント)。

#: ../../../reference/speed_python.rst:214
msgid "Generators are not supported."
msgstr "ジェネレータはサポートされていません。"

#: ../../../reference/speed_python.rst:215
msgid "If ``raise`` is used an argument must be supplied."
msgstr "``raise`` を使う場合は、引数を指定する必要があります。"

#: ../../../reference/speed_python.rst:217
msgid ""
"The trade-off for the improved performance (roughly twice as fast as "
"bytecode) is an increase in compiled code size."
msgstr ""
"パフォーマンスの向上(バイトコードの約2倍の速さ)とのトレードオフは、"
"コンパイルされたコードサイズの増加です。"

#: ../../../reference/speed_python.rst:221
msgid "The Viper code emitter"
msgstr "バイパーコードエミッター"

#: ../../../reference/speed_python.rst:223
msgid ""
"The optimisations discussed above involve standards-compliant Python "
"code. The Viper code emitter is not fully compliant. It supports special "
"Viper native data types in pursuit of performance. Integer processing is "
"non-compliant because it uses machine words: arithmetic on 32 bit "
"hardware is performed modulo 2**32."
msgstr ""
"先にとりあげた最適化には、標準に準拠した Python コードが含まれています。"
"バイパーコードのエミッターは完全には準拠していません。パフォーマンスを追求した特別な"
"バイパーネイティブデータ型をサポートします。整数処理が不適合となっていて、"
"機械語を使っているため、32ビットハードウェア上での算術演算は 2**32 の範囲となります。"

#: ../../../reference/speed_python.rst:228
msgid ""
"Like the Native emitter Viper produces machine instructions but further "
"optimisations are performed, substantially increasing performance "
"especially for integer arithmetic and bit manipulations. It is invoked "
"using a decorator:"
msgstr ""
"ネイティブエミッタと同様にバイパーは機械語命令を生成しますが、さらに最適化が実行され、"
"特に整数演算とビット操作のパフォーマンスが大幅に向上します。これはデコレータを使って"
"呼び出されます。"

#: ../../../reference/speed_python.rst:237
msgid ""
"@micropython.viper\n"
"def foo(self, arg: int) -> int:\n"
"    # code"
msgstr ""
"@micropython.viper\n"
"def foo(self, arg: int) -> int:\n"
"    # コード"

#: ../../../reference/speed_python.rst:238
msgid ""
"As the above fragment illustrates it is beneficial to use Python type "
"hints to assist the Viper optimiser. Type hints provide information on "
"the data types of arguments and of the return value; these are a standard"
" Python language feature formally defined here `PEP0484 "
"<https://www.python.org/dev/peps/pep-0484/>`_. Viper supports its own set"
" of types namely ``int``, ``uint`` (unsigned integer), ``ptr``, ``ptr8``,"
" ``ptr16`` and ``ptr32``. The ``ptrX`` types are discussed below. "
"Currently the ``uint`` type serves a single purpose: as a type hint for a"
" function return value. If such a function returns ``0xffffffff`` Python "
"will interpret the result as 2**32 -1 rather than as -1."
msgstr ""
"上記のコードが示すように、バイパー最適化ツールを支援するために Python の型ヒントを"
"使うことが有益です。型ヒントは、引数のデータ型と戻り値の情報を提供します。これは "
"`PEP0484 <https://www.python.org/dev/peps/pep-0484/>`_ で正式に定義された"
"標準の Python 言語機能です。バイパーは独自の型セット ``int``, ``uint`` (符号なし整数), "
"``ptr``, ``ptr8``, ``ptr16``, ``ptr32`` をサポートしています。"
"``ptrX`` 型については後述します。現在のところ ``uint`` 型は単一の目的、関数の戻り値の"
"型ヒントとして使うために提供しています。そのような関数が ``0xffffffff`` を返す場合、"
"Python は結果を -1 ではなく、2**32 -1 として解釈します。"

#: ../../../reference/speed_python.rst:246
msgid ""
"In addition to the restrictions imposed by the native emitter the "
"following constraints apply:"
msgstr ""
"バイパーでは、ネイティブエミッターの制限に加えて以下の制限が適用されます:"

#: ../../../reference/speed_python.rst:248
msgid "Functions may have up to four arguments."
msgstr "関数は持てる引数は最大４つまでです。"

#: ../../../reference/speed_python.rst:249
msgid "Default argument values are not permitted."
msgstr "デフォルトの引数値は許可されていません。"

#: ../../../reference/speed_python.rst:250
msgid "Floating point may be used but is not optimised."
msgstr "浮動小数点は使えますが、最適化されません。"

#: ../../../reference/speed_python.rst:252
msgid "Viper provides pointer types to assist the optimiser. These comprise"
msgstr "バイパーは最適化を支援するためのポインタ型を提供します。次のものがあります。"

#: ../../../reference/speed_python.rst:254
msgid "``ptr`` Pointer to an object."
msgstr "``ptr`` オブジェクトのポインター"

#: ../../../reference/speed_python.rst:255
msgid "``ptr8`` Points to a byte."
msgstr "``ptr8`` バイトを指すポインター"

#: ../../../reference/speed_python.rst:256
msgid "``ptr16`` Points to a 16 bit half-word."
msgstr "``ptr16`` 16ビット、半ワードを指すポインター"

#: ../../../reference/speed_python.rst:257
msgid "``ptr32`` Points to a 32 bit machine word."
msgstr "``ptr32`` 32ビットマシンワードを指すポインター"

#: ../../../reference/speed_python.rst:259
msgid ""
"The concept of a pointer may be unfamiliar to Python programmers. It has "
"similarities to a Python `memoryview` object in that it provides direct "
"access to data stored in memory. Items are accessed using subscript "
"notation, but slices are not supported: a pointer can return a single "
"item only. Its purpose is to provide fast random access to data stored in"
" contiguous memory locations - such as data stored in objects which "
"support the buffer protocol, and memory-mapped peripheral registers in a "
"microcontroller. It should be noted that programming using pointers is "
"hazardous: bounds checking is not performed and the compiler does nothing"
" to prevent buffer overrun errors."
msgstr ""
"ポインターの概念は、Python プログラマにはなじみがないかもしれません。 `memoryview` "
"メモリに格納されているデータに直接アクセスできるという点で、Python オブジェクトと"
"似ています。項目には添え字表記を使ってアクセスしますが、スライスはサポートしていません。"
"ポインターは単一の項目のみを返すことができます。その目的は、バッファプロトコルをサポート"
"するオブジェクトに格納されたデータや、マイクロコントローラ内のメモリマップされた周辺"
"レジスタなど、連続したメモリ位置に格納されたデータへの高速ランダムアクセスを提供する"
"ことです。ポインターを使用したプログラミングは危険です。境界チェックは実行されず、"
"コンパイラはバッファオーバーランエラーを防ぐために何もしません。"

#: ../../../reference/speed_python.rst:268
msgid "Typical usage is to cache variables:"
msgstr "典型的な使い方は変数をキャッシュすることです:"

#: ../../../reference/speed_python.rst:278
msgid ""
"@micropython.viper\n"
"def foo(self, arg: int) -> int:\n"
"    buf = ptr8(self.linebuf) # self.linebuf is a bytearray or bytes "
"object\n"
"    for x in range(20, 30):\n"
"        bar = buf[x] # Access a data item through the pointer\n"
"        # code omitted"
msgstr ""
"@micropython.viper\n"
"def foo(self, arg: int) -> int:\n"
"    buf = ptr8(self.linebuf) # self.linebuf は bytearray または bytes オブジェクト\n"
"    for x in range(20, 30):\n"
"        bar = buf[x] # ポインターでデータ項目にアクセス\n"
"        # 以下省略"

#: ../../../reference/speed_python.rst:279
msgid ""
"In this instance the compiler \"knows\" that ``buf`` is the address of an"
" array of bytes; it can emit code to rapidly compute the address of "
"``buf[x]`` at runtime. Where casts are used to convert objects to Viper "
"native types these should be performed at the start of the function "
"rather than in critical timing loops as the cast operation can take "
"several microseconds. The rules for casting are as follows:"
msgstr ""
"この例において、コンパイラは ``buf`` がバイト配列のアドレスであることを「認識」しています。"
"このため、 ``buf[x]`` 実行時にアドレスを迅速に計算するためのコードを発行できます。"
"オブジェクトをバイパーネイティブ型に変換するのにキャストを使う場合、キャスト操作には"
"数マイクロ秒かかることがあるため、これらはクリティカルなタイミングループではなく関数の"
"開始時に実行する必要があります。キャストの規則は次のとおりです:"

#: ../../../reference/speed_python.rst:285
msgid ""
"Casting operators are currently: ``int``, ``bool``, ``uint``, ``ptr``, "
"``ptr8``, ``ptr16`` and ``ptr32``."
msgstr ""
"キャスト演算子には現在のところ ``int``, ``bool``, ``uint``, ``ptr``, ``ptr8``, "
"``ptr16``, ``ptr32`` があります。"

#: ../../../reference/speed_python.rst:286
msgid "The result of a cast will be a native Viper variable."
msgstr ""
"キャストの結果は、ネイティブのバイパー変数になります。"

#: ../../../reference/speed_python.rst:287
msgid "Arguments to a cast can be a Python object or a native Viper variable."
msgstr ""
"キャストの引数には、Python オブジェクトまたはネイティブのバイパー変数を指定できます。"

#: ../../../reference/speed_python.rst:288
msgid ""
"If argument is a native Viper variable, then cast is a no-op (i.e. costs "
"nothing at runtime) that just changes the type (e.g. from ``uint`` to "
"``ptr8``) so that you can then store/load using this pointer."
msgstr ""
"引数がネイティブバイパー変数である場合、単に型が変わるだけで(たとえば  ``uint`` から `ptr8``)、"
"キャストは何もしない(実行時にコストはかからない)ので、このポインターでストア/ロードできるように"
"なります。"

#: ../../../reference/speed_python.rst:291
msgid ""
"If the argument is a Python object and the cast is ``int`` or ``uint``, "
"then the Python object must be of integral type and the value of that "
"integral object is returned."
msgstr ""
"引数が Python オブジェクトであり、キャストが ``int`` または ``uint`` である場合、"
"Python オブジェクトは整数型でなければならず、その整数オブジェクトの値が返されます。"

#: ../../../reference/speed_python.rst:293
msgid ""
"The argument to a bool cast must be integral type (boolean or integer); "
"when used as a return type the viper function will return True or False "
"objects."
msgstr ""
"bool キャストへの引数は整数型(ブール値または整数)でなければなりません。"
"戻り値の型として使われた場合、バイパー関数は True または False オブジェクトを返します。"

#: ../../../reference/speed_python.rst:295
msgid ""
"If the argument is a Python object and the cast is ``ptr``, ``ptr``, "
"``ptr16`` or ``ptr32``, then the Python object must either have the "
"buffer protocol with read-write capabilities (in which case a pointer to "
"the start of the buffer is returned) or it must be of integral type (in "
"which case the value of that integral object is returned)."
msgstr ""
"引数が Python オブジェクトであり、キャストが ``ptr``, ``ptr16``, PPptr32`` の"
"場合、Python オブジェクトは読み書き機能を持つバッファプロトコルを有しているか"
"(バッファの先頭へのポインタを返す場合)、整数型のものでなければなりません(この場合、"
"その整数オブジェクトの値が返されます)。"

#: ../../../reference/speed_python.rst:300
msgid ""
"The following example illustrates the use of a ``ptr16`` cast to toggle "
"pin X1 ``n`` times:"
msgstr ""
"次はピン X1 を ``n`` 回切り替えるために ``ptr16`` キャストを使った例を示しています。

#: ../../../reference/speed_python.rst:310
msgid ""
"BIT0 = const(1)\n"
"@micropython.viper\n"
"def toggle_n(n: int):\n"
"    odr = ptr16(stm.GPIOA + stm.GPIO_ODR)\n"
"    for _ in range(n):\n"
"        odr[0] ^= BIT0"
msgstr ""

#: ../../../reference/speed_python.rst:311
msgid ""
"A detailed technical description of the three code emitters may be found "
"on Kickstarter here `Note 1 "
"<https://www.kickstarter.com/projects/214379695/micro-python-python-for-"
"microcontrollers/posts/664832>`_ and here `Note 2 "
"<https://www.kickstarter.com/projects/214379695/micro-python-python-for-"
"microcontrollers/posts/665145>`_"
msgstr ""
"３つのコードエミッターの詳細な技術的説明が、Kickstarter の "
"`Note 1 <https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/664832>`_ "
"と "
"`Note 2 <https://www.kickstarter.com/projects/214379695/micro-python-python-for-microcontrollers/posts/665145>`_ "
"にあります。"

#: ../../../reference/speed_python.rst:316
msgid "Accessing hardware directly"
msgstr "ハードウェアに直接アクセスする"

#: ../../../reference/speed_python.rst:320
msgid ""
"Code examples in this section are given for the Pyboard. The techniques "
"described however may be applied to other MicroPython ports too."
msgstr ""
"この章のコード例は pyboard 用です。ただし、ここで説明した手法は他の MicroPython "
"ポートにも適用できます。"

#: ../../../reference/speed_python.rst:323
msgid ""
"This comes into the category of more advanced programming and involves "
"some knowledge of the target MCU. Consider the example of toggling an "
"output pin on the Pyboard. The standard approach would be to write"
msgstr ""
"ここからはより高度なプログラミングの範疇に入り、ターゲット MCU の知識が必要になります。"
"pyboard で出力ピンを切り替える例を考えてみましょう。標準的なアプローチは、次のように"
"書くことです。"

#: ../../../reference/speed_python.rst:330
msgid "mypin.value(mypin.value() ^ 1) # mypin was instantiated as an output pin"
msgstr "mypin.value(mypin.value() ^ 1) # mypin は出力ピンとしてインスタンス化したもの"

#: ../../../reference/speed_python.rst:331
msgid ""
"This involves the overhead of two calls to the :class:`~machine.Pin` "
"instance's :meth:`~machine.Pin.value()` method. This overhead can be "
"eliminated by performing a read/write to the relevant bit of the chip's "
"GPIO port output data register (odr). To facilitate this the ``stm`` "
"module provides a set of constants providing the addresses of the "
"relevant registers. A fast toggle of pin ``P4`` (CPU pin ``A14``) - "
"corresponding to the green LED - can be performed as follows:"
msgstr ""
"これには :class:`~machine.Pin` "インスタンスの :meth:`~machine.Pin.value()` "
"メソッドに対する2回の呼び出しのオーバーヘッドが含まれます。このオーバーヘッドは、"
"チップの GPIO ポート出力データレジスタ(odr)の関連ビットへの読み書きを実行することで"
"解消できます。これを容易にするために ``stm`` モジュールは関連レジスタのアドレスの"
"定数のセットを提供します。緑色のLEDに対応するピン ``P4`` (CPU ピン ``A14``)の"
"高速トグルは、次のように実行できます。"

#: ../../../<rst_epilog>:1
msgid ""
"import machine\n"
"import stm\n"
"\n"
"BIT14 = const(1 << 14)\n"
"machine.mem16[stm.GPIOA + stm.GPIO_ODR] ^= BIT14"
msgstr ""

